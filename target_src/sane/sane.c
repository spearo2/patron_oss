/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 209 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef unsigned long size_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 34 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int8_t __int_least8_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint8_t __uint_least8_t;
#line 54 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int16_t __int_least16_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint16_t __uint_least16_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int32_t __int_least32_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint32_t __uint_least32_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int64_t __int_least64_t;
#line 59 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint64_t __uint_least64_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __quad_t;
#line 64 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_quad_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 154 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct_0 {
   int __val[2] ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct_0 __fsid_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 157 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 161 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 163 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds64_t;
#line 165 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __daddr_t;
#line 166 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 169 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef void *__timer_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 185 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 188 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 192 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 194 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 197 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 199 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 203 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 204 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 207 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 210 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 215 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion_2 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct_1 {
   int __count ;
   union __anonunion_2 __value ;
};
#line 21 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct_1 __mbstate_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
struct _G_fpos_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
typedef struct _G_fpos_t __fpos_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
struct _G_fpos64_t {
   __off64_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
typedef struct _G_fpos64_t __fpos64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
typedef struct _IO_FILE __FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef __ssize_t cookie_read_function_t(void * , char * , size_t  );
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef __ssize_t cookie_write_function_t(void * , char const   * , size_t  );
#line 45 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef int cookie_seek_function_t(void * , __off64_t * , int  );
#line 48 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef int cookie_close_function_t(void * );
#line 55 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
struct _IO_cookie_io_functions_t {
   cookie_read_function_t *read ;
   cookie_write_function_t *write ;
   cookie_seek_function_t *seek ;
   cookie_close_function_t *close ;
};
#line 61 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef struct _IO_cookie_io_functions_t cookie_io_functions_t;
#line 52 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 77 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 84 "/usr/include/stdio.h"
typedef __fpos_t fpos_t;
#line 89 "/usr/include/stdio.h"
typedef __fpos64_t fpos64_t;
#line 850
struct obstack ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_data ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 41 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
typedef struct __locale_struct *__locale_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h"
typedef __locale_t locale_t;
#line 321 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef int wchar_t;
#line 59 "/usr/include/stdlib.h"
struct __anonstruct_3 {
   int quot ;
   int rem ;
};
#line 63 "/usr/include/stdlib.h"
typedef struct __anonstruct_3 div_t;
#line 67 "/usr/include/stdlib.h"
struct __anonstruct_4 {
   long quot ;
   long rem ;
};
#line 71 "/usr/include/stdlib.h"
typedef struct __anonstruct_4 ldiv_t;
#line 77 "/usr/include/stdlib.h"
struct __anonstruct_5 {
   long long quot ;
   long long rem ;
};
#line 81 "/usr/include/stdlib.h"
typedef struct __anonstruct_5 lldiv_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 37 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __quad_t quad_t;
#line 38 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_quad_t u_quad_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsid_t fsid_t;
#line 42 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 47 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino64_t ino64_t;
#line 59 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 64 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 69 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 74 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 79 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 97 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 103 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 114 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __daddr_t daddr_t;
#line 115 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 121 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h"
typedef __timer_t timer_t;
#line 134 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __useconds_t useconds_t;
#line 138 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __suseconds_t suseconds_t;
#line 148 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long ulong;
#line 149 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 150 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 158 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint8_t u_int8_t;
#line 159 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint16_t u_int16_t;
#line 160 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint32_t u_int32_t;
#line 161 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint64_t u_int64_t;
#line 164 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long register_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_7 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_7 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 11 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_8 {
   __fd_mask fds_bits[16] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_8 fd_set;
#line 77 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __fd_mask fd_mask;
#line 185 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blksize_t blksize_t;
#line 192 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt_t blkcnt_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt_t fsblkcnt_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt_t fsfilcnt_t;
#line 219 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt64_t blkcnt64_t;
#line 220 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt64_t fsblkcnt64_t;
#line 221 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt64_t fsfilcnt64_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h"
struct __anonstruct_10 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 25 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h"
union __anonunion_9 {
   unsigned long long __value64 ;
   struct __anonstruct_10 __value32 ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h"
typedef union __anonunion_9 __atomic_wide_counter;
#line 51 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 55 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 60 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   __atomic_wide_counter __wseq ;
   __atomic_wide_counter __g1_start ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 105 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef unsigned int __tss_t;
#line 106 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef unsigned long __thrd_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_11 {
   int __data ;
};
#line 111 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __anonstruct_11 __once_flag;
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_12 {
   char __size[4] ;
   int __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_12 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_13 {
   char __size[4] ;
   int __align ;
};
#line 45 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_13 pthread_condattr_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_14 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_14 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_15 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 80 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_15 pthread_cond_t;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_16 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_16 pthread_rwlock_t;
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_17 {
   char __size[8] ;
   long __align ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_17 pthread_rwlockattr_t;
#line 103 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_spinlock_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_18 {
   char __size[32] ;
   long __align ;
};
#line 112 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_18 pthread_barrier_t;
#line 114 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_19 {
   char __size[4] ;
   int __align ;
};
#line 118 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_19 pthread_barrierattr_t;
#line 424 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 491 "/usr/include/stdlib.h"
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
#line 816 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 819 "/usr/include/stdlib.h"
typedef __compar_fn_t comparison_fn_t;
#line 823 "/usr/include/stdlib.h"
typedef int (*__compar_d_fn_t)(void const   * , void const   * , void * );
#line 77 "../include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h"
typedef int error_t;
#line 42 "/usr/include/sane/sane.h"
typedef unsigned char SANE_Byte;
#line 43 "/usr/include/sane/sane.h"
typedef int SANE_Word;
#line 44 "/usr/include/sane/sane.h"
typedef SANE_Word SANE_Bool;
#line 45 "/usr/include/sane/sane.h"
typedef SANE_Word SANE_Int;
#line 46 "/usr/include/sane/sane.h"
typedef char SANE_Char;
#line 47 "/usr/include/sane/sane.h"
typedef SANE_Char *SANE_String;
#line 48 "/usr/include/sane/sane.h"
typedef SANE_Char *SANE_String_Const;
#line 49 "/usr/include/sane/sane.h"
typedef void *SANE_Handle;
#line 50 "/usr/include/sane/sane.h"
typedef SANE_Word SANE_Fixed;
#line 56
enum __anonenum__39 {
    SANE_STATUS_GOOD = 0,
    SANE_STATUS_UNSUPPORTED = 1,
    SANE_STATUS_CANCELLED = 2,
    SANE_STATUS_DEVICE_BUSY = 3,
    SANE_STATUS_INVAL = 4,
    SANE_STATUS_EOF = 5,
    SANE_STATUS_JAMMED = 6,
    SANE_STATUS_NO_DOCS = 7,
    SANE_STATUS_COVER_OPEN = 8,
    SANE_STATUS_IO_ERROR = 9,
    SANE_STATUS_NO_MEM = 10,
    SANE_STATUS_ACCESS_DENIED = 11
} ;
#line 71 "/usr/include/sane/sane.h"
typedef enum __anonenum__39 SANE_Status;
#line 79
enum __anonenum__40 {
    SANE_TYPE_BOOL = 0,
    SANE_TYPE_INT = 1,
    SANE_TYPE_FIXED = 2,
    SANE_TYPE_STRING = 3,
    SANE_TYPE_BUTTON = 4,
    SANE_TYPE_GROUP = 5
} ;
#line 88 "/usr/include/sane/sane.h"
typedef enum __anonenum__40 SANE_Value_Type;
#line 90
enum __anonenum__41 {
    SANE_UNIT_NONE = 0,
    SANE_UNIT_PIXEL = 1,
    SANE_UNIT_BIT = 2,
    SANE_UNIT_MM = 3,
    SANE_UNIT_DPI = 4,
    SANE_UNIT_PERCENT = 5,
    SANE_UNIT_MICROSECOND = 6
} ;
#line 100 "/usr/include/sane/sane.h"
typedef enum __anonenum__41 SANE_Unit;
#line 102 "/usr/include/sane/sane.h"
struct __anonstruct_42 {
   SANE_String_Const name ;
   SANE_String_Const vendor ;
   SANE_String_Const model ;
   SANE_String_Const type ;
};
#line 109 "/usr/include/sane/sane.h"
typedef struct __anonstruct_42 SANE_Device;
#line 126
enum __anonenum__43 {
    SANE_CONSTRAINT_NONE = 0,
    SANE_CONSTRAINT_RANGE = 1,
    SANE_CONSTRAINT_WORD_LIST = 2,
    SANE_CONSTRAINT_STRING_LIST = 3
} ;
#line 133 "/usr/include/sane/sane.h"
typedef enum __anonenum__43 SANE_Constraint_Type;
#line 135 "/usr/include/sane/sane.h"
struct __anonstruct_44 {
   SANE_Word min ;
   SANE_Word max ;
   SANE_Word quant ;
};
#line 141 "/usr/include/sane/sane.h"
typedef struct __anonstruct_44 SANE_Range;
#line 154 "/usr/include/sane/sane.h"
union __anonunion_46 {
   SANE_String_Const *string_list ;
   SANE_Word *word_list ;
   SANE_Range *range ;
};
#line 143 "/usr/include/sane/sane.h"
struct __anonstruct_45 {
   SANE_String_Const name ;
   SANE_String_Const title ;
   SANE_String_Const desc ;
   SANE_Value_Type type ;
   SANE_Unit unit ;
   SANE_Int size ;
   SANE_Int cap ;
   SANE_Constraint_Type constraint_type ;
   union __anonunion_46 constraint ;
};
#line 162 "/usr/include/sane/sane.h"
typedef struct __anonstruct_45 SANE_Option_Descriptor;
#line 164
enum __anonenum__47 {
    SANE_ACTION_GET_VALUE = 0,
    SANE_ACTION_SET_VALUE = 1,
    SANE_ACTION_SET_AUTO = 2
} ;
#line 170 "/usr/include/sane/sane.h"
typedef enum __anonenum__47 SANE_Action;
#line 172
enum __anonenum__48 {
    SANE_FRAME_GRAY = 0,
    SANE_FRAME_RGB = 1,
    SANE_FRAME_RED = 2,
    SANE_FRAME_GREEN = 3,
    SANE_FRAME_BLUE = 4
} ;
#line 180 "/usr/include/sane/sane.h"
typedef enum __anonenum__48 SANE_Frame;
#line 198 "/usr/include/sane/sane.h"
struct __anonstruct_49 {
   SANE_Frame format ;
   SANE_Bool last_frame ;
   SANE_Int bytes_per_line ;
   SANE_Int pixels_per_line ;
   SANE_Int lines ;
   SANE_Int depth ;
};
#line 207 "/usr/include/sane/sane.h"
typedef struct __anonstruct_49 SANE_Parameters;
#line 209
struct SANE_Auth_Data ;
#line 214 "/usr/include/sane/sane.h"
typedef void (*SANE_Auth_Callback)(SANE_String_Const  , SANE_Char * , SANE_Char * );
#line 50 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/../include/sane/sanei_wire.h"
enum __anonenum__50 {
    WIRE_ENCODE = 0,
    WIRE_DECODE = 1,
    WIRE_FREE = 2
} ;
#line 56 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/../include/sane/sanei_wire.h"
typedef enum __anonenum__50 WireDirection;
#line 58
struct Wire ;
#line 60 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/../include/sane/sanei_wire.h"
typedef void (*WireCodecFunc)(struct Wire * , void * );
#line 61 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/../include/sane/sanei_wire.h"
typedef ssize_t (*WireReadFunc)(int  , void * , size_t  );
#line 62 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/../include/sane/sanei_wire.h"
typedef ssize_t (*WireWriteFunc)(int  , void const   * , size_t  );
#line 70 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/../include/sane/sanei_wire.h"
struct __anonstruct_51 {
   WireCodecFunc w_byte ;
   WireCodecFunc w_char ;
   WireCodecFunc w_word ;
   WireCodecFunc w_string ;
};
#line 78 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/../include/sane/sanei_wire.h"
struct __anonstruct_52 {
   size_t size ;
   char *curr ;
   char *start ;
   char *end ;
};
#line 86 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/../include/sane/sanei_wire.h"
struct __anonstruct_53 {
   int fd ;
   WireReadFunc read ;
   WireWriteFunc write ;
};
#line 64 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/../include/sane/sanei_wire.h"
struct Wire {
   int version ;
   WireDirection direction ;
   int status ;
   int allocated_memory ;
   struct __anonstruct_51 codec ;
   struct __anonstruct_52 buffer ;
   struct __anonstruct_53 io ;
};
#line 94 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/../include/sane/sanei_wire.h"
typedef struct Wire Wire;
#line 267 "/usr/include/unistd.h"
typedef __intptr_t intptr_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__54 {
    _PC_LINK_MAX = 0,
    _PC_MAX_CANON = 1,
    _PC_MAX_INPUT = 2,
    _PC_NAME_MAX = 3,
    _PC_PATH_MAX = 4,
    _PC_PIPE_BUF = 5,
    _PC_CHOWN_RESTRICTED = 6,
    _PC_NO_TRUNC = 7,
    _PC_VDISABLE = 8,
    _PC_SYNC_IO = 9,
    _PC_ASYNC_IO = 10,
    _PC_PRIO_IO = 11,
    _PC_SOCK_MAXBUF = 12,
    _PC_FILESIZEBITS = 13,
    _PC_REC_INCR_XFER_SIZE = 14,
    _PC_REC_MAX_XFER_SIZE = 15,
    _PC_REC_MIN_XFER_SIZE = 16,
    _PC_REC_XFER_ALIGN = 17,
    _PC_ALLOC_SIZE_MIN = 18,
    _PC_SYMLINK_MAX = 19,
    _PC_2_SYMLINKS = 20
} ;
#line 71
enum __anonenum__55 {
    _SC_ARG_MAX = 0,
    _SC_CHILD_MAX = 1,
    _SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX = 4,
    _SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC = 15,
    _SC_MAPPED_FILES = 16,
    _SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX = 28,
    _SC_VERSION = 29,
    _SC_PAGESIZE = 30,
    _SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION = 46,
    _SC_2_C_BIND = 47,
    _SC_2_C_DEV = 48,
    _SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF = 52,
    _SC_PII = 53,
    _SC_PII_XTI = 54,
    _SC_PII_SOCKET = 55,
    _SC_PII_INTERNET = 56,
    _SC_PII_OSI = 57,
    _SC_POLL = 58,
    _SC_SELECT = 59,
    _SC_UIO_MAXIOV = 60,
    _SC_IOV_MAX = 60,
    _SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX = 66,
    _SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION = 96,
    _SC_2_UPE = 97,
    _SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT = 101,
    _SC_CHAR_MAX = 102,
    _SC_CHAR_MIN = 103,
    _SC_INT_MAX = 104,
    _SC_INT_MIN = 105,
    _SC_LONG_BIT = 106,
    _SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX = 108,
    _SC_NZERO = 109,
    _SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX = 113,
    _SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX = 115,
    _SC_UINT_MAX = 116,
    _SC_ULONG_MAX = 117,
    _SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX = 121,
    _SC_NL_NMAX = 122,
    _SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO = 132,
    _SC_BARRIERS = 133,
    _SC_BASE = 134,
    _SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT = 143,
    _SC_FIFO = 144,
    _SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS = 154,
    _SC_REGEXP = 155,
    _SC_REGEX_VERSION = 156,
    _SC_SHELL = 157,
    _SC_SIGNALS = 158,
    _SC_SPAWN = 159,
    _SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R = 167,
    _SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX = 173,
    _SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX = 180,
    _SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6 = 235,
    _SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT = 248,
    _SC_MINSIGSTKSZ = 249,
    _SC_SIGSTKSZ = 250
} ;
#line 539
enum __anonenum__56 {
    _CS_PATH = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
    _CS_GNU_LIBC_VERSION = 2,
    _CS_GNU_LIBPTHREAD_VERSION = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS = 5,
    _CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS = 1001,
    _CS_LFS_LIBS = 1002,
    _CS_LFS_LINTFLAGS = 1003,
    _CS_LFS64_CFLAGS = 1004,
    _CS_LFS64_LDFLAGS = 1005,
    _CS_LFS64_LIBS = 1006,
    _CS_LFS64_LINTFLAGS = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
    _CS_XBS5_LP64_OFF64_LIBS = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
    _CS_V6_ENV = 1148,
    _CS_V7_ENV = 1149
} ;
#line 24
enum __anonenum__72 {
    _PC_LINK_MAX___0 = 0,
    _PC_MAX_CANON___0 = 1,
    _PC_MAX_INPUT___0 = 2,
    _PC_NAME_MAX___0 = 3,
    _PC_PATH_MAX___0 = 4,
    _PC_PIPE_BUF___0 = 5,
    _PC_CHOWN_RESTRICTED___0 = 6,
    _PC_NO_TRUNC___0 = 7,
    _PC_VDISABLE___0 = 8,
    _PC_SYNC_IO___0 = 9,
    _PC_ASYNC_IO___0 = 10,
    _PC_PRIO_IO___0 = 11,
    _PC_SOCK_MAXBUF___0 = 12,
    _PC_FILESIZEBITS___0 = 13,
    _PC_REC_INCR_XFER_SIZE___0 = 14,
    _PC_REC_MAX_XFER_SIZE___0 = 15,
    _PC_REC_MIN_XFER_SIZE___0 = 16,
    _PC_REC_XFER_ALIGN___0 = 17,
    _PC_ALLOC_SIZE_MIN___0 = 18,
    _PC_SYMLINK_MAX___0 = 19,
    _PC_2_SYMLINKS___0 = 20
} ;
#line 71
enum __anonenum__73 {
    _SC_ARG_MAX___0 = 0,
    _SC_CHILD_MAX___0 = 1,
    _SC_CLK_TCK___0 = 2,
    _SC_NGROUPS_MAX___0 = 3,
    _SC_OPEN_MAX___0 = 4,
    _SC_STREAM_MAX___0 = 5,
    _SC_TZNAME_MAX___0 = 6,
    _SC_JOB_CONTROL___0 = 7,
    _SC_SAVED_IDS___0 = 8,
    _SC_REALTIME_SIGNALS___0 = 9,
    _SC_PRIORITY_SCHEDULING___0 = 10,
    _SC_TIMERS___0 = 11,
    _SC_ASYNCHRONOUS_IO___0 = 12,
    _SC_PRIORITIZED_IO___0 = 13,
    _SC_SYNCHRONIZED_IO___0 = 14,
    _SC_FSYNC___0 = 15,
    _SC_MAPPED_FILES___0 = 16,
    _SC_MEMLOCK___0 = 17,
    _SC_MEMLOCK_RANGE___0 = 18,
    _SC_MEMORY_PROTECTION___0 = 19,
    _SC_MESSAGE_PASSING___0 = 20,
    _SC_SEMAPHORES___0 = 21,
    _SC_SHARED_MEMORY_OBJECTS___0 = 22,
    _SC_AIO_LISTIO_MAX___0 = 23,
    _SC_AIO_MAX___0 = 24,
    _SC_AIO_PRIO_DELTA_MAX___0 = 25,
    _SC_DELAYTIMER_MAX___0 = 26,
    _SC_MQ_OPEN_MAX___0 = 27,
    _SC_MQ_PRIO_MAX___0 = 28,
    _SC_VERSION___0 = 29,
    _SC_PAGESIZE___0 = 30,
    _SC_RTSIG_MAX___0 = 31,
    _SC_SEM_NSEMS_MAX___0 = 32,
    _SC_SEM_VALUE_MAX___0 = 33,
    _SC_SIGQUEUE_MAX___0 = 34,
    _SC_TIMER_MAX___0 = 35,
    _SC_BC_BASE_MAX___0 = 36,
    _SC_BC_DIM_MAX___0 = 37,
    _SC_BC_SCALE_MAX___0 = 38,
    _SC_BC_STRING_MAX___0 = 39,
    _SC_COLL_WEIGHTS_MAX___0 = 40,
    _SC_EQUIV_CLASS_MAX___0 = 41,
    _SC_EXPR_NEST_MAX___0 = 42,
    _SC_LINE_MAX___0 = 43,
    _SC_RE_DUP_MAX___0 = 44,
    _SC_CHARCLASS_NAME_MAX___0 = 45,
    _SC_2_VERSION___0 = 46,
    _SC_2_C_BIND___0 = 47,
    _SC_2_C_DEV___0 = 48,
    _SC_2_FORT_DEV___0 = 49,
    _SC_2_FORT_RUN___0 = 50,
    _SC_2_SW_DEV___0 = 51,
    _SC_2_LOCALEDEF___0 = 52,
    _SC_PII___0 = 53,
    _SC_PII_XTI___0 = 54,
    _SC_PII_SOCKET___0 = 55,
    _SC_PII_INTERNET___0 = 56,
    _SC_PII_OSI___0 = 57,
    _SC_POLL___0 = 58,
    _SC_SELECT___0 = 59,
    _SC_UIO_MAXIOV___0 = 60,
    _SC_IOV_MAX___0 = 60,
    _SC_PII_INTERNET_STREAM___0 = 61,
    _SC_PII_INTERNET_DGRAM___0 = 62,
    _SC_PII_OSI_COTS___0 = 63,
    _SC_PII_OSI_CLTS___0 = 64,
    _SC_PII_OSI_M___0 = 65,
    _SC_T_IOV_MAX___0 = 66,
    _SC_THREADS___0 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___0 = 68,
    _SC_GETGR_R_SIZE_MAX___0 = 69,
    _SC_GETPW_R_SIZE_MAX___0 = 70,
    _SC_LOGIN_NAME_MAX___0 = 71,
    _SC_TTY_NAME_MAX___0 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___0 = 73,
    _SC_THREAD_KEYS_MAX___0 = 74,
    _SC_THREAD_STACK_MIN___0 = 75,
    _SC_THREAD_THREADS_MAX___0 = 76,
    _SC_THREAD_ATTR_STACKADDR___0 = 77,
    _SC_THREAD_ATTR_STACKSIZE___0 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___0 = 79,
    _SC_THREAD_PRIO_INHERIT___0 = 80,
    _SC_THREAD_PRIO_PROTECT___0 = 81,
    _SC_THREAD_PROCESS_SHARED___0 = 82,
    _SC_NPROCESSORS_CONF___0 = 83,
    _SC_NPROCESSORS_ONLN___0 = 84,
    _SC_PHYS_PAGES___0 = 85,
    _SC_AVPHYS_PAGES___0 = 86,
    _SC_ATEXIT_MAX___0 = 87,
    _SC_PASS_MAX___0 = 88,
    _SC_XOPEN_VERSION___0 = 89,
    _SC_XOPEN_XCU_VERSION___0 = 90,
    _SC_XOPEN_UNIX___0 = 91,
    _SC_XOPEN_CRYPT___0 = 92,
    _SC_XOPEN_ENH_I18N___0 = 93,
    _SC_XOPEN_SHM___0 = 94,
    _SC_2_CHAR_TERM___0 = 95,
    _SC_2_C_VERSION___0 = 96,
    _SC_2_UPE___0 = 97,
    _SC_XOPEN_XPG2___0 = 98,
    _SC_XOPEN_XPG3___0 = 99,
    _SC_XOPEN_XPG4___0 = 100,
    _SC_CHAR_BIT___0 = 101,
    _SC_CHAR_MAX___0 = 102,
    _SC_CHAR_MIN___0 = 103,
    _SC_INT_MAX___0 = 104,
    _SC_INT_MIN___0 = 105,
    _SC_LONG_BIT___0 = 106,
    _SC_WORD_BIT___0 = 107,
    _SC_MB_LEN_MAX___0 = 108,
    _SC_NZERO___0 = 109,
    _SC_SSIZE_MAX___0 = 110,
    _SC_SCHAR_MAX___0 = 111,
    _SC_SCHAR_MIN___0 = 112,
    _SC_SHRT_MAX___0 = 113,
    _SC_SHRT_MIN___0 = 114,
    _SC_UCHAR_MAX___0 = 115,
    _SC_UINT_MAX___0 = 116,
    _SC_ULONG_MAX___0 = 117,
    _SC_USHRT_MAX___0 = 118,
    _SC_NL_ARGMAX___0 = 119,
    _SC_NL_LANGMAX___0 = 120,
    _SC_NL_MSGMAX___0 = 121,
    _SC_NL_NMAX___0 = 122,
    _SC_NL_SETMAX___0 = 123,
    _SC_NL_TEXTMAX___0 = 124,
    _SC_XBS5_ILP32_OFF32___0 = 125,
    _SC_XBS5_ILP32_OFFBIG___0 = 126,
    _SC_XBS5_LP64_OFF64___0 = 127,
    _SC_XBS5_LPBIG_OFFBIG___0 = 128,
    _SC_XOPEN_LEGACY___0 = 129,
    _SC_XOPEN_REALTIME___0 = 130,
    _SC_XOPEN_REALTIME_THREADS___0 = 131,
    _SC_ADVISORY_INFO___0 = 132,
    _SC_BARRIERS___0 = 133,
    _SC_BASE___0 = 134,
    _SC_C_LANG_SUPPORT___0 = 135,
    _SC_C_LANG_SUPPORT_R___0 = 136,
    _SC_CLOCK_SELECTION___0 = 137,
    _SC_CPUTIME___0 = 138,
    _SC_THREAD_CPUTIME___0 = 139,
    _SC_DEVICE_IO___0 = 140,
    _SC_DEVICE_SPECIFIC___0 = 141,
    _SC_DEVICE_SPECIFIC_R___0 = 142,
    _SC_FD_MGMT___0 = 143,
    _SC_FIFO___0 = 144,
    _SC_PIPE___0 = 145,
    _SC_FILE_ATTRIBUTES___0 = 146,
    _SC_FILE_LOCKING___0 = 147,
    _SC_FILE_SYSTEM___0 = 148,
    _SC_MONOTONIC_CLOCK___0 = 149,
    _SC_MULTI_PROCESS___0 = 150,
    _SC_SINGLE_PROCESS___0 = 151,
    _SC_NETWORKING___0 = 152,
    _SC_READER_WRITER_LOCKS___0 = 153,
    _SC_SPIN_LOCKS___0 = 154,
    _SC_REGEXP___0 = 155,
    _SC_REGEX_VERSION___0 = 156,
    _SC_SHELL___0 = 157,
    _SC_SIGNALS___0 = 158,
    _SC_SPAWN___0 = 159,
    _SC_SPORADIC_SERVER___0 = 160,
    _SC_THREAD_SPORADIC_SERVER___0 = 161,
    _SC_SYSTEM_DATABASE___0 = 162,
    _SC_SYSTEM_DATABASE_R___0 = 163,
    _SC_TIMEOUTS___0 = 164,
    _SC_TYPED_MEMORY_OBJECTS___0 = 165,
    _SC_USER_GROUPS___0 = 166,
    _SC_USER_GROUPS_R___0 = 167,
    _SC_2_PBS___0 = 168,
    _SC_2_PBS_ACCOUNTING___0 = 169,
    _SC_2_PBS_LOCATE___0 = 170,
    _SC_2_PBS_MESSAGE___0 = 171,
    _SC_2_PBS_TRACK___0 = 172,
    _SC_SYMLOOP_MAX___0 = 173,
    _SC_STREAMS___0 = 174,
    _SC_2_PBS_CHECKPOINT___0 = 175,
    _SC_V6_ILP32_OFF32___0 = 176,
    _SC_V6_ILP32_OFFBIG___0 = 177,
    _SC_V6_LP64_OFF64___0 = 178,
    _SC_V6_LPBIG_OFFBIG___0 = 179,
    _SC_HOST_NAME_MAX___0 = 180,
    _SC_TRACE___0 = 181,
    _SC_TRACE_EVENT_FILTER___0 = 182,
    _SC_TRACE_INHERIT___0 = 183,
    _SC_TRACE_LOG___0 = 184,
    _SC_LEVEL1_ICACHE_SIZE___0 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___0 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___0 = 187,
    _SC_LEVEL1_DCACHE_SIZE___0 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___0 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___0 = 190,
    _SC_LEVEL2_CACHE_SIZE___0 = 191,
    _SC_LEVEL2_CACHE_ASSOC___0 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___0 = 193,
    _SC_LEVEL3_CACHE_SIZE___0 = 194,
    _SC_LEVEL3_CACHE_ASSOC___0 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___0 = 196,
    _SC_LEVEL4_CACHE_SIZE___0 = 197,
    _SC_LEVEL4_CACHE_ASSOC___0 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___0 = 199,
    _SC_IPV6___0 = 235,
    _SC_RAW_SOCKETS___0 = 236,
    _SC_V7_ILP32_OFF32___0 = 237,
    _SC_V7_ILP32_OFFBIG___0 = 238,
    _SC_V7_LP64_OFF64___0 = 239,
    _SC_V7_LPBIG_OFFBIG___0 = 240,
    _SC_SS_REPL_MAX___0 = 241,
    _SC_TRACE_EVENT_NAME_MAX___0 = 242,
    _SC_TRACE_NAME_MAX___0 = 243,
    _SC_TRACE_SYS_MAX___0 = 244,
    _SC_TRACE_USER_EVENT_MAX___0 = 245,
    _SC_XOPEN_STREAMS___0 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___0 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___0 = 248,
    _SC_MINSIGSTKSZ___0 = 249,
    _SC_SIGSTKSZ___0 = 250
} ;
#line 539
enum __anonenum__74 {
    _CS_PATH___0 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___0 = 1,
    _CS_GNU_LIBC_VERSION___0 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___0 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___0 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___0 = 5,
    _CS_LFS_CFLAGS___0 = 1000,
    _CS_LFS_LDFLAGS___0 = 1001,
    _CS_LFS_LIBS___0 = 1002,
    _CS_LFS_LINTFLAGS___0 = 1003,
    _CS_LFS64_CFLAGS___0 = 1004,
    _CS_LFS64_LDFLAGS___0 = 1005,
    _CS_LFS64_LIBS___0 = 1006,
    _CS_LFS64_LINTFLAGS___0 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___0 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___0 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___0 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___0 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___0 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___0 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___0 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___0 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___0 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___0 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___0 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___0 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___0 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___0 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___0 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___0 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___0 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___0 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___0 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___0 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___0 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___0 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___0 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___0 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___0 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___0 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___0 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___0 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___0 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___0 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___0 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___0 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___0 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___0 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___0 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___0 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___0 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___0 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___0 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___0 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___0 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___0 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___0 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___0 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___0 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___0 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___0 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___0 = 1147,
    _CS_V6_ENV___0 = 1148,
    _CS_V7_ENV___0 = 1149
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__91 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__110 {
    _PC_LINK_MAX___1 = 0,
    _PC_MAX_CANON___1 = 1,
    _PC_MAX_INPUT___1 = 2,
    _PC_NAME_MAX___1 = 3,
    _PC_PATH_MAX___1 = 4,
    _PC_PIPE_BUF___1 = 5,
    _PC_CHOWN_RESTRICTED___1 = 6,
    _PC_NO_TRUNC___1 = 7,
    _PC_VDISABLE___1 = 8,
    _PC_SYNC_IO___1 = 9,
    _PC_ASYNC_IO___1 = 10,
    _PC_PRIO_IO___1 = 11,
    _PC_SOCK_MAXBUF___1 = 12,
    _PC_FILESIZEBITS___1 = 13,
    _PC_REC_INCR_XFER_SIZE___1 = 14,
    _PC_REC_MAX_XFER_SIZE___1 = 15,
    _PC_REC_MIN_XFER_SIZE___1 = 16,
    _PC_REC_XFER_ALIGN___1 = 17,
    _PC_ALLOC_SIZE_MIN___1 = 18,
    _PC_SYMLINK_MAX___1 = 19,
    _PC_2_SYMLINKS___1 = 20
} ;
#line 71
enum __anonenum__111 {
    _SC_ARG_MAX___1 = 0,
    _SC_CHILD_MAX___1 = 1,
    _SC_CLK_TCK___1 = 2,
    _SC_NGROUPS_MAX___1 = 3,
    _SC_OPEN_MAX___1 = 4,
    _SC_STREAM_MAX___1 = 5,
    _SC_TZNAME_MAX___1 = 6,
    _SC_JOB_CONTROL___1 = 7,
    _SC_SAVED_IDS___1 = 8,
    _SC_REALTIME_SIGNALS___1 = 9,
    _SC_PRIORITY_SCHEDULING___1 = 10,
    _SC_TIMERS___1 = 11,
    _SC_ASYNCHRONOUS_IO___1 = 12,
    _SC_PRIORITIZED_IO___1 = 13,
    _SC_SYNCHRONIZED_IO___1 = 14,
    _SC_FSYNC___1 = 15,
    _SC_MAPPED_FILES___1 = 16,
    _SC_MEMLOCK___1 = 17,
    _SC_MEMLOCK_RANGE___1 = 18,
    _SC_MEMORY_PROTECTION___1 = 19,
    _SC_MESSAGE_PASSING___1 = 20,
    _SC_SEMAPHORES___1 = 21,
    _SC_SHARED_MEMORY_OBJECTS___1 = 22,
    _SC_AIO_LISTIO_MAX___1 = 23,
    _SC_AIO_MAX___1 = 24,
    _SC_AIO_PRIO_DELTA_MAX___1 = 25,
    _SC_DELAYTIMER_MAX___1 = 26,
    _SC_MQ_OPEN_MAX___1 = 27,
    _SC_MQ_PRIO_MAX___1 = 28,
    _SC_VERSION___1 = 29,
    _SC_PAGESIZE___1 = 30,
    _SC_RTSIG_MAX___1 = 31,
    _SC_SEM_NSEMS_MAX___1 = 32,
    _SC_SEM_VALUE_MAX___1 = 33,
    _SC_SIGQUEUE_MAX___1 = 34,
    _SC_TIMER_MAX___1 = 35,
    _SC_BC_BASE_MAX___1 = 36,
    _SC_BC_DIM_MAX___1 = 37,
    _SC_BC_SCALE_MAX___1 = 38,
    _SC_BC_STRING_MAX___1 = 39,
    _SC_COLL_WEIGHTS_MAX___1 = 40,
    _SC_EQUIV_CLASS_MAX___1 = 41,
    _SC_EXPR_NEST_MAX___1 = 42,
    _SC_LINE_MAX___1 = 43,
    _SC_RE_DUP_MAX___1 = 44,
    _SC_CHARCLASS_NAME_MAX___1 = 45,
    _SC_2_VERSION___1 = 46,
    _SC_2_C_BIND___1 = 47,
    _SC_2_C_DEV___1 = 48,
    _SC_2_FORT_DEV___1 = 49,
    _SC_2_FORT_RUN___1 = 50,
    _SC_2_SW_DEV___1 = 51,
    _SC_2_LOCALEDEF___1 = 52,
    _SC_PII___1 = 53,
    _SC_PII_XTI___1 = 54,
    _SC_PII_SOCKET___1 = 55,
    _SC_PII_INTERNET___1 = 56,
    _SC_PII_OSI___1 = 57,
    _SC_POLL___1 = 58,
    _SC_SELECT___1 = 59,
    _SC_UIO_MAXIOV___1 = 60,
    _SC_IOV_MAX___1 = 60,
    _SC_PII_INTERNET_STREAM___1 = 61,
    _SC_PII_INTERNET_DGRAM___1 = 62,
    _SC_PII_OSI_COTS___1 = 63,
    _SC_PII_OSI_CLTS___1 = 64,
    _SC_PII_OSI_M___1 = 65,
    _SC_T_IOV_MAX___1 = 66,
    _SC_THREADS___1 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___1 = 68,
    _SC_GETGR_R_SIZE_MAX___1 = 69,
    _SC_GETPW_R_SIZE_MAX___1 = 70,
    _SC_LOGIN_NAME_MAX___1 = 71,
    _SC_TTY_NAME_MAX___1 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___1 = 73,
    _SC_THREAD_KEYS_MAX___1 = 74,
    _SC_THREAD_STACK_MIN___1 = 75,
    _SC_THREAD_THREADS_MAX___1 = 76,
    _SC_THREAD_ATTR_STACKADDR___1 = 77,
    _SC_THREAD_ATTR_STACKSIZE___1 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___1 = 79,
    _SC_THREAD_PRIO_INHERIT___1 = 80,
    _SC_THREAD_PRIO_PROTECT___1 = 81,
    _SC_THREAD_PROCESS_SHARED___1 = 82,
    _SC_NPROCESSORS_CONF___1 = 83,
    _SC_NPROCESSORS_ONLN___1 = 84,
    _SC_PHYS_PAGES___1 = 85,
    _SC_AVPHYS_PAGES___1 = 86,
    _SC_ATEXIT_MAX___1 = 87,
    _SC_PASS_MAX___1 = 88,
    _SC_XOPEN_VERSION___1 = 89,
    _SC_XOPEN_XCU_VERSION___1 = 90,
    _SC_XOPEN_UNIX___1 = 91,
    _SC_XOPEN_CRYPT___1 = 92,
    _SC_XOPEN_ENH_I18N___1 = 93,
    _SC_XOPEN_SHM___1 = 94,
    _SC_2_CHAR_TERM___1 = 95,
    _SC_2_C_VERSION___1 = 96,
    _SC_2_UPE___1 = 97,
    _SC_XOPEN_XPG2___1 = 98,
    _SC_XOPEN_XPG3___1 = 99,
    _SC_XOPEN_XPG4___1 = 100,
    _SC_CHAR_BIT___1 = 101,
    _SC_CHAR_MAX___1 = 102,
    _SC_CHAR_MIN___1 = 103,
    _SC_INT_MAX___1 = 104,
    _SC_INT_MIN___1 = 105,
    _SC_LONG_BIT___1 = 106,
    _SC_WORD_BIT___1 = 107,
    _SC_MB_LEN_MAX___1 = 108,
    _SC_NZERO___1 = 109,
    _SC_SSIZE_MAX___1 = 110,
    _SC_SCHAR_MAX___1 = 111,
    _SC_SCHAR_MIN___1 = 112,
    _SC_SHRT_MAX___1 = 113,
    _SC_SHRT_MIN___1 = 114,
    _SC_UCHAR_MAX___1 = 115,
    _SC_UINT_MAX___1 = 116,
    _SC_ULONG_MAX___1 = 117,
    _SC_USHRT_MAX___1 = 118,
    _SC_NL_ARGMAX___1 = 119,
    _SC_NL_LANGMAX___1 = 120,
    _SC_NL_MSGMAX___1 = 121,
    _SC_NL_NMAX___1 = 122,
    _SC_NL_SETMAX___1 = 123,
    _SC_NL_TEXTMAX___1 = 124,
    _SC_XBS5_ILP32_OFF32___1 = 125,
    _SC_XBS5_ILP32_OFFBIG___1 = 126,
    _SC_XBS5_LP64_OFF64___1 = 127,
    _SC_XBS5_LPBIG_OFFBIG___1 = 128,
    _SC_XOPEN_LEGACY___1 = 129,
    _SC_XOPEN_REALTIME___1 = 130,
    _SC_XOPEN_REALTIME_THREADS___1 = 131,
    _SC_ADVISORY_INFO___1 = 132,
    _SC_BARRIERS___1 = 133,
    _SC_BASE___1 = 134,
    _SC_C_LANG_SUPPORT___1 = 135,
    _SC_C_LANG_SUPPORT_R___1 = 136,
    _SC_CLOCK_SELECTION___1 = 137,
    _SC_CPUTIME___1 = 138,
    _SC_THREAD_CPUTIME___1 = 139,
    _SC_DEVICE_IO___1 = 140,
    _SC_DEVICE_SPECIFIC___1 = 141,
    _SC_DEVICE_SPECIFIC_R___1 = 142,
    _SC_FD_MGMT___1 = 143,
    _SC_FIFO___1 = 144,
    _SC_PIPE___1 = 145,
    _SC_FILE_ATTRIBUTES___1 = 146,
    _SC_FILE_LOCKING___1 = 147,
    _SC_FILE_SYSTEM___1 = 148,
    _SC_MONOTONIC_CLOCK___1 = 149,
    _SC_MULTI_PROCESS___1 = 150,
    _SC_SINGLE_PROCESS___1 = 151,
    _SC_NETWORKING___1 = 152,
    _SC_READER_WRITER_LOCKS___1 = 153,
    _SC_SPIN_LOCKS___1 = 154,
    _SC_REGEXP___1 = 155,
    _SC_REGEX_VERSION___1 = 156,
    _SC_SHELL___1 = 157,
    _SC_SIGNALS___1 = 158,
    _SC_SPAWN___1 = 159,
    _SC_SPORADIC_SERVER___1 = 160,
    _SC_THREAD_SPORADIC_SERVER___1 = 161,
    _SC_SYSTEM_DATABASE___1 = 162,
    _SC_SYSTEM_DATABASE_R___1 = 163,
    _SC_TIMEOUTS___1 = 164,
    _SC_TYPED_MEMORY_OBJECTS___1 = 165,
    _SC_USER_GROUPS___1 = 166,
    _SC_USER_GROUPS_R___1 = 167,
    _SC_2_PBS___1 = 168,
    _SC_2_PBS_ACCOUNTING___1 = 169,
    _SC_2_PBS_LOCATE___1 = 170,
    _SC_2_PBS_MESSAGE___1 = 171,
    _SC_2_PBS_TRACK___1 = 172,
    _SC_SYMLOOP_MAX___1 = 173,
    _SC_STREAMS___1 = 174,
    _SC_2_PBS_CHECKPOINT___1 = 175,
    _SC_V6_ILP32_OFF32___1 = 176,
    _SC_V6_ILP32_OFFBIG___1 = 177,
    _SC_V6_LP64_OFF64___1 = 178,
    _SC_V6_LPBIG_OFFBIG___1 = 179,
    _SC_HOST_NAME_MAX___1 = 180,
    _SC_TRACE___1 = 181,
    _SC_TRACE_EVENT_FILTER___1 = 182,
    _SC_TRACE_INHERIT___1 = 183,
    _SC_TRACE_LOG___1 = 184,
    _SC_LEVEL1_ICACHE_SIZE___1 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___1 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___1 = 187,
    _SC_LEVEL1_DCACHE_SIZE___1 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___1 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___1 = 190,
    _SC_LEVEL2_CACHE_SIZE___1 = 191,
    _SC_LEVEL2_CACHE_ASSOC___1 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___1 = 193,
    _SC_LEVEL3_CACHE_SIZE___1 = 194,
    _SC_LEVEL3_CACHE_ASSOC___1 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___1 = 196,
    _SC_LEVEL4_CACHE_SIZE___1 = 197,
    _SC_LEVEL4_CACHE_ASSOC___1 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___1 = 199,
    _SC_IPV6___1 = 235,
    _SC_RAW_SOCKETS___1 = 236,
    _SC_V7_ILP32_OFF32___1 = 237,
    _SC_V7_ILP32_OFFBIG___1 = 238,
    _SC_V7_LP64_OFF64___1 = 239,
    _SC_V7_LPBIG_OFFBIG___1 = 240,
    _SC_SS_REPL_MAX___1 = 241,
    _SC_TRACE_EVENT_NAME_MAX___1 = 242,
    _SC_TRACE_NAME_MAX___1 = 243,
    _SC_TRACE_SYS_MAX___1 = 244,
    _SC_TRACE_USER_EVENT_MAX___1 = 245,
    _SC_XOPEN_STREAMS___1 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___1 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___1 = 248,
    _SC_MINSIGSTKSZ___1 = 249,
    _SC_SIGSTKSZ___1 = 250
} ;
#line 539
enum __anonenum__112 {
    _CS_PATH___1 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___1 = 1,
    _CS_GNU_LIBC_VERSION___1 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___1 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___1 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___1 = 5,
    _CS_LFS_CFLAGS___1 = 1000,
    _CS_LFS_LDFLAGS___1 = 1001,
    _CS_LFS_LIBS___1 = 1002,
    _CS_LFS_LINTFLAGS___1 = 1003,
    _CS_LFS64_CFLAGS___1 = 1004,
    _CS_LFS64_LDFLAGS___1 = 1005,
    _CS_LFS64_LIBS___1 = 1006,
    _CS_LFS64_LINTFLAGS___1 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___1 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___1 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___1 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___1 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___1 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___1 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___1 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___1 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___1 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___1 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___1 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___1 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___1 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___1 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___1 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___1 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___1 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___1 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___1 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___1 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___1 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___1 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___1 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___1 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___1 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___1 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___1 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___1 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___1 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___1 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___1 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___1 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___1 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___1 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___1 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___1 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___1 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___1 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___1 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___1 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___1 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___1 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___1 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___1 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___1 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___1 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___1 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___1 = 1147,
    _CS_V6_ENV___1 = 1148,
    _CS_V7_ENV___1 = 1149
} ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h"
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 21 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef short __s16;
#line 24 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef int __s32;
#line 27 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "/usr/include/asm-generic/int-ll64.h"
typedef long long __s64;
#line 31 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 25 "/usr/include/linux/posix_types.h"
struct __anonstruct_113 {
   unsigned long fds_bits[16] ;
};
#line 27 "/usr/include/linux/posix_types.h"
typedef struct __anonstruct_113 __kernel_fd_set;
#line 30 "/usr/include/linux/posix_types.h"
typedef void (*__kernel_sighandler_t)(int  );
#line 33 "/usr/include/linux/posix_types.h"
typedef int __kernel_key_t;
#line 34 "/usr/include/linux/posix_types.h"
typedef int __kernel_mqd_t;
#line 11 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h"
typedef unsigned short __kernel_old_uid_t;
#line 12 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h"
typedef unsigned short __kernel_old_gid_t;
#line 15 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h"
typedef unsigned long __kernel_old_dev_t;
#line 15 "/usr/include/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 16 "/usr/include/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 20 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_ino_t;
#line 24 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_mode_t;
#line 28 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 32 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_ipc_pid_t;
#line 36 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid_t;
#line 37 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid_t;
#line 41 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 45 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_daddr_t;
#line 49 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 50 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 72 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 73 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 74 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ptrdiff_t;
#line 79 "/usr/include/asm-generic/posix_types.h"
struct __anonstruct_114 {
   int val[2] ;
};
#line 81 "/usr/include/asm-generic/posix_types.h"
typedef struct __anonstruct_114 __kernel_fsid_t;
#line 87 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_off_t;
#line 88 "/usr/include/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 89 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_old_time_t;
#line 90 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 91 "/usr/include/asm-generic/posix_types.h"
typedef long long __kernel_time64_t;
#line 92 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 93 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 94 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 95 "/usr/include/asm-generic/posix_types.h"
typedef char *__kernel_caddr_t;
#line 96 "/usr/include/asm-generic/posix_types.h"
typedef unsigned short __kernel_uid16_t;
#line 97 "/usr/include/asm-generic/posix_types.h"
typedef unsigned short __kernel_gid16_t;
#line 24 "/usr/include/linux/types.h"
typedef __u16 __le16;
#line 25 "/usr/include/linux/types.h"
typedef __u16 __be16;
#line 26 "/usr/include/linux/types.h"
typedef __u32 __le32;
#line 27 "/usr/include/linux/types.h"
typedef __u32 __be32;
#line 28 "/usr/include/linux/types.h"
typedef __u64 __le64;
#line 29 "/usr/include/linux/types.h"
typedef __u64 __be64;
#line 31 "/usr/include/linux/types.h"
typedef __u16 __sum16;
#line 32 "/usr/include/linux/types.h"
typedef __u32 __wsum;
#line 47 "/usr/include/linux/types.h"
typedef unsigned int __poll_t;
#line 56 "/usr/include/linux/stat.h"
struct statx_timestamp {
   __s64 tv_sec ;
   __u32 tv_nsec ;
   __s32 __reserved ;
};
#line 99 "/usr/include/linux/stat.h"
struct statx {
   __u32 stx_mask ;
   __u32 stx_blksize ;
   __u64 stx_attributes ;
   __u32 stx_nlink ;
   __u32 stx_uid ;
   __u32 stx_gid ;
   __u16 stx_mode ;
   __u16 __spare0[1] ;
   __u64 stx_ino ;
   __u64 stx_size ;
   __u64 stx_blocks ;
   __u64 stx_attributes_mask ;
   struct statx_timestamp stx_atime ;
   struct statx_timestamp stx_btime ;
   struct statx_timestamp stx_ctime ;
   struct statx_timestamp stx_mtime ;
   __u32 stx_rdev_major ;
   __u32 stx_rdev_minor ;
   __u32 stx_dev_major ;
   __u32 stx_dev_minor ;
   __u64 stx_mnt_id ;
   __u64 __spare2 ;
   __u64 __spare3[12] ;
};
#line 46 "/usr/include/ctype.h"
enum __anonenum__91___0 {
    _ISupper___0 = 256,
    _ISlower___0 = 512,
    _ISalpha___0 = 1024,
    _ISdigit___0 = 2048,
    _ISxdigit___0 = 4096,
    _ISspace___0 = 8192,
    _ISprint___0 = 16384,
    _ISgraph___0 = 32768,
    _ISblank___0 = 1,
    _IScntrl___0 = 2,
    _ISpunct___0 = 4,
    _ISalnum___0 = 8
} ;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__176 {
    _PC_LINK_MAX___2 = 0,
    _PC_MAX_CANON___2 = 1,
    _PC_MAX_INPUT___2 = 2,
    _PC_NAME_MAX___2 = 3,
    _PC_PATH_MAX___2 = 4,
    _PC_PIPE_BUF___2 = 5,
    _PC_CHOWN_RESTRICTED___2 = 6,
    _PC_NO_TRUNC___2 = 7,
    _PC_VDISABLE___2 = 8,
    _PC_SYNC_IO___2 = 9,
    _PC_ASYNC_IO___2 = 10,
    _PC_PRIO_IO___2 = 11,
    _PC_SOCK_MAXBUF___2 = 12,
    _PC_FILESIZEBITS___2 = 13,
    _PC_REC_INCR_XFER_SIZE___2 = 14,
    _PC_REC_MAX_XFER_SIZE___2 = 15,
    _PC_REC_MIN_XFER_SIZE___2 = 16,
    _PC_REC_XFER_ALIGN___2 = 17,
    _PC_ALLOC_SIZE_MIN___2 = 18,
    _PC_SYMLINK_MAX___2 = 19,
    _PC_2_SYMLINKS___2 = 20
} ;
#line 71
enum __anonenum__177 {
    _SC_ARG_MAX___2 = 0,
    _SC_CHILD_MAX___2 = 1,
    _SC_CLK_TCK___2 = 2,
    _SC_NGROUPS_MAX___2 = 3,
    _SC_OPEN_MAX___2 = 4,
    _SC_STREAM_MAX___2 = 5,
    _SC_TZNAME_MAX___2 = 6,
    _SC_JOB_CONTROL___2 = 7,
    _SC_SAVED_IDS___2 = 8,
    _SC_REALTIME_SIGNALS___2 = 9,
    _SC_PRIORITY_SCHEDULING___2 = 10,
    _SC_TIMERS___2 = 11,
    _SC_ASYNCHRONOUS_IO___2 = 12,
    _SC_PRIORITIZED_IO___2 = 13,
    _SC_SYNCHRONIZED_IO___2 = 14,
    _SC_FSYNC___2 = 15,
    _SC_MAPPED_FILES___2 = 16,
    _SC_MEMLOCK___2 = 17,
    _SC_MEMLOCK_RANGE___2 = 18,
    _SC_MEMORY_PROTECTION___2 = 19,
    _SC_MESSAGE_PASSING___2 = 20,
    _SC_SEMAPHORES___2 = 21,
    _SC_SHARED_MEMORY_OBJECTS___2 = 22,
    _SC_AIO_LISTIO_MAX___2 = 23,
    _SC_AIO_MAX___2 = 24,
    _SC_AIO_PRIO_DELTA_MAX___2 = 25,
    _SC_DELAYTIMER_MAX___2 = 26,
    _SC_MQ_OPEN_MAX___2 = 27,
    _SC_MQ_PRIO_MAX___2 = 28,
    _SC_VERSION___2 = 29,
    _SC_PAGESIZE___2 = 30,
    _SC_RTSIG_MAX___2 = 31,
    _SC_SEM_NSEMS_MAX___2 = 32,
    _SC_SEM_VALUE_MAX___2 = 33,
    _SC_SIGQUEUE_MAX___2 = 34,
    _SC_TIMER_MAX___2 = 35,
    _SC_BC_BASE_MAX___2 = 36,
    _SC_BC_DIM_MAX___2 = 37,
    _SC_BC_SCALE_MAX___2 = 38,
    _SC_BC_STRING_MAX___2 = 39,
    _SC_COLL_WEIGHTS_MAX___2 = 40,
    _SC_EQUIV_CLASS_MAX___2 = 41,
    _SC_EXPR_NEST_MAX___2 = 42,
    _SC_LINE_MAX___2 = 43,
    _SC_RE_DUP_MAX___2 = 44,
    _SC_CHARCLASS_NAME_MAX___2 = 45,
    _SC_2_VERSION___2 = 46,
    _SC_2_C_BIND___2 = 47,
    _SC_2_C_DEV___2 = 48,
    _SC_2_FORT_DEV___2 = 49,
    _SC_2_FORT_RUN___2 = 50,
    _SC_2_SW_DEV___2 = 51,
    _SC_2_LOCALEDEF___2 = 52,
    _SC_PII___2 = 53,
    _SC_PII_XTI___2 = 54,
    _SC_PII_SOCKET___2 = 55,
    _SC_PII_INTERNET___2 = 56,
    _SC_PII_OSI___2 = 57,
    _SC_POLL___2 = 58,
    _SC_SELECT___2 = 59,
    _SC_UIO_MAXIOV___2 = 60,
    _SC_IOV_MAX___2 = 60,
    _SC_PII_INTERNET_STREAM___2 = 61,
    _SC_PII_INTERNET_DGRAM___2 = 62,
    _SC_PII_OSI_COTS___2 = 63,
    _SC_PII_OSI_CLTS___2 = 64,
    _SC_PII_OSI_M___2 = 65,
    _SC_T_IOV_MAX___2 = 66,
    _SC_THREADS___2 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___2 = 68,
    _SC_GETGR_R_SIZE_MAX___2 = 69,
    _SC_GETPW_R_SIZE_MAX___2 = 70,
    _SC_LOGIN_NAME_MAX___2 = 71,
    _SC_TTY_NAME_MAX___2 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___2 = 73,
    _SC_THREAD_KEYS_MAX___2 = 74,
    _SC_THREAD_STACK_MIN___2 = 75,
    _SC_THREAD_THREADS_MAX___2 = 76,
    _SC_THREAD_ATTR_STACKADDR___2 = 77,
    _SC_THREAD_ATTR_STACKSIZE___2 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___2 = 79,
    _SC_THREAD_PRIO_INHERIT___2 = 80,
    _SC_THREAD_PRIO_PROTECT___2 = 81,
    _SC_THREAD_PROCESS_SHARED___2 = 82,
    _SC_NPROCESSORS_CONF___2 = 83,
    _SC_NPROCESSORS_ONLN___2 = 84,
    _SC_PHYS_PAGES___2 = 85,
    _SC_AVPHYS_PAGES___2 = 86,
    _SC_ATEXIT_MAX___2 = 87,
    _SC_PASS_MAX___2 = 88,
    _SC_XOPEN_VERSION___2 = 89,
    _SC_XOPEN_XCU_VERSION___2 = 90,
    _SC_XOPEN_UNIX___2 = 91,
    _SC_XOPEN_CRYPT___2 = 92,
    _SC_XOPEN_ENH_I18N___2 = 93,
    _SC_XOPEN_SHM___2 = 94,
    _SC_2_CHAR_TERM___2 = 95,
    _SC_2_C_VERSION___2 = 96,
    _SC_2_UPE___2 = 97,
    _SC_XOPEN_XPG2___2 = 98,
    _SC_XOPEN_XPG3___2 = 99,
    _SC_XOPEN_XPG4___2 = 100,
    _SC_CHAR_BIT___2 = 101,
    _SC_CHAR_MAX___2 = 102,
    _SC_CHAR_MIN___2 = 103,
    _SC_INT_MAX___2 = 104,
    _SC_INT_MIN___2 = 105,
    _SC_LONG_BIT___2 = 106,
    _SC_WORD_BIT___2 = 107,
    _SC_MB_LEN_MAX___2 = 108,
    _SC_NZERO___2 = 109,
    _SC_SSIZE_MAX___2 = 110,
    _SC_SCHAR_MAX___2 = 111,
    _SC_SCHAR_MIN___2 = 112,
    _SC_SHRT_MAX___2 = 113,
    _SC_SHRT_MIN___2 = 114,
    _SC_UCHAR_MAX___2 = 115,
    _SC_UINT_MAX___2 = 116,
    _SC_ULONG_MAX___2 = 117,
    _SC_USHRT_MAX___2 = 118,
    _SC_NL_ARGMAX___2 = 119,
    _SC_NL_LANGMAX___2 = 120,
    _SC_NL_MSGMAX___2 = 121,
    _SC_NL_NMAX___2 = 122,
    _SC_NL_SETMAX___2 = 123,
    _SC_NL_TEXTMAX___2 = 124,
    _SC_XBS5_ILP32_OFF32___2 = 125,
    _SC_XBS5_ILP32_OFFBIG___2 = 126,
    _SC_XBS5_LP64_OFF64___2 = 127,
    _SC_XBS5_LPBIG_OFFBIG___2 = 128,
    _SC_XOPEN_LEGACY___2 = 129,
    _SC_XOPEN_REALTIME___2 = 130,
    _SC_XOPEN_REALTIME_THREADS___2 = 131,
    _SC_ADVISORY_INFO___2 = 132,
    _SC_BARRIERS___2 = 133,
    _SC_BASE___2 = 134,
    _SC_C_LANG_SUPPORT___2 = 135,
    _SC_C_LANG_SUPPORT_R___2 = 136,
    _SC_CLOCK_SELECTION___2 = 137,
    _SC_CPUTIME___2 = 138,
    _SC_THREAD_CPUTIME___2 = 139,
    _SC_DEVICE_IO___2 = 140,
    _SC_DEVICE_SPECIFIC___2 = 141,
    _SC_DEVICE_SPECIFIC_R___2 = 142,
    _SC_FD_MGMT___2 = 143,
    _SC_FIFO___2 = 144,
    _SC_PIPE___2 = 145,
    _SC_FILE_ATTRIBUTES___2 = 146,
    _SC_FILE_LOCKING___2 = 147,
    _SC_FILE_SYSTEM___2 = 148,
    _SC_MONOTONIC_CLOCK___2 = 149,
    _SC_MULTI_PROCESS___2 = 150,
    _SC_SINGLE_PROCESS___2 = 151,
    _SC_NETWORKING___2 = 152,
    _SC_READER_WRITER_LOCKS___2 = 153,
    _SC_SPIN_LOCKS___2 = 154,
    _SC_REGEXP___2 = 155,
    _SC_REGEX_VERSION___2 = 156,
    _SC_SHELL___2 = 157,
    _SC_SIGNALS___2 = 158,
    _SC_SPAWN___2 = 159,
    _SC_SPORADIC_SERVER___2 = 160,
    _SC_THREAD_SPORADIC_SERVER___2 = 161,
    _SC_SYSTEM_DATABASE___2 = 162,
    _SC_SYSTEM_DATABASE_R___2 = 163,
    _SC_TIMEOUTS___2 = 164,
    _SC_TYPED_MEMORY_OBJECTS___2 = 165,
    _SC_USER_GROUPS___2 = 166,
    _SC_USER_GROUPS_R___2 = 167,
    _SC_2_PBS___2 = 168,
    _SC_2_PBS_ACCOUNTING___2 = 169,
    _SC_2_PBS_LOCATE___2 = 170,
    _SC_2_PBS_MESSAGE___2 = 171,
    _SC_2_PBS_TRACK___2 = 172,
    _SC_SYMLOOP_MAX___2 = 173,
    _SC_STREAMS___2 = 174,
    _SC_2_PBS_CHECKPOINT___2 = 175,
    _SC_V6_ILP32_OFF32___2 = 176,
    _SC_V6_ILP32_OFFBIG___2 = 177,
    _SC_V6_LP64_OFF64___2 = 178,
    _SC_V6_LPBIG_OFFBIG___2 = 179,
    _SC_HOST_NAME_MAX___2 = 180,
    _SC_TRACE___2 = 181,
    _SC_TRACE_EVENT_FILTER___2 = 182,
    _SC_TRACE_INHERIT___2 = 183,
    _SC_TRACE_LOG___2 = 184,
    _SC_LEVEL1_ICACHE_SIZE___2 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___2 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___2 = 187,
    _SC_LEVEL1_DCACHE_SIZE___2 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___2 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___2 = 190,
    _SC_LEVEL2_CACHE_SIZE___2 = 191,
    _SC_LEVEL2_CACHE_ASSOC___2 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___2 = 193,
    _SC_LEVEL3_CACHE_SIZE___2 = 194,
    _SC_LEVEL3_CACHE_ASSOC___2 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___2 = 196,
    _SC_LEVEL4_CACHE_SIZE___2 = 197,
    _SC_LEVEL4_CACHE_ASSOC___2 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___2 = 199,
    _SC_IPV6___2 = 235,
    _SC_RAW_SOCKETS___2 = 236,
    _SC_V7_ILP32_OFF32___2 = 237,
    _SC_V7_ILP32_OFFBIG___2 = 238,
    _SC_V7_LP64_OFF64___2 = 239,
    _SC_V7_LPBIG_OFFBIG___2 = 240,
    _SC_SS_REPL_MAX___2 = 241,
    _SC_TRACE_EVENT_NAME_MAX___2 = 242,
    _SC_TRACE_NAME_MAX___2 = 243,
    _SC_TRACE_SYS_MAX___2 = 244,
    _SC_TRACE_USER_EVENT_MAX___2 = 245,
    _SC_XOPEN_STREAMS___2 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___2 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___2 = 248,
    _SC_MINSIGSTKSZ___2 = 249,
    _SC_SIGSTKSZ___2 = 250
} ;
#line 539
enum __anonenum__178 {
    _CS_PATH___2 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___2 = 1,
    _CS_GNU_LIBC_VERSION___2 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___2 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___2 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___2 = 5,
    _CS_LFS_CFLAGS___2 = 1000,
    _CS_LFS_LDFLAGS___2 = 1001,
    _CS_LFS_LIBS___2 = 1002,
    _CS_LFS_LINTFLAGS___2 = 1003,
    _CS_LFS64_CFLAGS___2 = 1004,
    _CS_LFS64_LDFLAGS___2 = 1005,
    _CS_LFS64_LIBS___2 = 1006,
    _CS_LFS64_LINTFLAGS___2 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___2 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___2 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___2 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___2 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___2 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___2 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___2 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___2 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___2 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___2 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___2 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___2 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___2 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___2 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___2 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___2 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___2 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___2 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___2 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___2 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___2 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___2 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___2 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___2 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___2 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___2 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___2 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___2 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___2 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___2 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___2 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___2 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___2 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___2 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___2 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___2 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___2 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___2 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___2 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___2 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___2 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___2 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___2 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___2 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___2 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___2 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___2 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___2 = 1147,
    _CS_V6_ENV___2 = 1148,
    _CS_V7_ENV___2 = 1149
} ;
#line 143 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef long ptrdiff_t;
#line 415 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
struct __anonstruct_181 {
   long long __max_align_ll ;
   long double __max_align_ld ;
};
#line 426 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef struct __anonstruct_181 max_align_t;
#line 42 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef signed char gint8;
#line 43 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned char guint8;
#line 45 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef short gint16;
#line 46 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned short guint16;
#line 53 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef int gint32;
#line 54 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned int guint32;
#line 63 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef long gint64;
#line 64 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned long guint64;
#line 79 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef long gssize;
#line 80 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned long gsize;
#line 90 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef gint64 goffset;
#line 106 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef long gintptr;
#line 107 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned long guintptr;
#line 199 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef int GPid;
#line 26 "/usr/include/x86_64-linux-gnu/bits/timex.h"
struct timex {
   unsigned int modes ;
   __syscall_slong_t offset ;
   __syscall_slong_t freq ;
   __syscall_slong_t maxerror ;
   __syscall_slong_t esterror ;
   int status ;
   __syscall_slong_t constant ;
   __syscall_slong_t precision ;
   __syscall_slong_t tolerance ;
   struct timeval time ;
   __syscall_slong_t tick ;
   __syscall_slong_t ppsfreq ;
   __syscall_slong_t jitter ;
   int shift ;
   __syscall_slong_t stabil ;
   __syscall_slong_t jitcnt ;
   __syscall_slong_t calcnt ;
   __syscall_slong_t errcnt ;
   __syscall_slong_t stbcnt ;
   int tai ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 49 "/usr/include/time.h"
struct sigevent ;
#line 46 "/usr/include/glib-2.0/glib/gtypes.h"
typedef char gchar;
#line 47 "/usr/include/glib-2.0/glib/gtypes.h"
typedef short gshort;
#line 48 "/usr/include/glib-2.0/glib/gtypes.h"
typedef long glong;
#line 49 "/usr/include/glib-2.0/glib/gtypes.h"
typedef int gint;
#line 50 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gint gboolean;
#line 52 "/usr/include/glib-2.0/glib/gtypes.h"
typedef unsigned char guchar;
#line 53 "/usr/include/glib-2.0/glib/gtypes.h"
typedef unsigned short gushort;
#line 54 "/usr/include/glib-2.0/glib/gtypes.h"
typedef unsigned long gulong;
#line 55 "/usr/include/glib-2.0/glib/gtypes.h"
typedef unsigned int guint;
#line 57 "/usr/include/glib-2.0/glib/gtypes.h"
typedef float gfloat;
#line 58 "/usr/include/glib-2.0/glib/gtypes.h"
typedef double gdouble;
#line 103 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void *gpointer;
#line 104 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void const   *gconstpointer;
#line 106 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gint (*GCompareFunc)(gconstpointer  , gconstpointer  );
#line 108 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gint (*GCompareDataFunc)(gconstpointer  , gconstpointer  , gpointer  );
#line 111 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gboolean (*GEqualFunc)(gconstpointer  , gconstpointer  );
#line 113 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void (*GDestroyNotify)(gpointer  );
#line 114 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void (*GFunc)(gpointer  , gpointer  );
#line 116 "/usr/include/glib-2.0/glib/gtypes.h"
typedef guint (*GHashFunc)(gconstpointer  );
#line 117 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void (*GHFunc)(gpointer  , gpointer  , gpointer  );
#line 133 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gpointer (*GCopyFunc)(gconstpointer  , gpointer  );
#line 143 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void (*GFreeFunc)(gpointer  );
#line 157 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gchar *(*GTranslateFunc)(gchar * , gpointer  );
#line 501
union _GDoubleIEEE754 ;
#line 501 "/usr/include/glib-2.0/glib/gtypes.h"
typedef union _GDoubleIEEE754 GDoubleIEEE754;
#line 502
union _GFloatIEEE754 ;
#line 502 "/usr/include/glib-2.0/glib/gtypes.h"
typedef union _GFloatIEEE754 GFloatIEEE754;
#line 511 "/usr/include/glib-2.0/glib/gtypes.h"
struct __anonstruct_182 {
   guint mantissa ;
   guint biased_exponent ;
   guint sign ;
};
#line 508 "/usr/include/glib-2.0/glib/gtypes.h"
union _GFloatIEEE754 {
   gfloat v_float ;
   struct __anonstruct_182 mpn ;
};
#line 520 "/usr/include/glib-2.0/glib/gtypes.h"
struct __anonstruct_183 {
   guint mantissa_low ;
   guint mantissa_high ;
   guint biased_exponent ;
   guint sign ;
};
#line 517 "/usr/include/glib-2.0/glib/gtypes.h"
union _GDoubleIEEE754 {
   gdouble v_double ;
   struct __anonstruct_183 mpn ;
};
#line 551
struct _GTimeVal ;
#line 551 "/usr/include/glib-2.0/glib/gtypes.h"
typedef struct _GTimeVal GTimeVal;
#line 553 "/usr/include/glib-2.0/glib/gtypes.h"
struct _GTimeVal {
   glong tv_sec ;
   glong tv_usec ;
};
#line 559 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gint grefcount;
#line 560 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gint gatomicrefcount;
#line 36 "/usr/include/glib-2.0/glib/garray.h"
struct _GBytes ;
#line 36 "/usr/include/glib-2.0/glib/garray.h"
typedef struct _GBytes GBytes;
#line 37
struct _GArray ;
#line 37 "/usr/include/glib-2.0/glib/garray.h"
typedef struct _GArray GArray;
#line 38
struct _GByteArray ;
#line 38 "/usr/include/glib-2.0/glib/garray.h"
typedef struct _GByteArray GByteArray;
#line 39
struct _GPtrArray ;
#line 39 "/usr/include/glib-2.0/glib/garray.h"
typedef struct _GPtrArray GPtrArray;
#line 41 "/usr/include/glib-2.0/glib/garray.h"
struct _GArray {
   gchar *data ;
   guint len ;
};
#line 47 "/usr/include/glib-2.0/glib/garray.h"
struct _GByteArray {
   guint8 *data ;
   guint len ;
};
#line 53 "/usr/include/glib-2.0/glib/garray.h"
struct _GPtrArray {
   gpointer *pdata ;
   guint len ;
};
#line 36 "/usr/include/glib-2.0/glib/gquark.h"
typedef guint32 GQuark;
#line 41 "/usr/include/glib-2.0/glib/gerror.h"
struct _GError ;
#line 41 "/usr/include/glib-2.0/glib/gerror.h"
typedef struct _GError GError;
#line 43 "/usr/include/glib-2.0/glib/gerror.h"
struct _GError {
   GQuark domain ;
   gint code ;
   gchar *message ;
};
#line 140 "/usr/include/glib-2.0/glib/gerror.h"
typedef void (*GErrorInitFunc)(GError * );
#line 158 "/usr/include/glib-2.0/glib/gerror.h"
typedef void (*GErrorCopyFunc)(GError * , GError * );
#line 173 "/usr/include/glib-2.0/glib/gerror.h"
typedef void (*GErrorClearFunc)(GError * );
#line 252 "/usr/include/glib-2.0/glib/gutils.h"
enum __anonenum__184 {
    G_USER_DIRECTORY_DESKTOP = 0,
    G_USER_DIRECTORY_DOCUMENTS = 1,
    G_USER_DIRECTORY_DOWNLOAD = 2,
    G_USER_DIRECTORY_MUSIC = 3,
    G_USER_DIRECTORY_PICTURES = 4,
    G_USER_DIRECTORY_PUBLIC_SHARE = 5,
    G_USER_DIRECTORY_TEMPLATES = 6,
    G_USER_DIRECTORY_VIDEOS = 7,
    G_USER_N_DIRECTORIES = 8
} ;
#line 263 "/usr/include/glib-2.0/glib/gutils.h"
typedef enum __anonenum__184 GUserDirectory;
#line 276
struct _GDebugKey ;
#line 276 "/usr/include/glib-2.0/glib/gutils.h"
typedef struct _GDebugKey GDebugKey;
#line 277 "/usr/include/glib-2.0/glib/gutils.h"
struct _GDebugKey {
   gchar *key ;
   guint value ;
};
#line 305
enum __anonenum__185 {
    G_FORMAT_SIZE_DEFAULT = 0,
    G_FORMAT_SIZE_LONG_FORMAT = 1,
    G_FORMAT_SIZE_IEC_UNITS = 2,
    G_FORMAT_SIZE_BITS = 4
} ;
#line 311 "/usr/include/glib-2.0/glib/gutils.h"
typedef enum __anonenum__185 GFormatSizeFlags;
#line 333 "/usr/include/glib-2.0/glib/gutils.h"
typedef void (*GVoidFunc)(void);
#line 42 "/usr/include/glib-2.0/glib/gthread.h"
enum __anonenum__186 {
    G_THREAD_ERROR_AGAIN = 0
} ;
#line 45 "/usr/include/glib-2.0/glib/gthread.h"
typedef enum __anonenum__186 GThreadError;
#line 47 "/usr/include/glib-2.0/glib/gthread.h"
typedef gpointer (*GThreadFunc)(gpointer  );
#line 49
struct _GThread ;
#line 49 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GThread GThread;
#line 51
union _GMutex ;
#line 51 "/usr/include/glib-2.0/glib/gthread.h"
typedef union _GMutex GMutex;
#line 52
struct _GRecMutex ;
#line 52 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GRecMutex GRecMutex;
#line 53
struct _GRWLock ;
#line 53 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GRWLock GRWLock;
#line 54
struct _GCond ;
#line 54 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GCond GCond;
#line 55
struct _GPrivate ;
#line 55 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GPrivate GPrivate;
#line 56
struct _GOnce ;
#line 56 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GOnce GOnce;
#line 58 "/usr/include/glib-2.0/glib/gthread.h"
union _GMutex {
   gpointer p ;
   guint i[2] ;
};
#line 65 "/usr/include/glib-2.0/glib/gthread.h"
struct _GRWLock {
   gpointer p ;
   guint i[2] ;
};
#line 72 "/usr/include/glib-2.0/glib/gthread.h"
struct _GCond {
   gpointer p ;
   guint i[2] ;
};
#line 79 "/usr/include/glib-2.0/glib/gthread.h"
struct _GRecMutex {
   gpointer p ;
   guint i[2] ;
};
#line 87 "/usr/include/glib-2.0/glib/gthread.h"
struct _GPrivate {
   gpointer p ;
   GDestroyNotify notify ;
   gpointer future[2] ;
};
#line 95
enum __anonenum__187 {
    G_ONCE_STATUS_NOTCALLED = 0,
    G_ONCE_STATUS_PROGRESS = 1,
    G_ONCE_STATUS_READY = 2
} ;
#line 100 "/usr/include/glib-2.0/glib/gthread.h"
typedef enum __anonenum__187 GOnceStatus;
#line 103 "/usr/include/glib-2.0/glib/gthread.h"
struct _GOnce {
   GOnceStatus status ;
   gpointer retval ;
};
#line 285 "/usr/include/glib-2.0/glib/gthread.h"
typedef void GMutexLocker;
#line 360 "/usr/include/glib-2.0/glib/gthread.h"
typedef void GRecMutexLocker;
#line 439 "/usr/include/glib-2.0/glib/gthread.h"
typedef void GRWLockWriterLocker;
#line 550 "/usr/include/glib-2.0/glib/gthread.h"
typedef void GRWLockReaderLocker;
#line 36 "/usr/include/glib-2.0/glib/gasyncqueue.h"
struct _GAsyncQueue ;
#line 36 "/usr/include/glib-2.0/glib/gasyncqueue.h"
typedef struct _GAsyncQueue GAsyncQueue;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/sig_atomic_t.h"
typedef __sig_atomic_t sig_atomic_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
typedef union sigval __sigval_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_190 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 63 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_191 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
#line 71 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_192 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
#line 79 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_193 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_196 {
   void *_lower ;
   void *_upper ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion_195 {
   struct __anonstruct_196 _addr_bnd ;
   __uint32_t _pkey ;
};
#line 89 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_194 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion_195 _bounds ;
};
#line 108 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_197 {
   long si_band ;
   int si_fd ;
};
#line 116 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_198 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 51 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion_189 {
   int _pad[28] ;
   struct __anonstruct_190 _kill ;
   struct __anonstruct_191 _timer ;
   struct __anonstruct_192 _rt ;
   struct __anonstruct_193 _sigchld ;
   struct __anonstruct_194 _sigfault ;
   struct __anonstruct_197 _sigpoll ;
   struct __anonstruct_198 _sigsys ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_188 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion_189 _sifields ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
typedef struct __anonstruct_188 siginfo_t;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__199 {
    SI_ASYNCNL = -60,
    SI_DETHREAD = -7,
    SI_TKILL = -6,
    SI_SIGIO = -5,
    SI_ASYNCIO = -4,
    SI_MESGQ = -3,
    SI_TIMER = -2,
    SI_QUEUE = -1,
    SI_USER = 0,
    SI_KERNEL = 128
} ;
#line 71
enum __anonenum__200 {
    ILL_ILLOPC = 1,
    ILL_ILLOPN = 2,
    ILL_ILLADR = 3,
    ILL_ILLTRP = 4,
    ILL_PRVOPC = 5,
    ILL_PRVREG = 6,
    ILL_COPROC = 7,
    ILL_BADSTK = 8,
    ILL_BADIADDR = 9
} ;
#line 94
enum __anonenum__201 {
    FPE_INTDIV = 1,
    FPE_INTOVF = 2,
    FPE_FLTDIV = 3,
    FPE_FLTOVF = 4,
    FPE_FLTUND = 5,
    FPE_FLTRES = 6,
    FPE_FLTINV = 7,
    FPE_FLTSUB = 8,
    FPE_FLTUNK = 14,
    FPE_CONDTRAP = 15
} ;
#line 119
enum __anonenum__202 {
    SEGV_MAPERR = 1,
    SEGV_ACCERR = 2,
    SEGV_BNDERR = 3,
    SEGV_PKUERR = 4,
    SEGV_ACCADI = 5,
    SEGV_ADIDERR = 6,
    SEGV_ADIPERR = 7,
    SEGV_MTEAERR = 8,
    SEGV_MTESERR = 9
} ;
#line 142
enum __anonenum__203 {
    BUS_ADRALN = 1,
    BUS_ADRERR = 2,
    BUS_OBJERR = 3,
    BUS_MCEERR_AR = 4,
    BUS_MCEERR_AO = 5
} ;
#line 159
enum __anonenum__204 {
    TRAP_BRKPT = 1,
    TRAP_TRACE = 2,
    TRAP_BRANCH = 3,
    TRAP_HWBKPT = 4,
    TRAP_UNK = 5
} ;
#line 176
enum __anonenum__205 {
    CLD_EXITED = 1,
    CLD_KILLED = 2,
    CLD_DUMPED = 3,
    CLD_TRAPPED = 4,
    CLD_STOPPED = 5,
    CLD_CONTINUED = 6
} ;
#line 193
enum __anonenum__206 {
    POLL_IN = 1,
    POLL_OUT = 2,
    POLL_MSG = 3,
    POLL_ERR = 4,
    POLL_PRI = 5,
    POLL_HUP = 6
} ;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h"
typedef __sigval_t sigval_t;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
struct __anonstruct_208 {
   void (*_function)(__sigval_t  ) ;
   pthread_attr_t *_attribute ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
union __anonunion_207 {
   int _pad[12] ;
   __pid_t _tid ;
   struct __anonstruct_208 _sigev_thread ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
struct sigevent {
   __sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion_207 _sigev_un ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
typedef struct sigevent sigevent_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__209 {
    SIGEV_SIGNAL = 0,
    SIGEV_NONE = 1,
    SIGEV_THREAD = 2,
    SIGEV_THREAD_ID = 4
} ;
#line 72 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 188 "/usr/include/signal.h"
typedef __sighandler_t sighandler_t;
#line 193 "/usr/include/signal.h"
typedef __sighandler_t sig_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion_210 {
   __sighandler_t sa_handler ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion_210 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpx_sw_bytes {
   __uint32_t magic1 ;
   __uint32_t extended_size ;
   __uint64_t xstate_bv ;
   __uint32_t xstate_size ;
   __uint32_t __glibc_reserved1[7] ;
};
#line 40 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short __glibc_reserved1[3] ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xmmreg {
   __uint32_t element[4] ;
};
#line 123 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _fpxreg _st[8] ;
   struct _xmmreg _xmm[16] ;
   __uint32_t __glibc_reserved1[24] ;
};
#line 167 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
union __anonunion_211 {
   struct _fpstate *fpstate ;
   __uint64_t __fpstate_word ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct sigcontext {
   __uint64_t r8 ;
   __uint64_t r9 ;
   __uint64_t r10 ;
   __uint64_t r11 ;
   __uint64_t r12 ;
   __uint64_t r13 ;
   __uint64_t r14 ;
   __uint64_t r15 ;
   __uint64_t rdi ;
   __uint64_t rsi ;
   __uint64_t rbp ;
   __uint64_t rbx ;
   __uint64_t rdx ;
   __uint64_t rax ;
   __uint64_t rcx ;
   __uint64_t rsp ;
   __uint64_t rip ;
   __uint64_t eflags ;
   unsigned short cs ;
   unsigned short gs ;
   unsigned short fs ;
   unsigned short __pad0 ;
   __uint64_t err ;
   __uint64_t trapno ;
   __uint64_t oldmask ;
   __uint64_t cr2 ;
   union __anonunion_211  ;
   struct _fpstate *fpstate ;
   __uint64_t __fpstate_word ;
   __uint64_t __reserved1[8] ;
};
#line 177 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xsave_hdr {
   __uint64_t xstate_bv ;
   __uint64_t __glibc_reserved1[2] ;
   __uint64_t __glibc_reserved2[5] ;
};
#line 184 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _ymmh_state {
   __uint32_t ymmh_space[64] ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xstate {
   struct _fpstate fpstate ;
   struct _xsave_hdr xstate_hdr ;
   struct _ymmh_state ymmh ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h"
struct __anonstruct_212 {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h"
typedef struct __anonstruct_212 stack_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef long long greg_t;
#line 46 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef greg_t gregset_t[23];
#line 50
enum __anonenum__213 {
    REG_R8 = 0,
    REG_R9 = 1,
    REG_R10 = 2,
    REG_R11 = 3,
    REG_R12 = 4,
    REG_R13 = 5,
    REG_R14 = 6,
    REG_R15 = 7,
    REG_RDI = 8,
    REG_RSI = 9,
    REG_RBP = 10,
    REG_RBX = 11,
    REG_RDX = 12,
    REG_RAX = 13,
    REG_RCX = 14,
    REG_RSP = 15,
    REG_RIP = 16,
    REG_EFL = 17,
    REG_CSGSFS = 18,
    REG_ERR = 19,
    REG_TRAPNO = 20,
    REG_OLDMASK = 21,
    REG_CR2 = 22
} ;
#line 101 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short __glibc_reserved1[3] ;
};
#line 108 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_xmmreg {
   __uint32_t element[4] ;
};
#line 113 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _libc_fpxreg _st[8] ;
   struct _libc_xmmreg _xmm[16] ;
   __uint32_t __glibc_reserved1[24] ;
};
#line 130 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct _libc_fpstate *fpregset_t;
#line 133 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct __anonstruct_214 {
   gregset_t gregs ;
   fpregset_t fpregs ;
   unsigned long long __reserved1[8] ;
};
#line 139 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct __anonstruct_214 mcontext_t;
#line 142 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct ucontext_t {
   unsigned long uc_flags ;
   struct ucontext_t *uc_link ;
   stack_t uc_stack ;
   mcontext_t uc_mcontext ;
   sigset_t uc_sigmask ;
   struct _libc_fpstate __fpregs_mem ;
   unsigned long long __ssp[4] ;
};
#line 151 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct ucontext_t ucontext_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__215 {
    SS_ONSTACK = 1,
    SS_DISABLE = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h"
struct sigstack {
   void *ss_sp ;
   int ss_onstack ;
};
#line 32 "/usr/include/glib-2.0/glib/gtimezone.h"
struct _GTimeZone ;
#line 32 "/usr/include/glib-2.0/glib/gtimezone.h"
typedef struct _GTimeZone GTimeZone;
#line 49
enum __anonenum__216 {
    G_TIME_TYPE_STANDARD = 0,
    G_TIME_TYPE_DAYLIGHT = 1,
    G_TIME_TYPE_UNIVERSAL = 2
} ;
#line 54 "/usr/include/glib-2.0/glib/gtimezone.h"
typedef enum __anonenum__216 GTimeType;
#line 87 "/usr/include/glib-2.0/glib/gdatetime.h"
typedef gint64 GTimeSpan;
#line 96
struct _GDateTime ;
#line 96 "/usr/include/glib-2.0/glib/gdatetime.h"
typedef struct _GDateTime GDateTime;
#line 58 "/usr/include/glib-2.0/glib/gbookmarkfile.h"
enum __anonenum__217 {
    G_BOOKMARK_FILE_ERROR_INVALID_URI = 0,
    G_BOOKMARK_FILE_ERROR_INVALID_VALUE = 1,
    G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED = 2,
    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND = 3,
    G_BOOKMARK_FILE_ERROR_READ = 4,
    G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING = 5,
    G_BOOKMARK_FILE_ERROR_WRITE = 6,
    G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND = 7
} ;
#line 68 "/usr/include/glib-2.0/glib/gbookmarkfile.h"
typedef enum __anonenum__217 GBookmarkFileError;
#line 78
struct _GBookmarkFile ;
#line 78 "/usr/include/glib-2.0/glib/gbookmarkfile.h"
typedef struct _GBookmarkFile GBookmarkFile;
#line 47 "/usr/include/glib-2.0/glib/gchecksum.h"
enum __anonenum__218 {
    G_CHECKSUM_MD5 = 0,
    G_CHECKSUM_SHA1 = 1,
    G_CHECKSUM_SHA256 = 2,
    G_CHECKSUM_SHA512 = 3,
    G_CHECKSUM_SHA384 = 4
} ;
#line 53 "/usr/include/glib-2.0/glib/gchecksum.h"
typedef enum __anonenum__218 GChecksumType;
#line 65
struct _GChecksum ;
#line 65 "/usr/include/glib-2.0/glib/gchecksum.h"
typedef struct _GChecksum GChecksum;
#line 54 "/usr/include/glib-2.0/glib/gconvert.h"
enum __anonenum__219 {
    G_CONVERT_ERROR_NO_CONVERSION = 0,
    G_CONVERT_ERROR_ILLEGAL_SEQUENCE = 1,
    G_CONVERT_ERROR_FAILED = 2,
    G_CONVERT_ERROR_PARTIAL_INPUT = 3,
    G_CONVERT_ERROR_BAD_URI = 4,
    G_CONVERT_ERROR_NOT_ABSOLUTE_PATH = 5,
    G_CONVERT_ERROR_NO_MEMORY = 6,
    G_CONVERT_ERROR_EMBEDDED_NUL = 7
} ;
#line 64 "/usr/include/glib-2.0/glib/gconvert.h"
typedef enum __anonenum__219 GConvertError;
#line 83
struct _GIConv ;
#line 83 "/usr/include/glib-2.0/glib/gconvert.h"
typedef struct _GIConv *GIConv;
#line 36 "/usr/include/glib-2.0/glib/gdataset.h"
struct _GData ;
#line 36 "/usr/include/glib-2.0/glib/gdataset.h"
typedef struct _GData GData;
#line 38 "/usr/include/glib-2.0/glib/gdataset.h"
typedef void (*GDataForeachFunc)(GQuark  , gpointer  , gpointer  );
#line 57 "/usr/include/glib-2.0/glib/gdataset.h"
typedef gpointer (*GDuplicateFunc)(gpointer  , gpointer  );
#line 48 "/usr/include/glib-2.0/glib/gdate.h"
typedef gint32 GTime;
#line 49 "/usr/include/glib-2.0/glib/gdate.h"
typedef guint16 GDateYear;
#line 50 "/usr/include/glib-2.0/glib/gdate.h"
typedef guint8 GDateDay;
#line 51
struct _GDate ;
#line 51 "/usr/include/glib-2.0/glib/gdate.h"
typedef struct _GDate GDate;
#line 54
enum __anonenum__220 {
    G_DATE_DAY = 0,
    G_DATE_MONTH = 1,
    G_DATE_YEAR = 2
} ;
#line 59 "/usr/include/glib-2.0/glib/gdate.h"
typedef enum __anonenum__220 GDateDMY;
#line 62
enum __anonenum__221 {
    G_DATE_BAD_WEEKDAY = 0,
    G_DATE_MONDAY = 1,
    G_DATE_TUESDAY = 2,
    G_DATE_WEDNESDAY = 3,
    G_DATE_THURSDAY = 4,
    G_DATE_FRIDAY = 5,
    G_DATE_SATURDAY = 6,
    G_DATE_SUNDAY = 7
} ;
#line 72 "/usr/include/glib-2.0/glib/gdate.h"
typedef enum __anonenum__221 GDateWeekday;
#line 73
enum __anonenum__222 {
    G_DATE_BAD_MONTH = 0,
    G_DATE_JANUARY = 1,
    G_DATE_FEBRUARY = 2,
    G_DATE_MARCH = 3,
    G_DATE_APRIL = 4,
    G_DATE_MAY = 5,
    G_DATE_JUNE = 6,
    G_DATE_JULY = 7,
    G_DATE_AUGUST = 8,
    G_DATE_SEPTEMBER = 9,
    G_DATE_OCTOBER = 10,
    G_DATE_NOVEMBER = 11,
    G_DATE_DECEMBER = 12
} ;
#line 88 "/usr/include/glib-2.0/glib/gdate.h"
typedef enum __anonenum__222 GDateMonth;
#line 99 "/usr/include/glib-2.0/glib/gdate.h"
struct _GDate {
   guint julian_days ;
   guint julian ;
   guint dmy ;
   guint day ;
   guint month ;
   guint year ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 37 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent64 {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 97 "/usr/include/dirent.h"
enum __anonenum__223 {
    DT_UNKNOWN = 0,
    DT_FIFO = 1,
    DT_CHR = 2,
    DT_DIR = 4,
    DT_BLK = 6,
    DT_REG = 8,
    DT_LNK = 10,
    DT_SOCK = 12,
    DT_WHT = 14
} ;
#line 127
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 37 "/usr/include/glib-2.0/glib/gdir.h"
struct _GDir ;
#line 37 "/usr/include/glib-2.0/glib/gdir.h"
typedef struct _GDir GDir;
#line 33 "/usr/include/glib-2.0/glib/gfileutils.h"
enum __anonenum__224 {
    G_FILE_ERROR_EXIST = 0,
    G_FILE_ERROR_ISDIR = 1,
    G_FILE_ERROR_ACCES = 2,
    G_FILE_ERROR_NAMETOOLONG = 3,
    G_FILE_ERROR_NOENT = 4,
    G_FILE_ERROR_NOTDIR = 5,
    G_FILE_ERROR_NXIO = 6,
    G_FILE_ERROR_NODEV = 7,
    G_FILE_ERROR_ROFS = 8,
    G_FILE_ERROR_TXTBSY = 9,
    G_FILE_ERROR_FAULT = 10,
    G_FILE_ERROR_LOOP = 11,
    G_FILE_ERROR_NOSPC = 12,
    G_FILE_ERROR_NOMEM = 13,
    G_FILE_ERROR_MFILE = 14,
    G_FILE_ERROR_NFILE = 15,
    G_FILE_ERROR_BADF = 16,
    G_FILE_ERROR_INVAL = 17,
    G_FILE_ERROR_PIPE = 18,
    G_FILE_ERROR_AGAIN = 19,
    G_FILE_ERROR_INTR = 20,
    G_FILE_ERROR_IO = 21,
    G_FILE_ERROR_PERM = 22,
    G_FILE_ERROR_NOSYS = 23,
    G_FILE_ERROR_FAILED = 24
} ;
#line 60 "/usr/include/glib-2.0/glib/gfileutils.h"
typedef enum __anonenum__224 GFileError;
#line 66
enum __anonenum__225 {
    G_FILE_TEST_IS_REGULAR = 1,
    G_FILE_TEST_IS_SYMLINK = 2,
    G_FILE_TEST_IS_DIR = 4,
    G_FILE_TEST_IS_EXECUTABLE = 8,
    G_FILE_TEST_EXISTS = 16
} ;
#line 73 "/usr/include/glib-2.0/glib/gfileutils.h"
typedef enum __anonenum__225 GFileTest;
#line 99
enum __anonenum__226 {
    G_FILE_SET_CONTENTS_NONE = 0,
    G_FILE_SET_CONTENTS_CONSISTENT = 1,
    G_FILE_SET_CONTENTS_DURABLE = 2,
    G_FILE_SET_CONTENTS_ONLY_EXISTING = 4
} ;
#line 105 "/usr/include/glib-2.0/glib/gfileutils.h"
typedef enum __anonenum__226 GFileSetContentsFlags;
#line 52 "/usr/include/glib-2.0/glib/gmem.h"
struct _GMemVTable ;
#line 52 "/usr/include/glib-2.0/glib/gmem.h"
typedef struct _GMemVTable GMemVTable;
#line 380 "/usr/include/glib-2.0/glib/gmem.h"
struct _GMemVTable {
   gpointer (*malloc)(gsize  ) ;
   gpointer (*realloc)(gpointer  , gsize  ) ;
   void (*free)(gpointer  ) ;
   gpointer (*calloc)(gsize  , gsize  ) ;
   gpointer (*try_malloc)(gsize  ) ;
   gpointer (*try_realloc)(gpointer  , gsize  ) ;
};
#line 36 "/usr/include/glib-2.0/glib/gnode.h"
struct _GNode ;
#line 36 "/usr/include/glib-2.0/glib/gnode.h"
typedef struct _GNode GNode;
#line 39
enum __anonenum__227 {
    G_TRAVERSE_LEAVES = 1,
    G_TRAVERSE_NON_LEAVES = 2,
    G_TRAVERSE_ALL = 3,
    G_TRAVERSE_MASK = 3,
    G_TRAVERSE_LEAFS = 1,
    G_TRAVERSE_NON_LEAFS = 2
} ;
#line 47 "/usr/include/glib-2.0/glib/gnode.h"
typedef enum __anonenum__227 GTraverseFlags;
#line 50
enum __anonenum__228 {
    G_IN_ORDER = 0,
    G_PRE_ORDER = 1,
    G_POST_ORDER = 2,
    G_LEVEL_ORDER = 3
} ;
#line 56 "/usr/include/glib-2.0/glib/gnode.h"
typedef enum __anonenum__228 GTraverseType;
#line 58 "/usr/include/glib-2.0/glib/gnode.h"
typedef gboolean (*GNodeTraverseFunc)(GNode * , gpointer  );
#line 60 "/usr/include/glib-2.0/glib/gnode.h"
typedef void (*GNodeForeachFunc)(GNode * , gpointer  );
#line 65 "/usr/include/glib-2.0/glib/gnode.h"
struct _GNode {
   gpointer data ;
   GNode *next ;
   GNode *prev ;
   GNode *parent ;
   GNode *children ;
};
#line 37 "/usr/include/glib-2.0/glib/glist.h"
struct _GList ;
#line 37 "/usr/include/glib-2.0/glib/glist.h"
typedef struct _GList GList;
#line 39 "/usr/include/glib-2.0/glib/glist.h"
struct _GList {
   gpointer data ;
   GList *next ;
   GList *prev ;
};
#line 37 "/usr/include/glib-2.0/glib/ghash.h"
struct _GHashTable ;
#line 37 "/usr/include/glib-2.0/glib/ghash.h"
typedef struct _GHashTable GHashTable;
#line 39 "/usr/include/glib-2.0/glib/ghash.h"
typedef gboolean (*GHRFunc)(gpointer  , gpointer  , gpointer  );
#line 43
struct _GHashTableIter ;
#line 43 "/usr/include/glib-2.0/glib/ghash.h"
typedef struct _GHashTableIter GHashTableIter;
#line 45 "/usr/include/glib-2.0/glib/ghash.h"
struct _GHashTableIter {
   gpointer dummy1 ;
   gpointer dummy2 ;
   gpointer dummy3 ;
   int dummy4 ;
   gboolean dummy5 ;
   gpointer dummy6 ;
};
#line 40 "/usr/include/glib-2.0/glib/ghmac.h"
struct _GHmac ;
#line 40 "/usr/include/glib-2.0/glib/ghmac.h"
typedef struct _GHmac GHmac;
#line 38 "/usr/include/glib-2.0/glib/ghook.h"
struct _GHook ;
#line 38 "/usr/include/glib-2.0/glib/ghook.h"
typedef struct _GHook GHook;
#line 39
struct _GHookList ;
#line 39 "/usr/include/glib-2.0/glib/ghook.h"
typedef struct _GHookList GHookList;
#line 41 "/usr/include/glib-2.0/glib/ghook.h"
typedef gint (*GHookCompareFunc)(GHook * , GHook * );
#line 43 "/usr/include/glib-2.0/glib/ghook.h"
typedef gboolean (*GHookFindFunc)(GHook * , gpointer  );
#line 45 "/usr/include/glib-2.0/glib/ghook.h"
typedef void (*GHookMarshaller)(GHook * , gpointer  );
#line 47 "/usr/include/glib-2.0/glib/ghook.h"
typedef gboolean (*GHookCheckMarshaller)(GHook * , gpointer  );
#line 49 "/usr/include/glib-2.0/glib/ghook.h"
typedef void (*GHookFunc)(gpointer  );
#line 50 "/usr/include/glib-2.0/glib/ghook.h"
typedef gboolean (*GHookCheckFunc)(gpointer  );
#line 51 "/usr/include/glib-2.0/glib/ghook.h"
typedef void (*GHookFinalizeFunc)(GHookList * , GHook * );
#line 53
enum __anonenum__229 {
    G_HOOK_FLAG_ACTIVE = 1,
    G_HOOK_FLAG_IN_CALL = 2,
    G_HOOK_FLAG_MASK = 15
} ;
#line 58 "/usr/include/glib-2.0/glib/ghook.h"
typedef enum __anonenum__229 GHookFlagMask;
#line 63 "/usr/include/glib-2.0/glib/ghook.h"
struct _GHookList {
   gulong seq_id ;
   guint hook_size ;
   guint is_setup ;
   GHook *hooks ;
   gpointer dummy3 ;
   GHookFinalizeFunc finalize_hook ;
   gpointer dummy[2] ;
};
#line 73 "/usr/include/glib-2.0/glib/ghook.h"
struct _GHook {
   gpointer data ;
   GHook *next ;
   GHook *prev ;
   guint ref_count ;
   gulong hook_id ;
   guint flags ;
   gpointer func ;
   GDestroyNotify destroy ;
};
#line 59 "/usr/include/glib-2.0/glib/gpoll.h"
struct _GPollFD ;
#line 59 "/usr/include/glib-2.0/glib/gpoll.h"
typedef struct _GPollFD GPollFD;
#line 74 "/usr/include/glib-2.0/glib/gpoll.h"
typedef gint (*GPollFunc)(GPollFD * , guint  , gint  );
#line 91 "/usr/include/glib-2.0/glib/gpoll.h"
struct _GPollFD {
   gint fd ;
   gushort events ;
   gushort revents ;
};
#line 37 "/usr/include/glib-2.0/glib/gslist.h"
struct _GSList ;
#line 37 "/usr/include/glib-2.0/glib/gslist.h"
typedef struct _GSList GSList;
#line 39 "/usr/include/glib-2.0/glib/gslist.h"
struct _GSList {
   gpointer data ;
   GSList *next ;
};
#line 31 "/usr/include/glib-2.0/glib/gmain.h"
enum __anonenum__230 {
    G_IO_IN = 1,
    G_IO_OUT = 4,
    G_IO_PRI = 2,
    G_IO_ERR = 8,
    G_IO_HUP = 16,
    G_IO_NVAL = 32
} ;
#line 39 "/usr/include/glib-2.0/glib/gmain.h"
typedef enum __anonenum__230 GIOCondition;
#line 55
enum __anonenum__231 {
    G_MAIN_CONTEXT_FLAGS_NONE = 0,
    G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING = 1
} ;
#line 59 "/usr/include/glib-2.0/glib/gmain.h"
typedef enum __anonenum__231 GMainContextFlags;
#line 68
struct _GMainContext ;
#line 68 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GMainContext GMainContext;
#line 76
struct _GMainLoop ;
#line 76 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GMainLoop GMainLoop;
#line 84
struct _GSource ;
#line 84 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GSource GSource;
#line 85
struct _GSourcePrivate ;
#line 85 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GSourcePrivate GSourcePrivate;
#line 97
struct _GSourceCallbackFuncs ;
#line 97 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GSourceCallbackFuncs GSourceCallbackFuncs;
#line 153
struct _GSourceFuncs ;
#line 153 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GSourceFuncs GSourceFuncs;
#line 193 "/usr/include/glib-2.0/glib/gmain.h"
typedef gboolean (*GSourceFunc)(gpointer  );
#line 228 "/usr/include/glib-2.0/glib/gmain.h"
typedef void (*GChildWatchFunc)(GPid  , gint  , gpointer  );
#line 243 "/usr/include/glib-2.0/glib/gmain.h"
typedef void (*GSourceDisposeFunc)(GSource * );
#line 245 "/usr/include/glib-2.0/glib/gmain.h"
struct _GSource {
   gpointer callback_data ;
   GSourceCallbackFuncs *callback_funcs ;
   GSourceFuncs *source_funcs ;
   guint ref_count ;
   GMainContext *context ;
   gint priority ;
   guint flags ;
   guint source_id ;
   GSList *poll_fds ;
   GSource *prev ;
   GSource *next ;
   char *name ;
   GSourcePrivate *priv ;
};
#line 270 "/usr/include/glib-2.0/glib/gmain.h"
struct _GSourceCallbackFuncs {
   void (*ref)(gpointer  ) ;
   void (*unref)(gpointer  ) ;
   void (*get)(gpointer  , GSource * , GSourceFunc * , gpointer * ) ;
};
#line 286 "/usr/include/glib-2.0/glib/gmain.h"
typedef void (*GSourceDummyMarshal)(void);
#line 288 "/usr/include/glib-2.0/glib/gmain.h"
struct _GSourceFuncs {
   gboolean (*prepare)(GSource * , gint * ) ;
   gboolean (*check)(GSource * ) ;
   gboolean (*dispatch)(GSource * , GSourceFunc  , gpointer  ) ;
   void (*finalize)(GSource * ) ;
   GSourceFunc closure_callback ;
   GSourceDummyMarshal closure_marshal ;
};
#line 482 "/usr/include/glib-2.0/glib/gmain.h"
typedef void GMainContextPusher;
#line 741 "/usr/include/glib-2.0/glib/gmain.h"
typedef void (*GClearHandleFunc)(guint  );
#line 59 "/usr/include/glib-2.0/glib/gunicode.h"
typedef guint32 gunichar;
#line 77 "/usr/include/glib-2.0/glib/gunicode.h"
typedef guint16 gunichar2;
#line 116
enum __anonenum__232 {
    G_UNICODE_CONTROL = 0,
    G_UNICODE_FORMAT = 1,
    G_UNICODE_UNASSIGNED = 2,
    G_UNICODE_PRIVATE_USE = 3,
    G_UNICODE_SURROGATE = 4,
    G_UNICODE_LOWERCASE_LETTER = 5,
    G_UNICODE_MODIFIER_LETTER = 6,
    G_UNICODE_OTHER_LETTER = 7,
    G_UNICODE_TITLECASE_LETTER = 8,
    G_UNICODE_UPPERCASE_LETTER = 9,
    G_UNICODE_SPACING_MARK = 10,
    G_UNICODE_ENCLOSING_MARK = 11,
    G_UNICODE_NON_SPACING_MARK = 12,
    G_UNICODE_DECIMAL_NUMBER = 13,
    G_UNICODE_LETTER_NUMBER = 14,
    G_UNICODE_OTHER_NUMBER = 15,
    G_UNICODE_CONNECT_PUNCTUATION = 16,
    G_UNICODE_DASH_PUNCTUATION = 17,
    G_UNICODE_CLOSE_PUNCTUATION = 18,
    G_UNICODE_FINAL_PUNCTUATION = 19,
    G_UNICODE_INITIAL_PUNCTUATION = 20,
    G_UNICODE_OTHER_PUNCTUATION = 21,
    G_UNICODE_OPEN_PUNCTUATION = 22,
    G_UNICODE_CURRENCY_SYMBOL = 23,
    G_UNICODE_MODIFIER_SYMBOL = 24,
    G_UNICODE_MATH_SYMBOL = 25,
    G_UNICODE_OTHER_SYMBOL = 26,
    G_UNICODE_LINE_SEPARATOR = 27,
    G_UNICODE_PARAGRAPH_SEPARATOR = 28,
    G_UNICODE_SPACE_SEPARATOR = 29
} ;
#line 148 "/usr/include/glib-2.0/glib/gunicode.h"
typedef enum __anonenum__232 GUnicodeType;
#line 213
enum __anonenum__233 {
    G_UNICODE_BREAK_MANDATORY = 0,
    G_UNICODE_BREAK_CARRIAGE_RETURN = 1,
    G_UNICODE_BREAK_LINE_FEED = 2,
    G_UNICODE_BREAK_COMBINING_MARK = 3,
    G_UNICODE_BREAK_SURROGATE = 4,
    G_UNICODE_BREAK_ZERO_WIDTH_SPACE = 5,
    G_UNICODE_BREAK_INSEPARABLE = 6,
    G_UNICODE_BREAK_NON_BREAKING_GLUE = 7,
    G_UNICODE_BREAK_CONTINGENT = 8,
    G_UNICODE_BREAK_SPACE = 9,
    G_UNICODE_BREAK_AFTER = 10,
    G_UNICODE_BREAK_BEFORE = 11,
    G_UNICODE_BREAK_BEFORE_AND_AFTER = 12,
    G_UNICODE_BREAK_HYPHEN = 13,
    G_UNICODE_BREAK_NON_STARTER = 14,
    G_UNICODE_BREAK_OPEN_PUNCTUATION = 15,
    G_UNICODE_BREAK_CLOSE_PUNCTUATION = 16,
    G_UNICODE_BREAK_QUOTATION = 17,
    G_UNICODE_BREAK_EXCLAMATION = 18,
    G_UNICODE_BREAK_IDEOGRAPHIC = 19,
    G_UNICODE_BREAK_NUMERIC = 20,
    G_UNICODE_BREAK_INFIX_SEPARATOR = 21,
    G_UNICODE_BREAK_SYMBOL = 22,
    G_UNICODE_BREAK_ALPHABETIC = 23,
    G_UNICODE_BREAK_PREFIX = 24,
    G_UNICODE_BREAK_POSTFIX = 25,
    G_UNICODE_BREAK_COMPLEX_CONTEXT = 26,
    G_UNICODE_BREAK_AMBIGUOUS = 27,
    G_UNICODE_BREAK_UNKNOWN = 28,
    G_UNICODE_BREAK_NEXT_LINE = 29,
    G_UNICODE_BREAK_WORD_JOINER = 30,
    G_UNICODE_BREAK_HANGUL_L_JAMO = 31,
    G_UNICODE_BREAK_HANGUL_V_JAMO = 32,
    G_UNICODE_BREAK_HANGUL_T_JAMO = 33,
    G_UNICODE_BREAK_HANGUL_LV_SYLLABLE = 34,
    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE = 35,
    G_UNICODE_BREAK_CLOSE_PARANTHESIS = 36,
    G_UNICODE_BREAK_CLOSE_PARENTHESIS = 36,
    G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER = 37,
    G_UNICODE_BREAK_HEBREW_LETTER = 38,
    G_UNICODE_BREAK_REGIONAL_INDICATOR = 39,
    G_UNICODE_BREAK_EMOJI_BASE = 40,
    G_UNICODE_BREAK_EMOJI_MODIFIER = 41,
    G_UNICODE_BREAK_ZERO_WIDTH_JOINER = 42
} ;
#line 259 "/usr/include/glib-2.0/glib/gunicode.h"
typedef enum __anonenum__233 GUnicodeBreakType;
#line 449
enum __anonenum__234 {
    G_UNICODE_SCRIPT_INVALID_CODE = -1,
    G_UNICODE_SCRIPT_COMMON = 0,
    G_UNICODE_SCRIPT_INHERITED = 1,
    G_UNICODE_SCRIPT_ARABIC = 2,
    G_UNICODE_SCRIPT_ARMENIAN = 3,
    G_UNICODE_SCRIPT_BENGALI = 4,
    G_UNICODE_SCRIPT_BOPOMOFO = 5,
    G_UNICODE_SCRIPT_CHEROKEE = 6,
    G_UNICODE_SCRIPT_COPTIC = 7,
    G_UNICODE_SCRIPT_CYRILLIC = 8,
    G_UNICODE_SCRIPT_DESERET = 9,
    G_UNICODE_SCRIPT_DEVANAGARI = 10,
    G_UNICODE_SCRIPT_ETHIOPIC = 11,
    G_UNICODE_SCRIPT_GEORGIAN = 12,
    G_UNICODE_SCRIPT_GOTHIC = 13,
    G_UNICODE_SCRIPT_GREEK = 14,
    G_UNICODE_SCRIPT_GUJARATI = 15,
    G_UNICODE_SCRIPT_GURMUKHI = 16,
    G_UNICODE_SCRIPT_HAN = 17,
    G_UNICODE_SCRIPT_HANGUL = 18,
    G_UNICODE_SCRIPT_HEBREW = 19,
    G_UNICODE_SCRIPT_HIRAGANA = 20,
    G_UNICODE_SCRIPT_KANNADA = 21,
    G_UNICODE_SCRIPT_KATAKANA = 22,
    G_UNICODE_SCRIPT_KHMER = 23,
    G_UNICODE_SCRIPT_LAO = 24,
    G_UNICODE_SCRIPT_LATIN = 25,
    G_UNICODE_SCRIPT_MALAYALAM = 26,
    G_UNICODE_SCRIPT_MONGOLIAN = 27,
    G_UNICODE_SCRIPT_MYANMAR = 28,
    G_UNICODE_SCRIPT_OGHAM = 29,
    G_UNICODE_SCRIPT_OLD_ITALIC = 30,
    G_UNICODE_SCRIPT_ORIYA = 31,
    G_UNICODE_SCRIPT_RUNIC = 32,
    G_UNICODE_SCRIPT_SINHALA = 33,
    G_UNICODE_SCRIPT_SYRIAC = 34,
    G_UNICODE_SCRIPT_TAMIL = 35,
    G_UNICODE_SCRIPT_TELUGU = 36,
    G_UNICODE_SCRIPT_THAANA = 37,
    G_UNICODE_SCRIPT_THAI = 38,
    G_UNICODE_SCRIPT_TIBETAN = 39,
    G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL = 40,
    G_UNICODE_SCRIPT_YI = 41,
    G_UNICODE_SCRIPT_TAGALOG = 42,
    G_UNICODE_SCRIPT_HANUNOO = 43,
    G_UNICODE_SCRIPT_BUHID = 44,
    G_UNICODE_SCRIPT_TAGBANWA = 45,
    G_UNICODE_SCRIPT_BRAILLE = 46,
    G_UNICODE_SCRIPT_CYPRIOT = 47,
    G_UNICODE_SCRIPT_LIMBU = 48,
    G_UNICODE_SCRIPT_OSMANYA = 49,
    G_UNICODE_SCRIPT_SHAVIAN = 50,
    G_UNICODE_SCRIPT_LINEAR_B = 51,
    G_UNICODE_SCRIPT_TAI_LE = 52,
    G_UNICODE_SCRIPT_UGARITIC = 53,
    G_UNICODE_SCRIPT_NEW_TAI_LUE = 54,
    G_UNICODE_SCRIPT_BUGINESE = 55,
    G_UNICODE_SCRIPT_GLAGOLITIC = 56,
    G_UNICODE_SCRIPT_TIFINAGH = 57,
    G_UNICODE_SCRIPT_SYLOTI_NAGRI = 58,
    G_UNICODE_SCRIPT_OLD_PERSIAN = 59,
    G_UNICODE_SCRIPT_KHAROSHTHI = 60,
    G_UNICODE_SCRIPT_UNKNOWN = 61,
    G_UNICODE_SCRIPT_BALINESE = 62,
    G_UNICODE_SCRIPT_CUNEIFORM = 63,
    G_UNICODE_SCRIPT_PHOENICIAN = 64,
    G_UNICODE_SCRIPT_PHAGS_PA = 65,
    G_UNICODE_SCRIPT_NKO = 66,
    G_UNICODE_SCRIPT_KAYAH_LI = 67,
    G_UNICODE_SCRIPT_LEPCHA = 68,
    G_UNICODE_SCRIPT_REJANG = 69,
    G_UNICODE_SCRIPT_SUNDANESE = 70,
    G_UNICODE_SCRIPT_SAURASHTRA = 71,
    G_UNICODE_SCRIPT_CHAM = 72,
    G_UNICODE_SCRIPT_OL_CHIKI = 73,
    G_UNICODE_SCRIPT_VAI = 74,
    G_UNICODE_SCRIPT_CARIAN = 75,
    G_UNICODE_SCRIPT_LYCIAN = 76,
    G_UNICODE_SCRIPT_LYDIAN = 77,
    G_UNICODE_SCRIPT_AVESTAN = 78,
    G_UNICODE_SCRIPT_BAMUM = 79,
    G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS = 80,
    G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC = 81,
    G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI = 82,
    G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN = 83,
    G_UNICODE_SCRIPT_JAVANESE = 84,
    G_UNICODE_SCRIPT_KAITHI = 85,
    G_UNICODE_SCRIPT_LISU = 86,
    G_UNICODE_SCRIPT_MEETEI_MAYEK = 87,
    G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN = 88,
    G_UNICODE_SCRIPT_OLD_TURKIC = 89,
    G_UNICODE_SCRIPT_SAMARITAN = 90,
    G_UNICODE_SCRIPT_TAI_THAM = 91,
    G_UNICODE_SCRIPT_TAI_VIET = 92,
    G_UNICODE_SCRIPT_BATAK = 93,
    G_UNICODE_SCRIPT_BRAHMI = 94,
    G_UNICODE_SCRIPT_MANDAIC = 95,
    G_UNICODE_SCRIPT_CHAKMA = 96,
    G_UNICODE_SCRIPT_MEROITIC_CURSIVE = 97,
    G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS = 98,
    G_UNICODE_SCRIPT_MIAO = 99,
    G_UNICODE_SCRIPT_SHARADA = 100,
    G_UNICODE_SCRIPT_SORA_SOMPENG = 101,
    G_UNICODE_SCRIPT_TAKRI = 102,
    G_UNICODE_SCRIPT_BASSA_VAH = 103,
    G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN = 104,
    G_UNICODE_SCRIPT_DUPLOYAN = 105,
    G_UNICODE_SCRIPT_ELBASAN = 106,
    G_UNICODE_SCRIPT_GRANTHA = 107,
    G_UNICODE_SCRIPT_KHOJKI = 108,
    G_UNICODE_SCRIPT_KHUDAWADI = 109,
    G_UNICODE_SCRIPT_LINEAR_A = 110,
    G_UNICODE_SCRIPT_MAHAJANI = 111,
    G_UNICODE_SCRIPT_MANICHAEAN = 112,
    G_UNICODE_SCRIPT_MENDE_KIKAKUI = 113,
    G_UNICODE_SCRIPT_MODI = 114,
    G_UNICODE_SCRIPT_MRO = 115,
    G_UNICODE_SCRIPT_NABATAEAN = 116,
    G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN = 117,
    G_UNICODE_SCRIPT_OLD_PERMIC = 118,
    G_UNICODE_SCRIPT_PAHAWH_HMONG = 119,
    G_UNICODE_SCRIPT_PALMYRENE = 120,
    G_UNICODE_SCRIPT_PAU_CIN_HAU = 121,
    G_UNICODE_SCRIPT_PSALTER_PAHLAVI = 122,
    G_UNICODE_SCRIPT_SIDDHAM = 123,
    G_UNICODE_SCRIPT_TIRHUTA = 124,
    G_UNICODE_SCRIPT_WARANG_CITI = 125,
    G_UNICODE_SCRIPT_AHOM = 126,
    G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS = 127,
    G_UNICODE_SCRIPT_HATRAN = 128,
    G_UNICODE_SCRIPT_MULTANI = 129,
    G_UNICODE_SCRIPT_OLD_HUNGARIAN = 130,
    G_UNICODE_SCRIPT_SIGNWRITING = 131,
    G_UNICODE_SCRIPT_ADLAM = 132,
    G_UNICODE_SCRIPT_BHAIKSUKI = 133,
    G_UNICODE_SCRIPT_MARCHEN = 134,
    G_UNICODE_SCRIPT_NEWA = 135,
    G_UNICODE_SCRIPT_OSAGE = 136,
    G_UNICODE_SCRIPT_TANGUT = 137,
    G_UNICODE_SCRIPT_MASARAM_GONDI = 138,
    G_UNICODE_SCRIPT_NUSHU = 139,
    G_UNICODE_SCRIPT_SOYOMBO = 140,
    G_UNICODE_SCRIPT_ZANABAZAR_SQUARE = 141,
    G_UNICODE_SCRIPT_DOGRA = 142,
    G_UNICODE_SCRIPT_GUNJALA_GONDI = 143,
    G_UNICODE_SCRIPT_HANIFI_ROHINGYA = 144,
    G_UNICODE_SCRIPT_MAKASAR = 145,
    G_UNICODE_SCRIPT_MEDEFAIDRIN = 146,
    G_UNICODE_SCRIPT_OLD_SOGDIAN = 147,
    G_UNICODE_SCRIPT_SOGDIAN = 148,
    G_UNICODE_SCRIPT_ELYMAIC = 149,
    G_UNICODE_SCRIPT_NANDINAGARI = 150,
    G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG = 151,
    G_UNICODE_SCRIPT_WANCHO = 152,
    G_UNICODE_SCRIPT_CHORASMIAN = 153,
    G_UNICODE_SCRIPT_DIVES_AKURU = 154,
    G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT = 155,
    G_UNICODE_SCRIPT_YEZIDI = 156,
    G_UNICODE_SCRIPT_CYPRO_MINOAN = 157,
    G_UNICODE_SCRIPT_OLD_UYGHUR = 158,
    G_UNICODE_SCRIPT_TANGSA = 159,
    G_UNICODE_SCRIPT_TOTO = 160,
    G_UNICODE_SCRIPT_VITHKUQI = 161,
    G_UNICODE_SCRIPT_MATH = 162
} ;
#line 647 "/usr/include/glib-2.0/glib/gunicode.h"
typedef enum __anonenum__234 GUnicodeScript;
#line 930
enum __anonenum__235 {
    G_NORMALIZE_DEFAULT = 0,
    G_NORMALIZE_NFD = 0,
    G_NORMALIZE_DEFAULT_COMPOSE = 1,
    G_NORMALIZE_NFC = 1,
    G_NORMALIZE_ALL = 2,
    G_NORMALIZE_NFKD = 2,
    G_NORMALIZE_ALL_COMPOSE = 3,
    G_NORMALIZE_NFKC = 3
} ;
#line 939 "/usr/include/glib-2.0/glib/gunicode.h"
typedef enum __anonenum__235 GNormalizeMode;
#line 39 "/usr/include/glib-2.0/glib/gstring.h"
struct _GString ;
#line 39 "/usr/include/glib-2.0/glib/gstring.h"
typedef struct _GString GString;
#line 41 "/usr/include/glib-2.0/glib/gstring.h"
struct _GString {
   gchar *str ;
   gsize len ;
   gsize allocated_len ;
};
#line 41 "/usr/include/glib-2.0/glib/giochannel.h"
struct _GIOChannel ;
#line 41 "/usr/include/glib-2.0/glib/giochannel.h"
typedef struct _GIOChannel GIOChannel;
#line 42
struct _GIOFuncs ;
#line 42 "/usr/include/glib-2.0/glib/giochannel.h"
typedef struct _GIOFuncs GIOFuncs;
#line 44
enum __anonenum__236 {
    G_IO_ERROR_NONE = 0,
    G_IO_ERROR_AGAIN = 1,
    G_IO_ERROR_INVAL = 2,
    G_IO_ERROR_UNKNOWN = 3
} ;
#line 50 "/usr/include/glib-2.0/glib/giochannel.h"
typedef enum __anonenum__236 GIOError;
#line 54
enum __anonenum__237 {
    G_IO_CHANNEL_ERROR_FBIG = 0,
    G_IO_CHANNEL_ERROR_INVAL = 1,
    G_IO_CHANNEL_ERROR_IO = 2,
    G_IO_CHANNEL_ERROR_ISDIR = 3,
    G_IO_CHANNEL_ERROR_NOSPC = 4,
    G_IO_CHANNEL_ERROR_NXIO = 5,
    G_IO_CHANNEL_ERROR_OVERFLOW = 6,
    G_IO_CHANNEL_ERROR_PIPE = 7,
    G_IO_CHANNEL_ERROR_FAILED = 8
} ;
#line 67 "/usr/include/glib-2.0/glib/giochannel.h"
typedef enum __anonenum__237 GIOChannelError;
#line 69
enum __anonenum__238 {
    G_IO_STATUS_ERROR = 0,
    G_IO_STATUS_NORMAL = 1,
    G_IO_STATUS_EOF = 2,
    G_IO_STATUS_AGAIN = 3
} ;
#line 75 "/usr/include/glib-2.0/glib/giochannel.h"
typedef enum __anonenum__238 GIOStatus;
#line 77
enum __anonenum__239 {
    G_SEEK_CUR = 0,
    G_SEEK_SET = 1,
    G_SEEK_END = 2
} ;
#line 82 "/usr/include/glib-2.0/glib/giochannel.h"
typedef enum __anonenum__239 GSeekType;
#line 84
enum __anonenum__240 {
    G_IO_FLAG_APPEND = 1,
    G_IO_FLAG_NONBLOCK = 2,
    G_IO_FLAG_IS_READABLE = 4,
    G_IO_FLAG_IS_WRITABLE = 8,
    G_IO_FLAG_IS_WRITEABLE = 8,
    G_IO_FLAG_IS_SEEKABLE = 16,
    G_IO_FLAG_MASK = 31,
    G_IO_FLAG_GET_MASK = 31,
    G_IO_FLAG_SET_MASK = 3
} ;
#line 95 "/usr/include/glib-2.0/glib/giochannel.h"
typedef enum __anonenum__240 GIOFlags;
#line 97 "/usr/include/glib-2.0/glib/giochannel.h"
struct _GIOChannel {
   gint ref_count ;
   GIOFuncs *funcs ;
   gchar *encoding ;
   GIConv read_cd ;
   GIConv write_cd ;
   gchar *line_term ;
   guint line_term_len ;
   gsize buf_size ;
   GString *read_buf ;
   GString *encoded_read_buf ;
   GString *write_buf ;
   gchar partial_write_buf[6] ;
   guint use_buffer ;
   guint do_encode ;
   guint close_on_unref ;
   guint is_readable ;
   guint is_writeable ;
   guint is_seekable ;
   gpointer reserved1 ;
   gpointer reserved2 ;
};
#line 128 "/usr/include/glib-2.0/glib/giochannel.h"
typedef gboolean (*GIOFunc)(GIOChannel * , GIOCondition  , gpointer  );
#line 131 "/usr/include/glib-2.0/glib/giochannel.h"
struct _GIOFuncs {
   GIOStatus (*io_read)(GIOChannel * , gchar * , gsize  , gsize * , GError ** ) ;
   GIOStatus (*io_write)(GIOChannel * , gchar * , gsize  , gsize * , GError ** ) ;
   GIOStatus (*io_seek)(GIOChannel * , gint64  , GSeekType  , GError ** ) ;
   GIOStatus (*io_close)(GIOChannel * , GError ** ) ;
   GSource *(*io_create_watch)(GIOChannel * , GIOCondition  ) ;
   void (*io_free)(GIOChannel * ) ;
   GIOStatus (*io_set_flags)(GIOChannel * , GIOFlags  , GError ** ) ;
   GIOFlags (*io_get_flags)(GIOChannel * ) ;
};
#line 33 "/usr/include/glib-2.0/glib/gkeyfile.h"
enum __anonenum__241 {
    G_KEY_FILE_ERROR_UNKNOWN_ENCODING = 0,
    G_KEY_FILE_ERROR_PARSE = 1,
    G_KEY_FILE_ERROR_NOT_FOUND = 2,
    G_KEY_FILE_ERROR_KEY_NOT_FOUND = 3,
    G_KEY_FILE_ERROR_GROUP_NOT_FOUND = 4,
    G_KEY_FILE_ERROR_INVALID_VALUE = 5
} ;
#line 41 "/usr/include/glib-2.0/glib/gkeyfile.h"
typedef enum __anonenum__241 GKeyFileError;
#line 48
struct _GKeyFile ;
#line 48 "/usr/include/glib-2.0/glib/gkeyfile.h"
typedef struct _GKeyFile GKeyFile;
#line 50
enum __anonenum__242 {
    G_KEY_FILE_NONE = 0,
    G_KEY_FILE_KEEP_COMMENTS = 1,
    G_KEY_FILE_KEEP_TRANSLATIONS = 2
} ;
#line 55 "/usr/include/glib-2.0/glib/gkeyfile.h"
typedef enum __anonenum__242 GKeyFileFlags;
#line 32 "/usr/include/glib-2.0/glib/gmappedfile.h"
struct _GMappedFile ;
#line 32 "/usr/include/glib-2.0/glib/gmappedfile.h"
typedef struct _GMappedFile GMappedFile;
#line 49 "/usr/include/glib-2.0/glib/gmarkup.h"
enum __anonenum__243 {
    G_MARKUP_ERROR_BAD_UTF8 = 0,
    G_MARKUP_ERROR_EMPTY = 1,
    G_MARKUP_ERROR_PARSE = 2,
    G_MARKUP_ERROR_UNKNOWN_ELEMENT = 3,
    G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE = 4,
    G_MARKUP_ERROR_INVALID_CONTENT = 5,
    G_MARKUP_ERROR_MISSING_ATTRIBUTE = 6
} ;
#line 61 "/usr/include/glib-2.0/glib/gmarkup.h"
typedef enum __anonenum__243 GMarkupError;
#line 95
enum __anonenum__244 {
    G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1,
    G_MARKUP_TREAT_CDATA_AS_TEXT = 2,
    G_MARKUP_PREFIX_ERROR_POSITION = 4,
    G_MARKUP_IGNORE_QUALIFIED = 8
} ;
#line 101 "/usr/include/glib-2.0/glib/gmarkup.h"
typedef enum __anonenum__244 GMarkupParseFlags;
#line 112
struct _GMarkupParseContext ;
#line 112 "/usr/include/glib-2.0/glib/gmarkup.h"
typedef struct _GMarkupParseContext GMarkupParseContext;
#line 113
struct _GMarkupParser ;
#line 113 "/usr/include/glib-2.0/glib/gmarkup.h"
typedef struct _GMarkupParser GMarkupParser;
#line 143 "/usr/include/glib-2.0/glib/gmarkup.h"
struct _GMarkupParser {
   void (*start_element)(GMarkupParseContext * , gchar * , gchar ** , gchar ** , gpointer  ,
                         GError ** ) ;
   void (*end_element)(GMarkupParseContext * , gchar * , gpointer  , GError ** ) ;
   void (*text)(GMarkupParseContext * , gchar * , gsize  , gpointer  , GError ** ) ;
   void (*passthrough)(GMarkupParseContext * , gchar * , gsize  , gpointer  , GError ** ) ;
   void (*error)(GMarkupParseContext * , GError * , gpointer  ) ;
};
#line 237
enum __anonenum__245 {
    G_MARKUP_COLLECT_INVALID = 0,
    G_MARKUP_COLLECT_STRING = 1,
    G_MARKUP_COLLECT_STRDUP = 2,
    G_MARKUP_COLLECT_BOOLEAN = 3,
    G_MARKUP_COLLECT_TRISTATE = 4,
    G_MARKUP_COLLECT_OPTIONAL = 65536
} ;
#line 246 "/usr/include/glib-2.0/glib/gmarkup.h"
typedef enum __anonenum__245 GMarkupCollectType;
#line 41 "/usr/include/glib-2.0/glib/gvarianttype.h"
struct _GVariantType ;
#line 41 "/usr/include/glib-2.0/glib/gvarianttype.h"
typedef struct _GVariantType GVariantType;
#line 34 "/usr/include/glib-2.0/glib/gvariant.h"
struct _GVariant ;
#line 34 "/usr/include/glib-2.0/glib/gvariant.h"
typedef struct _GVariant GVariant;
#line 36
enum __anonenum__246 {
    G_VARIANT_CLASS_BOOLEAN = 98,
    G_VARIANT_CLASS_BYTE = 121,
    G_VARIANT_CLASS_INT16 = 110,
    G_VARIANT_CLASS_UINT16 = 113,
    G_VARIANT_CLASS_INT32 = 105,
    G_VARIANT_CLASS_UINT32 = 117,
    G_VARIANT_CLASS_INT64 = 120,
    G_VARIANT_CLASS_UINT64 = 116,
    G_VARIANT_CLASS_HANDLE = 104,
    G_VARIANT_CLASS_DOUBLE = 100,
    G_VARIANT_CLASS_STRING = 115,
    G_VARIANT_CLASS_OBJECT_PATH = 111,
    G_VARIANT_CLASS_SIGNATURE = 103,
    G_VARIANT_CLASS_VARIANT = 118,
    G_VARIANT_CLASS_MAYBE = 109,
    G_VARIANT_CLASS_ARRAY = 97,
    G_VARIANT_CLASS_TUPLE = 40,
    G_VARIANT_CLASS_DICT_ENTRY = 123
} ;
#line 56 "/usr/include/glib-2.0/glib/gvariant.h"
typedef enum __anonenum__246 GVariantClass;
#line 268
struct _GVariantIter ;
#line 268 "/usr/include/glib-2.0/glib/gvariant.h"
typedef struct _GVariantIter GVariantIter;
#line 269 "/usr/include/glib-2.0/glib/gvariant.h"
struct _GVariantIter {
   gsize x[16] ;
};
#line 297
struct _GVariantBuilder ;
#line 297 "/usr/include/glib-2.0/glib/gvariant.h"
typedef struct _GVariantBuilder GVariantBuilder;
#line 302 "/usr/include/glib-2.0/glib/gvariant.h"
struct __anonstruct_248 {
   gsize partial_magic ;
   GVariantType *type ;
   gsize y[14] ;
};
#line 300 "/usr/include/glib-2.0/glib/gvariant.h"
union __anonunion_247 {
   struct __anonstruct_248 s ;
   gsize x[16] ;
};
#line 298 "/usr/include/glib-2.0/glib/gvariant.h"
struct _GVariantBuilder {
   union __anonunion_247 u ;
};
#line 311
enum __anonenum__249 {
    G_VARIANT_PARSE_ERROR_FAILED = 0,
    G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED = 1,
    G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE = 2,
    G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED = 3,
    G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END = 4,
    G_VARIANT_PARSE_ERROR_INVALID_CHARACTER = 5,
    G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING = 6,
    G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH = 7,
    G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE = 8,
    G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING = 9,
    G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE = 10,
    G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE = 11,
    G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG = 12,
    G_VARIANT_PARSE_ERROR_TYPE_ERROR = 13,
    G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN = 14,
    G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD = 15,
    G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT = 16,
    G_VARIANT_PARSE_ERROR_VALUE_EXPECTED = 17,
    G_VARIANT_PARSE_ERROR_RECURSION = 18
} ;
#line 332 "/usr/include/glib-2.0/glib/gvariant.h"
typedef enum __anonenum__249 GVariantParseError;
#line 446
struct _GVariantDict ;
#line 446 "/usr/include/glib-2.0/glib/gvariant.h"
typedef struct _GVariantDict GVariantDict;
#line 451 "/usr/include/glib-2.0/glib/gvariant.h"
struct __anonstruct_251 {
   GVariant *asv ;
   gsize partial_magic ;
   gsize y[14] ;
};
#line 449 "/usr/include/glib-2.0/glib/gvariant.h"
union __anonunion_250 {
   struct __anonstruct_251 s ;
   gsize x[16] ;
};
#line 447 "/usr/include/glib-2.0/glib/gvariant.h"
struct _GVariantDict {
   union __anonunion_250 u ;
};
#line 53 "/usr/include/glib-2.0/glib/gmessages.h"
enum __anonenum__252 {
    G_LOG_FLAG_RECURSION = 1,
    G_LOG_FLAG_FATAL = 2,
    G_LOG_LEVEL_ERROR = 4,
    G_LOG_LEVEL_CRITICAL = 8,
    G_LOG_LEVEL_WARNING = 16,
    G_LOG_LEVEL_MESSAGE = 32,
    G_LOG_LEVEL_INFO = 64,
    G_LOG_LEVEL_DEBUG = 128,
    G_LOG_LEVEL_MASK = -4
} ;
#line 68 "/usr/include/glib-2.0/glib/gmessages.h"
typedef enum __anonenum__252 GLogLevelFlags;
#line 73 "/usr/include/glib-2.0/glib/gmessages.h"
typedef void (*GLogFunc)(gchar * , GLogLevelFlags  , gchar * , gpointer  );
#line 134
enum __anonenum__253 {
    G_LOG_WRITER_HANDLED = 1,
    G_LOG_WRITER_UNHANDLED = 0
} ;
#line 138 "/usr/include/glib-2.0/glib/gmessages.h"
typedef enum __anonenum__253 GLogWriterOutput;
#line 156
struct _GLogField ;
#line 156 "/usr/include/glib-2.0/glib/gmessages.h"
typedef struct _GLogField GLogField;
#line 157 "/usr/include/glib-2.0/glib/gmessages.h"
struct _GLogField {
   gchar *key ;
   gconstpointer value ;
   gssize length ;
};
#line 195 "/usr/include/glib-2.0/glib/gmessages.h"
typedef GLogWriterOutput (*GLogWriterFunc)(GLogLevelFlags  , GLogField * , gsize  ,
                                           gpointer  );
#line 515 "/usr/include/glib-2.0/glib/gmessages.h"
typedef void (*GPrintFunc)(gchar * );
#line 38 "/usr/include/glib-2.0/glib/goption.h"
struct _GOptionContext ;
#line 38 "/usr/include/glib-2.0/glib/goption.h"
typedef struct _GOptionContext GOptionContext;
#line 51
struct _GOptionGroup ;
#line 51 "/usr/include/glib-2.0/glib/goption.h"
typedef struct _GOptionGroup GOptionGroup;
#line 52
struct _GOptionEntry ;
#line 52 "/usr/include/glib-2.0/glib/goption.h"
typedef struct _GOptionEntry GOptionEntry;
#line 81
enum __anonenum__254 {
    G_OPTION_FLAG_NONE = 0,
    G_OPTION_FLAG_HIDDEN = 1,
    G_OPTION_FLAG_IN_MAIN = 2,
    G_OPTION_FLAG_REVERSE = 4,
    G_OPTION_FLAG_NO_ARG = 8,
    G_OPTION_FLAG_FILENAME = 16,
    G_OPTION_FLAG_OPTIONAL_ARG = 32,
    G_OPTION_FLAG_NOALIAS = 64
} ;
#line 91 "/usr/include/glib-2.0/glib/goption.h"
typedef enum __anonenum__254 GOptionFlags;
#line 119
enum __anonenum__255 {
    G_OPTION_ARG_NONE = 0,
    G_OPTION_ARG_STRING = 1,
    G_OPTION_ARG_INT = 2,
    G_OPTION_ARG_CALLBACK = 3,
    G_OPTION_ARG_FILENAME = 4,
    G_OPTION_ARG_STRING_ARRAY = 5,
    G_OPTION_ARG_FILENAME_ARRAY = 6,
    G_OPTION_ARG_DOUBLE = 7,
    G_OPTION_ARG_INT64 = 8
} ;
#line 130 "/usr/include/glib-2.0/glib/goption.h"
typedef enum __anonenum__255 GOptionArg;
#line 149 "/usr/include/glib-2.0/glib/goption.h"
typedef gboolean (*GOptionArgFunc)(gchar * , gchar * , gpointer  , GError ** );
#line 167 "/usr/include/glib-2.0/glib/goption.h"
typedef gboolean (*GOptionParseFunc)(GOptionContext * , GOptionGroup * , gpointer  ,
                                     GError ** );
#line 182 "/usr/include/glib-2.0/glib/goption.h"
typedef void (*GOptionErrorFunc)(GOptionContext * , GOptionGroup * , gpointer  , GError ** );
#line 206
enum __anonenum__256 {
    G_OPTION_ERROR_UNKNOWN_OPTION = 0,
    G_OPTION_ERROR_BAD_VALUE = 1,
    G_OPTION_ERROR_FAILED = 2
} ;
#line 211 "/usr/include/glib-2.0/glib/goption.h"
typedef enum __anonenum__256 GOptionError;
#line 258 "/usr/include/glib-2.0/glib/goption.h"
struct _GOptionEntry {
   gchar *long_name ;
   gchar short_name ;
   gint flags ;
   GOptionArg arg ;
   gpointer arg_data ;
   gchar *description ;
   gchar *arg_description ;
};
#line 30 "/usr/include/glib-2.0/glib/gpattern.h"
struct _GPatternSpec ;
#line 30 "/usr/include/glib-2.0/glib/gpattern.h"
typedef struct _GPatternSpec GPatternSpec;
#line 36 "/usr/include/glib-2.0/glib/gqueue.h"
struct _GQueue ;
#line 36 "/usr/include/glib-2.0/glib/gqueue.h"
typedef struct _GQueue GQueue;
#line 47 "/usr/include/glib-2.0/glib/gqueue.h"
struct _GQueue {
   GList *head ;
   GList *tail ;
   guint length ;
};
#line 36 "/usr/include/glib-2.0/glib/grand.h"
struct _GRand ;
#line 36 "/usr/include/glib-2.0/glib/grand.h"
typedef struct _GRand GRand;
#line 55 "/usr/include/glib-2.0/glib/grefstring.h"
typedef char GRefString;
#line 140 "/usr/include/glib-2.0/glib/gregex.h"
enum __anonenum__257 {
    G_REGEX_ERROR_COMPILE = 0,
    G_REGEX_ERROR_OPTIMIZE = 1,
    G_REGEX_ERROR_REPLACE = 2,
    G_REGEX_ERROR_MATCH = 3,
    G_REGEX_ERROR_INTERNAL = 4,
    G_REGEX_ERROR_STRAY_BACKSLASH = 101,
    G_REGEX_ERROR_MISSING_CONTROL_CHAR = 102,
    G_REGEX_ERROR_UNRECOGNIZED_ESCAPE = 103,
    G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER = 104,
    G_REGEX_ERROR_QUANTIFIER_TOO_BIG = 105,
    G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS = 106,
    G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS = 107,
    G_REGEX_ERROR_RANGE_OUT_OF_ORDER = 108,
    G_REGEX_ERROR_NOTHING_TO_REPEAT = 109,
    G_REGEX_ERROR_UNRECOGNIZED_CHARACTER = 112,
    G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS = 113,
    G_REGEX_ERROR_UNMATCHED_PARENTHESIS = 114,
    G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE = 115,
    G_REGEX_ERROR_UNTERMINATED_COMMENT = 118,
    G_REGEX_ERROR_EXPRESSION_TOO_LARGE = 120,
    G_REGEX_ERROR_MEMORY_ERROR = 121,
    G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND = 125,
    G_REGEX_ERROR_MALFORMED_CONDITION = 126,
    G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES = 127,
    G_REGEX_ERROR_ASSERTION_EXPECTED = 128,
    G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME = 130,
    G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED = 131,
    G_REGEX_ERROR_HEX_CODE_TOO_LARGE = 134,
    G_REGEX_ERROR_INVALID_CONDITION = 135,
    G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND = 136,
    G_REGEX_ERROR_INFINITE_LOOP = 140,
    G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR = 142,
    G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME = 143,
    G_REGEX_ERROR_MALFORMED_PROPERTY = 146,
    G_REGEX_ERROR_UNKNOWN_PROPERTY = 147,
    G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG = 148,
    G_REGEX_ERROR_TOO_MANY_SUBPATTERNS = 149,
    G_REGEX_ERROR_INVALID_OCTAL_VALUE = 151,
    G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE = 154,
    G_REGEX_ERROR_DEFINE_REPETION = 155,
    G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS = 156,
    G_REGEX_ERROR_MISSING_BACK_REFERENCE = 157,
    G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE = 158,
    G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN = 159,
    G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB = 160,
    G_REGEX_ERROR_NUMBER_TOO_BIG = 161,
    G_REGEX_ERROR_MISSING_SUBPATTERN_NAME = 162,
    G_REGEX_ERROR_MISSING_DIGIT = 163,
    G_REGEX_ERROR_INVALID_DATA_CHARACTER = 164,
    G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME = 165,
    G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED = 166,
    G_REGEX_ERROR_INVALID_CONTROL_CHAR = 168,
    G_REGEX_ERROR_MISSING_NAME = 169,
    G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS = 171,
    G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES = 172,
    G_REGEX_ERROR_NAME_TOO_LONG = 175,
    G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE = 176
} ;
#line 201 "/usr/include/glib-2.0/glib/gregex.h"
typedef enum __anonenum__257 GRegexError;
#line 296
enum __anonenum__258 {
    G_REGEX_CASELESS = 1,
    G_REGEX_MULTILINE = 2,
    G_REGEX_DOTALL = 4,
    G_REGEX_EXTENDED = 8,
    G_REGEX_ANCHORED = 16,
    G_REGEX_DOLLAR_ENDONLY = 32,
    G_REGEX_UNGREEDY = 512,
    G_REGEX_RAW = 2048,
    G_REGEX_NO_AUTO_CAPTURE = 4096,
    G_REGEX_OPTIMIZE = 8192,
    G_REGEX_FIRSTLINE = 262144,
    G_REGEX_DUPNAMES = 524288,
    G_REGEX_NEWLINE_CR = 1048576,
    G_REGEX_NEWLINE_LF = 2097152,
    G_REGEX_NEWLINE_CRLF = 3145728,
    G_REGEX_NEWLINE_ANYCRLF = 5242880,
    G_REGEX_BSR_ANYCRLF = 8388608,
    G_REGEX_JAVASCRIPT_COMPAT = 33554432
} ;
#line 316 "/usr/include/glib-2.0/glib/gregex.h"
typedef enum __anonenum__258 GRegexCompileFlags;
#line 386
enum __anonenum__259 {
    G_REGEX_MATCH_ANCHORED = 16,
    G_REGEX_MATCH_NOTBOL = 128,
    G_REGEX_MATCH_NOTEOL = 256,
    G_REGEX_MATCH_NOTEMPTY = 1024,
    G_REGEX_MATCH_PARTIAL = 32768,
    G_REGEX_MATCH_NEWLINE_CR = 1048576,
    G_REGEX_MATCH_NEWLINE_LF = 2097152,
    G_REGEX_MATCH_NEWLINE_CRLF = 3145728,
    G_REGEX_MATCH_NEWLINE_ANY = 4194304,
    G_REGEX_MATCH_NEWLINE_ANYCRLF = 5242880,
    G_REGEX_MATCH_BSR_ANYCRLF = 8388608,
    G_REGEX_MATCH_BSR_ANY = 16777216,
    G_REGEX_MATCH_PARTIAL_SOFT = 32768,
    G_REGEX_MATCH_PARTIAL_HARD = 134217728,
    G_REGEX_MATCH_NOTEMPTY_ATSTART = 268435456
} ;
#line 403 "/usr/include/glib-2.0/glib/gregex.h"
typedef enum __anonenum__259 GRegexMatchFlags;
#line 413
struct _GRegex ;
#line 413 "/usr/include/glib-2.0/glib/gregex.h"
typedef struct _GRegex GRegex;
#line 422
struct _GMatchInfo ;
#line 422 "/usr/include/glib-2.0/glib/gregex.h"
typedef struct _GMatchInfo GMatchInfo;
#line 441 "/usr/include/glib-2.0/glib/gregex.h"
typedef gboolean (*GRegexEvalCallback)(GMatchInfo * , GString * , gpointer  );
#line 37 "/usr/include/glib-2.0/glib/gscanner.h"
struct _GScanner ;
#line 37 "/usr/include/glib-2.0/glib/gscanner.h"
typedef struct _GScanner GScanner;
#line 38
struct _GScannerConfig ;
#line 38 "/usr/include/glib-2.0/glib/gscanner.h"
typedef struct _GScannerConfig GScannerConfig;
#line 39
union _GTokenValue ;
#line 39 "/usr/include/glib-2.0/glib/gscanner.h"
typedef union _GTokenValue GTokenValue;
#line 41 "/usr/include/glib-2.0/glib/gscanner.h"
typedef void (*GScannerMsgFunc)(GScanner * , gchar * , gboolean  );
#line 62
enum __anonenum__260 {
    G_ERR_UNKNOWN = 0,
    G_ERR_UNEXP_EOF = 1,
    G_ERR_UNEXP_EOF_IN_STRING = 2,
    G_ERR_UNEXP_EOF_IN_COMMENT = 3,
    G_ERR_NON_DIGIT_IN_CONST = 4,
    G_ERR_DIGIT_RADIX = 5,
    G_ERR_FLOAT_RADIX = 6,
    G_ERR_FLOAT_MALFORMED = 7
} ;
#line 72 "/usr/include/glib-2.0/glib/gscanner.h"
typedef enum __anonenum__260 GErrorType;
#line 75
enum __anonenum__261 {
    G_TOKEN_EOF = 0,
    G_TOKEN_LEFT_PAREN = 40,
    G_TOKEN_RIGHT_PAREN = 41,
    G_TOKEN_LEFT_CURLY = 123,
    G_TOKEN_RIGHT_CURLY = 125,
    G_TOKEN_LEFT_BRACE = 91,
    G_TOKEN_RIGHT_BRACE = 93,
    G_TOKEN_EQUAL_SIGN = 61,
    G_TOKEN_COMMA = 44,
    G_TOKEN_NONE = 256,
    G_TOKEN_ERROR = 257,
    G_TOKEN_CHAR = 258,
    G_TOKEN_BINARY = 259,
    G_TOKEN_OCTAL = 260,
    G_TOKEN_INT = 261,
    G_TOKEN_HEX = 262,
    G_TOKEN_FLOAT = 263,
    G_TOKEN_STRING = 264,
    G_TOKEN_SYMBOL = 265,
    G_TOKEN_IDENTIFIER = 266,
    G_TOKEN_IDENTIFIER_NULL = 267,
    G_TOKEN_COMMENT_SINGLE = 268,
    G_TOKEN_COMMENT_MULTI = 269,
    G_TOKEN_LAST = 270
} ;
#line 109 "/usr/include/glib-2.0/glib/gscanner.h"
typedef enum __anonenum__261 GTokenType;
#line 111 "/usr/include/glib-2.0/glib/gscanner.h"
union _GTokenValue {
   gpointer v_symbol ;
   gchar *v_identifier ;
   gulong v_binary ;
   gulong v_octal ;
   gulong v_int ;
   guint64 v_int64 ;
   gdouble v_float ;
   gulong v_hex ;
   gchar *v_string ;
   gchar *v_comment ;
   guchar v_char ;
   guint v_error ;
};
#line 127 "/usr/include/glib-2.0/glib/gscanner.h"
struct _GScannerConfig {
   gchar *cset_skip_characters ;
   gchar *cset_identifier_first ;
   gchar *cset_identifier_nth ;
   gchar *cpair_comment_single ;
   guint case_sensitive ;
   guint skip_comment_multi ;
   guint skip_comment_single ;
   guint scan_comment_multi ;
   guint scan_identifier ;
   guint scan_identifier_1char ;
   guint scan_identifier_NULL ;
   guint scan_symbols ;
   guint scan_binary ;
   guint scan_octal ;
   guint scan_float ;
   guint scan_hex ;
   guint scan_hex_dollar ;
   guint scan_string_sq ;
   guint scan_string_dq ;
   guint numbers_2_int ;
   guint int_2_float ;
   guint identifier_2_string ;
   guint char_2_token ;
   guint symbol_2_token ;
   guint scope_0_fallback ;
   guint store_int64 ;
   guint padding_dummy ;
};
#line 169 "/usr/include/glib-2.0/glib/gscanner.h"
struct _GScanner {
   gpointer user_data ;
   guint max_parse_errors ;
   guint parse_errors ;
   gchar *input_name ;
   GData *qdata ;
   GScannerConfig *config ;
   GTokenType token ;
   GTokenValue value ;
   guint line ;
   guint position ;
   GTokenType next_token ;
   GTokenValue next_value ;
   guint next_line ;
   guint next_position ;
   GHashTable *symbol_table ;
   gint input_fd ;
   gchar *text ;
   gchar *text_end ;
   gchar *buffer ;
   guint scope_id ;
   GScannerMsgFunc msg_handler ;
};
#line 30 "/usr/include/glib-2.0/glib/gsequence.h"
struct _GSequence ;
#line 30 "/usr/include/glib-2.0/glib/gsequence.h"
typedef struct _GSequence GSequence;
#line 31
struct _GSequenceNode ;
#line 31 "/usr/include/glib-2.0/glib/gsequence.h"
typedef struct _GSequenceNode GSequenceIter;
#line 33 "/usr/include/glib-2.0/glib/gsequence.h"
typedef gint (*GSequenceIterCompareFunc)(GSequenceIter * , GSequenceIter * , gpointer  );
#line 32 "/usr/include/glib-2.0/glib/gshell.h"
enum __anonenum__262 {
    G_SHELL_ERROR_BAD_QUOTING = 0,
    G_SHELL_ERROR_EMPTY_STRING = 1,
    G_SHELL_ERROR_FAILED = 2
} ;
#line 39 "/usr/include/glib-2.0/glib/gshell.h"
typedef enum __anonenum__262 GShellError;
#line 92 "/usr/include/glib-2.0/glib/gslice.h"
enum __anonenum__263 {
    G_SLICE_CONFIG_ALWAYS_MALLOC = 1,
    G_SLICE_CONFIG_BYPASS_MAGAZINES = 2,
    G_SLICE_CONFIG_WORKING_SET_MSECS = 3,
    G_SLICE_CONFIG_COLOR_INCREMENT = 4,
    G_SLICE_CONFIG_CHUNK_SIZES = 5,
    G_SLICE_CONFIG_CONTENTION_COUNTER = 6
} ;
#line 99 "/usr/include/glib-2.0/glib/gslice.h"
typedef enum __anonenum__263 GSliceConfig;
#line 68 "/usr/include/glib-2.0/glib/gspawn.h"
enum __anonenum__264 {
    G_SPAWN_ERROR_FORK = 0,
    G_SPAWN_ERROR_READ = 1,
    G_SPAWN_ERROR_CHDIR = 2,
    G_SPAWN_ERROR_ACCES = 3,
    G_SPAWN_ERROR_PERM = 4,
    G_SPAWN_ERROR_TOO_BIG = 5,
    G_SPAWN_ERROR_2BIG = 5,
    G_SPAWN_ERROR_NOEXEC = 6,
    G_SPAWN_ERROR_NAMETOOLONG = 7,
    G_SPAWN_ERROR_NOENT = 8,
    G_SPAWN_ERROR_NOMEM = 9,
    G_SPAWN_ERROR_NOTDIR = 10,
    G_SPAWN_ERROR_LOOP = 11,
    G_SPAWN_ERROR_TXTBUSY = 12,
    G_SPAWN_ERROR_IO = 13,
    G_SPAWN_ERROR_NFILE = 14,
    G_SPAWN_ERROR_MFILE = 15,
    G_SPAWN_ERROR_INVAL = 16,
    G_SPAWN_ERROR_ISDIR = 17,
    G_SPAWN_ERROR_LIBBAD = 18,
    G_SPAWN_ERROR_FAILED = 19
} ;
#line 93 "/usr/include/glib-2.0/glib/gspawn.h"
typedef enum __anonenum__264 GSpawnError;
#line 138 "/usr/include/glib-2.0/glib/gspawn.h"
typedef void (*GSpawnChildSetupFunc)(gpointer  );
#line 168
enum __anonenum__265 {
    G_SPAWN_DEFAULT = 0,
    G_SPAWN_LEAVE_DESCRIPTORS_OPEN = 1,
    G_SPAWN_DO_NOT_REAP_CHILD = 2,
    G_SPAWN_SEARCH_PATH = 4,
    G_SPAWN_STDOUT_TO_DEV_NULL = 8,
    G_SPAWN_STDERR_TO_DEV_NULL = 16,
    G_SPAWN_CHILD_INHERITS_STDIN = 32,
    G_SPAWN_FILE_AND_ARGV_ZERO = 64,
    G_SPAWN_SEARCH_PATH_FROM_ENVP = 128,
    G_SPAWN_CLOEXEC_PIPES = 256
} ;
#line 182 "/usr/include/glib-2.0/glib/gspawn.h"
typedef enum __anonenum__265 GSpawnFlags;
#line 40 "/usr/include/glib-2.0/glib/gstrfuncs.h"
enum __anonenum__266 {
    G_ASCII_ALNUM = 1,
    G_ASCII_ALPHA = 2,
    G_ASCII_CNTRL = 4,
    G_ASCII_DIGIT = 8,
    G_ASCII_GRAPH = 16,
    G_ASCII_LOWER = 32,
    G_ASCII_PRINT = 64,
    G_ASCII_PUNCT = 128,
    G_ASCII_SPACE = 256,
    G_ASCII_UPPER = 512,
    G_ASCII_XDIGIT = 1024
} ;
#line 52 "/usr/include/glib-2.0/glib/gstrfuncs.h"
typedef enum __anonenum__266 GAsciiType;
#line 273 "/usr/include/glib-2.0/glib/gstrfuncs.h"
typedef gchar **GStrv;
#line 329
enum __anonenum__267 {
    G_NUMBER_PARSER_ERROR_INVALID = 0,
    G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS = 1
} ;
#line 333 "/usr/include/glib-2.0/glib/gstrfuncs.h"
typedef enum __anonenum__267 GNumberParserError;
#line 36 "/usr/include/glib-2.0/glib/gstringchunk.h"
struct _GStringChunk ;
#line 36 "/usr/include/glib-2.0/glib/gstringchunk.h"
typedef struct _GStringChunk GStringChunk;
#line 39 "/usr/include/glib-2.0/glib/gstrvbuilder.h"
struct _GStrvBuilder ;
#line 39 "/usr/include/glib-2.0/glib/gstrvbuilder.h"
typedef struct _GStrvBuilder GStrvBuilder;
#line 35 "/usr/include/glib-2.0/glib/gtestutils.h"
struct GTestCase ;
#line 35 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef struct GTestCase GTestCase;
#line 36
struct GTestSuite ;
#line 36 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef struct GTestSuite GTestSuite;
#line 37 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef void (*GTestFunc)(void);
#line 38 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef void (*GTestDataFunc)(gconstpointer  );
#line 39 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef void (*GTestFixtureFunc)(gpointer  , gconstpointer  );
#line 445
enum __anonenum__268 {
    G_TEST_TRAP_SILENCE_STDOUT = 128,
    G_TEST_TRAP_SILENCE_STDERR = 256,
    G_TEST_TRAP_INHERIT_STDIN = 512
} ;
#line 449 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef enum __anonenum__268 GTestTrapFlags;
#line 459
enum __anonenum__269 {
    G_TEST_SUBPROCESS_INHERIT_STDIN = 1,
    G_TEST_SUBPROCESS_INHERIT_STDOUT = 2,
    G_TEST_SUBPROCESS_INHERIT_STDERR = 4
} ;
#line 463 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef enum __anonenum__269 GTestSubprocessFlags;
#line 590 "/usr/include/glib-2.0/glib/gtestutils.h"
struct __anonstruct_270 {
   gboolean test_initialized ;
   gboolean test_quick ;
   gboolean test_perf ;
   gboolean test_verbose ;
   gboolean test_quiet ;
   gboolean test_undefined ;
};
#line 597 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef struct __anonstruct_270 GTestConfig;
#line 601
enum __anonenum__271 {
    G_TEST_RUN_SUCCESS = 0,
    G_TEST_RUN_SKIPPED = 1,
    G_TEST_RUN_FAILURE = 2,
    G_TEST_RUN_INCOMPLETE = 3
} ;
#line 606 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef enum __anonenum__271 GTestResult;
#line 608
enum __anonenum__272 {
    G_TEST_LOG_NONE = 0,
    G_TEST_LOG_ERROR = 1,
    G_TEST_LOG_START_BINARY = 2,
    G_TEST_LOG_LIST_CASE = 3,
    G_TEST_LOG_SKIP_CASE = 4,
    G_TEST_LOG_START_CASE = 5,
    G_TEST_LOG_STOP_CASE = 6,
    G_TEST_LOG_MIN_RESULT = 7,
    G_TEST_LOG_MAX_RESULT = 8,
    G_TEST_LOG_MESSAGE = 9,
    G_TEST_LOG_START_SUITE = 10,
    G_TEST_LOG_STOP_SUITE = 11
} ;
#line 621 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef enum __anonenum__272 GTestLogType;
#line 623 "/usr/include/glib-2.0/glib/gtestutils.h"
struct __anonstruct_273 {
   GTestLogType log_type ;
   guint n_strings ;
   gchar **strings ;
   guint n_nums ;
   long double *nums ;
};
#line 629 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef struct __anonstruct_273 GTestLogMsg;
#line 630 "/usr/include/glib-2.0/glib/gtestutils.h"
struct __anonstruct_274 {
   GString *data ;
   GSList *msgs ;
};
#line 634 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef struct __anonstruct_274 GTestLogBuffer;
#line 664 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef gboolean (*GTestLogFatalFunc)(gchar * , GLogLevelFlags  , gchar * , gpointer  );
#line 683
enum __anonenum__275 {
    G_TEST_DIST = 0,
    G_TEST_BUILT = 1
} ;
#line 687 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef enum __anonenum__275 GTestFileType;
#line 36 "/usr/include/glib-2.0/glib/gthreadpool.h"
struct _GThreadPool ;
#line 36 "/usr/include/glib-2.0/glib/gthreadpool.h"
typedef struct _GThreadPool GThreadPool;
#line 41 "/usr/include/glib-2.0/glib/gthreadpool.h"
struct _GThreadPool {
   GFunc func ;
   gpointer user_data ;
   gboolean exclusive ;
};
#line 40 "/usr/include/glib-2.0/glib/gtimer.h"
struct _GTimer ;
#line 40 "/usr/include/glib-2.0/glib/gtimer.h"
typedef struct _GTimer GTimer;
#line 38 "/usr/include/glib-2.0/glib/gtrashstack.h"
struct _GTrashStack ;
#line 38 "/usr/include/glib-2.0/glib/gtrashstack.h"
typedef struct _GTrashStack GTrashStack;
#line 39 "/usr/include/glib-2.0/glib/gtrashstack.h"
struct _GTrashStack {
   GTrashStack *next ;
};
#line 38 "/usr/include/glib-2.0/glib/gtree.h"
struct _GTree ;
#line 38 "/usr/include/glib-2.0/glib/gtree.h"
typedef struct _GTree GTree;
#line 47
struct _GTreeNode ;
#line 47 "/usr/include/glib-2.0/glib/gtree.h"
typedef struct _GTreeNode GTreeNode;
#line 49 "/usr/include/glib-2.0/glib/gtree.h"
typedef gboolean (*GTraverseFunc)(gpointer  , gpointer  , gpointer  );
#line 66 "/usr/include/glib-2.0/glib/gtree.h"
typedef gboolean (*GTraverseNodeFunc)(GTreeNode * , gpointer  );
#line 31 "/usr/include/glib-2.0/glib/guri.h"
struct _GUri ;
#line 31 "/usr/include/glib-2.0/glib/guri.h"
typedef struct _GUri GUri;
#line 80
enum __anonenum__276 {
    G_URI_FLAGS_NONE = 0,
    G_URI_FLAGS_PARSE_RELAXED = 1,
    G_URI_FLAGS_HAS_PASSWORD = 2,
    G_URI_FLAGS_HAS_AUTH_PARAMS = 4,
    G_URI_FLAGS_ENCODED = 8,
    G_URI_FLAGS_NON_DNS = 16,
    G_URI_FLAGS_ENCODED_QUERY = 32,
    G_URI_FLAGS_ENCODED_PATH = 64,
    G_URI_FLAGS_ENCODED_FRAGMENT = 128,
    G_URI_FLAGS_SCHEME_NORMALIZE = 256
} ;
#line 91 "/usr/include/glib-2.0/glib/guri.h"
typedef enum __anonenum__276 GUriFlags;
#line 205
enum __anonenum__277 {
    G_URI_HIDE_NONE = 0,
    G_URI_HIDE_USERINFO = 1,
    G_URI_HIDE_PASSWORD = 2,
    G_URI_HIDE_AUTH_PARAMS = 4,
    G_URI_HIDE_QUERY = 8,
    G_URI_HIDE_FRAGMENT = 16
} ;
#line 212 "/usr/include/glib-2.0/glib/guri.h"
typedef enum __anonenum__277 GUriHideFlags;
#line 257
enum __anonenum__278 {
    G_URI_PARAMS_NONE = 0,
    G_URI_PARAMS_CASE_INSENSITIVE = 1,
    G_URI_PARAMS_WWW_FORM = 2,
    G_URI_PARAMS_PARSE_RELAXED = 4
} ;
#line 262 "/usr/include/glib-2.0/glib/guri.h"
typedef enum __anonenum__278 GUriParamsFlags;
#line 271
struct _GUriParamsIter ;
#line 271 "/usr/include/glib-2.0/glib/guri.h"
typedef struct _GUriParamsIter GUriParamsIter;
#line 273 "/usr/include/glib-2.0/glib/guri.h"
struct _GUriParamsIter {
   gint dummy0 ;
   gpointer dummy1 ;
   gpointer dummy2 ;
   guint8 dummy3[256] ;
};
#line 326
enum __anonenum__279 {
    G_URI_ERROR_FAILED = 0,
    G_URI_ERROR_BAD_SCHEME = 1,
    G_URI_ERROR_BAD_USER = 2,
    G_URI_ERROR_BAD_PASSWORD = 3,
    G_URI_ERROR_BAD_AUTH_PARAMS = 4,
    G_URI_ERROR_BAD_HOST = 5,
    G_URI_ERROR_BAD_PORT = 6,
    G_URI_ERROR_BAD_PATH = 7,
    G_URI_ERROR_BAD_QUERY = 8,
    G_URI_ERROR_BAD_FRAGMENT = 9
} ;
#line 337 "/usr/include/glib-2.0/glib/guri.h"
typedef enum __anonenum__279 GUriError;
#line 27 "/usr/include/glib-2.0/glib/deprecated/gallocator.h"
struct _GAllocator ;
#line 27 "/usr/include/glib-2.0/glib/deprecated/gallocator.h"
typedef struct _GAllocator GAllocator;
#line 28
struct _GMemChunk ;
#line 28 "/usr/include/glib-2.0/glib/deprecated/gallocator.h"
typedef struct _GMemChunk GMemChunk;
#line 36 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
struct _GCache ;
#line 36 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
typedef struct _GCache GCache;
#line 38 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
typedef gpointer (*GCacheNewFunc)(gpointer  );
#line 39 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
typedef gpointer (*GCacheDupFunc)(gpointer  );
#line 40 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
typedef void (*GCacheDestroyFunc)(gpointer  );
#line 36 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
struct _GCompletion ;
#line 36 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
typedef struct _GCompletion GCompletion;
#line 38 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
typedef gchar *(*GCompletionFunc)(gpointer  );
#line 43 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
typedef gint (*GCompletionStrncmpFunc)(gchar * , gchar * , gsize  );
#line 47 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
struct _GCompletion {
   GList *items ;
   GCompletionFunc func ;
   gchar *prefix ;
   GList *cache ;
   GCompletionStrncmpFunc strncmp_func ;
};
#line 36 "/usr/include/glib-2.0/glib/deprecated/grel.h"
struct _GRelation ;
#line 36 "/usr/include/glib-2.0/glib/deprecated/grel.h"
typedef struct _GRelation GRelation;
#line 37
struct _GTuples ;
#line 37 "/usr/include/glib-2.0/glib/deprecated/grel.h"
typedef struct _GTuples GTuples;
#line 39 "/usr/include/glib-2.0/glib/deprecated/grel.h"
struct _GTuples {
   guint len ;
};
#line 38 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
enum __anonenum__280 {
    G_THREAD_PRIORITY_LOW = 0,
    G_THREAD_PRIORITY_NORMAL = 1,
    G_THREAD_PRIORITY_HIGH = 2,
    G_THREAD_PRIORITY_URGENT = 3
} ;
#line 44 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef enum __anonenum__280 GThreadPriority;
#line 46 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct _GThread {
   GThreadFunc func ;
   gpointer data ;
   gboolean joinable ;
   GThreadPriority priority ;
};
#line 55
struct _GThreadFunctions ;
#line 55 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef struct _GThreadFunctions GThreadFunctions;
#line 56 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct _GThreadFunctions {
   GMutex *(*mutex_new)(void) ;
   void (*mutex_lock)(GMutex * ) ;
   gboolean (*mutex_trylock)(GMutex * ) ;
   void (*mutex_unlock)(GMutex * ) ;
   void (*mutex_free)(GMutex * ) ;
   GCond *(*cond_new)(void) ;
   void (*cond_signal)(GCond * ) ;
   void (*cond_broadcast)(GCond * ) ;
   void (*cond_wait)(GCond * , GMutex * ) ;
   gboolean (*cond_timed_wait)(GCond * , GMutex * , GTimeVal * ) ;
   void (*cond_free)(GCond * ) ;
   GPrivate *(*private_new)(GDestroyNotify  ) ;
   gpointer (*private_get)(GPrivate * ) ;
   void (*private_set)(GPrivate * , gpointer  ) ;
   void (*thread_create)(GThreadFunc  , gpointer  , gulong  , gboolean  , gboolean  ,
                         GThreadPriority  , gpointer  , GError ** ) ;
   void (*thread_yield)(void) ;
   void (*thread_join)(gpointer  ) ;
   void (*thread_exit)(void) ;
   void (*thread_set_priority)(gpointer  , GThreadPriority  ) ;
   void (*thread_self)(gpointer  ) ;
   gboolean (*thread_equal)(gpointer  , gpointer  ) ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h"
struct sched_param {
   int sched_priority ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef unsigned long __cpu_mask;
#line 39 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
struct __anonstruct_281 {
   __cpu_mask __bits[16] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef struct __anonstruct_281 cpu_set_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 37 "/usr/include/pthread.h"
enum __anonenum__282 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1
} ;
#line 47
enum __anonenum__283 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
    PTHREAD_MUTEX_NORMAL = 0,
    PTHREAD_MUTEX_RECURSIVE = 1,
    PTHREAD_MUTEX_ERRORCHECK = 2,
    PTHREAD_MUTEX_DEFAULT = 0,
    PTHREAD_MUTEX_FAST_NP = 0
} ;
#line 69
enum __anonenum__284 {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_STALLED_NP = 0,
    PTHREAD_MUTEX_ROBUST = 1,
    PTHREAD_MUTEX_ROBUST_NP = 1
} ;
#line 81
enum __anonenum__285 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2
} ;
#line 104
enum __anonenum__286 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
    PTHREAD_RWLOCK_DEFAULT_NP = 0
} ;
#line 124
enum __anonenum__287 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1
} ;
#line 134
enum __anonenum__288 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1
} ;
#line 144
enum __anonenum__289 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1
} ;
#line 159 "/usr/include/pthread.h"
struct _pthread_cleanup_buffer {
   void (*__routine)(void * ) ;
   void *__arg ;
   int __canceltype ;
   struct _pthread_cleanup_buffer *__prev ;
};
#line 168
enum __anonenum__290 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1
} ;
#line 175
enum __anonenum__291 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1
} ;
#line 538 "/usr/include/pthread.h"
struct __cancel_jmp_buf_tag {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
#line 544 "/usr/include/pthread.h"
struct __anonstruct_292 {
   struct __cancel_jmp_buf_tag __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
#line 548 "/usr/include/pthread.h"
typedef struct __anonstruct_292 __pthread_unwind_buf_t;
#line 557 "/usr/include/pthread.h"
struct __pthread_cleanup_frame {
   void (*__cancel_routine)(void * ) ;
   void *__cancel_arg ;
   int __do_it ;
   int __cancel_type ;
};
#line 133 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct __anonstruct_293 {
   GMutex *mutex ;
   pthread_mutex_t unused ;
};
#line 140 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef struct __anonstruct_293 GStaticMutex;
#line 156
struct _GStaticRecMutex ;
#line 156 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef struct _GStaticRecMutex GStaticRecMutex;
#line 164 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
union __anonunion_294 {
   pthread_t owner ;
   gdouble dummy ;
};
#line 157 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct _GStaticRecMutex {
   GStaticMutex mutex ;
   guint depth ;
   union __anonunion_294 unused ;
};
#line 197
struct _GStaticRWLock ;
#line 197 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef struct _GStaticRWLock GStaticRWLock;
#line 198 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct _GStaticRWLock {
   GStaticMutex mutex ;
   GCond *read_cond ;
   GCond *write_cond ;
   guint read_counter ;
   gboolean have_writer ;
   guint want_to_read ;
   guint want_to_write ;
};
#line 239
struct _GStaticPrivate ;
#line 239 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef struct _GStaticPrivate GStaticPrivate;
#line 240 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct _GStaticPrivate {
   guint index ;
};
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GAsyncQueue *GAsyncQueue_autoptr;
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GAsyncQueue_listautoptr;
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GAsyncQueue_slistautoptr;
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GAsyncQueue_queueautoptr;
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GBookmarkFile *GBookmarkFile_autoptr;
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GBookmarkFile_listautoptr;
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GBookmarkFile_slistautoptr;
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GBookmarkFile_queueautoptr;
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GBytes *GBytes_autoptr;
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GBytes_listautoptr;
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GBytes_slistautoptr;
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GBytes_queueautoptr;
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GChecksum *GChecksum_autoptr;
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GChecksum_listautoptr;
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GChecksum_slistautoptr;
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GChecksum_queueautoptr;
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GDateTime *GDateTime_autoptr;
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GDateTime_listautoptr;
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GDateTime_slistautoptr;
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GDateTime_queueautoptr;
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GDate *GDate_autoptr;
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GDate_listautoptr;
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GDate_slistautoptr;
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GDate_queueautoptr;
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GDir *GDir_autoptr;
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GDir_listautoptr;
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GDir_slistautoptr;
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GDir_queueautoptr;
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GError *GError_autoptr;
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GError_listautoptr;
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GError_slistautoptr;
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GError_queueautoptr;
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GHashTable *GHashTable_autoptr;
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GHashTable_listautoptr;
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GHashTable_slistautoptr;
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GHashTable_queueautoptr;
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GHmac *GHmac_autoptr;
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GHmac_listautoptr;
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GHmac_slistautoptr;
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GHmac_queueautoptr;
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GIOChannel *GIOChannel_autoptr;
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GIOChannel_listautoptr;
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GIOChannel_slistautoptr;
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GIOChannel_queueautoptr;
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GKeyFile *GKeyFile_autoptr;
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GKeyFile_listautoptr;
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GKeyFile_slistautoptr;
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GKeyFile_queueautoptr;
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GList_autoptr;
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GList_listautoptr;
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GList_slistautoptr;
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GList_queueautoptr;
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GArray *GArray_autoptr;
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GArray_listautoptr;
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GArray_slistautoptr;
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GArray_queueautoptr;
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GPtrArray *GPtrArray_autoptr;
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GPtrArray_listautoptr;
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GPtrArray_slistautoptr;
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GPtrArray_queueautoptr;
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GByteArray *GByteArray_autoptr;
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GByteArray_listautoptr;
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GByteArray_slistautoptr;
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GByteArray_queueautoptr;
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMainContext *GMainContext_autoptr;
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMainContext_listautoptr;
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMainContext_slistautoptr;
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMainContext_queueautoptr;
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMainContextPusher *GMainContextPusher_autoptr;
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMainContextPusher_listautoptr;
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMainContextPusher_slistautoptr;
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMainContextPusher_queueautoptr;
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMainLoop *GMainLoop_autoptr;
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMainLoop_listautoptr;
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMainLoop_slistautoptr;
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMainLoop_queueautoptr;
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSource *GSource_autoptr;
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GSource_listautoptr;
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GSource_slistautoptr;
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GSource_queueautoptr;
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMappedFile *GMappedFile_autoptr;
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMappedFile_listautoptr;
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMappedFile_slistautoptr;
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMappedFile_queueautoptr;
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMarkupParseContext *GMarkupParseContext_autoptr;
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMarkupParseContext_listautoptr;
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMarkupParseContext_slistautoptr;
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMarkupParseContext_queueautoptr;
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GNode *GNode_autoptr;
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GNode_listautoptr;
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GNode_slistautoptr;
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GNode_queueautoptr;
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GOptionContext *GOptionContext_autoptr;
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GOptionContext_listautoptr;
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GOptionContext_slistautoptr;
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GOptionContext_queueautoptr;
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GOptionGroup *GOptionGroup_autoptr;
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GOptionGroup_listautoptr;
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GOptionGroup_slistautoptr;
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GOptionGroup_queueautoptr;
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GPatternSpec *GPatternSpec_autoptr;
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GPatternSpec_listautoptr;
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GPatternSpec_slistautoptr;
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GPatternSpec_queueautoptr;
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GQueue_autoptr;
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GQueue_listautoptr;
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GQueue_slistautoptr;
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GQueue_queueautoptr;
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRand *GRand_autoptr;
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRand_listautoptr;
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRand_slistautoptr;
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRand_queueautoptr;
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRegex *GRegex_autoptr;
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRegex_listautoptr;
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRegex_slistautoptr;
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRegex_queueautoptr;
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMatchInfo *GMatchInfo_autoptr;
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMatchInfo_listautoptr;
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMatchInfo_slistautoptr;
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMatchInfo_queueautoptr;
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GScanner *GScanner_autoptr;
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GScanner_listautoptr;
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GScanner_slistautoptr;
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GScanner_queueautoptr;
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSequence *GSequence_autoptr;
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GSequence_listautoptr;
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GSequence_slistautoptr;
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GSequence_queueautoptr;
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GSList_autoptr;
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GSList_listautoptr;
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GSList_slistautoptr;
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GSList_queueautoptr;
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GString *GString_autoptr;
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GString_listautoptr;
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GString_slistautoptr;
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GString_queueautoptr;
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GStringChunk *GStringChunk_autoptr;
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GStringChunk_listautoptr;
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GStringChunk_slistautoptr;
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GStringChunk_queueautoptr;
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GStrvBuilder *GStrvBuilder_autoptr;
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GStrvBuilder_listautoptr;
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GStrvBuilder_slistautoptr;
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GStrvBuilder_queueautoptr;
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GThread *GThread_autoptr;
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GThread_listautoptr;
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GThread_slistautoptr;
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GThread_queueautoptr;
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMutexLocker *GMutexLocker_autoptr;
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMutexLocker_listautoptr;
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMutexLocker_slistautoptr;
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMutexLocker_queueautoptr;
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRecMutexLocker *GRecMutexLocker_autoptr;
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRecMutexLocker_listautoptr;
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRecMutexLocker_slistautoptr;
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRecMutexLocker_queueautoptr;
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRWLockWriterLocker *GRWLockWriterLocker_autoptr;
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRWLockWriterLocker_listautoptr;
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRWLockWriterLocker_slistautoptr;
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRWLockWriterLocker_queueautoptr;
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRWLockReaderLocker *GRWLockReaderLocker_autoptr;
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRWLockReaderLocker_listautoptr;
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRWLockReaderLocker_slistautoptr;
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRWLockReaderLocker_queueautoptr;
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GTimer *GTimer_autoptr;
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GTimer_listautoptr;
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GTimer_slistautoptr;
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GTimer_queueautoptr;
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GTimeZone *GTimeZone_autoptr;
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GTimeZone_listautoptr;
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GTimeZone_slistautoptr;
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GTimeZone_queueautoptr;
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GTree *GTree_autoptr;
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GTree_listautoptr;
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GTree_slistautoptr;
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GTree_queueautoptr;
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GVariant *GVariant_autoptr;
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GVariant_listautoptr;
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GVariant_slistautoptr;
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GVariant_queueautoptr;
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GVariantBuilder *GVariantBuilder_autoptr;
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GVariantBuilder_listautoptr;
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GVariantBuilder_slistautoptr;
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GVariantBuilder_queueautoptr;
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GVariantIter *GVariantIter_autoptr;
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GVariantIter_listautoptr;
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GVariantIter_slistautoptr;
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GVariantIter_queueautoptr;
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GVariantDict *GVariantDict_autoptr;
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GVariantDict_listautoptr;
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GVariantDict_slistautoptr;
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GVariantDict_queueautoptr;
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GVariantType *GVariantType_autoptr;
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GVariantType_listautoptr;
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GVariantType_slistautoptr;
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GVariantType_queueautoptr;
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRefString *GRefString_autoptr;
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRefString_listautoptr;
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRefString_slistautoptr;
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRefString_queueautoptr;
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GUri *GUri_autoptr;
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GUri_listautoptr;
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GUri_slistautoptr;
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GUri_queueautoptr;
#line 400 "/usr/include/glib-2.0/gobject/gtype.h"
typedef gsize GType;
#line 404
struct _GValue ;
#line 404 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GValue GValue;
#line 405
union _GTypeCValue ;
#line 405 "/usr/include/glib-2.0/gobject/gtype.h"
typedef union _GTypeCValue GTypeCValue;
#line 406
struct _GTypePlugin ;
#line 406 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypePlugin GTypePlugin;
#line 407
struct _GTypeClass ;
#line 407 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypeClass GTypeClass;
#line 408
struct _GTypeInterface ;
#line 408 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypeInterface GTypeInterface;
#line 409
struct _GTypeInstance ;
#line 409 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypeInstance GTypeInstance;
#line 410
struct _GTypeInfo ;
#line 410 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypeInfo GTypeInfo;
#line 411
struct _GTypeFundamentalInfo ;
#line 411 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypeFundamentalInfo GTypeFundamentalInfo;
#line 412
struct _GInterfaceInfo ;
#line 412 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GInterfaceInfo GInterfaceInfo;
#line 413
struct _GTypeValueTable ;
#line 413 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypeValueTable GTypeValueTable;
#line 414
struct _GTypeQuery ;
#line 414 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypeQuery GTypeQuery;
#line 424 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeClass {
   GType g_type ;
};
#line 434 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeInstance {
   GTypeClass *g_class ;
};
#line 444 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeInterface {
   GType g_type ;
   GType g_instance_type ;
};
#line 461 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeQuery {
   GType type ;
   gchar *type_name ;
   guint class_size ;
   guint instance_size ;
};
#line 697
enum __anonenum__295 {
    G_TYPE_DEBUG_NONE = 0,
    G_TYPE_DEBUG_OBJECTS = 1,
    G_TYPE_DEBUG_SIGNALS = 2,
    G_TYPE_DEBUG_INSTANCE_COUNT = 4,
    G_TYPE_DEBUG_MASK = 7
} ;
#line 704 "/usr/include/glib-2.0/gobject/gtype.h"
typedef enum __anonenum__295 GTypeDebugFlags;
#line 794 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GBaseInitFunc)(gpointer  );
#line 808 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GBaseFinalizeFunc)(gpointer  );
#line 912 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GClassInitFunc)(gpointer  , gpointer  );
#line 929 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GClassFinalizeFunc)(gpointer  , gpointer  );
#line 951 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GInstanceInitFunc)(GTypeInstance * , gpointer  );
#line 967 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GInterfaceInitFunc)(gpointer  , gpointer  );
#line 979 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GInterfaceFinalizeFunc)(gpointer  , gpointer  );
#line 1001 "/usr/include/glib-2.0/gobject/gtype.h"
typedef gboolean (*GTypeClassCacheFunc)(gpointer  , GTypeClass * );
#line 1015 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GTypeInterfaceCheckFunc)(gpointer  , gpointer  );
#line 1027
enum __anonenum__296 {
    G_TYPE_FLAG_CLASSED = 1,
    G_TYPE_FLAG_INSTANTIATABLE = 2,
    G_TYPE_FLAG_DERIVABLE = 4,
    G_TYPE_FLAG_DEEP_DERIVABLE = 8
} ;
#line 1033 "/usr/include/glib-2.0/gobject/gtype.h"
typedef enum __anonenum__296 GTypeFundamentalFlags;
#line 1046
enum __anonenum__297 {
    G_TYPE_FLAG_ABSTRACT = 16,
    G_TYPE_FLAG_VALUE_ABSTRACT = 32,
    G_TYPE_FLAG_FINAL = 64
} ;
#line 1051 "/usr/include/glib-2.0/gobject/gtype.h"
typedef enum __anonenum__297 GTypeFlags;
#line 1083 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeInfo {
   guint16 class_size ;
   GBaseInitFunc base_init ;
   GBaseFinalizeFunc base_finalize ;
   GClassInitFunc class_init ;
   GClassFinalizeFunc class_finalize ;
   gconstpointer class_data ;
   guint16 instance_size ;
   guint16 n_preallocs ;
   GInstanceInitFunc instance_init ;
   GTypeValueTable *value_table ;
};
#line 1111 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeFundamentalInfo {
   GTypeFundamentalFlags type_flags ;
};
#line 1124 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GInterfaceInfo {
   GInterfaceInitFunc interface_init ;
   GInterfaceFinalizeFunc interface_finalize ;
   gpointer interface_data ;
};
#line 1284 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeValueTable {
   void (*value_init)(GValue * ) ;
   void (*value_free)(GValue * ) ;
   void (*value_copy)(GValue * , GValue * ) ;
   gpointer (*value_peek_pointer)(GValue * ) ;
   gchar *collect_format ;
   gchar *(*collect_value)(GValue * , guint  , GTypeCValue * , guint  ) ;
   gchar *lcopy_format ;
   gchar *(*lcopy_value)(GValue * , guint  , GTypeCValue * , guint  ) ;
};
#line 95 "/usr/include/glib-2.0/gobject/gvalue.h"
typedef void (*GValueTransform)(GValue * , GValue * );
#line 117 "/usr/include/glib-2.0/gobject/gvalue.h"
union __anonunion_298 {
   gint v_int ;
   guint v_uint ;
   glong v_long ;
   gulong v_ulong ;
   gint64 v_int64 ;
   guint64 v_uint64 ;
   gfloat v_float ;
   gdouble v_double ;
   gpointer v_pointer ;
};
#line 111 "/usr/include/glib-2.0/gobject/gvalue.h"
struct _GValue {
   GType g_type ;
   union __anonunion_298 data[2] ;
};
#line 152 "/usr/include/glib-2.0/gobject/gparam.h"
enum __anonenum__299 {
    G_PARAM_READABLE = 1,
    G_PARAM_WRITABLE = 2,
    G_PARAM_READWRITE = 3,
    G_PARAM_CONSTRUCT = 4,
    G_PARAM_CONSTRUCT_ONLY = 8,
    G_PARAM_LAX_VALIDATION = 16,
    G_PARAM_STATIC_NAME = 32,
    G_PARAM_PRIVATE = 32,
    G_PARAM_STATIC_NICK = 64,
    G_PARAM_STATIC_BLURB = 128,
    G_PARAM_EXPLICIT_NOTIFY = 1073741824,
    G_PARAM_DEPRECATED = (-0x7FFFFFFF-1)
} ;
#line 168 "/usr/include/glib-2.0/gobject/gparam.h"
typedef enum __anonenum__299 GParamFlags;
#line 194
struct _GParamSpec ;
#line 194 "/usr/include/glib-2.0/gobject/gparam.h"
typedef struct _GParamSpec GParamSpec;
#line 195
struct _GParamSpecClass ;
#line 195 "/usr/include/glib-2.0/gobject/gparam.h"
typedef struct _GParamSpecClass GParamSpecClass;
#line 196
struct _GParameter ;
#line 196 "/usr/include/glib-2.0/gobject/gparam.h"
typedef struct _GParameter GParameter;
#line 197
struct _GParamSpecPool ;
#line 197 "/usr/include/glib-2.0/gobject/gparam.h"
typedef struct _GParamSpecPool GParamSpecPool;
#line 209 "/usr/include/glib-2.0/gobject/gparam.h"
struct _GParamSpec {
   GTypeInstance g_type_instance ;
   gchar *name ;
   GParamFlags flags ;
   GType value_type ;
   GType owner_type ;
   gchar *_nick ;
   gchar *_blurb ;
   GData *qdata ;
   guint ref_count ;
   guint param_id ;
};
#line 244 "/usr/include/glib-2.0/gobject/gparam.h"
struct _GParamSpecClass {
   GTypeClass g_type_class ;
   GType value_type ;
   void (*finalize)(GParamSpec * ) ;
   void (*value_set_default)(GParamSpec * , GValue * ) ;
   gboolean (*value_validate)(GParamSpec * , GValue * ) ;
   gint (*values_cmp)(GParamSpec * , GValue * , GValue * ) ;
   gpointer dummy[4] ;
};
#line 273 "/usr/include/glib-2.0/gobject/gparam.h"
struct _GParameter {
   gchar *name ;
   GValue value ;
};
#line 353
struct _GParamSpecTypeInfo ;
#line 353 "/usr/include/glib-2.0/gobject/gparam.h"
typedef struct _GParamSpecTypeInfo GParamSpecTypeInfo;
#line 379 "/usr/include/glib-2.0/gobject/gparam.h"
struct _GParamSpecTypeInfo {
   guint16 instance_size ;
   guint16 n_preallocs ;
   void (*instance_init)(GParamSpec * ) ;
   GType value_type ;
   void (*finalize)(GParamSpec * ) ;
   void (*value_set_default)(GParamSpec * , GValue * ) ;
   gboolean (*value_validate)(GParamSpec * , GValue * ) ;
   gint (*values_cmp)(GParamSpec * , GValue * , GValue * ) ;
};
#line 75 "/usr/include/glib-2.0/gobject/gclosure.h"
struct _GClosure ;
#line 75 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef struct _GClosure GClosure;
#line 76
struct _GClosureNotifyData ;
#line 76 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef struct _GClosureNotifyData GClosureNotifyData;
#line 90 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef void (*GCallback)(void);
#line 99 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef void (*GClosureNotify)(gpointer  , GClosure * );
#line 119 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef void (*GClosureMarshal)(GClosure * , GValue * , guint  , GValue * , gpointer  ,
                                gpointer  );
#line 146 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef void (*GVaClosureMarshal)(GClosure * , GValue * , gpointer  , va_list  , gpointer  ,
                                  int  , GType * );
#line 161
struct _GCClosure ;
#line 161 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef struct _GCClosure GCClosure;
#line 165 "/usr/include/glib-2.0/gobject/gclosure.h"
struct _GClosureNotifyData {
   gpointer data ;
   GClosureNotify notify ;
};
#line 179 "/usr/include/glib-2.0/gobject/gclosure.h"
struct _GClosure {
   guint ref_count ;
   guint meta_marshal_nouse ;
   guint n_guards ;
   guint n_fnotifiers ;
   guint n_inotifiers ;
   guint in_inotify ;
   guint floating ;
   guint derivative_flag ;
   guint in_marshal ;
   guint is_invalid ;
   void (*marshal)(GClosure * , GValue * , guint  , GValue * , gpointer  , gpointer  ) ;
   gpointer data ;
   GClosureNotifyData *notifiers ;
};
#line 220 "/usr/include/glib-2.0/gobject/gclosure.h"
struct _GCClosure {
   GClosure closure ;
   gpointer callback ;
};
#line 32 "/usr/include/glib-2.0/gobject/gsignal.h"
struct _GSignalQuery ;
#line 32 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef struct _GSignalQuery GSignalQuery;
#line 33
struct _GSignalInvocationHint ;
#line 33 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef struct _GSignalInvocationHint GSignalInvocationHint;
#line 45 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef GClosureMarshal GSignalCMarshaller;
#line 53 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef GVaClosureMarshal GSignalCVaMarshaller;
#line 73 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef gboolean (*GSignalEmissionHook)(GSignalInvocationHint * , guint  , GValue * ,
                                        gpointer  );
#line 101 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef gboolean (*GSignalAccumulator)(GSignalInvocationHint * , GValue * , GValue * ,
                                       gpointer  );
#line 136
enum __anonenum__300 {
    G_SIGNAL_RUN_FIRST = 1,
    G_SIGNAL_RUN_LAST = 2,
    G_SIGNAL_RUN_CLEANUP = 4,
    G_SIGNAL_NO_RECURSE = 8,
    G_SIGNAL_DETAILED = 16,
    G_SIGNAL_ACTION = 32,
    G_SIGNAL_NO_HOOKS = 64,
    G_SIGNAL_MUST_COLLECT = 128,
    G_SIGNAL_DEPRECATED = 256,
    G_SIGNAL_ACCUMULATOR_FIRST_RUN = 131072
} ;
#line 149 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef enum __anonenum__300 GSignalFlags;
#line 166
enum __anonenum__301 {
    G_CONNECT_AFTER = 1,
    G_CONNECT_SWAPPED = 2
} ;
#line 170 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef enum __anonenum__301 GConnectFlags;
#line 184
enum __anonenum__302 {
    G_SIGNAL_MATCH_ID = 1,
    G_SIGNAL_MATCH_DETAIL = 2,
    G_SIGNAL_MATCH_CLOSURE = 4,
    G_SIGNAL_MATCH_FUNC = 8,
    G_SIGNAL_MATCH_DATA = 16,
    G_SIGNAL_MATCH_UNBLOCKED = 32
} ;
#line 192 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef enum __anonenum__302 GSignalMatchType;
#line 236 "/usr/include/glib-2.0/gobject/gsignal.h"
struct _GSignalInvocationHint {
   guint signal_id ;
   GQuark detail ;
   GSignalFlags run_type ;
};
#line 263 "/usr/include/glib-2.0/gobject/gsignal.h"
struct _GSignalQuery {
   guint signal_id ;
   gchar *signal_name ;
   GType itype ;
   GSignalFlags signal_flags ;
   GType return_type ;
   guint n_params ;
   GType *param_types ;
};
#line 56 "/usr/include/glib-2.0/gobject/gboxed.h"
typedef gpointer (*GBoxedCopyFunc)(gpointer  );
#line 65 "/usr/include/glib-2.0/gobject/gboxed.h"
typedef void (*GBoxedFreeFunc)(gpointer  );
#line 190 "/usr/include/glib-2.0/gobject/gobject.h"
struct _GObject ;
#line 190 "/usr/include/glib-2.0/gobject/gobject.h"
typedef struct _GObject GObject;
#line 191
struct _GObjectClass ;
#line 191 "/usr/include/glib-2.0/gobject/gobject.h"
typedef struct _GObjectClass GObjectClass;
#line 192 "/usr/include/glib-2.0/gobject/gobject.h"
typedef struct _GObject GInitiallyUnowned;
#line 193 "/usr/include/glib-2.0/gobject/gobject.h"
typedef struct _GObjectClass GInitiallyUnownedClass;
#line 194
struct _GObjectConstructParam ;
#line 194 "/usr/include/glib-2.0/gobject/gobject.h"
typedef struct _GObjectConstructParam GObjectConstructParam;
#line 205 "/usr/include/glib-2.0/gobject/gobject.h"
typedef void (*GObjectGetPropertyFunc)(GObject * , guint  , GValue * , GParamSpec * );
#line 219 "/usr/include/glib-2.0/gobject/gobject.h"
typedef void (*GObjectSetPropertyFunc)(GObject * , guint  , GValue * , GParamSpec * );
#line 229 "/usr/include/glib-2.0/gobject/gobject.h"
typedef void (*GObjectFinalizeFunc)(GObject * );
#line 247 "/usr/include/glib-2.0/gobject/gobject.h"
typedef void (*GWeakNotify)(gpointer  , GObject * );
#line 265 "/usr/include/glib-2.0/gobject/gobject.h"
struct _GObject {
   GTypeInstance g_type_instance ;
   guint ref_count ;
   GData *qdata ;
};
#line 335 "/usr/include/glib-2.0/gobject/gobject.h"
struct _GObjectClass {
   GTypeClass g_type_class ;
   GSList *construct_properties ;
   GObject *(*constructor)(GType  , guint  , GObjectConstructParam * ) ;
   void (*set_property)(GObject * , guint  , GValue * , GParamSpec * ) ;
   void (*get_property)(GObject * , guint  , GValue * , GParamSpec * ) ;
   void (*dispose)(GObject * ) ;
   void (*finalize)(GObject * ) ;
   void (*dispatch_properties_changed)(GObject * , guint  , GParamSpec ** ) ;
   void (*notify)(GObject * , GParamSpec * ) ;
   void (*constructed)(GObject * ) ;
   gsize flags ;
   gpointer pdummy[6] ;
};
#line 384 "/usr/include/glib-2.0/gobject/gobject.h"
struct _GObjectConstructParam {
   GParamSpec *pspec ;
   GValue *value ;
};
#line 559 "/usr/include/glib-2.0/gobject/gobject.h"
typedef void (*GToggleNotify)(gpointer  , GObject * , gboolean  );
#line 930 "/usr/include/glib-2.0/gobject/gobject.h"
union __anonunion_304 {
   gpointer p ;
};
#line 928 "/usr/include/glib-2.0/gobject/gobject.h"
struct __anonstruct_303 {
   union __anonunion_304 priv ;
};
#line 931 "/usr/include/glib-2.0/gobject/gobject.h"
typedef struct __anonstruct_303 GWeakRef;
#line 47 "/usr/include/glib-2.0/gobject/gbinding.h"
struct _GBinding ;
#line 47 "/usr/include/glib-2.0/gobject/gbinding.h"
typedef struct _GBinding GBinding;
#line 69 "/usr/include/glib-2.0/gobject/gbinding.h"
typedef gboolean (*GBindingTransformFunc)(GBinding * , GValue * , GValue * , gpointer  );
#line 97
enum __anonenum__305 {
    G_BINDING_DEFAULT = 0,
    G_BINDING_BIDIRECTIONAL = 1,
    G_BINDING_SYNC_CREATE = 2,
    G_BINDING_INVERT_BOOLEAN = 4
} ;
#line 103 "/usr/include/glib-2.0/gobject/gbinding.h"
typedef enum __anonenum__305 GBindingFlags;
#line 47 "/usr/include/glib-2.0/gobject/gbindinggroup.h"
struct _GBindingGroup ;
#line 47 "/usr/include/glib-2.0/gobject/gbindinggroup.h"
typedef struct _GBindingGroup GBindingGroup;
#line 138 "/usr/include/glib-2.0/gobject/genums.h"
struct _GEnumClass ;
#line 138 "/usr/include/glib-2.0/gobject/genums.h"
typedef struct _GEnumClass GEnumClass;
#line 139
struct _GFlagsClass ;
#line 139 "/usr/include/glib-2.0/gobject/genums.h"
typedef struct _GFlagsClass GFlagsClass;
#line 140
struct _GEnumValue ;
#line 140 "/usr/include/glib-2.0/gobject/genums.h"
typedef struct _GEnumValue GEnumValue;
#line 141
struct _GFlagsValue ;
#line 141 "/usr/include/glib-2.0/gobject/genums.h"
typedef struct _GFlagsValue GFlagsValue;
#line 155 "/usr/include/glib-2.0/gobject/genums.h"
struct _GEnumClass {
   GTypeClass g_type_class ;
   gint minimum ;
   gint maximum ;
   guint n_values ;
   GEnumValue *values ;
};
#line 176 "/usr/include/glib-2.0/gobject/genums.h"
struct _GFlagsClass {
   GTypeClass g_type_class ;
   guint mask ;
   guint n_values ;
   GFlagsValue *values ;
};
#line 194 "/usr/include/glib-2.0/gobject/genums.h"
struct _GEnumValue {
   gint value ;
   gchar *value_name ;
   gchar *value_nick ;
};
#line 209 "/usr/include/glib-2.0/gobject/genums.h"
struct _GFlagsValue {
   guint value ;
   gchar *value_name ;
   gchar *value_nick ;
};
#line 586 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecChar ;
#line 586 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecChar GParamSpecChar;
#line 587
struct _GParamSpecUChar ;
#line 587 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecUChar GParamSpecUChar;
#line 588
struct _GParamSpecBoolean ;
#line 588 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecBoolean GParamSpecBoolean;
#line 589
struct _GParamSpecInt ;
#line 589 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecInt GParamSpecInt;
#line 590
struct _GParamSpecUInt ;
#line 590 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecUInt GParamSpecUInt;
#line 591
struct _GParamSpecLong ;
#line 591 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecLong GParamSpecLong;
#line 592
struct _GParamSpecULong ;
#line 592 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecULong GParamSpecULong;
#line 593
struct _GParamSpecInt64 ;
#line 593 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecInt64 GParamSpecInt64;
#line 594
struct _GParamSpecUInt64 ;
#line 594 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecUInt64 GParamSpecUInt64;
#line 595
struct _GParamSpecUnichar ;
#line 595 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecUnichar GParamSpecUnichar;
#line 596
struct _GParamSpecEnum ;
#line 596 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecEnum GParamSpecEnum;
#line 597
struct _GParamSpecFlags ;
#line 597 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecFlags GParamSpecFlags;
#line 598
struct _GParamSpecFloat ;
#line 598 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecFloat GParamSpecFloat;
#line 599
struct _GParamSpecDouble ;
#line 599 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecDouble GParamSpecDouble;
#line 600
struct _GParamSpecString ;
#line 600 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecString GParamSpecString;
#line 601
struct _GParamSpecParam ;
#line 601 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecParam GParamSpecParam;
#line 602
struct _GParamSpecBoxed ;
#line 602 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecBoxed GParamSpecBoxed;
#line 603
struct _GParamSpecPointer ;
#line 603 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecPointer GParamSpecPointer;
#line 604
struct _GParamSpecValueArray ;
#line 604 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecValueArray GParamSpecValueArray;
#line 605
struct _GParamSpecObject ;
#line 605 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecObject GParamSpecObject;
#line 606
struct _GParamSpecOverride ;
#line 606 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecOverride GParamSpecOverride;
#line 607
struct _GParamSpecGType ;
#line 607 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecGType GParamSpecGType;
#line 608
struct _GParamSpecVariant ;
#line 608 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecVariant GParamSpecVariant;
#line 619 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecChar {
   GParamSpec parent_instance ;
   gint8 minimum ;
   gint8 maximum ;
   gint8 default_value ;
};
#line 636 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecUChar {
   GParamSpec parent_instance ;
   guint8 minimum ;
   guint8 maximum ;
   guint8 default_value ;
};
#line 651 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecBoolean {
   GParamSpec parent_instance ;
   gboolean default_value ;
};
#line 666 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecInt {
   GParamSpec parent_instance ;
   gint minimum ;
   gint maximum ;
   gint default_value ;
};
#line 683 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecUInt {
   GParamSpec parent_instance ;
   guint minimum ;
   guint maximum ;
   guint default_value ;
};
#line 700 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecLong {
   GParamSpec parent_instance ;
   glong minimum ;
   glong maximum ;
   glong default_value ;
};
#line 717 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecULong {
   GParamSpec parent_instance ;
   gulong minimum ;
   gulong maximum ;
   gulong default_value ;
};
#line 734 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecInt64 {
   GParamSpec parent_instance ;
   gint64 minimum ;
   gint64 maximum ;
   gint64 default_value ;
};
#line 751 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecUInt64 {
   GParamSpec parent_instance ;
   guint64 minimum ;
   guint64 maximum ;
   guint64 default_value ;
};
#line 766 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecUnichar {
   GParamSpec parent_instance ;
   gunichar default_value ;
};
#line 781 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecEnum {
   GParamSpec parent_instance ;
   GEnumClass *enum_class ;
   gint default_value ;
};
#line 797 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecFlags {
   GParamSpec parent_instance ;
   GFlagsClass *flags_class ;
   guint default_value ;
};
#line 815 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecFloat {
   GParamSpec parent_instance ;
   gfloat minimum ;
   gfloat maximum ;
   gfloat default_value ;
   gfloat epsilon ;
};
#line 835 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecDouble {
   GParamSpec parent_instance ;
   gdouble minimum ;
   gdouble maximum ;
   gdouble default_value ;
   gdouble epsilon ;
};
#line 857 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecString {
   GParamSpec parent_instance ;
   gchar *default_value ;
   gchar *cset_first ;
   gchar *cset_nth ;
   gchar substitutor ;
   guint null_fold_if_empty ;
   guint ensure_non_null ;
};
#line 875 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecParam {
   GParamSpec parent_instance ;
};
#line 885 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecBoxed {
   GParamSpec parent_instance ;
};
#line 895 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecPointer {
   GParamSpec parent_instance ;
};
#line 907 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecValueArray {
   GParamSpec parent_instance ;
   GParamSpec *element_spec ;
   guint fixed_n_elements ;
};
#line 919 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecObject {
   GParamSpec parent_instance ;
};
#line 940 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecOverride {
   GParamSpec parent_instance ;
   GParamSpec *overridden ;
};
#line 955 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecGType {
   GParamSpec parent_instance ;
   GType is_a_type ;
};
#line 976 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecVariant {
   GParamSpec parent_instance ;
   GVariantType *type ;
   GVariant *default_value ;
   gpointer padding[4] ;
};
#line 47 "/usr/include/glib-2.0/gobject/gsignalgroup.h"
struct _GSignalGroup ;
#line 47 "/usr/include/glib-2.0/gobject/gsignalgroup.h"
typedef struct _GSignalGroup GSignalGroup;
#line 29 "/usr/include/glib-2.0/gobject/gtypemodule.h"
struct _GTypeModule ;
#line 29 "/usr/include/glib-2.0/gobject/gtypemodule.h"
typedef struct _GTypeModule GTypeModule;
#line 30
struct _GTypeModuleClass ;
#line 30 "/usr/include/glib-2.0/gobject/gtypemodule.h"
typedef struct _GTypeModuleClass GTypeModuleClass;
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
typedef GTypeModule *GTypeModule_autoptr;
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
typedef GList *GTypeModule_listautoptr;
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
typedef GSList *GTypeModule_slistautoptr;
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
typedef GQueue *GTypeModule_queueautoptr;
#line 48 "/usr/include/glib-2.0/gobject/gtypemodule.h"
struct _GTypeModule {
   GObject parent_instance ;
   guint use_count ;
   GSList *type_infos ;
   GSList *interface_infos ;
   gchar *name ;
};
#line 70 "/usr/include/glib-2.0/gobject/gtypemodule.h"
struct _GTypeModuleClass {
   GObjectClass parent_class ;
   gboolean (*load)(GTypeModule * ) ;
   void (*unload)(GTypeModule * ) ;
   void (*reserved1)(void) ;
   void (*reserved2)(void) ;
   void (*reserved3)(void) ;
   void (*reserved4)(void) ;
};
#line 38 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
struct _GTypePluginClass ;
#line 38 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
typedef struct _GTypePluginClass GTypePluginClass;
#line 46 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
typedef void (*GTypePluginUse)(GTypePlugin * );
#line 53 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
typedef void (*GTypePluginUnuse)(GTypePlugin * );
#line 63 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
typedef void (*GTypePluginCompleteTypeInfo)(GTypePlugin * , GType  , GTypeInfo * ,
                                            GTypeValueTable * );
#line 77 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
typedef void (*GTypePluginCompleteInterfaceInfo)(GTypePlugin * , GType  , GType  ,
                                                 GInterfaceInfo * );
#line 101 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
struct _GTypePluginClass {
   GTypeInterface base_iface ;
   GTypePluginUse use_plugin ;
   GTypePluginUnuse unuse_plugin ;
   GTypePluginCompleteTypeInfo complete_type_info ;
   GTypePluginCompleteInterfaceInfo complete_interface_info ;
};
#line 41 "/usr/include/glib-2.0/gobject/gvaluearray.h"
struct _GValueArray ;
#line 41 "/usr/include/glib-2.0/gobject/gvaluearray.h"
typedef struct _GValueArray GValueArray;
#line 49 "/usr/include/glib-2.0/gobject/gvaluearray.h"
struct _GValueArray {
   guint n_values ;
   GValue *values ;
   guint n_prealloced ;
};
#line 311 "/usr/include/glib-2.0/gobject/gvaluetypes.h"
typedef gchar *gchararray;
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GClosure *GClosure_autoptr;
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GList *GClosure_listautoptr;
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GSList *GClosure_slistautoptr;
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GQueue *GClosure_queueautoptr;
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GEnumClass *GEnumClass_autoptr;
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GList *GEnumClass_listautoptr;
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GSList *GEnumClass_slistautoptr;
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GQueue *GEnumClass_queueautoptr;
#line 26 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GFlagsClass *GFlagsClass_autoptr;
#line 26 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GList *GFlagsClass_listautoptr;
#line 26 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GSList *GFlagsClass_slistautoptr;
#line 26 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GQueue *GFlagsClass_queueautoptr;
#line 27 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GObject *GObject_autoptr;
#line 27 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GList *GObject_listautoptr;
#line 27 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GSList *GObject_slistautoptr;
#line 27 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GQueue *GObject_queueautoptr;
#line 28 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GInitiallyUnowned *GInitiallyUnowned_autoptr;
#line 28 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GList *GInitiallyUnowned_listautoptr;
#line 28 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GSList *GInitiallyUnowned_slistautoptr;
#line 28 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GQueue *GInitiallyUnowned_queueautoptr;
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GParamSpec *GParamSpec_autoptr;
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GList *GParamSpec_listautoptr;
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GSList *GParamSpec_slistautoptr;
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GQueue *GParamSpec_queueautoptr;
#line 30 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GTypeClass *GTypeClass_autoptr;
#line 30 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GList *GTypeClass_listautoptr;
#line 30 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GSList *GTypeClass_slistautoptr;
#line 30 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GQueue *GTypeClass_queueautoptr;
#line 42 "/usr/include/glib-2.0/gio/gioenums.h"
enum __anonenum__306 {
    G_APP_INFO_CREATE_NONE = 0,
    G_APP_INFO_CREATE_NEEDS_TERMINAL = 1,
    G_APP_INFO_CREATE_SUPPORTS_URIS = 2,
    G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION = 4
} ;
#line 47 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__306 GAppInfoCreateFlags;
#line 59
enum __anonenum__307 {
    G_CONVERTER_NO_FLAGS = 0,
    G_CONVERTER_INPUT_AT_END = 1,
    G_CONVERTER_FLUSH = 2
} ;
#line 63 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__307 GConverterFlags;
#line 76
enum __anonenum__308 {
    G_CONVERTER_ERROR = 0,
    G_CONVERTER_CONVERTED = 1,
    G_CONVERTER_FINISHED = 2,
    G_CONVERTER_FLUSHED = 3
} ;
#line 81 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__308 GConverterResult;
#line 94
enum __anonenum__309 {
    G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN = 0,
    G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN = 1,
    G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN = 2
} ;
#line 98 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__309 GDataStreamByteOrder;
#line 110
enum __anonenum__310 {
    G_DATA_STREAM_NEWLINE_TYPE_LF = 0,
    G_DATA_STREAM_NEWLINE_TYPE_CR = 1,
    G_DATA_STREAM_NEWLINE_TYPE_CR_LF = 2,
    G_DATA_STREAM_NEWLINE_TYPE_ANY = 3
} ;
#line 115 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__310 GDataStreamNewlineType;
#line 133
enum __anonenum__311 {
    G_FILE_ATTRIBUTE_TYPE_INVALID = 0,
    G_FILE_ATTRIBUTE_TYPE_STRING = 1,
    G_FILE_ATTRIBUTE_TYPE_BYTE_STRING = 2,
    G_FILE_ATTRIBUTE_TYPE_BOOLEAN = 3,
    G_FILE_ATTRIBUTE_TYPE_UINT32 = 4,
    G_FILE_ATTRIBUTE_TYPE_INT32 = 5,
    G_FILE_ATTRIBUTE_TYPE_UINT64 = 6,
    G_FILE_ATTRIBUTE_TYPE_INT64 = 7,
    G_FILE_ATTRIBUTE_TYPE_OBJECT = 8,
    G_FILE_ATTRIBUTE_TYPE_STRINGV = 9
} ;
#line 144 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__311 GFileAttributeType;
#line 155
enum __anonenum__312 {
    G_FILE_ATTRIBUTE_INFO_NONE = 0,
    G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE = 1,
    G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED = 2
} ;
#line 159 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__312 GFileAttributeInfoFlags;
#line 170
enum __anonenum__313 {
    G_FILE_ATTRIBUTE_STATUS_UNSET = 0,
    G_FILE_ATTRIBUTE_STATUS_SET = 1,
    G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING = 2
} ;
#line 174 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__313 GFileAttributeStatus;
#line 184
enum __anonenum__314 {
    G_FILE_QUERY_INFO_NONE = 0,
    G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS = 1
} ;
#line 187 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__314 GFileQueryInfoFlags;
#line 208
enum __anonenum__315 {
    G_FILE_CREATE_NONE = 0,
    G_FILE_CREATE_PRIVATE = 1,
    G_FILE_CREATE_REPLACE_DESTINATION = 2
} ;
#line 212 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__315 GFileCreateFlags;
#line 231
enum __anonenum__316 {
    G_FILE_MEASURE_NONE = 0,
    G_FILE_MEASURE_REPORT_ANY_ERROR = 2,
    G_FILE_MEASURE_APPARENT_SIZE = 4,
    G_FILE_MEASURE_NO_XDEV = 8
} ;
#line 236 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__316 GFileMeasureFlags;
#line 244
enum __anonenum__317 {
    G_MOUNT_MOUNT_NONE = 0
} ;
#line 246 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__317 GMountMountFlags;
#line 257
enum __anonenum__318 {
    G_MOUNT_UNMOUNT_NONE = 0,
    G_MOUNT_UNMOUNT_FORCE = 1
} ;
#line 260 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__318 GMountUnmountFlags;
#line 270
enum __anonenum__319 {
    G_DRIVE_START_NONE = 0
} ;
#line 272 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__319 GDriveStartFlags;
#line 294
enum __anonenum__320 {
    G_DRIVE_START_STOP_TYPE_UNKNOWN = 0,
    G_DRIVE_START_STOP_TYPE_SHUTDOWN = 1,
    G_DRIVE_START_STOP_TYPE_NETWORK = 2,
    G_DRIVE_START_STOP_TYPE_MULTIDISK = 3,
    G_DRIVE_START_STOP_TYPE_PASSWORD = 4
} ;
#line 300 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__320 GDriveStartStopType;
#line 314
enum __anonenum__321 {
    G_FILE_COPY_NONE = 0,
    G_FILE_COPY_OVERWRITE = 1,
    G_FILE_COPY_BACKUP = 2,
    G_FILE_COPY_NOFOLLOW_SYMLINKS = 4,
    G_FILE_COPY_ALL_METADATA = 8,
    G_FILE_COPY_NO_FALLBACK_FOR_MOVE = 16,
    G_FILE_COPY_TARGET_DEFAULT_PERMS = 32
} ;
#line 322 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__321 GFileCopyFlags;
#line 344
enum __anonenum__322 {
    G_FILE_MONITOR_NONE = 0,
    G_FILE_MONITOR_WATCH_MOUNTS = 1,
    G_FILE_MONITOR_SEND_MOVED = 2,
    G_FILE_MONITOR_WATCH_HARD_LINKS = 4,
    G_FILE_MONITOR_WATCH_MOVES = 8
} ;
#line 350 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__322 GFileMonitorFlags;
#line 376
enum __anonenum__323 {
    G_FILE_TYPE_UNKNOWN = 0,
    G_FILE_TYPE_REGULAR = 1,
    G_FILE_TYPE_DIRECTORY = 2,
    G_FILE_TYPE_SYMBOLIC_LINK = 3,
    G_FILE_TYPE_SPECIAL = 4,
    G_FILE_TYPE_SHORTCUT = 5,
    G_FILE_TYPE_MOUNTABLE = 6
} ;
#line 384 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__323 GFileType;
#line 397
enum __anonenum__324 {
    G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS = 0,
    G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL = 1,
    G_FILESYSTEM_PREVIEW_TYPE_NEVER = 2
} ;
#line 401 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__324 GFilesystemPreviewType;
#line 427
enum __anonenum__325 {
    G_FILE_MONITOR_EVENT_CHANGED = 0,
    G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT = 1,
    G_FILE_MONITOR_EVENT_DELETED = 2,
    G_FILE_MONITOR_EVENT_CREATED = 3,
    G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED = 4,
    G_FILE_MONITOR_EVENT_PRE_UNMOUNT = 5,
    G_FILE_MONITOR_EVENT_UNMOUNTED = 6,
    G_FILE_MONITOR_EVENT_MOVED = 7,
    G_FILE_MONITOR_EVENT_RENAMED = 8,
    G_FILE_MONITOR_EVENT_MOVED_IN = 9,
    G_FILE_MONITOR_EVENT_MOVED_OUT = 10
} ;
#line 439 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__325 GFileMonitorEvent;
#line 530
enum __anonenum__326 {
    G_IO_ERROR_FAILED = 0,
    G_IO_ERROR_NOT_FOUND = 1,
    G_IO_ERROR_EXISTS = 2,
    G_IO_ERROR_IS_DIRECTORY = 3,
    G_IO_ERROR_NOT_DIRECTORY = 4,
    G_IO_ERROR_NOT_EMPTY = 5,
    G_IO_ERROR_NOT_REGULAR_FILE = 6,
    G_IO_ERROR_NOT_SYMBOLIC_LINK = 7,
    G_IO_ERROR_NOT_MOUNTABLE_FILE = 8,
    G_IO_ERROR_FILENAME_TOO_LONG = 9,
    G_IO_ERROR_INVALID_FILENAME = 10,
    G_IO_ERROR_TOO_MANY_LINKS = 11,
    G_IO_ERROR_NO_SPACE = 12,
    G_IO_ERROR_INVALID_ARGUMENT = 13,
    G_IO_ERROR_PERMISSION_DENIED = 14,
    G_IO_ERROR_NOT_SUPPORTED = 15,
    G_IO_ERROR_NOT_MOUNTED = 16,
    G_IO_ERROR_ALREADY_MOUNTED = 17,
    G_IO_ERROR_CLOSED = 18,
    G_IO_ERROR_CANCELLED = 19,
    G_IO_ERROR_PENDING = 20,
    G_IO_ERROR_READ_ONLY = 21,
    G_IO_ERROR_CANT_CREATE_BACKUP = 22,
    G_IO_ERROR_WRONG_ETAG = 23,
    G_IO_ERROR_TIMED_OUT = 24,
    G_IO_ERROR_WOULD_RECURSE = 25,
    G_IO_ERROR_BUSY = 26,
    G_IO_ERROR_WOULD_BLOCK = 27,
    G_IO_ERROR_HOST_NOT_FOUND = 28,
    G_IO_ERROR_WOULD_MERGE = 29,
    G_IO_ERROR_FAILED_HANDLED = 30,
    G_IO_ERROR_TOO_MANY_OPEN_FILES = 31,
    G_IO_ERROR_NOT_INITIALIZED = 32,
    G_IO_ERROR_ADDRESS_IN_USE = 33,
    G_IO_ERROR_PARTIAL_INPUT = 34,
    G_IO_ERROR_INVALID_DATA = 35,
    G_IO_ERROR_DBUS_ERROR = 36,
    G_IO_ERROR_HOST_UNREACHABLE = 37,
    G_IO_ERROR_NETWORK_UNREACHABLE = 38,
    G_IO_ERROR_CONNECTION_REFUSED = 39,
    G_IO_ERROR_PROXY_FAILED = 40,
    G_IO_ERROR_PROXY_AUTH_FAILED = 41,
    G_IO_ERROR_PROXY_NEED_AUTH = 42,
    G_IO_ERROR_PROXY_NOT_ALLOWED = 43,
    G_IO_ERROR_BROKEN_PIPE = 44,
    G_IO_ERROR_CONNECTION_CLOSED = 44,
    G_IO_ERROR_NOT_CONNECTED = 45,
    G_IO_ERROR_MESSAGE_TOO_LARGE = 46
} ;
#line 579 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__326 GIOErrorEnum;
#line 595
enum __anonenum__327 {
    G_ASK_PASSWORD_NEED_PASSWORD = 1,
    G_ASK_PASSWORD_NEED_USERNAME = 2,
    G_ASK_PASSWORD_NEED_DOMAIN = 4,
    G_ASK_PASSWORD_SAVING_SUPPORTED = 8,
    G_ASK_PASSWORD_ANONYMOUS_SUPPORTED = 16,
    G_ASK_PASSWORD_TCRYPT = 32
} ;
#line 602 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__327 GAskPasswordFlags;
#line 616
enum __anonenum__328 {
    G_PASSWORD_SAVE_NEVER = 0,
    G_PASSWORD_SAVE_FOR_SESSION = 1,
    G_PASSWORD_SAVE_PERMANENTLY = 2
} ;
#line 620 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__328 GPasswordSave;
#line 635
enum __anonenum__329 {
    G_MOUNT_OPERATION_HANDLED = 0,
    G_MOUNT_OPERATION_ABORTED = 1,
    G_MOUNT_OPERATION_UNHANDLED = 2
} ;
#line 639 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__329 GMountOperationResult;
#line 652
enum __anonenum__330 {
    G_OUTPUT_STREAM_SPLICE_NONE = 0,
    G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE = 1,
    G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET = 2
} ;
#line 656 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__330 GOutputStreamSpliceFlags;
#line 673
enum __anonenum__331 {
    G_IO_STREAM_SPLICE_NONE = 0,
    G_IO_STREAM_SPLICE_CLOSE_STREAM1 = 1,
    G_IO_STREAM_SPLICE_CLOSE_STREAM2 = 2,
    G_IO_STREAM_SPLICE_WAIT_FOR_BOTH = 4
} ;
#line 678 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__331 GIOStreamSpliceFlags;
#line 692
enum __anonenum__332 {
    G_EMBLEM_ORIGIN_UNKNOWN = 0,
    G_EMBLEM_ORIGIN_DEVICE = 1,
    G_EMBLEM_ORIGIN_LIVEMETADATA = 2,
    G_EMBLEM_ORIGIN_TAG = 3
} ;
#line 697 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__332 GEmblemOrigin;
#line 712
enum __anonenum__333 {
    G_RESOLVER_ERROR_NOT_FOUND = 0,
    G_RESOLVER_ERROR_TEMPORARY_FAILURE = 1,
    G_RESOLVER_ERROR_INTERNAL = 2
} ;
#line 716 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__333 GResolverError;
#line 759
enum __anonenum__334 {
    G_RESOLVER_RECORD_SRV = 1,
    G_RESOLVER_RECORD_MX = 2,
    G_RESOLVER_RECORD_TXT = 3,
    G_RESOLVER_RECORD_SOA = 4,
    G_RESOLVER_RECORD_NS = 5
} ;
#line 765 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__334 GResolverRecordType;
#line 777
enum __anonenum__335 {
    G_RESOURCE_ERROR_NOT_FOUND = 0,
    G_RESOURCE_ERROR_INTERNAL = 1
} ;
#line 780 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__335 GResourceError;
#line 792
enum __anonenum__336 {
    G_RESOURCE_FLAGS_NONE = 0,
    G_RESOURCE_FLAGS_COMPRESSED = 1
} ;
#line 795 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__336 GResourceFlags;
#line 805
enum __anonenum__337 {
    G_RESOURCE_LOOKUP_FLAGS_NONE = 0
} ;
#line 807 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__337 GResourceLookupFlags;
#line 822
enum __anonenum__338 {
    G_SOCKET_FAMILY_INVALID = 0,
    G_SOCKET_FAMILY_UNIX = 1,
    G_SOCKET_FAMILY_IPV4 = 2,
    G_SOCKET_FAMILY_IPV6 = 10
} ;
#line 827 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__338 GSocketFamily;
#line 843
enum __anonenum__339 {
    G_SOCKET_TYPE_INVALID = 0,
    G_SOCKET_TYPE_STREAM = 1,
    G_SOCKET_TYPE_DATAGRAM = 2,
    G_SOCKET_TYPE_SEQPACKET = 3
} ;
#line 849 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__339 GSocketType;
#line 868
enum __anonenum__340 {
    G_SOCKET_MSG_NONE = 0,
    G_SOCKET_MSG_OOB = 1,
    G_SOCKET_MSG_PEEK = 2,
    G_SOCKET_MSG_DONTROUTE = 4
} ;
#line 874 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__340 GSocketMsgFlags;
#line 894
enum __anonenum__341 {
    G_SOCKET_PROTOCOL_UNKNOWN = -1,
    G_SOCKET_PROTOCOL_DEFAULT = 0,
    G_SOCKET_PROTOCOL_TCP = 6,
    G_SOCKET_PROTOCOL_UDP = 17,
    G_SOCKET_PROTOCOL_SCTP = 132
} ;
#line 900 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__341 GSocketProtocol;
#line 913
enum __anonenum__342 {
    G_ZLIB_COMPRESSOR_FORMAT_ZLIB = 0,
    G_ZLIB_COMPRESSOR_FORMAT_GZIP = 1,
    G_ZLIB_COMPRESSOR_FORMAT_RAW = 2
} ;
#line 917 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__342 GZlibCompressorFormat;
#line 944
enum __anonenum__343 {
    G_UNIX_SOCKET_ADDRESS_INVALID = 0,
    G_UNIX_SOCKET_ADDRESS_ANONYMOUS = 1,
    G_UNIX_SOCKET_ADDRESS_PATH = 2,
    G_UNIX_SOCKET_ADDRESS_ABSTRACT = 3,
    G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED = 4
} ;
#line 950 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__343 GUnixSocketAddressType;
#line 963
enum __anonenum__344 {
    G_BUS_TYPE_STARTER = -1,
    G_BUS_TYPE_NONE = 0,
    G_BUS_TYPE_SYSTEM = 1,
    G_BUS_TYPE_SESSION = 2
} ;
#line 969 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__344 GBusType;
#line 984
enum __anonenum__345 {
    G_BUS_NAME_OWNER_FLAGS_NONE = 0,
    G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT = 1,
    G_BUS_NAME_OWNER_FLAGS_REPLACE = 2,
    G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE = 4
} ;
#line 990 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__345 GBusNameOwnerFlags;
#line 1005
enum __anonenum__346 {
    G_BUS_NAME_WATCHER_FLAGS_NONE = 0,
    G_BUS_NAME_WATCHER_FLAGS_AUTO_START = 1
} ;
#line 1009 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__346 GBusNameWatcherFlags;
#line 1032
enum __anonenum__347 {
    G_DBUS_PROXY_FLAGS_NONE = 0,
    G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES = 1,
    G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS = 2,
    G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START = 4,
    G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES = 8,
    G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION = 16,
    G_DBUS_PROXY_FLAGS_NO_MATCH_RULE = 32
} ;
#line 1041 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__347 GDBusProxyFlags;
#line 1150
enum __anonenum__348 {
    G_DBUS_ERROR_FAILED = 0,
    G_DBUS_ERROR_NO_MEMORY = 1,
    G_DBUS_ERROR_SERVICE_UNKNOWN = 2,
    G_DBUS_ERROR_NAME_HAS_NO_OWNER = 3,
    G_DBUS_ERROR_NO_REPLY = 4,
    G_DBUS_ERROR_IO_ERROR = 5,
    G_DBUS_ERROR_BAD_ADDRESS = 6,
    G_DBUS_ERROR_NOT_SUPPORTED = 7,
    G_DBUS_ERROR_LIMITS_EXCEEDED = 8,
    G_DBUS_ERROR_ACCESS_DENIED = 9,
    G_DBUS_ERROR_AUTH_FAILED = 10,
    G_DBUS_ERROR_NO_SERVER = 11,
    G_DBUS_ERROR_TIMEOUT = 12,
    G_DBUS_ERROR_NO_NETWORK = 13,
    G_DBUS_ERROR_ADDRESS_IN_USE = 14,
    G_DBUS_ERROR_DISCONNECTED = 15,
    G_DBUS_ERROR_INVALID_ARGS = 16,
    G_DBUS_ERROR_FILE_NOT_FOUND = 17,
    G_DBUS_ERROR_FILE_EXISTS = 18,
    G_DBUS_ERROR_UNKNOWN_METHOD = 19,
    G_DBUS_ERROR_TIMED_OUT = 20,
    G_DBUS_ERROR_MATCH_RULE_NOT_FOUND = 21,
    G_DBUS_ERROR_MATCH_RULE_INVALID = 22,
    G_DBUS_ERROR_SPAWN_EXEC_FAILED = 23,
    G_DBUS_ERROR_SPAWN_FORK_FAILED = 24,
    G_DBUS_ERROR_SPAWN_CHILD_EXITED = 25,
    G_DBUS_ERROR_SPAWN_CHILD_SIGNALED = 26,
    G_DBUS_ERROR_SPAWN_FAILED = 27,
    G_DBUS_ERROR_SPAWN_SETUP_FAILED = 28,
    G_DBUS_ERROR_SPAWN_CONFIG_INVALID = 29,
    G_DBUS_ERROR_SPAWN_SERVICE_INVALID = 30,
    G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND = 31,
    G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID = 32,
    G_DBUS_ERROR_SPAWN_FILE_INVALID = 33,
    G_DBUS_ERROR_SPAWN_NO_MEMORY = 34,
    G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN = 35,
    G_DBUS_ERROR_INVALID_SIGNATURE = 36,
    G_DBUS_ERROR_INVALID_FILE_CONTENT = 37,
    G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN = 38,
    G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN = 39,
    G_DBUS_ERROR_OBJECT_PATH_IN_USE = 40,
    G_DBUS_ERROR_UNKNOWN_OBJECT = 41,
    G_DBUS_ERROR_UNKNOWN_INTERFACE = 42,
    G_DBUS_ERROR_UNKNOWN_PROPERTY = 43,
    G_DBUS_ERROR_PROPERTY_READ_ONLY = 44
} ;
#line 1198 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__348 GDBusError;
#line 1220
enum __anonenum__349 {
    G_DBUS_CONNECTION_FLAGS_NONE = 0,
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT = 1,
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER = 2,
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = 4,
    G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION = 8,
    G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING = 16,
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER = 32
} ;
#line 1228 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__349 GDBusConnectionFlags;
#line 1240
enum __anonenum__350 {
    G_DBUS_CAPABILITY_FLAGS_NONE = 0,
    G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING = 1
} ;
#line 1243 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__350 GDBusCapabilityFlags;
#line 1258
enum __anonenum__351 {
    G_DBUS_CALL_FLAGS_NONE = 0,
    G_DBUS_CALL_FLAGS_NO_AUTO_START = 1,
    G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = 2
} ;
#line 1262 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__351 GDBusCallFlags;
#line 1277
enum __anonenum__352 {
    G_DBUS_MESSAGE_TYPE_INVALID = 0,
    G_DBUS_MESSAGE_TYPE_METHOD_CALL = 1,
    G_DBUS_MESSAGE_TYPE_METHOD_RETURN = 2,
    G_DBUS_MESSAGE_TYPE_ERROR = 3,
    G_DBUS_MESSAGE_TYPE_SIGNAL = 4
} ;
#line 1283 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__352 GDBusMessageType;
#line 1299
enum __anonenum__353 {
    G_DBUS_MESSAGE_FLAGS_NONE = 0,
    G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED = 1,
    G_DBUS_MESSAGE_FLAGS_NO_AUTO_START = 2,
    G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = 4
} ;
#line 1304 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__353 GDBusMessageFlags;
#line 1323
enum __anonenum__354 {
    G_DBUS_MESSAGE_HEADER_FIELD_INVALID = 0,
    G_DBUS_MESSAGE_HEADER_FIELD_PATH = 1,
    G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE = 2,
    G_DBUS_MESSAGE_HEADER_FIELD_MEMBER = 3,
    G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME = 4,
    G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL = 5,
    G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION = 6,
    G_DBUS_MESSAGE_HEADER_FIELD_SENDER = 7,
    G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE = 8,
    G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS = 9
} ;
#line 1334 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__354 GDBusMessageHeaderField;
#line 1346
enum __anonenum__355 {
    G_DBUS_PROPERTY_INFO_FLAGS_NONE = 0,
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE = 1,
    G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE = 2
} ;
#line 1351 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__355 GDBusPropertyInfoFlags;
#line 1364
enum __anonenum__356 {
    G_DBUS_SUBTREE_FLAGS_NONE = 0,
    G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES = 1
} ;
#line 1368 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__356 GDBusSubtreeFlags;
#line 1385
enum __anonenum__357 {
    G_DBUS_SERVER_FLAGS_NONE = 0,
    G_DBUS_SERVER_FLAGS_RUN_IN_THREAD = 1,
    G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = 2,
    G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER = 4
} ;
#line 1391 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__357 GDBusServerFlags;
#line 1409
enum __anonenum__358 {
    G_DBUS_SIGNAL_FLAGS_NONE = 0,
    G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE = 1,
    G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE = 2,
    G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH = 4
} ;
#line 1415 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__358 GDBusSignalFlags;
#line 1428
enum __anonenum__359 {
    G_DBUS_SEND_MESSAGE_FLAGS_NONE = 0,
    G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL = 1
} ;
#line 1432 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__359 GDBusSendMessageFlags;
#line 1450
enum __anonenum__360 {
    G_CREDENTIALS_TYPE_INVALID = 0,
    G_CREDENTIALS_TYPE_LINUX_UCRED = 1,
    G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED = 2,
    G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED = 3,
    G_CREDENTIALS_TYPE_SOLARIS_UCRED = 4,
    G_CREDENTIALS_TYPE_NETBSD_UNPCBID = 5,
    G_CREDENTIALS_TYPE_APPLE_XUCRED = 6,
    G_CREDENTIALS_TYPE_WIN32_PID = 7
} ;
#line 1460 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__360 GCredentialsType;
#line 1471
enum __anonenum__361 {
    G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN = 66,
    G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN = 108
} ;
#line 1475 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__361 GDBusMessageByteOrder;
#line 1521
enum __anonenum__362 {
    G_APPLICATION_FLAGS_NONE = 0,
    G_APPLICATION_IS_SERVICE = 1,
    G_APPLICATION_IS_LAUNCHER = 2,
    G_APPLICATION_HANDLES_OPEN = 4,
    G_APPLICATION_HANDLES_COMMAND_LINE = 8,
    G_APPLICATION_SEND_ENVIRONMENT = 16,
    G_APPLICATION_NON_UNIQUE = 32,
    G_APPLICATION_CAN_OVERRIDE_APP_ID = 64,
    G_APPLICATION_ALLOW_REPLACEMENT = 128,
    G_APPLICATION_REPLACE = 256
} ;
#line 1536 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__362 GApplicationFlags;
#line 1565
enum __anonenum__363 {
    G_TLS_ERROR_UNAVAILABLE = 0,
    G_TLS_ERROR_MISC = 1,
    G_TLS_ERROR_BAD_CERTIFICATE = 2,
    G_TLS_ERROR_NOT_TLS = 3,
    G_TLS_ERROR_HANDSHAKE = 4,
    G_TLS_ERROR_CERTIFICATE_REQUIRED = 5,
    G_TLS_ERROR_EOF = 6,
    G_TLS_ERROR_INAPPROPRIATE_FALLBACK = 7,
    G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD = 8
} ;
#line 1575 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__363 GTlsError;
#line 1609
enum __anonenum__364 {
    G_TLS_CERTIFICATE_UNKNOWN_CA = 1,
    G_TLS_CERTIFICATE_BAD_IDENTITY = 2,
    G_TLS_CERTIFICATE_NOT_ACTIVATED = 4,
    G_TLS_CERTIFICATE_EXPIRED = 8,
    G_TLS_CERTIFICATE_REVOKED = 16,
    G_TLS_CERTIFICATE_INSECURE = 32,
    G_TLS_CERTIFICATE_GENERIC_ERROR = 64,
    G_TLS_CERTIFICATE_VALIDATE_ALL = 127
} ;
#line 1619 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__364 GTlsCertificateFlags;
#line 1631
enum __anonenum__365 {
    G_TLS_AUTHENTICATION_NONE = 0,
    G_TLS_AUTHENTICATION_REQUESTED = 1,
    G_TLS_AUTHENTICATION_REQUIRED = 2
} ;
#line 1635 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__365 GTlsAuthenticationMode;
#line 1654
enum __anonenum__366 {
    G_TLS_CHANNEL_BINDING_TLS_UNIQUE = 0,
    G_TLS_CHANNEL_BINDING_TLS_SERVER_END_POINT = 1
} ;
#line 1657 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__366 GTlsChannelBindingType;
#line 1684
enum __anonenum__367 {
    G_TLS_CHANNEL_BINDING_ERROR_NOT_IMPLEMENTED = 0,
    G_TLS_CHANNEL_BINDING_ERROR_INVALID_STATE = 1,
    G_TLS_CHANNEL_BINDING_ERROR_NOT_AVAILABLE = 2,
    G_TLS_CHANNEL_BINDING_ERROR_NOT_SUPPORTED = 3,
    G_TLS_CHANNEL_BINDING_ERROR_GENERAL_ERROR = 4
} ;
#line 1690 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__367 GTlsChannelBindingError;
#line 1707
enum __anonenum__368 {
    G_TLS_REHANDSHAKE_NEVER = 0,
    G_TLS_REHANDSHAKE_SAFELY = 1,
    G_TLS_REHANDSHAKE_UNSAFELY = 2
} ;
#line 1711 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__368 GTlsRehandshakeMode;
#line 1733
enum _GTlsPasswordFlags {
    G_TLS_PASSWORD_NONE = 0,
    G_TLS_PASSWORD_RETRY = 2,
    G_TLS_PASSWORD_MANY_TRIES = 4,
    G_TLS_PASSWORD_FINAL_TRY = 8,
    G_TLS_PASSWORD_PKCS11_USER = 16,
    G_TLS_PASSWORD_PKCS11_SECURITY_OFFICER = 32,
    G_TLS_PASSWORD_PKCS11_CONTEXT_SPECIFIC = 64
} ;
#line 1742 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum _GTlsPasswordFlags GTlsPasswordFlags;
#line 1758
enum __anonenum__369 {
    G_TLS_INTERACTION_UNHANDLED = 0,
    G_TLS_INTERACTION_HANDLED = 1,
    G_TLS_INTERACTION_FAILED = 2
} ;
#line 1762 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__369 GTlsInteractionResult;
#line 1776
enum __anonenum__370 {
    G_DBUS_INTERFACE_SKELETON_FLAGS_NONE = 0,
    G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD = 1
} ;
#line 1780 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__370 GDBusInterfaceSkeletonFlags;
#line 1794
enum __anonenum__371 {
    G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE = 0,
    G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START = 1
} ;
#line 1798 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__371 GDBusObjectManagerClientFlags;
#line 1808
enum __anonenum__372 {
    G_TLS_DATABASE_VERIFY_NONE = 0
} ;
#line 1810 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__372 GTlsDatabaseVerifyFlags;
#line 1824
enum __anonenum__373 {
    G_TLS_DATABASE_LOOKUP_NONE = 0,
    G_TLS_DATABASE_LOOKUP_KEYPAIR = 1
} ;
#line 1827 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__373 GTlsDatabaseLookupFlags;
#line 1839
enum __anonenum__374 {
    G_TLS_CERTIFICATE_REQUEST_NONE = 0
} ;
#line 1841 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__374 GTlsCertificateRequestFlags;
#line 1866
enum __anonenum__375 {
    G_TLS_PROTOCOL_VERSION_UNKNOWN = 0,
    G_TLS_PROTOCOL_VERSION_SSL_3_0 = 1,
    G_TLS_PROTOCOL_VERSION_TLS_1_0 = 2,
    G_TLS_PROTOCOL_VERSION_TLS_1_1 = 3,
    G_TLS_PROTOCOL_VERSION_TLS_1_2 = 4,
    G_TLS_PROTOCOL_VERSION_TLS_1_3 = 5,
    G_TLS_PROTOCOL_VERSION_DTLS_1_0 = 201,
    G_TLS_PROTOCOL_VERSION_DTLS_1_2 = 202
} ;
#line 1875 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__375 GTlsProtocolVersion;
#line 1888
enum __anonenum__376 {
    G_IO_MODULE_SCOPE_NONE = 0,
    G_IO_MODULE_SCOPE_BLOCK_DUPLICATES = 1
} ;
#line 1891 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__376 GIOModuleScopeFlags;
#line 1919
enum __anonenum__377 {
    G_SOCKET_CLIENT_RESOLVING = 0,
    G_SOCKET_CLIENT_RESOLVED = 1,
    G_SOCKET_CLIENT_CONNECTING = 2,
    G_SOCKET_CLIENT_CONNECTED = 3,
    G_SOCKET_CLIENT_PROXY_NEGOTIATING = 4,
    G_SOCKET_CLIENT_PROXY_NEGOTIATED = 5,
    G_SOCKET_CLIENT_TLS_HANDSHAKING = 6,
    G_SOCKET_CLIENT_TLS_HANDSHAKED = 7,
    G_SOCKET_CLIENT_COMPLETE = 8
} ;
#line 1929 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__377 GSocketClientEvent;
#line 1947
enum __anonenum__378 {
    G_SOCKET_LISTENER_BINDING = 0,
    G_SOCKET_LISTENER_BOUND = 1,
    G_SOCKET_LISTENER_LISTENING = 2,
    G_SOCKET_LISTENER_LISTENED = 3
} ;
#line 1952 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__378 GSocketListenerEvent;
#line 1962
enum __anonenum__379 {
    G_TEST_DBUS_NONE = 0
} ;
#line 1964 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__379 GTestDBusFlags;
#line 2007
enum __anonenum__380 {
    G_SUBPROCESS_FLAGS_NONE = 0,
    G_SUBPROCESS_FLAGS_STDIN_PIPE = 1,
    G_SUBPROCESS_FLAGS_STDIN_INHERIT = 2,
    G_SUBPROCESS_FLAGS_STDOUT_PIPE = 4,
    G_SUBPROCESS_FLAGS_STDOUT_SILENCE = 8,
    G_SUBPROCESS_FLAGS_STDERR_PIPE = 16,
    G_SUBPROCESS_FLAGS_STDERR_SILENCE = 32,
    G_SUBPROCESS_FLAGS_STDERR_MERGE = 64,
    G_SUBPROCESS_FLAGS_INHERIT_FDS = 128,
    G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP = 256
} ;
#line 2018 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__380 GSubprocessFlags;
#line 2039
enum __anonenum__381 {
    G_NOTIFICATION_PRIORITY_NORMAL = 0,
    G_NOTIFICATION_PRIORITY_LOW = 1,
    G_NOTIFICATION_PRIORITY_HIGH = 2,
    G_NOTIFICATION_PRIORITY_URGENT = 3
} ;
#line 2044 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__381 GNotificationPriority;
#line 2063
enum __anonenum__382 {
    G_NETWORK_CONNECTIVITY_LOCAL = 1,
    G_NETWORK_CONNECTIVITY_LIMITED = 2,
    G_NETWORK_CONNECTIVITY_PORTAL = 3,
    G_NETWORK_CONNECTIVITY_FULL = 4
} ;
#line 2068 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__382 GNetworkConnectivity;
#line 2088
enum __anonenum__383 {
    G_POLLABLE_RETURN_FAILED = 0,
    G_POLLABLE_RETURN_OK = 1,
    G_POLLABLE_RETURN_WOULD_BLOCK = -27
} ;
#line 2092 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__383 GPollableReturn;
#line 2117
enum __anonenum__384 {
    G_MEMORY_MONITOR_WARNING_LEVEL_LOW = 50,
    G_MEMORY_MONITOR_WARNING_LEVEL_MEDIUM = 100,
    G_MEMORY_MONITOR_WARNING_LEVEL_CRITICAL = 255
} ;
#line 2121 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__384 GMemoryMonitorWarningLevel;
#line 32 "/usr/include/glib-2.0/gio/giotypes.h"
struct _GAppLaunchContext ;
#line 32 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GAppLaunchContext GAppLaunchContext;
#line 33
struct _GAppInfo ;
#line 33 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GAppInfo GAppInfo;
#line 34
struct _GAsyncResult ;
#line 34 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GAsyncResult GAsyncResult;
#line 35
struct _GAsyncInitable ;
#line 35 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GAsyncInitable GAsyncInitable;
#line 36
struct _GBufferedInputStream ;
#line 36 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GBufferedInputStream GBufferedInputStream;
#line 37
struct _GBufferedOutputStream ;
#line 37 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GBufferedOutputStream GBufferedOutputStream;
#line 38
struct _GCancellable ;
#line 38 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GCancellable GCancellable;
#line 39
struct _GCharsetConverter ;
#line 39 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GCharsetConverter GCharsetConverter;
#line 40
struct _GConverter ;
#line 40 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GConverter GConverter;
#line 41
struct _GConverterInputStream ;
#line 41 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GConverterInputStream GConverterInputStream;
#line 42
struct _GConverterOutputStream ;
#line 42 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GConverterOutputStream GConverterOutputStream;
#line 43
struct _GDatagramBased ;
#line 43 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDatagramBased GDatagramBased;
#line 44
struct _GDataInputStream ;
#line 44 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDataInputStream GDataInputStream;
#line 45
struct _GSimplePermission ;
#line 45 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSimplePermission GSimplePermission;
#line 46
struct _GZlibCompressor ;
#line 46 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GZlibCompressor GZlibCompressor;
#line 47
struct _GZlibDecompressor ;
#line 47 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GZlibDecompressor GZlibDecompressor;
#line 49
struct _GSimpleActionGroup ;
#line 49 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSimpleActionGroup GSimpleActionGroup;
#line 50
struct _GRemoteActionGroup ;
#line 50 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GRemoteActionGroup GRemoteActionGroup;
#line 51
struct _GDBusActionGroup ;
#line 51 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusActionGroup GDBusActionGroup;
#line 52
struct _GActionMap ;
#line 52 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GActionMap GActionMap;
#line 53
struct _GActionGroup ;
#line 53 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GActionGroup GActionGroup;
#line 54
struct _GPropertyAction ;
#line 54 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GPropertyAction GPropertyAction;
#line 55
struct _GSimpleAction ;
#line 55 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSimpleAction GSimpleAction;
#line 56
struct _GAction ;
#line 56 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GAction GAction;
#line 57
struct _GApplication ;
#line 57 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GApplication GApplication;
#line 58
struct _GApplicationCommandLine ;
#line 58 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GApplicationCommandLine GApplicationCommandLine;
#line 59
struct _GSettingsBackend ;
#line 59 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSettingsBackend GSettingsBackend;
#line 60
struct _GSettings ;
#line 60 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSettings GSettings;
#line 61
struct _GPermission ;
#line 61 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GPermission GPermission;
#line 63
struct _GMenuModel ;
#line 63 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GMenuModel GMenuModel;
#line 64
struct _GNotification ;
#line 64 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GNotification GNotification;
#line 71
struct _GDrive ;
#line 71 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDrive GDrive;
#line 72
struct _GFileEnumerator ;
#line 72 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFileEnumerator GFileEnumerator;
#line 73
struct _GFileMonitor ;
#line 73 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFileMonitor GFileMonitor;
#line 74
struct _GFilterInputStream ;
#line 74 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFilterInputStream GFilterInputStream;
#line 75
struct _GFilterOutputStream ;
#line 75 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFilterOutputStream GFilterOutputStream;
#line 84
struct _GFile ;
#line 84 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFile GFile;
#line 85
struct _GFileInfo ;
#line 85 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFileInfo GFileInfo;
#line 92
struct _GFileAttributeMatcher ;
#line 92 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFileAttributeMatcher GFileAttributeMatcher;
#line 93
struct _GFileAttributeInfo ;
#line 93 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFileAttributeInfo GFileAttributeInfo;
#line 94
struct _GFileAttributeInfoList ;
#line 94 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFileAttributeInfoList GFileAttributeInfoList;
#line 95
struct _GFileDescriptorBased ;
#line 95 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFileDescriptorBased GFileDescriptorBased;
#line 96
struct _GFileInputStream ;
#line 96 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFileInputStream GFileInputStream;
#line 97
struct _GFileOutputStream ;
#line 97 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFileOutputStream GFileOutputStream;
#line 98
struct _GFileIOStream ;
#line 98 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFileIOStream GFileIOStream;
#line 99
struct _GFileIcon ;
#line 99 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFileIcon GFileIcon;
#line 100
struct _GFilenameCompleter ;
#line 100 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFilenameCompleter GFilenameCompleter;
#line 103
struct _GIcon ;
#line 103 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GIcon GIcon;
#line 104
struct _GInetAddress ;
#line 104 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GInetAddress GInetAddress;
#line 105
struct _GInetAddressMask ;
#line 105 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GInetAddressMask GInetAddressMask;
#line 106
struct _GInetSocketAddress ;
#line 106 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GInetSocketAddress GInetSocketAddress;
#line 107
struct _GNativeSocketAddress ;
#line 107 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GNativeSocketAddress GNativeSocketAddress;
#line 108
struct _GInputStream ;
#line 108 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GInputStream GInputStream;
#line 109
struct _GInitable ;
#line 109 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GInitable GInitable;
#line 110
struct _GIOModule ;
#line 110 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GIOModule GIOModule;
#line 111
struct _GIOExtensionPoint ;
#line 111 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GIOExtensionPoint GIOExtensionPoint;
#line 112
struct _GIOExtension ;
#line 112 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GIOExtension GIOExtension;
#line 119
struct _GIOSchedulerJob ;
#line 119 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GIOSchedulerJob GIOSchedulerJob;
#line 120
struct _GIOStreamAdapter ;
#line 120 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GIOStreamAdapter GIOStreamAdapter;
#line 121
struct _GLoadableIcon ;
#line 121 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GLoadableIcon GLoadableIcon;
#line 122
struct _GBytesIcon ;
#line 122 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GBytesIcon GBytesIcon;
#line 123
struct _GMemoryInputStream ;
#line 123 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GMemoryInputStream GMemoryInputStream;
#line 124
struct _GMemoryOutputStream ;
#line 124 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GMemoryOutputStream GMemoryOutputStream;
#line 131
struct _GMount ;
#line 131 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GMount GMount;
#line 132
struct _GMountOperation ;
#line 132 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GMountOperation GMountOperation;
#line 133
struct _GNetworkAddress ;
#line 133 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GNetworkAddress GNetworkAddress;
#line 134
struct _GNetworkMonitor ;
#line 134 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GNetworkMonitor GNetworkMonitor;
#line 135
struct _GNetworkService ;
#line 135 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GNetworkService GNetworkService;
#line 136
struct _GOutputStream ;
#line 136 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GOutputStream GOutputStream;
#line 137
struct _GIOStream ;
#line 137 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GIOStream GIOStream;
#line 138
struct _GSimpleIOStream ;
#line 138 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSimpleIOStream GSimpleIOStream;
#line 139
struct _GPollableInputStream ;
#line 139 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GPollableInputStream GPollableInputStream;
#line 140
struct _GPollableOutputStream ;
#line 140 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GPollableOutputStream GPollableOutputStream;
#line 141
struct _GResolver ;
#line 141 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GResolver GResolver;
#line 150
struct _GResource ;
#line 150 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GResource GResource;
#line 151
struct _GSeekable ;
#line 151 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSeekable GSeekable;
#line 152
struct _GSimpleAsyncResult ;
#line 152 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSimpleAsyncResult GSimpleAsyncResult;
#line 161
struct _GSocket ;
#line 161 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSocket GSocket;
#line 169
struct _GSocketControlMessage ;
#line 169 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSocketControlMessage GSocketControlMessage;
#line 177
struct _GSocketClient ;
#line 177 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSocketClient GSocketClient;
#line 185
struct _GSocketConnection ;
#line 185 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSocketConnection GSocketConnection;
#line 193
struct _GSocketListener ;
#line 193 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSocketListener GSocketListener;
#line 202
struct _GSocketService ;
#line 202 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSocketService GSocketService;
#line 203
struct _GSocketAddress ;
#line 203 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSocketAddress GSocketAddress;
#line 204
struct _GSocketAddressEnumerator ;
#line 204 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSocketAddressEnumerator GSocketAddressEnumerator;
#line 205
struct _GSocketConnectable ;
#line 205 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSocketConnectable GSocketConnectable;
#line 206
struct _GSrvTarget ;
#line 206 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSrvTarget GSrvTarget;
#line 207
struct _GTask ;
#line 207 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTask GTask;
#line 215
struct _GTcpConnection ;
#line 215 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTcpConnection GTcpConnection;
#line 216
struct _GTcpWrapperConnection ;
#line 216 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTcpWrapperConnection GTcpWrapperConnection;
#line 225
struct _GThreadedSocketService ;
#line 225 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GThreadedSocketService GThreadedSocketService;
#line 226
struct _GDtlsConnection ;
#line 226 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDtlsConnection GDtlsConnection;
#line 227
struct _GDtlsClientConnection ;
#line 227 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDtlsClientConnection GDtlsClientConnection;
#line 228
struct _GDtlsServerConnection ;
#line 228 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDtlsServerConnection GDtlsServerConnection;
#line 229
struct _GThemedIcon ;
#line 229 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GThemedIcon GThemedIcon;
#line 230
struct _GTlsCertificate ;
#line 230 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTlsCertificate GTlsCertificate;
#line 231
struct _GTlsClientConnection ;
#line 231 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTlsClientConnection GTlsClientConnection;
#line 232
struct _GTlsConnection ;
#line 232 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTlsConnection GTlsConnection;
#line 233
struct _GTlsDatabase ;
#line 233 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTlsDatabase GTlsDatabase;
#line 234
struct _GTlsFileDatabase ;
#line 234 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTlsFileDatabase GTlsFileDatabase;
#line 235
struct _GTlsInteraction ;
#line 235 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTlsInteraction GTlsInteraction;
#line 236
struct _GTlsPassword ;
#line 236 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTlsPassword GTlsPassword;
#line 237
struct _GTlsServerConnection ;
#line 237 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTlsServerConnection GTlsServerConnection;
#line 238
struct _GVfs ;
#line 238 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GVfs GVfs;
#line 247
struct _GProxyResolver ;
#line 247 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GProxyResolver GProxyResolver;
#line 248
struct _GProxy ;
#line 248 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GProxy GProxy;
#line 249
struct _GProxyAddress ;
#line 249 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GProxyAddress GProxyAddress;
#line 250
struct _GProxyAddressEnumerator ;
#line 250 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GProxyAddressEnumerator GProxyAddressEnumerator;
#line 257
struct _GVolume ;
#line 257 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GVolume GVolume;
#line 258
struct _GVolumeMonitor ;
#line 258 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GVolumeMonitor GVolumeMonitor;
#line 279 "/usr/include/glib-2.0/gio/giotypes.h"
typedef void (*GAsyncReadyCallback)(GObject * , GAsyncResult * , gpointer  );
#line 293 "/usr/include/glib-2.0/gio/giotypes.h"
typedef void (*GFileProgressCallback)(goffset  , goffset  , gpointer  );
#line 310 "/usr/include/glib-2.0/gio/giotypes.h"
typedef gboolean (*GFileReadMoreCallback)(char const   * , goffset  , gpointer  );
#line 352 "/usr/include/glib-2.0/gio/giotypes.h"
typedef void (*GFileMeasureProgressCallback)(gboolean  , guint64  , guint64  , guint64  ,
                                             gpointer  );
#line 372 "/usr/include/glib-2.0/gio/giotypes.h"
typedef gboolean (*GIOSchedulerJobFunc)(GIOSchedulerJob * , GCancellable * , gpointer  );
#line 385 "/usr/include/glib-2.0/gio/giotypes.h"
typedef void (*GSimpleAsyncThreadFunc)(GSimpleAsyncResult * , GObject * , GCancellable * );
#line 402 "/usr/include/glib-2.0/gio/giotypes.h"
typedef gboolean (*GSocketSourceFunc)(GSocket * , GIOCondition  , gpointer  );
#line 420 "/usr/include/glib-2.0/gio/giotypes.h"
typedef gboolean (*GDatagramBasedSourceFunc)(GDatagramBased * , GIOCondition  , gpointer  );
#line 436
struct _GInputVector ;
#line 436 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GInputVector GInputVector;
#line 438 "/usr/include/glib-2.0/gio/giotypes.h"
struct _GInputVector {
   gpointer buffer ;
   gsize size ;
};
#line 482
struct _GInputMessage ;
#line 482 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GInputMessage GInputMessage;
#line 484 "/usr/include/glib-2.0/gio/giotypes.h"
struct _GInputMessage {
   GSocketAddress **address ;
   GInputVector *vectors ;
   guint num_vectors ;
   gsize bytes_received ;
   gint flags ;
   GSocketControlMessage ***control_messages ;
   guint *num_control_messages ;
};
#line 509
struct _GOutputVector ;
#line 509 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GOutputVector GOutputVector;
#line 511 "/usr/include/glib-2.0/gio/giotypes.h"
struct _GOutputVector {
   gconstpointer buffer ;
   gsize size ;
};
#line 537
struct _GOutputMessage ;
#line 537 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GOutputMessage GOutputMessage;
#line 539 "/usr/include/glib-2.0/gio/giotypes.h"
struct _GOutputMessage {
   GSocketAddress *address ;
   GOutputVector *vectors ;
   guint num_vectors ;
   guint bytes_sent ;
   GSocketControlMessage **control_messages ;
   guint num_control_messages ;
};
#line 551
struct _GCredentials ;
#line 551 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GCredentials GCredentials;
#line 552
struct _GUnixCredentialsMessage ;
#line 552 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GUnixCredentialsMessage GUnixCredentialsMessage;
#line 553
struct _GUnixFDList ;
#line 553 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GUnixFDList GUnixFDList;
#line 554
struct _GDBusMessage ;
#line 554 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusMessage GDBusMessage;
#line 555
struct _GDBusConnection ;
#line 555 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusConnection GDBusConnection;
#line 556
struct _GDBusProxy ;
#line 556 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusProxy GDBusProxy;
#line 557
struct _GDBusMethodInvocation ;
#line 557 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusMethodInvocation GDBusMethodInvocation;
#line 558
struct _GDBusServer ;
#line 558 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusServer GDBusServer;
#line 559
struct _GDBusAuthObserver ;
#line 559 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusAuthObserver GDBusAuthObserver;
#line 560
struct _GDBusErrorEntry ;
#line 560 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusErrorEntry GDBusErrorEntry;
#line 561
struct _GDBusInterfaceVTable ;
#line 561 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusInterfaceVTable GDBusInterfaceVTable;
#line 562
struct _GDBusSubtreeVTable ;
#line 562 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusSubtreeVTable GDBusSubtreeVTable;
#line 563
struct _GDBusAnnotationInfo ;
#line 563 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusAnnotationInfo GDBusAnnotationInfo;
#line 564
struct _GDBusArgInfo ;
#line 564 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusArgInfo GDBusArgInfo;
#line 565
struct _GDBusMethodInfo ;
#line 565 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusMethodInfo GDBusMethodInfo;
#line 566
struct _GDBusSignalInfo ;
#line 566 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusSignalInfo GDBusSignalInfo;
#line 567
struct _GDBusPropertyInfo ;
#line 567 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusPropertyInfo GDBusPropertyInfo;
#line 568
struct _GDBusInterfaceInfo ;
#line 568 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusInterfaceInfo GDBusInterfaceInfo;
#line 569
struct _GDBusNodeInfo ;
#line 569 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusNodeInfo GDBusNodeInfo;
#line 583 "/usr/include/glib-2.0/gio/giotypes.h"
typedef gboolean (*GCancellableSourceFunc)(GCancellable * , gpointer  );
#line 599 "/usr/include/glib-2.0/gio/giotypes.h"
typedef gboolean (*GPollableSourceFunc)(GObject * , gpointer  );
#line 602
struct _GDBusInterface ;
#line 602 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusInterface GDBusInterface;
#line 603
struct _GDBusInterfaceSkeleton ;
#line 603 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusInterfaceSkeleton GDBusInterfaceSkeleton;
#line 604
struct _GDBusObject ;
#line 604 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusObject GDBusObject;
#line 605
struct _GDBusObjectSkeleton ;
#line 605 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusObjectSkeleton GDBusObjectSkeleton;
#line 606
struct _GDBusObjectProxy ;
#line 606 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusObjectProxy GDBusObjectProxy;
#line 607
struct _GDBusObjectManager ;
#line 607 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusObjectManager GDBusObjectManager;
#line 608
struct _GDBusObjectManagerClient ;
#line 608 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusObjectManagerClient GDBusObjectManagerClient;
#line 609
struct _GDBusObjectManagerServer ;
#line 609 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusObjectManagerServer GDBusObjectManagerServer;
#line 632 "/usr/include/glib-2.0/gio/giotypes.h"
typedef GType (*GDBusProxyTypeFunc)(GDBusObjectManagerClient * , gchar * , gchar * ,
                                    gpointer  );
#line 637
struct _GTestDBus ;
#line 637 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTestDBus GTestDBus;
#line 646
struct _GSubprocess ;
#line 646 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSubprocess GSubprocess;
#line 654
struct _GSubprocessLauncher ;
#line 654 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSubprocessLauncher GSubprocessLauncher;
#line 38 "/usr/include/glib-2.0/gio/gaction.h"
struct _GActionInterface ;
#line 38 "/usr/include/glib-2.0/gio/gaction.h"
typedef struct _GActionInterface GActionInterface;
#line 40 "/usr/include/glib-2.0/gio/gaction.h"
struct _GActionInterface {
   GTypeInterface g_iface ;
   gchar *(*get_name)(GAction * ) ;
   GVariantType *(*get_parameter_type)(GAction * ) ;
   GVariantType *(*get_state_type)(GAction * ) ;
   GVariant *(*get_state_hint)(GAction * ) ;
   gboolean (*get_enabled)(GAction * ) ;
   GVariant *(*get_state)(GAction * ) ;
   void (*change_state)(GAction * , GVariant * ) ;
   void (*activate)(GAction * , GVariant * ) ;
};
#line 40 "/usr/include/glib-2.0/gio/gactiongroup.h"
struct _GActionGroupInterface ;
#line 40 "/usr/include/glib-2.0/gio/gactiongroup.h"
typedef struct _GActionGroupInterface GActionGroupInterface;
#line 42 "/usr/include/glib-2.0/gio/gactiongroup.h"
struct _GActionGroupInterface {
   GTypeInterface g_iface ;
   gboolean (*has_action)(GActionGroup * , gchar * ) ;
   gchar **(*list_actions)(GActionGroup * ) ;
   gboolean (*get_action_enabled)(GActionGroup * , gchar * ) ;
   GVariantType *(*get_action_parameter_type)(GActionGroup * , gchar * ) ;
   GVariantType *(*get_action_state_type)(GActionGroup * , gchar * ) ;
   GVariant *(*get_action_state_hint)(GActionGroup * , gchar * ) ;
   GVariant *(*get_action_state)(GActionGroup * , gchar * ) ;
   void (*change_action_state)(GActionGroup * , gchar * , GVariant * ) ;
   void (*activate_action)(GActionGroup * , gchar * , GVariant * ) ;
   void (*action_added)(GActionGroup * , gchar * ) ;
   void (*action_removed)(GActionGroup * , gchar * ) ;
   void (*action_enabled_changed)(GActionGroup * , gchar * , gboolean  ) ;
   void (*action_state_changed)(GActionGroup * , gchar * , GVariant * ) ;
   gboolean (*query_action)(GActionGroup * , gchar * , gboolean * , GVariantType ** ,
                            GVariantType ** , GVariant ** , GVariant ** ) ;
};
#line 40 "/usr/include/glib-2.0/gio/gactionmap.h"
struct _GActionMapInterface ;
#line 40 "/usr/include/glib-2.0/gio/gactionmap.h"
typedef struct _GActionMapInterface GActionMapInterface;
#line 41
struct _GActionEntry ;
#line 41 "/usr/include/glib-2.0/gio/gactionmap.h"
typedef struct _GActionEntry GActionEntry;
#line 43 "/usr/include/glib-2.0/gio/gactionmap.h"
struct _GActionMapInterface {
   GTypeInterface g_iface ;
   GAction *(*lookup_action)(GActionMap * , gchar * ) ;
   void (*add_action)(GActionMap * , GAction * ) ;
   void (*remove_action)(GActionMap * , gchar * ) ;
};
#line 55 "/usr/include/glib-2.0/gio/gactionmap.h"
struct _GActionEntry {
   gchar *name ;
   void (*activate)(GSimpleAction * , GVariant * , gpointer  ) ;
   gchar *parameter_type ;
   gchar *state ;
   void (*change_state)(GSimpleAction * , GVariant * , gpointer  ) ;
   gsize padding[3] ;
};
#line 44 "/usr/include/glib-2.0/gio/gappinfo.h"
struct _GAppLaunchContextClass ;
#line 44 "/usr/include/glib-2.0/gio/gappinfo.h"
typedef struct _GAppLaunchContextClass GAppLaunchContextClass;
#line 45
struct _GAppLaunchContextPrivate ;
#line 45 "/usr/include/glib-2.0/gio/gappinfo.h"
typedef struct _GAppLaunchContextPrivate GAppLaunchContextPrivate;
#line 86
struct _GAppInfoIface ;
#line 86 "/usr/include/glib-2.0/gio/gappinfo.h"
typedef struct _GAppInfoIface GAppInfoIface;
#line 88 "/usr/include/glib-2.0/gio/gappinfo.h"
struct _GAppInfoIface {
   GTypeInterface g_iface ;
   GAppInfo *(*dup)(GAppInfo * ) ;
   gboolean (*equal)(GAppInfo * , GAppInfo * ) ;
   char const   *(*get_id)(GAppInfo * ) ;
   char const   *(*get_name)(GAppInfo * ) ;
   char const   *(*get_description)(GAppInfo * ) ;
   char const   *(*get_executable)(GAppInfo * ) ;
   GIcon *(*get_icon)(GAppInfo * ) ;
   gboolean (*launch)(GAppInfo * , GList * , GAppLaunchContext * , GError ** ) ;
   gboolean (*supports_uris)(GAppInfo * ) ;
   gboolean (*supports_files)(GAppInfo * ) ;
   gboolean (*launch_uris)(GAppInfo * , GList * , GAppLaunchContext * , GError ** ) ;
   gboolean (*should_show)(GAppInfo * ) ;
   gboolean (*set_as_default_for_type)(GAppInfo * , char const   * , GError ** ) ;
   gboolean (*set_as_default_for_extension)(GAppInfo * , char const   * , GError ** ) ;
   gboolean (*add_supports_type)(GAppInfo * , char const   * , GError ** ) ;
   gboolean (*can_remove_supports_type)(GAppInfo * ) ;
   gboolean (*remove_supports_type)(GAppInfo * , char const   * , GError ** ) ;
   gboolean (*can_delete)(GAppInfo * ) ;
   gboolean (*do_delete)(GAppInfo * ) ;
   char const   *(*get_commandline)(GAppInfo * ) ;
   char const   *(*get_display_name)(GAppInfo * ) ;
   gboolean (*set_as_last_used_for_type)(GAppInfo * , char const   * , GError ** ) ;
   char const   **(*get_supported_types)(GAppInfo * ) ;
   void (*launch_uris_async)(GAppInfo * , GList * , GAppLaunchContext * , GCancellable * ,
                             GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*launch_uris_finish)(GAppInfo * , GAsyncResult * , GError ** ) ;
};
#line 273 "/usr/include/glib-2.0/gio/gappinfo.h"
struct _GAppLaunchContext {
   GObject parent_instance ;
   GAppLaunchContextPrivate *priv ;
};
#line 281 "/usr/include/glib-2.0/gio/gappinfo.h"
struct _GAppLaunchContextClass {
   GObjectClass parent_class ;
   char *(*get_display)(GAppLaunchContext * , GAppInfo * , GList * ) ;
   char *(*get_startup_notify_id)(GAppLaunchContext * , GAppInfo * , GList * ) ;
   void (*launch_failed)(GAppLaunchContext * , char const   * ) ;
   void (*launched)(GAppLaunchContext * , GAppInfo * , GVariant * ) ;
   void (*launch_started)(GAppLaunchContext * , GAppInfo * , GVariant * ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
};
#line 339
struct _GAppInfoMonitor ;
#line 339 "/usr/include/glib-2.0/gio/gappinfo.h"
typedef struct _GAppInfoMonitor GAppInfoMonitor;
#line 41 "/usr/include/glib-2.0/gio/gapplication.h"
struct _GApplicationPrivate ;
#line 41 "/usr/include/glib-2.0/gio/gapplication.h"
typedef struct _GApplicationPrivate GApplicationPrivate;
#line 42
struct _GApplicationClass ;
#line 42 "/usr/include/glib-2.0/gio/gapplication.h"
typedef struct _GApplicationClass GApplicationClass;
#line 44 "/usr/include/glib-2.0/gio/gapplication.h"
struct _GApplication {
   GObject parent_instance ;
   GApplicationPrivate *priv ;
};
#line 52 "/usr/include/glib-2.0/gio/gapplication.h"
struct _GApplicationClass {
   GObjectClass parent_class ;
   void (*startup)(GApplication * ) ;
   void (*activate)(GApplication * ) ;
   void (*open)(GApplication * , GFile ** , gint  , gchar * ) ;
   int (*command_line)(GApplication * , GApplicationCommandLine * ) ;
   gboolean (*local_command_line)(GApplication * , gchar *** , int * ) ;
   void (*before_emit)(GApplication * , GVariant * ) ;
   void (*after_emit)(GApplication * , GVariant * ) ;
   void (*add_platform_data)(GApplication * , GVariantBuilder * ) ;
   void (*quit_mainloop)(GApplication * ) ;
   void (*run_mainloop)(GApplication * ) ;
   void (*shutdown)(GApplication * ) ;
   gboolean (*dbus_register)(GApplication * , GDBusConnection * , gchar * , GError ** ) ;
   void (*dbus_unregister)(GApplication * , GDBusConnection * , gchar * ) ;
   gint (*handle_local_options)(GApplication * , GVariantDict * ) ;
   gboolean (*name_lost)(GApplication * ) ;
   gpointer padding[7] ;
};
#line 47 "/usr/include/glib-2.0/gio/gapplicationcommandline.h"
struct _GApplicationCommandLinePrivate ;
#line 47 "/usr/include/glib-2.0/gio/gapplicationcommandline.h"
typedef struct _GApplicationCommandLinePrivate GApplicationCommandLinePrivate;
#line 48
struct _GApplicationCommandLineClass ;
#line 48 "/usr/include/glib-2.0/gio/gapplicationcommandline.h"
typedef struct _GApplicationCommandLineClass GApplicationCommandLineClass;
#line 50 "/usr/include/glib-2.0/gio/gapplicationcommandline.h"
struct _GApplicationCommandLine {
   GObject parent_instance ;
   GApplicationCommandLinePrivate *priv ;
};
#line 58 "/usr/include/glib-2.0/gio/gapplicationcommandline.h"
struct _GApplicationCommandLineClass {
   GObjectClass parent_class ;
   void (*print_literal)(GApplicationCommandLine * , gchar * ) ;
   void (*printerr_literal)(GApplicationCommandLine * , gchar * ) ;
   GInputStream *(*get_stdin)(GApplicationCommandLine * ) ;
   gpointer padding[11] ;
};
#line 45 "/usr/include/glib-2.0/gio/ginitable.h"
struct _GInitableIface ;
#line 45 "/usr/include/glib-2.0/gio/ginitable.h"
typedef struct _GInitableIface GInitableIface;
#line 57 "/usr/include/glib-2.0/gio/ginitable.h"
struct _GInitableIface {
   GTypeInterface g_iface ;
   gboolean (*init)(GInitable * , GCancellable * , GError ** ) ;
};
#line 46 "/usr/include/glib-2.0/gio/gasyncinitable.h"
struct _GAsyncInitableIface ;
#line 46 "/usr/include/glib-2.0/gio/gasyncinitable.h"
typedef struct _GAsyncInitableIface GAsyncInitableIface;
#line 59 "/usr/include/glib-2.0/gio/gasyncinitable.h"
struct _GAsyncInitableIface {
   GTypeInterface g_iface ;
   void (*init_async)(GAsyncInitable * , int  , GCancellable * , GAsyncReadyCallback  ,
                      gpointer  ) ;
   gboolean (*init_finish)(GAsyncInitable * , GAsyncResult * , GError ** ) ;
};
#line 43 "/usr/include/glib-2.0/gio/gasyncresult.h"
struct _GAsyncResultIface ;
#line 43 "/usr/include/glib-2.0/gio/gasyncresult.h"
typedef struct _GAsyncResultIface GAsyncResultIface;
#line 55 "/usr/include/glib-2.0/gio/gasyncresult.h"
struct _GAsyncResultIface {
   GTypeInterface g_iface ;
   gpointer (*get_user_data)(GAsyncResult * ) ;
   GObject *(*get_source_object)(GAsyncResult * ) ;
   gboolean (*is_tagged)(GAsyncResult * , gpointer  ) ;
};
#line 44 "/usr/include/glib-2.0/gio/ginputstream.h"
struct _GInputStreamClass ;
#line 44 "/usr/include/glib-2.0/gio/ginputstream.h"
typedef struct _GInputStreamClass GInputStreamClass;
#line 45
struct _GInputStreamPrivate ;
#line 45 "/usr/include/glib-2.0/gio/ginputstream.h"
typedef struct _GInputStreamPrivate GInputStreamPrivate;
#line 47 "/usr/include/glib-2.0/gio/ginputstream.h"
struct _GInputStream {
   GObject parent_instance ;
   GInputStreamPrivate *priv ;
};
#line 55 "/usr/include/glib-2.0/gio/ginputstream.h"
struct _GInputStreamClass {
   GObjectClass parent_class ;
   gssize (*read_fn)(GInputStream * , void * , gsize  , GCancellable * , GError ** ) ;
   gssize (*skip)(GInputStream * , gsize  , GCancellable * , GError ** ) ;
   gboolean (*close_fn)(GInputStream * , GCancellable * , GError ** ) ;
   void (*read_async)(GInputStream * , void * , gsize  , int  , GCancellable * , GAsyncReadyCallback  ,
                      gpointer  ) ;
   gssize (*read_finish)(GInputStream * , GAsyncResult * , GError ** ) ;
   void (*skip_async)(GInputStream * , gsize  , int  , GCancellable * , GAsyncReadyCallback  ,
                      gpointer  ) ;
   gssize (*skip_finish)(GInputStream * , GAsyncResult * , GError ** ) ;
   void (*close_async)(GInputStream * , int  , GCancellable * , GAsyncReadyCallback  ,
                       gpointer  ) ;
   gboolean (*close_finish)(GInputStream * , GAsyncResult * , GError ** ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 44 "/usr/include/glib-2.0/gio/gfilterinputstream.h"
struct _GFilterInputStreamClass ;
#line 44 "/usr/include/glib-2.0/gio/gfilterinputstream.h"
typedef struct _GFilterInputStreamClass GFilterInputStreamClass;
#line 46 "/usr/include/glib-2.0/gio/gfilterinputstream.h"
struct _GFilterInputStream {
   GInputStream parent_instance ;
   GInputStream *base_stream ;
};
#line 54 "/usr/include/glib-2.0/gio/gfilterinputstream.h"
struct _GFilterInputStreamClass {
   GInputStreamClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
};
#line 44 "/usr/include/glib-2.0/gio/gbufferedinputstream.h"
struct _GBufferedInputStreamClass ;
#line 44 "/usr/include/glib-2.0/gio/gbufferedinputstream.h"
typedef struct _GBufferedInputStreamClass GBufferedInputStreamClass;
#line 45
struct _GBufferedInputStreamPrivate ;
#line 45 "/usr/include/glib-2.0/gio/gbufferedinputstream.h"
typedef struct _GBufferedInputStreamPrivate GBufferedInputStreamPrivate;
#line 47 "/usr/include/glib-2.0/gio/gbufferedinputstream.h"
struct _GBufferedInputStream {
   GFilterInputStream parent_instance ;
   GBufferedInputStreamPrivate *priv ;
};
#line 55 "/usr/include/glib-2.0/gio/gbufferedinputstream.h"
struct _GBufferedInputStreamClass {
   GFilterInputStreamClass parent_class ;
   gssize (*fill)(GBufferedInputStream * , gssize  , GCancellable * , GError ** ) ;
   void (*fill_async)(GBufferedInputStream * , gssize  , int  , GCancellable * , GAsyncReadyCallback  ,
                      gpointer  ) ;
   gssize (*fill_finish)(GBufferedInputStream * , GAsyncResult * , GError ** ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 48 "/usr/include/glib-2.0/gio/goutputstream.h"
struct _GOutputStreamClass ;
#line 48 "/usr/include/glib-2.0/gio/goutputstream.h"
typedef struct _GOutputStreamClass GOutputStreamClass;
#line 49
struct _GOutputStreamPrivate ;
#line 49 "/usr/include/glib-2.0/gio/goutputstream.h"
typedef struct _GOutputStreamPrivate GOutputStreamPrivate;
#line 51 "/usr/include/glib-2.0/gio/goutputstream.h"
struct _GOutputStream {
   GObject parent_instance ;
   GOutputStreamPrivate *priv ;
};
#line 60 "/usr/include/glib-2.0/gio/goutputstream.h"
struct _GOutputStreamClass {
   GObjectClass parent_class ;
   gssize (*write_fn)(GOutputStream * , void const   * , gsize  , GCancellable * ,
                      GError ** ) ;
   gssize (*splice)(GOutputStream * , GInputStream * , GOutputStreamSpliceFlags  ,
                    GCancellable * , GError ** ) ;
   gboolean (*flush)(GOutputStream * , GCancellable * , GError ** ) ;
   gboolean (*close_fn)(GOutputStream * , GCancellable * , GError ** ) ;
   void (*write_async)(GOutputStream * , void const   * , gsize  , int  , GCancellable * ,
                       GAsyncReadyCallback  , gpointer  ) ;
   gssize (*write_finish)(GOutputStream * , GAsyncResult * , GError ** ) ;
   void (*splice_async)(GOutputStream * , GInputStream * , GOutputStreamSpliceFlags  ,
                        int  , GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gssize (*splice_finish)(GOutputStream * , GAsyncResult * , GError ** ) ;
   void (*flush_async)(GOutputStream * , int  , GCancellable * , GAsyncReadyCallback  ,
                       gpointer  ) ;
   gboolean (*flush_finish)(GOutputStream * , GAsyncResult * , GError ** ) ;
   void (*close_async)(GOutputStream * , int  , GCancellable * , GAsyncReadyCallback  ,
                       gpointer  ) ;
   gboolean (*close_finish)(GOutputStream * , GAsyncResult * , GError ** ) ;
   gboolean (*writev_fn)(GOutputStream * , GOutputVector * , gsize  , gsize * , GCancellable * ,
                         GError ** ) ;
   void (*writev_async)(GOutputStream * , GOutputVector * , gsize  , int  , GCancellable * ,
                        GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*writev_finish)(GOutputStream * , GAsyncResult * , gsize * , GError ** ) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
   void (*_g_reserved6)(void) ;
   void (*_g_reserved7)(void) ;
   void (*_g_reserved8)(void) ;
};
#line 44 "/usr/include/glib-2.0/gio/gfilteroutputstream.h"
struct _GFilterOutputStreamClass ;
#line 44 "/usr/include/glib-2.0/gio/gfilteroutputstream.h"
typedef struct _GFilterOutputStreamClass GFilterOutputStreamClass;
#line 46 "/usr/include/glib-2.0/gio/gfilteroutputstream.h"
struct _GFilterOutputStream {
   GOutputStream parent_instance ;
   GOutputStream *base_stream ;
};
#line 54 "/usr/include/glib-2.0/gio/gfilteroutputstream.h"
struct _GFilterOutputStreamClass {
   GOutputStreamClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
};
#line 44 "/usr/include/glib-2.0/gio/gbufferedoutputstream.h"
struct _GBufferedOutputStreamClass ;
#line 44 "/usr/include/glib-2.0/gio/gbufferedoutputstream.h"
typedef struct _GBufferedOutputStreamClass GBufferedOutputStreamClass;
#line 45
struct _GBufferedOutputStreamPrivate ;
#line 45 "/usr/include/glib-2.0/gio/gbufferedoutputstream.h"
typedef struct _GBufferedOutputStreamPrivate GBufferedOutputStreamPrivate;
#line 47 "/usr/include/glib-2.0/gio/gbufferedoutputstream.h"
struct _GBufferedOutputStream {
   GFilterOutputStream parent_instance ;
   GBufferedOutputStreamPrivate *priv ;
};
#line 55 "/usr/include/glib-2.0/gio/gbufferedoutputstream.h"
struct _GBufferedOutputStreamClass {
   GFilterOutputStreamClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
};
#line 44 "/usr/include/glib-2.0/gio/gcancellable.h"
struct _GCancellableClass ;
#line 44 "/usr/include/glib-2.0/gio/gcancellable.h"
typedef struct _GCancellableClass GCancellableClass;
#line 45
struct _GCancellablePrivate ;
#line 45 "/usr/include/glib-2.0/gio/gcancellable.h"
typedef struct _GCancellablePrivate GCancellablePrivate;
#line 47 "/usr/include/glib-2.0/gio/gcancellable.h"
struct _GCancellable {
   GObject parent_instance ;
   GCancellablePrivate *priv ;
};
#line 55 "/usr/include/glib-2.0/gio/gcancellable.h"
struct _GCancellableClass {
   GObjectClass parent_class ;
   void (*cancelled)(GCancellable * ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 44 "/usr/include/glib-2.0/gio/gconverter.h"
struct _GConverterIface ;
#line 44 "/usr/include/glib-2.0/gio/gconverter.h"
typedef struct _GConverterIface GConverterIface;
#line 58 "/usr/include/glib-2.0/gio/gconverter.h"
struct _GConverterIface {
   GTypeInterface g_iface ;
   GConverterResult (*convert)(GConverter * , void const   * , gsize  , void * , gsize  ,
                               GConverterFlags  , gsize * , gsize * , GError ** ) ;
   void (*reset)(GConverter * ) ;
};
#line 39 "/usr/include/glib-2.0/gio/gcharsetconverter.h"
struct _GCharsetConverterClass ;
#line 39 "/usr/include/glib-2.0/gio/gcharsetconverter.h"
typedef struct _GCharsetConverterClass GCharsetConverterClass;
#line 41 "/usr/include/glib-2.0/gio/gcharsetconverter.h"
struct _GCharsetConverterClass {
   GObjectClass parent_class ;
};
#line 46 "/usr/include/glib-2.0/gio/gconverterinputstream.h"
struct _GConverterInputStreamClass ;
#line 46 "/usr/include/glib-2.0/gio/gconverterinputstream.h"
typedef struct _GConverterInputStreamClass GConverterInputStreamClass;
#line 47
struct _GConverterInputStreamPrivate ;
#line 47 "/usr/include/glib-2.0/gio/gconverterinputstream.h"
typedef struct _GConverterInputStreamPrivate GConverterInputStreamPrivate;
#line 49 "/usr/include/glib-2.0/gio/gconverterinputstream.h"
struct _GConverterInputStream {
   GFilterInputStream parent_instance ;
   GConverterInputStreamPrivate *priv ;
};
#line 57 "/usr/include/glib-2.0/gio/gconverterinputstream.h"
struct _GConverterInputStreamClass {
   GFilterInputStreamClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 46 "/usr/include/glib-2.0/gio/gconverteroutputstream.h"
struct _GConverterOutputStreamClass ;
#line 46 "/usr/include/glib-2.0/gio/gconverteroutputstream.h"
typedef struct _GConverterOutputStreamClass GConverterOutputStreamClass;
#line 47
struct _GConverterOutputStreamPrivate ;
#line 47 "/usr/include/glib-2.0/gio/gconverteroutputstream.h"
typedef struct _GConverterOutputStreamPrivate GConverterOutputStreamPrivate;
#line 49 "/usr/include/glib-2.0/gio/gconverteroutputstream.h"
struct _GConverterOutputStream {
   GFilterOutputStream parent_instance ;
   GConverterOutputStreamPrivate *priv ;
};
#line 57 "/usr/include/glib-2.0/gio/gconverteroutputstream.h"
struct _GConverterOutputStreamClass {
   GFilterOutputStreamClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 45 "/usr/include/glib-2.0/gio/gcredentials.h"
struct _GCredentialsClass ;
#line 45 "/usr/include/glib-2.0/gio/gcredentials.h"
typedef struct _GCredentialsClass GCredentialsClass;
#line 49 "/usr/include/glib-2.0/gio/gdatagrambased.h"
struct _GDatagramBasedInterface ;
#line 49 "/usr/include/glib-2.0/gio/gdatagrambased.h"
typedef struct _GDatagramBasedInterface GDatagramBasedInterface;
#line 69 "/usr/include/glib-2.0/gio/gdatagrambased.h"
struct _GDatagramBasedInterface {
   GTypeInterface g_iface ;
   gint (*receive_messages)(GDatagramBased * , GInputMessage * , guint  , gint  ,
                            gint64  , GCancellable * , GError ** ) ;
   gint (*send_messages)(GDatagramBased * , GOutputMessage * , guint  , gint  , gint64  ,
                         GCancellable * , GError ** ) ;
   GSource *(*create_source)(GDatagramBased * , GIOCondition  , GCancellable * ) ;
   GIOCondition (*condition_check)(GDatagramBased * , GIOCondition  ) ;
   gboolean (*condition_wait)(GDatagramBased * , GIOCondition  , gint64  , GCancellable * ,
                              GError ** ) ;
};
#line 45 "/usr/include/glib-2.0/gio/gdatainputstream.h"
struct _GDataInputStreamClass ;
#line 45 "/usr/include/glib-2.0/gio/gdatainputstream.h"
typedef struct _GDataInputStreamClass GDataInputStreamClass;
#line 46
struct _GDataInputStreamPrivate ;
#line 46 "/usr/include/glib-2.0/gio/gdatainputstream.h"
typedef struct _GDataInputStreamPrivate GDataInputStreamPrivate;
#line 48 "/usr/include/glib-2.0/gio/gdatainputstream.h"
struct _GDataInputStream {
   GBufferedInputStream parent_instance ;
   GDataInputStreamPrivate *priv ;
};
#line 56 "/usr/include/glib-2.0/gio/gdatainputstream.h"
struct _GDataInputStreamClass {
   GBufferedInputStreamClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 45 "/usr/include/glib-2.0/gio/gdataoutputstream.h"
struct _GDataOutputStream ;
#line 45 "/usr/include/glib-2.0/gio/gdataoutputstream.h"
typedef struct _GDataOutputStream GDataOutputStream;
#line 46
struct _GDataOutputStreamClass ;
#line 46 "/usr/include/glib-2.0/gio/gdataoutputstream.h"
typedef struct _GDataOutputStreamClass GDataOutputStreamClass;
#line 47
struct _GDataOutputStreamPrivate ;
#line 47 "/usr/include/glib-2.0/gio/gdataoutputstream.h"
typedef struct _GDataOutputStreamPrivate GDataOutputStreamPrivate;
#line 49 "/usr/include/glib-2.0/gio/gdataoutputstream.h"
struct _GDataOutputStream {
   GFilterOutputStream parent_instance ;
   GDataOutputStreamPrivate *priv ;
};
#line 57 "/usr/include/glib-2.0/gio/gdataoutputstream.h"
struct _GDataOutputStreamClass {
   GFilterOutputStreamClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 273 "/usr/include/glib-2.0/gio/gdbusconnection.h"
typedef void (*GDBusInterfaceMethodCallFunc)(GDBusConnection * , gchar * , gchar * ,
                                             gchar * , gchar * , GVariant * , GDBusMethodInvocation * ,
                                             gpointer  );
#line 300 "/usr/include/glib-2.0/gio/gdbusconnection.h"
typedef GVariant *(*GDBusInterfaceGetPropertyFunc)(GDBusConnection * , gchar * , gchar * ,
                                                   gchar * , gchar * , GError ** ,
                                                   gpointer  );
#line 325 "/usr/include/glib-2.0/gio/gdbusconnection.h"
typedef gboolean (*GDBusInterfaceSetPropertyFunc)(GDBusConnection * , gchar * , gchar * ,
                                                  gchar * , gchar * , GVariant * ,
                                                  GError ** , gpointer  );
#line 384 "/usr/include/glib-2.0/gio/gdbusconnection.h"
struct _GDBusInterfaceVTable {
   GDBusInterfaceMethodCallFunc method_call ;
   GDBusInterfaceGetPropertyFunc get_property ;
   GDBusInterfaceSetPropertyFunc set_property ;
   gpointer padding[8] ;
};
#line 443 "/usr/include/glib-2.0/gio/gdbusconnection.h"
typedef gchar **(*GDBusSubtreeEnumerateFunc)(GDBusConnection * , gchar * , gchar * ,
                                             gpointer  );
#line 479 "/usr/include/glib-2.0/gio/gdbusconnection.h"
typedef GDBusInterfaceInfo **(*GDBusSubtreeIntrospectFunc)(GDBusConnection * , gchar * ,
                                                           gchar * , gchar * , gpointer  );
#line 504 "/usr/include/glib-2.0/gio/gdbusconnection.h"
typedef GDBusInterfaceVTable *(*GDBusSubtreeDispatchFunc)(GDBusConnection * , gchar * ,
                                                          gchar * , gchar * , gchar * ,
                                                          gpointer * , gpointer  );
#line 522 "/usr/include/glib-2.0/gio/gdbusconnection.h"
struct _GDBusSubtreeVTable {
   GDBusSubtreeEnumerateFunc enumerate ;
   GDBusSubtreeIntrospectFunc introspect ;
   GDBusSubtreeDispatchFunc dispatch ;
   gpointer padding[8] ;
};
#line 565 "/usr/include/glib-2.0/gio/gdbusconnection.h"
typedef void (*GDBusSignalCallback)(GDBusConnection * , gchar * , gchar * , gchar * ,
                                    gchar * , GVariant * , gpointer  );
#line 664 "/usr/include/glib-2.0/gio/gdbusconnection.h"
typedef GDBusMessage *(*GDBusMessageFilterFunction)(GDBusConnection * , GDBusMessage * ,
                                                    gboolean  , gpointer  );
#line 68 "/usr/include/glib-2.0/gio/gdbuserror.h"
struct _GDBusErrorEntry {
   gint error_code ;
   gchar *dbus_error_name ;
};
#line 41 "/usr/include/glib-2.0/gio/gdbusinterface.h"
struct _GDBusInterfaceIface ;
#line 41 "/usr/include/glib-2.0/gio/gdbusinterface.h"
typedef struct _GDBusInterfaceIface GDBusInterfaceIface;
#line 55 "/usr/include/glib-2.0/gio/gdbusinterface.h"
struct _GDBusInterfaceIface {
   GTypeInterface parent_iface ;
   GDBusInterfaceInfo *(*get_info)(GDBusInterface * ) ;
   GDBusObject *(*get_object)(GDBusInterface * ) ;
   void (*set_object)(GDBusInterface * , GDBusObject * ) ;
   GDBusObject *(*dup_object)(GDBusInterface * ) ;
};
#line 35 "/usr/include/glib-2.0/gio/gdbusinterfaceskeleton.h"
struct _GDBusInterfaceSkeletonClass ;
#line 35 "/usr/include/glib-2.0/gio/gdbusinterfaceskeleton.h"
typedef struct _GDBusInterfaceSkeletonClass GDBusInterfaceSkeletonClass;
#line 36
struct _GDBusInterfaceSkeletonPrivate ;
#line 36 "/usr/include/glib-2.0/gio/gdbusinterfaceskeleton.h"
typedef struct _GDBusInterfaceSkeletonPrivate GDBusInterfaceSkeletonPrivate;
#line 46 "/usr/include/glib-2.0/gio/gdbusinterfaceskeleton.h"
struct _GDBusInterfaceSkeleton {
   GObject parent_instance ;
   GDBusInterfaceSkeletonPrivate *priv ;
};
#line 66 "/usr/include/glib-2.0/gio/gdbusinterfaceskeleton.h"
struct _GDBusInterfaceSkeletonClass {
   GObjectClass parent_class ;
   GDBusInterfaceInfo *(*get_info)(GDBusInterfaceSkeleton * ) ;
   GDBusInterfaceVTable *(*get_vtable)(GDBusInterfaceSkeleton * ) ;
   GVariant *(*get_properties)(GDBusInterfaceSkeleton * ) ;
   void (*flush)(GDBusInterfaceSkeleton * ) ;
   gpointer vfunc_padding[8] ;
   gboolean (*g_authorize_method)(GDBusInterfaceSkeleton * , GDBusMethodInvocation * ) ;
   gpointer signal_padding[8] ;
};
#line 43 "/usr/include/glib-2.0/gio/gdbusintrospection.h"
struct _GDBusAnnotationInfo {
   gint ref_count ;
   gchar *key ;
   gchar *value ;
   GDBusAnnotationInfo **annotations ;
};
#line 63 "/usr/include/glib-2.0/gio/gdbusintrospection.h"
struct _GDBusArgInfo {
   gint ref_count ;
   gchar *name ;
   gchar *signature ;
   GDBusAnnotationInfo **annotations ;
};
#line 84 "/usr/include/glib-2.0/gio/gdbusintrospection.h"
struct _GDBusMethodInfo {
   gint ref_count ;
   gchar *name ;
   GDBusArgInfo **in_args ;
   GDBusArgInfo **out_args ;
   GDBusAnnotationInfo **annotations ;
};
#line 105 "/usr/include/glib-2.0/gio/gdbusintrospection.h"
struct _GDBusSignalInfo {
   gint ref_count ;
   gchar *name ;
   GDBusArgInfo **args ;
   GDBusAnnotationInfo **annotations ;
};
#line 126 "/usr/include/glib-2.0/gio/gdbusintrospection.h"
struct _GDBusPropertyInfo {
   gint ref_count ;
   gchar *name ;
   gchar *signature ;
   GDBusPropertyInfoFlags flags ;
   GDBusAnnotationInfo **annotations ;
};
#line 149 "/usr/include/glib-2.0/gio/gdbusintrospection.h"
struct _GDBusInterfaceInfo {
   gint ref_count ;
   gchar *name ;
   GDBusMethodInfo **methods ;
   GDBusSignalInfo **signals ;
   GDBusPropertyInfo **properties ;
   GDBusAnnotationInfo **annotations ;
};
#line 172 "/usr/include/glib-2.0/gio/gdbusintrospection.h"
struct _GDBusNodeInfo {
   gint ref_count ;
   gchar *path ;
   GDBusInterfaceInfo **interfaces ;
   GDBusNodeInfo **nodes ;
   GDBusAnnotationInfo **annotations ;
};
#line 33 "/usr/include/glib-2.0/gio/gdbusmenumodel.h"
struct _GDBusMenuModel ;
#line 33 "/usr/include/glib-2.0/gio/gdbusmenumodel.h"
typedef struct _GDBusMenuModel GDBusMenuModel;
#line 42 "/usr/include/glib-2.0/gio/gdbusnameowning.h"
typedef void (*GBusAcquiredCallback)(GDBusConnection * , gchar * , gpointer  );
#line 56 "/usr/include/glib-2.0/gio/gdbusnameowning.h"
typedef void (*GBusNameAcquiredCallback)(GDBusConnection * , gchar * , gpointer  );
#line 71 "/usr/include/glib-2.0/gio/gdbusnameowning.h"
typedef void (*GBusNameLostCallback)(GDBusConnection * , gchar * , gpointer  );
#line 43 "/usr/include/glib-2.0/gio/gdbusnamewatching.h"
typedef void (*GBusNameAppearedCallback)(GDBusConnection * , gchar * , gchar * , gpointer  );
#line 63 "/usr/include/glib-2.0/gio/gdbusnamewatching.h"
typedef void (*GBusNameVanishedCallback)(GDBusConnection * , gchar * , gpointer  );
#line 33 "/usr/include/glib-2.0/gio/gdbusobject.h"
struct _GDBusObjectIface ;
#line 33 "/usr/include/glib-2.0/gio/gdbusobject.h"
typedef struct _GDBusObjectIface GDBusObjectIface;
#line 48 "/usr/include/glib-2.0/gio/gdbusobject.h"
struct _GDBusObjectIface {
   GTypeInterface parent_iface ;
   gchar *(*get_object_path)(GDBusObject * ) ;
   GList *(*get_interfaces)(GDBusObject * ) ;
   GDBusInterface *(*get_interface)(GDBusObject * , gchar * ) ;
   void (*interface_added)(GDBusObject * , GDBusInterface * ) ;
   void (*interface_removed)(GDBusObject * , GDBusInterface * ) ;
};
#line 33 "/usr/include/glib-2.0/gio/gdbusobjectmanager.h"
struct _GDBusObjectManagerIface ;
#line 33 "/usr/include/glib-2.0/gio/gdbusobjectmanager.h"
typedef struct _GDBusObjectManagerIface GDBusObjectManagerIface;
#line 51 "/usr/include/glib-2.0/gio/gdbusobjectmanager.h"
struct _GDBusObjectManagerIface {
   GTypeInterface parent_iface ;
   gchar *(*get_object_path)(GDBusObjectManager * ) ;
   GList *(*get_objects)(GDBusObjectManager * ) ;
   GDBusObject *(*get_object)(GDBusObjectManager * , gchar * ) ;
   GDBusInterface *(*get_interface)(GDBusObjectManager * , gchar * , gchar * ) ;
   void (*object_added)(GDBusObjectManager * , GDBusObject * ) ;
   void (*object_removed)(GDBusObjectManager * , GDBusObject * ) ;
   void (*interface_added)(GDBusObjectManager * , GDBusObject * , GDBusInterface * ) ;
   void (*interface_removed)(GDBusObjectManager * , GDBusObject * , GDBusInterface * ) ;
};
#line 35 "/usr/include/glib-2.0/gio/gdbusobjectmanagerclient.h"
struct _GDBusObjectManagerClientClass ;
#line 35 "/usr/include/glib-2.0/gio/gdbusobjectmanagerclient.h"
typedef struct _GDBusObjectManagerClientClass GDBusObjectManagerClientClass;
#line 36
struct _GDBusObjectManagerClientPrivate ;
#line 36 "/usr/include/glib-2.0/gio/gdbusobjectmanagerclient.h"
typedef struct _GDBusObjectManagerClientPrivate GDBusObjectManagerClientPrivate;
#line 46 "/usr/include/glib-2.0/gio/gdbusobjectmanagerclient.h"
struct _GDBusObjectManagerClient {
   GObject parent_instance ;
   GDBusObjectManagerClientPrivate *priv ;
};
#line 63 "/usr/include/glib-2.0/gio/gdbusobjectmanagerclient.h"
struct _GDBusObjectManagerClientClass {
   GObjectClass parent_class ;
   void (*interface_proxy_signal)(GDBusObjectManagerClient * , GDBusObjectProxy * ,
                                  GDBusProxy * , gchar * , gchar * , GVariant * ) ;
   void (*interface_proxy_properties_changed)(GDBusObjectManagerClient * , GDBusObjectProxy * ,
                                              GDBusProxy * , GVariant * , gchar * const  * ) ;
   gpointer padding[8] ;
};
#line 35 "/usr/include/glib-2.0/gio/gdbusobjectmanagerserver.h"
struct _GDBusObjectManagerServerClass ;
#line 35 "/usr/include/glib-2.0/gio/gdbusobjectmanagerserver.h"
typedef struct _GDBusObjectManagerServerClass GDBusObjectManagerServerClass;
#line 36
struct _GDBusObjectManagerServerPrivate ;
#line 36 "/usr/include/glib-2.0/gio/gdbusobjectmanagerserver.h"
typedef struct _GDBusObjectManagerServerPrivate GDBusObjectManagerServerPrivate;
#line 46 "/usr/include/glib-2.0/gio/gdbusobjectmanagerserver.h"
struct _GDBusObjectManagerServer {
   GObject parent_instance ;
   GDBusObjectManagerServerPrivate *priv ;
};
#line 61 "/usr/include/glib-2.0/gio/gdbusobjectmanagerserver.h"
struct _GDBusObjectManagerServerClass {
   GObjectClass parent_class ;
   gpointer padding[8] ;
};
#line 35 "/usr/include/glib-2.0/gio/gdbusobjectproxy.h"
struct _GDBusObjectProxyClass ;
#line 35 "/usr/include/glib-2.0/gio/gdbusobjectproxy.h"
typedef struct _GDBusObjectProxyClass GDBusObjectProxyClass;
#line 36
struct _GDBusObjectProxyPrivate ;
#line 36 "/usr/include/glib-2.0/gio/gdbusobjectproxy.h"
typedef struct _GDBusObjectProxyPrivate GDBusObjectProxyPrivate;
#line 46 "/usr/include/glib-2.0/gio/gdbusobjectproxy.h"
struct _GDBusObjectProxy {
   GObject parent_instance ;
   GDBusObjectProxyPrivate *priv ;
};
#line 61 "/usr/include/glib-2.0/gio/gdbusobjectproxy.h"
struct _GDBusObjectProxyClass {
   GObjectClass parent_class ;
   gpointer padding[8] ;
};
#line 35 "/usr/include/glib-2.0/gio/gdbusobjectskeleton.h"
struct _GDBusObjectSkeletonClass ;
#line 35 "/usr/include/glib-2.0/gio/gdbusobjectskeleton.h"
typedef struct _GDBusObjectSkeletonClass GDBusObjectSkeletonClass;
#line 36
struct _GDBusObjectSkeletonPrivate ;
#line 36 "/usr/include/glib-2.0/gio/gdbusobjectskeleton.h"
typedef struct _GDBusObjectSkeletonPrivate GDBusObjectSkeletonPrivate;
#line 46 "/usr/include/glib-2.0/gio/gdbusobjectskeleton.h"
struct _GDBusObjectSkeleton {
   GObject parent_instance ;
   GDBusObjectSkeletonPrivate *priv ;
};
#line 62 "/usr/include/glib-2.0/gio/gdbusobjectskeleton.h"
struct _GDBusObjectSkeletonClass {
   GObjectClass parent_class ;
   gboolean (*authorize_method)(GDBusObjectSkeleton * , GDBusInterfaceSkeleton * ,
                                GDBusMethodInvocation * ) ;
   gpointer padding[8] ;
};
#line 40 "/usr/include/glib-2.0/gio/gdbusproxy.h"
struct _GDBusProxyClass ;
#line 40 "/usr/include/glib-2.0/gio/gdbusproxy.h"
typedef struct _GDBusProxyClass GDBusProxyClass;
#line 41
struct _GDBusProxyPrivate ;
#line 41 "/usr/include/glib-2.0/gio/gdbusproxy.h"
typedef struct _GDBusProxyPrivate GDBusProxyPrivate;
#line 51 "/usr/include/glib-2.0/gio/gdbusproxy.h"
struct _GDBusProxy {
   GObject parent_instance ;
   GDBusProxyPrivate *priv ;
};
#line 67 "/usr/include/glib-2.0/gio/gdbusproxy.h"
struct _GDBusProxyClass {
   GObjectClass parent_class ;
   void (*g_properties_changed)(GDBusProxy * , GVariant * , gchar * const  * ) ;
   void (*g_signal)(GDBusProxy * , gchar * , gchar * , GVariant * ) ;
   gpointer padding[32] ;
};
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
struct _GDebugController ;
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
typedef struct _GDebugController GDebugController;
#line 52
struct _GDebugControllerInterface ;
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
typedef struct _GDebugControllerInterface GDebugControllerInterface;
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
typedef GDebugController *GDebugController_autoptr;
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
typedef GList *GDebugController_listautoptr;
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
typedef GSList *GDebugController_slistautoptr;
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
typedef GQueue *GDebugController_queueautoptr;
#line 66 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
struct _GDebugControllerInterface {
   GTypeInterface g_iface ;
};
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
struct _GDebugControllerDBus ;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
typedef struct _GDebugControllerDBus GDebugControllerDBus;
#line 38
struct _GDebugControllerDBusClass ;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
typedef struct _GDebugControllerDBusClass GDebugControllerDBusClass;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
struct _GDebugControllerDBus {
   GObject parent_instance ;
};
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
typedef GDebugControllerDBus *GDebugControllerDBus_autoptr;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
typedef GList *GDebugControllerDBus_listautoptr;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
typedef GSList *GDebugControllerDBus_slistautoptr;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
typedef GQueue *GDebugControllerDBus_queueautoptr;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
typedef GDebugControllerDBusClass *GDebugControllerDBusClass_autoptr;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
typedef GList *GDebugControllerDBusClass_listautoptr;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
typedef GSList *GDebugControllerDBusClass_slistautoptr;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
typedef GQueue *GDebugControllerDBusClass_queueautoptr;
#line 49 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
struct _GDebugControllerDBusClass {
   GObjectClass parent_class ;
   gboolean (*authorize)(GDebugControllerDBus * , GDBusMethodInvocation * ) ;
   gpointer padding[12] ;
};
#line 87 "/usr/include/glib-2.0/gio/gdrive.h"
struct _GDriveIface ;
#line 87 "/usr/include/glib-2.0/gio/gdrive.h"
typedef struct _GDriveIface GDriveIface;
#line 89 "/usr/include/glib-2.0/gio/gdrive.h"
struct _GDriveIface {
   GTypeInterface g_iface ;
   void (*changed)(GDrive * ) ;
   void (*disconnected)(GDrive * ) ;
   void (*eject_button)(GDrive * ) ;
   char *(*get_name)(GDrive * ) ;
   GIcon *(*get_icon)(GDrive * ) ;
   gboolean (*has_volumes)(GDrive * ) ;
   GList *(*get_volumes)(GDrive * ) ;
   gboolean (*is_media_removable)(GDrive * ) ;
   gboolean (*has_media)(GDrive * ) ;
   gboolean (*is_media_check_automatic)(GDrive * ) ;
   gboolean (*can_eject)(GDrive * ) ;
   gboolean (*can_poll_for_media)(GDrive * ) ;
   void (*eject)(GDrive * , GMountUnmountFlags  , GCancellable * , GAsyncReadyCallback  ,
                 gpointer  ) ;
   gboolean (*eject_finish)(GDrive * , GAsyncResult * , GError ** ) ;
   void (*poll_for_media)(GDrive * , GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*poll_for_media_finish)(GDrive * , GAsyncResult * , GError ** ) ;
   char *(*get_identifier)(GDrive * , char const   * ) ;
   char **(*enumerate_identifiers)(GDrive * ) ;
   GDriveStartStopType (*get_start_stop_type)(GDrive * ) ;
   gboolean (*can_start)(GDrive * ) ;
   gboolean (*can_start_degraded)(GDrive * ) ;
   void (*start)(GDrive * , GDriveStartFlags  , GMountOperation * , GCancellable * ,
                 GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*start_finish)(GDrive * , GAsyncResult * , GError ** ) ;
   gboolean (*can_stop)(GDrive * ) ;
   void (*stop)(GDrive * , GMountUnmountFlags  , GMountOperation * , GCancellable * ,
                GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*stop_finish)(GDrive * , GAsyncResult * , GError ** ) ;
   void (*stop_button)(GDrive * ) ;
   void (*eject_with_operation)(GDrive * , GMountUnmountFlags  , GMountOperation * ,
                                GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*eject_with_operation_finish)(GDrive * , GAsyncResult * , GError ** ) ;
   gchar *(*get_sort_key)(GDrive * ) ;
   GIcon *(*get_symbolic_icon)(GDrive * ) ;
   gboolean (*is_removable)(GDrive * ) ;
};
#line 36 "/usr/include/glib-2.0/gio/gdtlsconnection.h"
struct _GDtlsConnectionInterface ;
#line 36 "/usr/include/glib-2.0/gio/gdtlsconnection.h"
typedef struct _GDtlsConnectionInterface GDtlsConnectionInterface;
#line 56 "/usr/include/glib-2.0/gio/gdtlsconnection.h"
struct _GDtlsConnectionInterface {
   GTypeInterface g_iface ;
   gboolean (*accept_certificate)(GDtlsConnection * , GTlsCertificate * , GTlsCertificateFlags  ) ;
   gboolean (*handshake)(GDtlsConnection * , GCancellable * , GError ** ) ;
   void (*handshake_async)(GDtlsConnection * , int  , GCancellable * , GAsyncReadyCallback  ,
                           gpointer  ) ;
   gboolean (*handshake_finish)(GDtlsConnection * , GAsyncResult * , GError ** ) ;
   gboolean (*shutdown)(GDtlsConnection * , gboolean  , gboolean  , GCancellable * ,
                        GError ** ) ;
   void (*shutdown_async)(GDtlsConnection * , gboolean  , gboolean  , int  , GCancellable * ,
                          GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*shutdown_finish)(GDtlsConnection * , GAsyncResult * , GError ** ) ;
   void (*set_advertised_protocols)(GDtlsConnection * , gchar * const  * ) ;
   gchar *(*get_negotiated_protocol)(GDtlsConnection * ) ;
   gboolean (*get_binding_data)(GDtlsConnection * , GTlsChannelBindingType  , GByteArray * ,
                                GError ** ) ;
};
#line 36 "/usr/include/glib-2.0/gio/gdtlsclientconnection.h"
struct _GDtlsClientConnectionInterface ;
#line 36 "/usr/include/glib-2.0/gio/gdtlsclientconnection.h"
typedef struct _GDtlsClientConnectionInterface GDtlsClientConnectionInterface;
#line 46 "/usr/include/glib-2.0/gio/gdtlsclientconnection.h"
struct _GDtlsClientConnectionInterface {
   GTypeInterface g_iface ;
};
#line 44 "/usr/include/glib-2.0/gio/gdtlsserverconnection.h"
struct _GDtlsServerConnectionInterface ;
#line 44 "/usr/include/glib-2.0/gio/gdtlsserverconnection.h"
typedef struct _GDtlsServerConnectionInterface GDtlsServerConnectionInterface;
#line 54 "/usr/include/glib-2.0/gio/gdtlsserverconnection.h"
struct _GDtlsServerConnectionInterface {
   GTypeInterface g_iface ;
};
#line 42 "/usr/include/glib-2.0/gio/gicon.h"
struct _GIconIface ;
#line 42 "/usr/include/glib-2.0/gio/gicon.h"
typedef struct _GIconIface GIconIface;
#line 61 "/usr/include/glib-2.0/gio/gicon.h"
struct _GIconIface {
   GTypeInterface g_iface ;
   guint (*hash)(GIcon * ) ;
   gboolean (*equal)(GIcon * , GIcon * ) ;
   gboolean (*to_tokens)(GIcon * , GPtrArray * , gint * ) ;
   GIcon *(*from_tokens)(gchar ** , gint  , gint  , GError ** ) ;
   GVariant *(*serialize)(GIcon * ) ;
};
#line 43 "/usr/include/glib-2.0/gio/gemblem.h"
struct _GEmblem ;
#line 43 "/usr/include/glib-2.0/gio/gemblem.h"
typedef struct _GEmblem GEmblem;
#line 44
struct _GEmblemClass ;
#line 44 "/usr/include/glib-2.0/gio/gemblem.h"
typedef struct _GEmblemClass GEmblemClass;
#line 46 "/usr/include/glib-2.0/gio/gemblemedicon.h"
struct _GEmblemedIcon ;
#line 46 "/usr/include/glib-2.0/gio/gemblemedicon.h"
typedef struct _GEmblemedIcon GEmblemedIcon;
#line 47
struct _GEmblemedIconClass ;
#line 47 "/usr/include/glib-2.0/gio/gemblemedicon.h"
typedef struct _GEmblemedIconClass GEmblemedIconClass;
#line 48
struct _GEmblemedIconPrivate ;
#line 48 "/usr/include/glib-2.0/gio/gemblemedicon.h"
typedef struct _GEmblemedIconPrivate GEmblemedIconPrivate;
#line 50 "/usr/include/glib-2.0/gio/gemblemedicon.h"
struct _GEmblemedIcon {
   GObject parent_instance ;
   GEmblemedIconPrivate *priv ;
};
#line 58 "/usr/include/glib-2.0/gio/gemblemedicon.h"
struct _GEmblemedIconClass {
   GObjectClass parent_class ;
};
#line 47 "/usr/include/glib-2.0/gio/gfile.h"
struct _GFileIface ;
#line 47 "/usr/include/glib-2.0/gio/gfile.h"
typedef struct _GFileIface GFileIface;
#line 162 "/usr/include/glib-2.0/gio/gfile.h"
struct _GFileIface {
   GTypeInterface g_iface ;
   GFile *(*dup)(GFile * ) ;
   guint (*hash)(GFile * ) ;
   gboolean (*equal)(GFile * , GFile * ) ;
   gboolean (*is_native)(GFile * ) ;
   gboolean (*has_uri_scheme)(GFile * , char const   * ) ;
   char *(*get_uri_scheme)(GFile * ) ;
   char *(*get_basename)(GFile * ) ;
   char *(*get_path)(GFile * ) ;
   char *(*get_uri)(GFile * ) ;
   char *(*get_parse_name)(GFile * ) ;
   GFile *(*get_parent)(GFile * ) ;
   gboolean (*prefix_matches)(GFile * , GFile * ) ;
   char *(*get_relative_path)(GFile * , GFile * ) ;
   GFile *(*resolve_relative_path)(GFile * , char const   * ) ;
   GFile *(*get_child_for_display_name)(GFile * , char const   * , GError ** ) ;
   GFileEnumerator *(*enumerate_children)(GFile * , char const   * , GFileQueryInfoFlags  ,
                                          GCancellable * , GError ** ) ;
   void (*enumerate_children_async)(GFile * , char const   * , GFileQueryInfoFlags  ,
                                    int  , GCancellable * , GAsyncReadyCallback  ,
                                    gpointer  ) ;
   GFileEnumerator *(*enumerate_children_finish)(GFile * , GAsyncResult * , GError ** ) ;
   GFileInfo *(*query_info)(GFile * , char const   * , GFileQueryInfoFlags  , GCancellable * ,
                            GError ** ) ;
   void (*query_info_async)(GFile * , char const   * , GFileQueryInfoFlags  , int  ,
                            GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   GFileInfo *(*query_info_finish)(GFile * , GAsyncResult * , GError ** ) ;
   GFileInfo *(*query_filesystem_info)(GFile * , char const   * , GCancellable * ,
                                       GError ** ) ;
   void (*query_filesystem_info_async)(GFile * , char const   * , int  , GCancellable * ,
                                       GAsyncReadyCallback  , gpointer  ) ;
   GFileInfo *(*query_filesystem_info_finish)(GFile * , GAsyncResult * , GError ** ) ;
   GMount *(*find_enclosing_mount)(GFile * , GCancellable * , GError ** ) ;
   void (*find_enclosing_mount_async)(GFile * , int  , GCancellable * , GAsyncReadyCallback  ,
                                      gpointer  ) ;
   GMount *(*find_enclosing_mount_finish)(GFile * , GAsyncResult * , GError ** ) ;
   GFile *(*set_display_name)(GFile * , char const   * , GCancellable * , GError ** ) ;
   void (*set_display_name_async)(GFile * , char const   * , int  , GCancellable * ,
                                  GAsyncReadyCallback  , gpointer  ) ;
   GFile *(*set_display_name_finish)(GFile * , GAsyncResult * , GError ** ) ;
   GFileAttributeInfoList *(*query_settable_attributes)(GFile * , GCancellable * ,
                                                        GError ** ) ;
   void (*_query_settable_attributes_async)(void) ;
   void (*_query_settable_attributes_finish)(void) ;
   GFileAttributeInfoList *(*query_writable_namespaces)(GFile * , GCancellable * ,
                                                        GError ** ) ;
   void (*_query_writable_namespaces_async)(void) ;
   void (*_query_writable_namespaces_finish)(void) ;
   gboolean (*set_attribute)(GFile * , char const   * , GFileAttributeType  , gpointer  ,
                             GFileQueryInfoFlags  , GCancellable * , GError ** ) ;
   gboolean (*set_attributes_from_info)(GFile * , GFileInfo * , GFileQueryInfoFlags  ,
                                        GCancellable * , GError ** ) ;
   void (*set_attributes_async)(GFile * , GFileInfo * , GFileQueryInfoFlags  , int  ,
                                GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*set_attributes_finish)(GFile * , GAsyncResult * , GFileInfo ** , GError ** ) ;
   GFileInputStream *(*read_fn)(GFile * , GCancellable * , GError ** ) ;
   void (*read_async)(GFile * , int  , GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   GFileInputStream *(*read_finish)(GFile * , GAsyncResult * , GError ** ) ;
   GFileOutputStream *(*append_to)(GFile * , GFileCreateFlags  , GCancellable * ,
                                   GError ** ) ;
   void (*append_to_async)(GFile * , GFileCreateFlags  , int  , GCancellable * , GAsyncReadyCallback  ,
                           gpointer  ) ;
   GFileOutputStream *(*append_to_finish)(GFile * , GAsyncResult * , GError ** ) ;
   GFileOutputStream *(*create)(GFile * , GFileCreateFlags  , GCancellable * , GError ** ) ;
   void (*create_async)(GFile * , GFileCreateFlags  , int  , GCancellable * , GAsyncReadyCallback  ,
                        gpointer  ) ;
   GFileOutputStream *(*create_finish)(GFile * , GAsyncResult * , GError ** ) ;
   GFileOutputStream *(*replace)(GFile * , char const   * , gboolean  , GFileCreateFlags  ,
                                 GCancellable * , GError ** ) ;
   void (*replace_async)(GFile * , char const   * , gboolean  , GFileCreateFlags  ,
                         int  , GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   GFileOutputStream *(*replace_finish)(GFile * , GAsyncResult * , GError ** ) ;
   gboolean (*delete_file)(GFile * , GCancellable * , GError ** ) ;
   void (*delete_file_async)(GFile * , int  , GCancellable * , GAsyncReadyCallback  ,
                             gpointer  ) ;
   gboolean (*delete_file_finish)(GFile * , GAsyncResult * , GError ** ) ;
   gboolean (*trash)(GFile * , GCancellable * , GError ** ) ;
   void (*trash_async)(GFile * , int  , GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*trash_finish)(GFile * , GAsyncResult * , GError ** ) ;
   gboolean (*make_directory)(GFile * , GCancellable * , GError ** ) ;
   void (*make_directory_async)(GFile * , int  , GCancellable * , GAsyncReadyCallback  ,
                                gpointer  ) ;
   gboolean (*make_directory_finish)(GFile * , GAsyncResult * , GError ** ) ;
   gboolean (*make_symbolic_link)(GFile * , char const   * , GCancellable * , GError ** ) ;
   void (*_make_symbolic_link_async)(void) ;
   void (*_make_symbolic_link_finish)(void) ;
   gboolean (*copy)(GFile * , GFile * , GFileCopyFlags  , GCancellable * , GFileProgressCallback  ,
                    gpointer  , GError ** ) ;
   void (*copy_async)(GFile * , GFile * , GFileCopyFlags  , int  , GCancellable * ,
                      GFileProgressCallback  , gpointer  , GAsyncReadyCallback  ,
                      gpointer  ) ;
   gboolean (*copy_finish)(GFile * , GAsyncResult * , GError ** ) ;
   gboolean (*move)(GFile * , GFile * , GFileCopyFlags  , GCancellable * , GFileProgressCallback  ,
                    gpointer  , GError ** ) ;
   void (*move_async)(GFile * , GFile * , GFileCopyFlags  , int  , GCancellable * ,
                      GFileProgressCallback  , gpointer  , GAsyncReadyCallback  ,
                      gpointer  ) ;
   gboolean (*move_finish)(GFile * , GAsyncResult * , GError ** ) ;
   void (*mount_mountable)(GFile * , GMountMountFlags  , GMountOperation * , GCancellable * ,
                           GAsyncReadyCallback  , gpointer  ) ;
   GFile *(*mount_mountable_finish)(GFile * , GAsyncResult * , GError ** ) ;
   void (*unmount_mountable)(GFile * , GMountUnmountFlags  , GCancellable * , GAsyncReadyCallback  ,
                             gpointer  ) ;
   gboolean (*unmount_mountable_finish)(GFile * , GAsyncResult * , GError ** ) ;
   void (*eject_mountable)(GFile * , GMountUnmountFlags  , GCancellable * , GAsyncReadyCallback  ,
                           gpointer  ) ;
   gboolean (*eject_mountable_finish)(GFile * , GAsyncResult * , GError ** ) ;
   void (*mount_enclosing_volume)(GFile * , GMountMountFlags  , GMountOperation * ,
                                  GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*mount_enclosing_volume_finish)(GFile * , GAsyncResult * , GError ** ) ;
   GFileMonitor *(*monitor_dir)(GFile * , GFileMonitorFlags  , GCancellable * , GError ** ) ;
   GFileMonitor *(*monitor_file)(GFile * , GFileMonitorFlags  , GCancellable * , GError ** ) ;
   GFileIOStream *(*open_readwrite)(GFile * , GCancellable * , GError ** ) ;
   void (*open_readwrite_async)(GFile * , int  , GCancellable * , GAsyncReadyCallback  ,
                                gpointer  ) ;
   GFileIOStream *(*open_readwrite_finish)(GFile * , GAsyncResult * , GError ** ) ;
   GFileIOStream *(*create_readwrite)(GFile * , GFileCreateFlags  , GCancellable * ,
                                      GError ** ) ;
   void (*create_readwrite_async)(GFile * , GFileCreateFlags  , int  , GCancellable * ,
                                  GAsyncReadyCallback  , gpointer  ) ;
   GFileIOStream *(*create_readwrite_finish)(GFile * , GAsyncResult * , GError ** ) ;
   GFileIOStream *(*replace_readwrite)(GFile * , char const   * , gboolean  , GFileCreateFlags  ,
                                       GCancellable * , GError ** ) ;
   void (*replace_readwrite_async)(GFile * , char const   * , gboolean  , GFileCreateFlags  ,
                                   int  , GCancellable * , GAsyncReadyCallback  ,
                                   gpointer  ) ;
   GFileIOStream *(*replace_readwrite_finish)(GFile * , GAsyncResult * , GError ** ) ;
   void (*start_mountable)(GFile * , GDriveStartFlags  , GMountOperation * , GCancellable * ,
                           GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*start_mountable_finish)(GFile * , GAsyncResult * , GError ** ) ;
   void (*stop_mountable)(GFile * , GMountUnmountFlags  , GMountOperation * , GCancellable * ,
                          GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*stop_mountable_finish)(GFile * , GAsyncResult * , GError ** ) ;
   gboolean supports_thread_contexts ;
   void (*unmount_mountable_with_operation)(GFile * , GMountUnmountFlags  , GMountOperation * ,
                                            GCancellable * , GAsyncReadyCallback  ,
                                            gpointer  ) ;
   gboolean (*unmount_mountable_with_operation_finish)(GFile * , GAsyncResult * ,
                                                       GError ** ) ;
   void (*eject_mountable_with_operation)(GFile * , GMountUnmountFlags  , GMountOperation * ,
                                          GCancellable * , GAsyncReadyCallback  ,
                                          gpointer  ) ;
   gboolean (*eject_mountable_with_operation_finish)(GFile * , GAsyncResult * , GError ** ) ;
   void (*poll_mountable)(GFile * , GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*poll_mountable_finish)(GFile * , GAsyncResult * , GError ** ) ;
   gboolean (*measure_disk_usage)(GFile * , GFileMeasureFlags  , GCancellable * ,
                                  GFileMeasureProgressCallback  , gpointer  , guint64 * ,
                                  guint64 * , guint64 * , GError ** ) ;
   void (*measure_disk_usage_async)(GFile * , GFileMeasureFlags  , gint  , GCancellable * ,
                                    GFileMeasureProgressCallback  , gpointer  , GAsyncReadyCallback  ,
                                    gpointer  ) ;
   gboolean (*measure_disk_usage_finish)(GFile * , GAsyncResult * , guint64 * , guint64 * ,
                                         guint64 * , GError ** ) ;
};
#line 40 "/usr/include/glib-2.0/gio/gfileattribute.h"
struct _GFileAttributeInfo {
   char *name ;
   GFileAttributeType type ;
   GFileAttributeInfoFlags flags ;
};
#line 55 "/usr/include/glib-2.0/gio/gfileattribute.h"
struct _GFileAttributeInfoList {
   GFileAttributeInfo *infos ;
   int n_infos ;
};
#line 44 "/usr/include/glib-2.0/gio/gfileenumerator.h"
struct _GFileEnumeratorClass ;
#line 44 "/usr/include/glib-2.0/gio/gfileenumerator.h"
typedef struct _GFileEnumeratorClass GFileEnumeratorClass;
#line 45
struct _GFileEnumeratorPrivate ;
#line 45 "/usr/include/glib-2.0/gio/gfileenumerator.h"
typedef struct _GFileEnumeratorPrivate GFileEnumeratorPrivate;
#line 47 "/usr/include/glib-2.0/gio/gfileenumerator.h"
struct _GFileEnumerator {
   GObject parent_instance ;
   GFileEnumeratorPrivate *priv ;
};
#line 55 "/usr/include/glib-2.0/gio/gfileenumerator.h"
struct _GFileEnumeratorClass {
   GObjectClass parent_class ;
   GFileInfo *(*next_file)(GFileEnumerator * , GCancellable * , GError ** ) ;
   gboolean (*close_fn)(GFileEnumerator * , GCancellable * , GError ** ) ;
   void (*next_files_async)(GFileEnumerator * , int  , int  , GCancellable * , GAsyncReadyCallback  ,
                            gpointer  ) ;
   GList *(*next_files_finish)(GFileEnumerator * , GAsyncResult * , GError ** ) ;
   void (*close_async)(GFileEnumerator * , int  , GCancellable * , GAsyncReadyCallback  ,
                       gpointer  ) ;
   gboolean (*close_finish)(GFileEnumerator * , GAsyncResult * , GError ** ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
   void (*_g_reserved6)(void) ;
   void (*_g_reserved7)(void) ;
};
#line 44 "/usr/include/glib-2.0/gio/gfileicon.h"
struct _GFileIconClass ;
#line 44 "/usr/include/glib-2.0/gio/gfileicon.h"
typedef struct _GFileIconClass GFileIconClass;
#line 44 "/usr/include/glib-2.0/gio/gfileinfo.h"
struct _GFileInfoClass ;
#line 44 "/usr/include/glib-2.0/gio/gfileinfo.h"
typedef struct _GFileInfoClass GFileInfoClass;
#line 47 "/usr/include/glib-2.0/gio/gfileinputstream.h"
struct _GFileInputStreamClass ;
#line 47 "/usr/include/glib-2.0/gio/gfileinputstream.h"
typedef struct _GFileInputStreamClass GFileInputStreamClass;
#line 48
struct _GFileInputStreamPrivate ;
#line 48 "/usr/include/glib-2.0/gio/gfileinputstream.h"
typedef struct _GFileInputStreamPrivate GFileInputStreamPrivate;
#line 50 "/usr/include/glib-2.0/gio/gfileinputstream.h"
struct _GFileInputStream {
   GInputStream parent_instance ;
   GFileInputStreamPrivate *priv ;
};
#line 58 "/usr/include/glib-2.0/gio/gfileinputstream.h"
struct _GFileInputStreamClass {
   GInputStreamClass parent_class ;
   goffset (*tell)(GFileInputStream * ) ;
   gboolean (*can_seek)(GFileInputStream * ) ;
   gboolean (*seek)(GFileInputStream * , goffset  , GSeekType  , GCancellable * ,
                    GError ** ) ;
   GFileInfo *(*query_info)(GFileInputStream * , char const   * , GCancellable * ,
                            GError ** ) ;
   void (*query_info_async)(GFileInputStream * , char const   * , int  , GCancellable * ,
                            GAsyncReadyCallback  , gpointer  ) ;
   GFileInfo *(*query_info_finish)(GFileInputStream * , GAsyncResult * , GError ** ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 38 "/usr/include/glib-2.0/gio/giostream.h"
struct _GIOStreamPrivate ;
#line 38 "/usr/include/glib-2.0/gio/giostream.h"
typedef struct _GIOStreamPrivate GIOStreamPrivate;
#line 39
struct _GIOStreamClass ;
#line 39 "/usr/include/glib-2.0/gio/giostream.h"
typedef struct _GIOStreamClass GIOStreamClass;
#line 46 "/usr/include/glib-2.0/gio/giostream.h"
struct _GIOStream {
   GObject parent_instance ;
   GIOStreamPrivate *priv ;
};
#line 54 "/usr/include/glib-2.0/gio/giostream.h"
struct _GIOStreamClass {
   GObjectClass parent_class ;
   GInputStream *(*get_input_stream)(GIOStream * ) ;
   GOutputStream *(*get_output_stream)(GIOStream * ) ;
   gboolean (*close_fn)(GIOStream * , GCancellable * , GError ** ) ;
   void (*close_async)(GIOStream * , int  , GCancellable * , GAsyncReadyCallback  ,
                       gpointer  ) ;
   gboolean (*close_finish)(GIOStream * , GAsyncResult * , GError ** ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
   void (*_g_reserved6)(void) ;
   void (*_g_reserved7)(void) ;
   void (*_g_reserved8)(void) ;
   void (*_g_reserved9)(void) ;
   void (*_g_reserved10)(void) ;
};
#line 47 "/usr/include/glib-2.0/gio/gfileiostream.h"
struct _GFileIOStreamClass ;
#line 47 "/usr/include/glib-2.0/gio/gfileiostream.h"
typedef struct _GFileIOStreamClass GFileIOStreamClass;
#line 48
struct _GFileIOStreamPrivate ;
#line 48 "/usr/include/glib-2.0/gio/gfileiostream.h"
typedef struct _GFileIOStreamPrivate GFileIOStreamPrivate;
#line 50 "/usr/include/glib-2.0/gio/gfileiostream.h"
struct _GFileIOStream {
   GIOStream parent_instance ;
   GFileIOStreamPrivate *priv ;
};
#line 58 "/usr/include/glib-2.0/gio/gfileiostream.h"
struct _GFileIOStreamClass {
   GIOStreamClass parent_class ;
   goffset (*tell)(GFileIOStream * ) ;
   gboolean (*can_seek)(GFileIOStream * ) ;
   gboolean (*seek)(GFileIOStream * , goffset  , GSeekType  , GCancellable * , GError ** ) ;
   gboolean (*can_truncate)(GFileIOStream * ) ;
   gboolean (*truncate_fn)(GFileIOStream * , goffset  , GCancellable * , GError ** ) ;
   GFileInfo *(*query_info)(GFileIOStream * , char const   * , GCancellable * , GError ** ) ;
   void (*query_info_async)(GFileIOStream * , char const   * , int  , GCancellable * ,
                            GAsyncReadyCallback  , gpointer  ) ;
   GFileInfo *(*query_info_finish)(GFileIOStream * , GAsyncResult * , GError ** ) ;
   char *(*get_etag)(GFileIOStream * ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 39 "/usr/include/glib-2.0/gio/gfilemonitor.h"
struct _GFileMonitorClass ;
#line 39 "/usr/include/glib-2.0/gio/gfilemonitor.h"
typedef struct _GFileMonitorClass GFileMonitorClass;
#line 40
struct _GFileMonitorPrivate ;
#line 40 "/usr/include/glib-2.0/gio/gfilemonitor.h"
typedef struct _GFileMonitorPrivate GFileMonitorPrivate;
#line 47 "/usr/include/glib-2.0/gio/gfilemonitor.h"
struct _GFileMonitor {
   GObject parent_instance ;
   GFileMonitorPrivate *priv ;
};
#line 55 "/usr/include/glib-2.0/gio/gfilemonitor.h"
struct _GFileMonitorClass {
   GObjectClass parent_class ;
   void (*changed)(GFileMonitor * , GFile * , GFile * , GFileMonitorEvent  ) ;
   gboolean (*cancel)(GFileMonitor * ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 44 "/usr/include/glib-2.0/gio/gfilenamecompleter.h"
struct _GFilenameCompleterClass ;
#line 44 "/usr/include/glib-2.0/gio/gfilenamecompleter.h"
typedef struct _GFilenameCompleterClass GFilenameCompleterClass;
#line 46 "/usr/include/glib-2.0/gio/gfilenamecompleter.h"
struct _GFilenameCompleterClass {
   GObjectClass parent_class ;
   void (*got_completion_data)(GFilenameCompleter * ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
};
#line 47 "/usr/include/glib-2.0/gio/gfileoutputstream.h"
struct _GFileOutputStreamClass ;
#line 47 "/usr/include/glib-2.0/gio/gfileoutputstream.h"
typedef struct _GFileOutputStreamClass GFileOutputStreamClass;
#line 48
struct _GFileOutputStreamPrivate ;
#line 48 "/usr/include/glib-2.0/gio/gfileoutputstream.h"
typedef struct _GFileOutputStreamPrivate GFileOutputStreamPrivate;
#line 50 "/usr/include/glib-2.0/gio/gfileoutputstream.h"
struct _GFileOutputStream {
   GOutputStream parent_instance ;
   GFileOutputStreamPrivate *priv ;
};
#line 58 "/usr/include/glib-2.0/gio/gfileoutputstream.h"
struct _GFileOutputStreamClass {
   GOutputStreamClass parent_class ;
   goffset (*tell)(GFileOutputStream * ) ;
   gboolean (*can_seek)(GFileOutputStream * ) ;
   gboolean (*seek)(GFileOutputStream * , goffset  , GSeekType  , GCancellable * ,
                    GError ** ) ;
   gboolean (*can_truncate)(GFileOutputStream * ) ;
   gboolean (*truncate_fn)(GFileOutputStream * , goffset  , GCancellable * , GError ** ) ;
   GFileInfo *(*query_info)(GFileOutputStream * , char const   * , GCancellable * ,
                            GError ** ) ;
   void (*query_info_async)(GFileOutputStream * , char const   * , int  , GCancellable * ,
                            GAsyncReadyCallback  , gpointer  ) ;
   GFileInfo *(*query_info_finish)(GFileOutputStream * , GAsyncResult * , GError ** ) ;
   char *(*get_etag)(GFileOutputStream * ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 40 "/usr/include/glib-2.0/gio/ginetaddress.h"
struct _GInetAddressClass ;
#line 40 "/usr/include/glib-2.0/gio/ginetaddress.h"
typedef struct _GInetAddressClass GInetAddressClass;
#line 41
struct _GInetAddressPrivate ;
#line 41 "/usr/include/glib-2.0/gio/ginetaddress.h"
typedef struct _GInetAddressPrivate GInetAddressPrivate;
#line 43 "/usr/include/glib-2.0/gio/ginetaddress.h"
struct _GInetAddress {
   GObject parent_instance ;
   GInetAddressPrivate *priv ;
};
#line 51 "/usr/include/glib-2.0/gio/ginetaddress.h"
struct _GInetAddressClass {
   GObjectClass parent_class ;
   gchar *(*to_string)(GInetAddress * ) ;
   guint8 *(*to_bytes)(GInetAddress * ) ;
};
#line 37 "/usr/include/glib-2.0/gio/ginetaddressmask.h"
struct _GInetAddressMaskClass ;
#line 37 "/usr/include/glib-2.0/gio/ginetaddressmask.h"
typedef struct _GInetAddressMaskClass GInetAddressMaskClass;
#line 38
struct _GInetAddressMaskPrivate ;
#line 38 "/usr/include/glib-2.0/gio/ginetaddressmask.h"
typedef struct _GInetAddressMaskPrivate GInetAddressMaskPrivate;
#line 40 "/usr/include/glib-2.0/gio/ginetaddressmask.h"
struct _GInetAddressMask {
   GObject parent_instance ;
   GInetAddressMaskPrivate *priv ;
};
#line 48 "/usr/include/glib-2.0/gio/ginetaddressmask.h"
struct _GInetAddressMaskClass {
   GObjectClass parent_class ;
};
#line 40 "/usr/include/glib-2.0/gio/gsocketaddress.h"
struct _GSocketAddressClass ;
#line 40 "/usr/include/glib-2.0/gio/gsocketaddress.h"
typedef struct _GSocketAddressClass GSocketAddressClass;
#line 42 "/usr/include/glib-2.0/gio/gsocketaddress.h"
struct _GSocketAddress {
   GObject parent_instance ;
};
#line 47 "/usr/include/glib-2.0/gio/gsocketaddress.h"
struct _GSocketAddressClass {
   GObjectClass parent_class ;
   GSocketFamily (*get_family)(GSocketAddress * ) ;
   gssize (*get_native_size)(GSocketAddress * ) ;
   gboolean (*to_native)(GSocketAddress * , gpointer  , gsize  , GError ** ) ;
};
#line 40 "/usr/include/glib-2.0/gio/ginetsocketaddress.h"
struct _GInetSocketAddressClass ;
#line 40 "/usr/include/glib-2.0/gio/ginetsocketaddress.h"
typedef struct _GInetSocketAddressClass GInetSocketAddressClass;
#line 41
struct _GInetSocketAddressPrivate ;
#line 41 "/usr/include/glib-2.0/gio/ginetsocketaddress.h"
typedef struct _GInetSocketAddressPrivate GInetSocketAddressPrivate;
#line 43 "/usr/include/glib-2.0/gio/ginetsocketaddress.h"
struct _GInetSocketAddress {
   GSocketAddress parent_instance ;
   GInetSocketAddressPrivate *priv ;
};
#line 51 "/usr/include/glib-2.0/gio/ginetsocketaddress.h"
struct _GInetSocketAddressClass {
   GSocketAddressClass parent_class ;
};
#line 58 "/usr/include/glib-2.0/gmodule.h"
enum __anonenum__385 {
    G_MODULE_BIND_LAZY = 1,
    G_MODULE_BIND_LOCAL = 2,
    G_MODULE_BIND_MASK = 3
} ;
#line 63 "/usr/include/glib-2.0/gmodule.h"
typedef enum __anonenum__385 GModuleFlags;
#line 65
struct _GModule ;
#line 65 "/usr/include/glib-2.0/gmodule.h"
typedef struct _GModule GModule;
#line 66 "/usr/include/glib-2.0/gmodule.h"
typedef gchar *(*GModuleCheckInit)(GModule * );
#line 67 "/usr/include/glib-2.0/gmodule.h"
typedef void (*GModuleUnload)(GModule * );
#line 82
enum __anonenum__386 {
    G_MODULE_ERROR_FAILED = 0,
    G_MODULE_ERROR_CHECK_FAILED = 1
} ;
#line 86 "/usr/include/glib-2.0/gmodule.h"
typedef enum __anonenum__386 GModuleError;
#line 33 "/usr/include/glib-2.0/gio/giomodule.h"
struct _GIOModuleScope ;
#line 33 "/usr/include/glib-2.0/gio/giomodule.h"
typedef struct _GIOModuleScope GIOModuleScope;
#line 55
struct _GIOModuleClass ;
#line 55 "/usr/include/glib-2.0/gio/giomodule.h"
typedef struct _GIOModuleClass GIOModuleClass;
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
struct _GListModel ;
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
typedef struct _GListModel GListModel;
#line 36
struct _GListModelInterface ;
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
typedef struct _GListModelInterface GListModelInterface;
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
typedef GListModel *GListModel_autoptr;
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
typedef GList *GListModel_listautoptr;
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
typedef GSList *GListModel_slistautoptr;
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
typedef GQueue *GListModel_queueautoptr;
#line 38 "/usr/include/glib-2.0/gio/glistmodel.h"
struct _GListModelInterface {
   GTypeInterface g_iface ;
   GType (*get_item_type)(GListModel * ) ;
   guint (*get_n_items)(GListModel * ) ;
   gpointer (*get_item)(GListModel * , guint  ) ;
};
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
struct _GListStore ;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
typedef struct _GListStore GListStore;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
struct __anonstruct_387 {
   GObjectClass parent_class ;
};
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
typedef struct __anonstruct_387 GListStoreClass;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
typedef GListStore *GListStore_autoptr;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
typedef GList *GListStore_listautoptr;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
typedef GSList *GListStore_slistautoptr;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
typedef GQueue *GListStore_queueautoptr;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
typedef GListStoreClass *GListStoreClass_autoptr;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
typedef GList *GListStoreClass_listautoptr;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
typedef GSList *GListStoreClass_slistautoptr;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
typedef GQueue *GListStoreClass_queueautoptr;
#line 43 "/usr/include/glib-2.0/gio/gloadableicon.h"
struct _GLoadableIconIface ;
#line 43 "/usr/include/glib-2.0/gio/gloadableicon.h"
typedef struct _GLoadableIconIface GLoadableIconIface;
#line 54 "/usr/include/glib-2.0/gio/gloadableicon.h"
struct _GLoadableIconIface {
   GTypeInterface g_iface ;
   GInputStream *(*load)(GLoadableIcon * , int  , char ** , GCancellable * , GError ** ) ;
   void (*load_async)(GLoadableIcon * , int  , GCancellable * , GAsyncReadyCallback  ,
                      gpointer  ) ;
   GInputStream *(*load_finish)(GLoadableIcon * , GAsyncResult * , char ** , GError ** ) ;
};
#line 44 "/usr/include/glib-2.0/gio/gmemoryinputstream.h"
struct _GMemoryInputStreamClass ;
#line 44 "/usr/include/glib-2.0/gio/gmemoryinputstream.h"
typedef struct _GMemoryInputStreamClass GMemoryInputStreamClass;
#line 45
struct _GMemoryInputStreamPrivate ;
#line 45 "/usr/include/glib-2.0/gio/gmemoryinputstream.h"
typedef struct _GMemoryInputStreamPrivate GMemoryInputStreamPrivate;
#line 47 "/usr/include/glib-2.0/gio/gmemoryinputstream.h"
struct _GMemoryInputStream {
   GInputStream parent_instance ;
   GMemoryInputStreamPrivate *priv ;
};
#line 55 "/usr/include/glib-2.0/gio/gmemoryinputstream.h"
struct _GMemoryInputStreamClass {
   GInputStreamClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
struct _GMemoryMonitor ;
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
typedef struct _GMemoryMonitor GMemoryMonitor;
#line 42
struct _GMemoryMonitorInterface ;
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
typedef struct _GMemoryMonitorInterface GMemoryMonitorInterface;
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
typedef GMemoryMonitor *GMemoryMonitor_autoptr;
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
typedef GList *GMemoryMonitor_listautoptr;
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
typedef GSList *GMemoryMonitor_slistautoptr;
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
typedef GQueue *GMemoryMonitor_queueautoptr;
#line 48 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
struct _GMemoryMonitorInterface {
   GTypeInterface g_iface ;
   void (*low_memory_warning)(GMemoryMonitor * , GMemoryMonitorWarningLevel  ) ;
};
#line 44 "/usr/include/glib-2.0/gio/gmemoryoutputstream.h"
struct _GMemoryOutputStreamClass ;
#line 44 "/usr/include/glib-2.0/gio/gmemoryoutputstream.h"
typedef struct _GMemoryOutputStreamClass GMemoryOutputStreamClass;
#line 45
struct _GMemoryOutputStreamPrivate ;
#line 45 "/usr/include/glib-2.0/gio/gmemoryoutputstream.h"
typedef struct _GMemoryOutputStreamPrivate GMemoryOutputStreamPrivate;
#line 47 "/usr/include/glib-2.0/gio/gmemoryoutputstream.h"
struct _GMemoryOutputStream {
   GOutputStream parent_instance ;
   GMemoryOutputStreamPrivate *priv ;
};
#line 55 "/usr/include/glib-2.0/gio/gmemoryoutputstream.h"
struct _GMemoryOutputStreamClass {
   GOutputStreamClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 80 "/usr/include/glib-2.0/gio/gmemoryoutputstream.h"
typedef gpointer (*GReallocFunc)(gpointer  , gsize  );
#line 125 "/usr/include/glib-2.0/gio/gmenumodel.h"
struct _GMenuModelPrivate ;
#line 125 "/usr/include/glib-2.0/gio/gmenumodel.h"
typedef struct _GMenuModelPrivate GMenuModelPrivate;
#line 126
struct _GMenuModelClass ;
#line 126 "/usr/include/glib-2.0/gio/gmenumodel.h"
typedef struct _GMenuModelClass GMenuModelClass;
#line 128
struct _GMenuAttributeIterPrivate ;
#line 128 "/usr/include/glib-2.0/gio/gmenumodel.h"
typedef struct _GMenuAttributeIterPrivate GMenuAttributeIterPrivate;
#line 129
struct _GMenuAttributeIterClass ;
#line 129 "/usr/include/glib-2.0/gio/gmenumodel.h"
typedef struct _GMenuAttributeIterClass GMenuAttributeIterClass;
#line 130
struct _GMenuAttributeIter ;
#line 130 "/usr/include/glib-2.0/gio/gmenumodel.h"
typedef struct _GMenuAttributeIter GMenuAttributeIter;
#line 132
struct _GMenuLinkIterPrivate ;
#line 132 "/usr/include/glib-2.0/gio/gmenumodel.h"
typedef struct _GMenuLinkIterPrivate GMenuLinkIterPrivate;
#line 133
struct _GMenuLinkIterClass ;
#line 133 "/usr/include/glib-2.0/gio/gmenumodel.h"
typedef struct _GMenuLinkIterClass GMenuLinkIterClass;
#line 134
struct _GMenuLinkIter ;
#line 134 "/usr/include/glib-2.0/gio/gmenumodel.h"
typedef struct _GMenuLinkIter GMenuLinkIter;
#line 136 "/usr/include/glib-2.0/gio/gmenumodel.h"
struct _GMenuModel {
   GObject parent_instance ;
   GMenuModelPrivate *priv ;
};
#line 158 "/usr/include/glib-2.0/gio/gmenumodel.h"
struct _GMenuModelClass {
   GObjectClass parent_class ;
   gboolean (*is_mutable)(GMenuModel * ) ;
   gint (*get_n_items)(GMenuModel * ) ;
   void (*get_item_attributes)(GMenuModel * , gint  , GHashTable ** ) ;
   GMenuAttributeIter *(*iterate_item_attributes)(GMenuModel * , gint  ) ;
   GVariant *(*get_item_attribute_value)(GMenuModel * , gint  , gchar * , GVariantType * ) ;
   void (*get_item_links)(GMenuModel * , gint  , GHashTable ** ) ;
   GMenuLinkIter *(*iterate_item_links)(GMenuModel * , gint  ) ;
   GMenuModel *(*get_item_link)(GMenuModel * , gint  , gchar * ) ;
};
#line 232 "/usr/include/glib-2.0/gio/gmenumodel.h"
struct _GMenuAttributeIter {
   GObject parent_instance ;
   GMenuAttributeIterPrivate *priv ;
};
#line 238 "/usr/include/glib-2.0/gio/gmenumodel.h"
struct _GMenuAttributeIterClass {
   GObjectClass parent_class ;
   gboolean (*get_next)(GMenuAttributeIter * , gchar ** , GVariant ** ) ;
};
#line 274 "/usr/include/glib-2.0/gio/gmenumodel.h"
struct _GMenuLinkIter {
   GObject parent_instance ;
   GMenuLinkIterPrivate *priv ;
};
#line 280 "/usr/include/glib-2.0/gio/gmenumodel.h"
struct _GMenuLinkIterClass {
   GObjectClass parent_class ;
   gboolean (*get_next)(GMenuLinkIter * , gchar ** , GMenuModel ** ) ;
};
#line 39 "/usr/include/glib-2.0/gio/gmenu.h"
struct _GMenuItem ;
#line 39 "/usr/include/glib-2.0/gio/gmenu.h"
typedef struct _GMenuItem GMenuItem;
#line 40
struct _GMenu ;
#line 40 "/usr/include/glib-2.0/gio/gmenu.h"
typedef struct _GMenu GMenu;
#line 38 "/usr/include/glib-2.0/gio/gmount.h"
struct _GMountIface ;
#line 38 "/usr/include/glib-2.0/gio/gmount.h"
typedef struct _GMountIface GMountIface;
#line 75 "/usr/include/glib-2.0/gio/gmount.h"
struct _GMountIface {
   GTypeInterface g_iface ;
   void (*changed)(GMount * ) ;
   void (*unmounted)(GMount * ) ;
   GFile *(*get_root)(GMount * ) ;
   char *(*get_name)(GMount * ) ;
   GIcon *(*get_icon)(GMount * ) ;
   char *(*get_uuid)(GMount * ) ;
   GVolume *(*get_volume)(GMount * ) ;
   GDrive *(*get_drive)(GMount * ) ;
   gboolean (*can_unmount)(GMount * ) ;
   gboolean (*can_eject)(GMount * ) ;
   void (*unmount)(GMount * , GMountUnmountFlags  , GCancellable * , GAsyncReadyCallback  ,
                   gpointer  ) ;
   gboolean (*unmount_finish)(GMount * , GAsyncResult * , GError ** ) ;
   void (*eject)(GMount * , GMountUnmountFlags  , GCancellable * , GAsyncReadyCallback  ,
                 gpointer  ) ;
   gboolean (*eject_finish)(GMount * , GAsyncResult * , GError ** ) ;
   void (*remount)(GMount * , GMountMountFlags  , GMountOperation * , GCancellable * ,
                   GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*remount_finish)(GMount * , GAsyncResult * , GError ** ) ;
   void (*guess_content_type)(GMount * , gboolean  , GCancellable * , GAsyncReadyCallback  ,
                              gpointer  ) ;
   gchar **(*guess_content_type_finish)(GMount * , GAsyncResult * , GError ** ) ;
   gchar **(*guess_content_type_sync)(GMount * , gboolean  , GCancellable * , GError ** ) ;
   void (*pre_unmount)(GMount * ) ;
   void (*unmount_with_operation)(GMount * , GMountUnmountFlags  , GMountOperation * ,
                                  GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*unmount_with_operation_finish)(GMount * , GAsyncResult * , GError ** ) ;
   void (*eject_with_operation)(GMount * , GMountUnmountFlags  , GMountOperation * ,
                                GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*eject_with_operation_finish)(GMount * , GAsyncResult * , GError ** ) ;
   GFile *(*get_default_location)(GMount * ) ;
   gchar *(*get_sort_key)(GMount * ) ;
   GIcon *(*get_symbolic_icon)(GMount * ) ;
};
#line 45 "/usr/include/glib-2.0/gio/gmountoperation.h"
struct _GMountOperationClass ;
#line 45 "/usr/include/glib-2.0/gio/gmountoperation.h"
typedef struct _GMountOperationClass GMountOperationClass;
#line 46
struct _GMountOperationPrivate ;
#line 46 "/usr/include/glib-2.0/gio/gmountoperation.h"
typedef struct _GMountOperationPrivate GMountOperationPrivate;
#line 48 "/usr/include/glib-2.0/gio/gmountoperation.h"
struct _GMountOperation {
   GObject parent_instance ;
   GMountOperationPrivate *priv ;
};
#line 55 "/usr/include/glib-2.0/gio/gmountoperation.h"
struct _GMountOperationClass {
   GObjectClass parent_class ;
   void (*ask_password)(GMountOperation * , char const   * , char const   * , char const   * ,
                        GAskPasswordFlags  ) ;
   void (*ask_question)(GMountOperation * , char const   * , char const   *[] ) ;
   void (*reply)(GMountOperation * , GMountOperationResult  ) ;
   void (*aborted)(GMountOperation * ) ;
   void (*show_processes)(GMountOperation * , gchar * , GArray * , gchar *[] ) ;
   void (*show_unmount_progress)(GMountOperation * , gchar * , gint64  , gint64  ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
   void (*_g_reserved6)(void) ;
   void (*_g_reserved7)(void) ;
   void (*_g_reserved8)(void) ;
   void (*_g_reserved9)(void) ;
};
#line 40 "/usr/include/glib-2.0/gio/gnativesocketaddress.h"
struct _GNativeSocketAddressClass ;
#line 40 "/usr/include/glib-2.0/gio/gnativesocketaddress.h"
typedef struct _GNativeSocketAddressClass GNativeSocketAddressClass;
#line 41
struct _GNativeSocketAddressPrivate ;
#line 41 "/usr/include/glib-2.0/gio/gnativesocketaddress.h"
typedef struct _GNativeSocketAddressPrivate GNativeSocketAddressPrivate;
#line 43 "/usr/include/glib-2.0/gio/gnativesocketaddress.h"
struct _GNativeSocketAddress {
   GSocketAddress parent_instance ;
   GNativeSocketAddressPrivate *priv ;
};
#line 51 "/usr/include/glib-2.0/gio/gnativesocketaddress.h"
struct _GNativeSocketAddressClass {
   GSocketAddressClass parent_class ;
};
#line 55 "/usr/include/glib-2.0/gio/gvolumemonitor.h"
struct _GVolumeMonitorClass ;
#line 55 "/usr/include/glib-2.0/gio/gvolumemonitor.h"
typedef struct _GVolumeMonitorClass GVolumeMonitorClass;
#line 57 "/usr/include/glib-2.0/gio/gvolumemonitor.h"
struct _GVolumeMonitor {
   GObject parent_instance ;
   gpointer priv ;
};
#line 65 "/usr/include/glib-2.0/gio/gvolumemonitor.h"
struct _GVolumeMonitorClass {
   GObjectClass parent_class ;
   void (*volume_added)(GVolumeMonitor * , GVolume * ) ;
   void (*volume_removed)(GVolumeMonitor * , GVolume * ) ;
   void (*volume_changed)(GVolumeMonitor * , GVolume * ) ;
   void (*mount_added)(GVolumeMonitor * , GMount * ) ;
   void (*mount_removed)(GVolumeMonitor * , GMount * ) ;
   void (*mount_pre_unmount)(GVolumeMonitor * , GMount * ) ;
   void (*mount_changed)(GVolumeMonitor * , GMount * ) ;
   void (*drive_connected)(GVolumeMonitor * , GDrive * ) ;
   void (*drive_disconnected)(GVolumeMonitor * , GDrive * ) ;
   void (*drive_changed)(GVolumeMonitor * , GDrive * ) ;
   gboolean (*is_supported)(void) ;
   GList *(*get_connected_drives)(GVolumeMonitor * ) ;
   GList *(*get_volumes)(GVolumeMonitor * ) ;
   GList *(*get_mounts)(GVolumeMonitor * ) ;
   GVolume *(*get_volume_for_uuid)(GVolumeMonitor * , char const   * ) ;
   GMount *(*get_mount_for_uuid)(GVolumeMonitor * , char const   * ) ;
   GVolume *(*adopt_orphan_mount)(GMount * , GVolumeMonitor * ) ;
   void (*drive_eject_button)(GVolumeMonitor * , GDrive * ) ;
   void (*drive_stop_button)(GVolumeMonitor * , GDrive * ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
   void (*_g_reserved6)(void) ;
};
#line 40 "/usr/include/glib-2.0/gio/gnativevolumemonitor.h"
struct _GNativeVolumeMonitor ;
#line 40 "/usr/include/glib-2.0/gio/gnativevolumemonitor.h"
typedef struct _GNativeVolumeMonitor GNativeVolumeMonitor;
#line 41
struct _GNativeVolumeMonitorClass ;
#line 41 "/usr/include/glib-2.0/gio/gnativevolumemonitor.h"
typedef struct _GNativeVolumeMonitorClass GNativeVolumeMonitorClass;
#line 43 "/usr/include/glib-2.0/gio/gnativevolumemonitor.h"
struct _GNativeVolumeMonitor {
   GVolumeMonitor parent_instance ;
};
#line 48 "/usr/include/glib-2.0/gio/gnativevolumemonitor.h"
struct _GNativeVolumeMonitorClass {
   GVolumeMonitorClass parent_class ;
   GMount *(*get_mount_for_mount_path)(char const   * , GCancellable * ) ;
};
#line 37 "/usr/include/glib-2.0/gio/gnetworkaddress.h"
struct _GNetworkAddressClass ;
#line 37 "/usr/include/glib-2.0/gio/gnetworkaddress.h"
typedef struct _GNetworkAddressClass GNetworkAddressClass;
#line 38
struct _GNetworkAddressPrivate ;
#line 38 "/usr/include/glib-2.0/gio/gnetworkaddress.h"
typedef struct _GNetworkAddressPrivate GNetworkAddressPrivate;
#line 40 "/usr/include/glib-2.0/gio/gnetworkaddress.h"
struct _GNetworkAddress {
   GObject parent_instance ;
   GNetworkAddressPrivate *priv ;
};
#line 48 "/usr/include/glib-2.0/gio/gnetworkaddress.h"
struct _GNetworkAddressClass {
   GObjectClass parent_class ;
};
#line 45 "/usr/include/glib-2.0/gio/gnetworkmonitor.h"
struct _GNetworkMonitorInterface ;
#line 45 "/usr/include/glib-2.0/gio/gnetworkmonitor.h"
typedef struct _GNetworkMonitorInterface GNetworkMonitorInterface;
#line 47 "/usr/include/glib-2.0/gio/gnetworkmonitor.h"
struct _GNetworkMonitorInterface {
   GTypeInterface g_iface ;
   void (*network_changed)(GNetworkMonitor * , gboolean  ) ;
   gboolean (*can_reach)(GNetworkMonitor * , GSocketConnectable * , GCancellable * ,
                         GError ** ) ;
   void (*can_reach_async)(GNetworkMonitor * , GSocketConnectable * , GCancellable * ,
                           GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*can_reach_finish)(GNetworkMonitor * , GAsyncResult * , GError ** ) ;
};
#line 37 "/usr/include/glib-2.0/gio/gnetworkservice.h"
struct _GNetworkServiceClass ;
#line 37 "/usr/include/glib-2.0/gio/gnetworkservice.h"
typedef struct _GNetworkServiceClass GNetworkServiceClass;
#line 38
struct _GNetworkServicePrivate ;
#line 38 "/usr/include/glib-2.0/gio/gnetworkservice.h"
typedef struct _GNetworkServicePrivate GNetworkServicePrivate;
#line 40 "/usr/include/glib-2.0/gio/gnetworkservice.h"
struct _GNetworkService {
   GObject parent_instance ;
   GNetworkServicePrivate *priv ;
};
#line 48 "/usr/include/glib-2.0/gio/gnetworkservice.h"
struct _GNetworkServiceClass {
   GObjectClass parent_class ;
};
#line 43 "/usr/include/glib-2.0/gio/gpermission.h"
struct _GPermissionPrivate ;
#line 43 "/usr/include/glib-2.0/gio/gpermission.h"
typedef struct _GPermissionPrivate GPermissionPrivate;
#line 44
struct _GPermissionClass ;
#line 44 "/usr/include/glib-2.0/gio/gpermission.h"
typedef struct _GPermissionClass GPermissionClass;
#line 46 "/usr/include/glib-2.0/gio/gpermission.h"
struct _GPermission {
   GObject parent_instance ;
   GPermissionPrivate *priv ;
};
#line 54 "/usr/include/glib-2.0/gio/gpermission.h"
struct _GPermissionClass {
   GObjectClass parent_class ;
   gboolean (*acquire)(GPermission * , GCancellable * , GError ** ) ;
   void (*acquire_async)(GPermission * , GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*acquire_finish)(GPermission * , GAsyncResult * , GError ** ) ;
   gboolean (*release)(GPermission * , GCancellable * , GError ** ) ;
   void (*release_async)(GPermission * , GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*release_finish)(GPermission * , GAsyncResult * , GError ** ) ;
   gpointer reserved[16] ;
};
#line 42 "/usr/include/glib-2.0/gio/gpollableinputstream.h"
struct _GPollableInputStreamInterface ;
#line 42 "/usr/include/glib-2.0/gio/gpollableinputstream.h"
typedef struct _GPollableInputStreamInterface GPollableInputStreamInterface;
#line 66 "/usr/include/glib-2.0/gio/gpollableinputstream.h"
struct _GPollableInputStreamInterface {
   GTypeInterface g_iface ;
   gboolean (*can_poll)(GPollableInputStream * ) ;
   gboolean (*is_readable)(GPollableInputStream * ) ;
   GSource *(*create_source)(GPollableInputStream * , GCancellable * ) ;
   gssize (*read_nonblocking)(GPollableInputStream * , void * , gsize  , GError ** ) ;
};
#line 42 "/usr/include/glib-2.0/gio/gpollableoutputstream.h"
struct _GPollableOutputStreamInterface ;
#line 42 "/usr/include/glib-2.0/gio/gpollableoutputstream.h"
typedef struct _GPollableOutputStreamInterface GPollableOutputStreamInterface;
#line 74 "/usr/include/glib-2.0/gio/gpollableoutputstream.h"
struct _GPollableOutputStreamInterface {
   GTypeInterface g_iface ;
   gboolean (*can_poll)(GPollableOutputStream * ) ;
   gboolean (*is_writable)(GPollableOutputStream * ) ;
   GSource *(*create_source)(GPollableOutputStream * , GCancellable * ) ;
   gssize (*write_nonblocking)(GPollableOutputStream * , void const   * , gsize  ,
                               GError ** ) ;
   GPollableReturn (*writev_nonblocking)(GPollableOutputStream * , GOutputVector * ,
                                         gsize  , gsize * , GError ** ) ;
};
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
struct _GPowerProfileMonitor ;
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
typedef struct _GPowerProfileMonitor GPowerProfileMonitor;
#line 43
struct _GPowerProfileMonitorInterface ;
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
typedef struct _GPowerProfileMonitorInterface GPowerProfileMonitorInterface;
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
typedef GPowerProfileMonitor *GPowerProfileMonitor_autoptr;
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
typedef GList *GPowerProfileMonitor_listautoptr;
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
typedef GSList *GPowerProfileMonitor_slistautoptr;
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
typedef GQueue *GPowerProfileMonitor_queueautoptr;
#line 49 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
struct _GPowerProfileMonitorInterface {
   GTypeInterface g_iface ;
};
#line 56 "/usr/include/glib-2.0/gio/gproxy.h"
struct _GProxyInterface ;
#line 56 "/usr/include/glib-2.0/gio/gproxy.h"
typedef struct _GProxyInterface GProxyInterface;
#line 71 "/usr/include/glib-2.0/gio/gproxy.h"
struct _GProxyInterface {
   GTypeInterface g_iface ;
   GIOStream *(*connect)(GProxy * , GIOStream * , GProxyAddress * , GCancellable * ,
                         GError ** ) ;
   void (*connect_async)(GProxy * , GIOStream * , GProxyAddress * , GCancellable * ,
                         GAsyncReadyCallback  , gpointer  ) ;
   GIOStream *(*connect_finish)(GProxy * , GAsyncResult * , GError ** ) ;
   gboolean (*supports_hostname)(GProxy * ) ;
};
#line 39 "/usr/include/glib-2.0/gio/gproxyaddress.h"
struct _GProxyAddressClass ;
#line 39 "/usr/include/glib-2.0/gio/gproxyaddress.h"
typedef struct _GProxyAddressClass GProxyAddressClass;
#line 40
struct _GProxyAddressPrivate ;
#line 40 "/usr/include/glib-2.0/gio/gproxyaddress.h"
typedef struct _GProxyAddressPrivate GProxyAddressPrivate;
#line 42 "/usr/include/glib-2.0/gio/gproxyaddress.h"
struct _GProxyAddress {
   GInetSocketAddress parent_instance ;
   GProxyAddressPrivate *priv ;
};
#line 50 "/usr/include/glib-2.0/gio/gproxyaddress.h"
struct _GProxyAddressClass {
   GInetSocketAddressClass parent_class ;
};
#line 43 "/usr/include/glib-2.0/gio/gsocketaddressenumerator.h"
struct _GSocketAddressEnumeratorClass ;
#line 43 "/usr/include/glib-2.0/gio/gsocketaddressenumerator.h"
typedef struct _GSocketAddressEnumeratorClass GSocketAddressEnumeratorClass;
#line 45 "/usr/include/glib-2.0/gio/gsocketaddressenumerator.h"
struct _GSocketAddressEnumerator {
   GObject parent_instance ;
};
#line 59 "/usr/include/glib-2.0/gio/gsocketaddressenumerator.h"
struct _GSocketAddressEnumeratorClass {
   GObjectClass parent_class ;
   GSocketAddress *(*next)(GSocketAddressEnumerator * , GCancellable * , GError ** ) ;
   void (*next_async)(GSocketAddressEnumerator * , GCancellable * , GAsyncReadyCallback  ,
                      gpointer  ) ;
   GSocketAddress *(*next_finish)(GSocketAddressEnumerator * , GAsyncResult * , GError ** ) ;
};
#line 47 "/usr/include/glib-2.0/gio/gproxyaddressenumerator.h"
struct _GProxyAddressEnumeratorClass ;
#line 47 "/usr/include/glib-2.0/gio/gproxyaddressenumerator.h"
typedef struct _GProxyAddressEnumeratorClass GProxyAddressEnumeratorClass;
#line 48
struct _GProxyAddressEnumeratorPrivate ;
#line 48 "/usr/include/glib-2.0/gio/gproxyaddressenumerator.h"
typedef struct _GProxyAddressEnumeratorPrivate GProxyAddressEnumeratorPrivate;
#line 50 "/usr/include/glib-2.0/gio/gproxyaddressenumerator.h"
struct _GProxyAddressEnumerator {
   GSocketAddressEnumerator parent_instance ;
   GProxyAddressEnumeratorPrivate *priv ;
};
#line 62 "/usr/include/glib-2.0/gio/gproxyaddressenumerator.h"
struct _GProxyAddressEnumeratorClass {
   GSocketAddressEnumeratorClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
   void (*_g_reserved6)(void) ;
   void (*_g_reserved7)(void) ;
};
#line 45 "/usr/include/glib-2.0/gio/gproxyresolver.h"
struct _GProxyResolverInterface ;
#line 45 "/usr/include/glib-2.0/gio/gproxyresolver.h"
typedef struct _GProxyResolverInterface GProxyResolverInterface;
#line 47 "/usr/include/glib-2.0/gio/gproxyresolver.h"
struct _GProxyResolverInterface {
   GTypeInterface g_iface ;
   gboolean (*is_supported)(GProxyResolver * ) ;
   gchar **(*lookup)(GProxyResolver * , gchar * , GCancellable * , GError ** ) ;
   void (*lookup_async)(GProxyResolver * , gchar * , GCancellable * , GAsyncReadyCallback  ,
                        gpointer  ) ;
   gchar **(*lookup_finish)(GProxyResolver * , GAsyncResult * , GError ** ) ;
};
#line 41 "/usr/include/glib-2.0/gio/gremoteactiongroup.h"
struct _GRemoteActionGroupInterface ;
#line 41 "/usr/include/glib-2.0/gio/gremoteactiongroup.h"
typedef struct _GRemoteActionGroupInterface GRemoteActionGroupInterface;
#line 43 "/usr/include/glib-2.0/gio/gremoteactiongroup.h"
struct _GRemoteActionGroupInterface {
   GTypeInterface g_iface ;
   void (*activate_action_full)(GRemoteActionGroup * , gchar * , GVariant * , GVariant * ) ;
   void (*change_action_state_full)(GRemoteActionGroup * , gchar * , GVariant * ,
                                    GVariant * ) ;
};
#line 38 "/usr/include/glib-2.0/gio/gresolver.h"
struct _GResolverPrivate ;
#line 38 "/usr/include/glib-2.0/gio/gresolver.h"
typedef struct _GResolverPrivate GResolverPrivate;
#line 39
struct _GResolverClass ;
#line 39 "/usr/include/glib-2.0/gio/gresolver.h"
typedef struct _GResolverClass GResolverClass;
#line 41 "/usr/include/glib-2.0/gio/gresolver.h"
struct _GResolver {
   GObject parent_instance ;
   GResolverPrivate *priv ;
};
#line 57
enum __anonenum__388 {
    G_RESOLVER_NAME_LOOKUP_FLAGS_DEFAULT = 0,
    G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY = 1,
    G_RESOLVER_NAME_LOOKUP_FLAGS_IPV6_ONLY = 2
} ;
#line 61 "/usr/include/glib-2.0/gio/gresolver.h"
typedef enum __anonenum__388 GResolverNameLookupFlags;
#line 63 "/usr/include/glib-2.0/gio/gresolver.h"
struct _GResolverClass {
   GObjectClass parent_class ;
   void (*reload)(GResolver * ) ;
   GList *(*lookup_by_name)(GResolver * , gchar * , GCancellable * , GError ** ) ;
   void (*lookup_by_name_async)(GResolver * , gchar * , GCancellable * , GAsyncReadyCallback  ,
                                gpointer  ) ;
   GList *(*lookup_by_name_finish)(GResolver * , GAsyncResult * , GError ** ) ;
   gchar *(*lookup_by_address)(GResolver * , GInetAddress * , GCancellable * , GError ** ) ;
   void (*lookup_by_address_async)(GResolver * , GInetAddress * , GCancellable * ,
                                   GAsyncReadyCallback  , gpointer  ) ;
   gchar *(*lookup_by_address_finish)(GResolver * , GAsyncResult * , GError ** ) ;
   GList *(*lookup_service)(GResolver * , gchar * , GCancellable * , GError ** ) ;
   void (*lookup_service_async)(GResolver * , gchar * , GCancellable * , GAsyncReadyCallback  ,
                                gpointer  ) ;
   GList *(*lookup_service_finish)(GResolver * , GAsyncResult * , GError ** ) ;
   GList *(*lookup_records)(GResolver * , gchar * , GResolverRecordType  , GCancellable * ,
                            GError ** ) ;
   void (*lookup_records_async)(GResolver * , gchar * , GResolverRecordType  , GCancellable * ,
                                GAsyncReadyCallback  , gpointer  ) ;
   GList *(*lookup_records_finish)(GResolver * , GAsyncResult * , GError ** ) ;
   void (*lookup_by_name_with_flags_async)(GResolver * , gchar * , GResolverNameLookupFlags  ,
                                           GCancellable * , GAsyncReadyCallback  ,
                                           gpointer  ) ;
   GList *(*lookup_by_name_with_flags_finish)(GResolver * , GAsyncResult * , GError ** ) ;
   GList *(*lookup_by_name_with_flags)(GResolver * , gchar * , GResolverNameLookupFlags  ,
                                       GCancellable * , GError ** ) ;
};
#line 51 "/usr/include/glib-2.0/gio/gresource.h"
struct _GStaticResource ;
#line 51 "/usr/include/glib-2.0/gio/gresource.h"
typedef struct _GStaticResource GStaticResource;
#line 53 "/usr/include/glib-2.0/gio/gresource.h"
struct _GStaticResource {
   guint8 *data ;
   gsize data_len ;
   GResource *resource ;
   GStaticResource *next ;
   gpointer padding ;
};
#line 42 "/usr/include/glib-2.0/gio/gseekable.h"
struct _GSeekableIface ;
#line 42 "/usr/include/glib-2.0/gio/gseekable.h"
typedef struct _GSeekableIface GSeekableIface;
#line 55 "/usr/include/glib-2.0/gio/gseekable.h"
struct _GSeekableIface {
   GTypeInterface g_iface ;
   goffset (*tell)(GSeekable * ) ;
   gboolean (*can_seek)(GSeekable * ) ;
   gboolean (*seek)(GSeekable * , goffset  , GSeekType  , GCancellable * , GError ** ) ;
   gboolean (*can_truncate)(GSeekable * ) ;
   gboolean (*truncate_fn)(GSeekable * , goffset  , GCancellable * , GError ** ) ;
};
#line 26 "/usr/include/glib-2.0/gio/gsettingsschema.h"
struct _GSettingsSchemaSource ;
#line 26 "/usr/include/glib-2.0/gio/gsettingsschema.h"
typedef struct _GSettingsSchemaSource GSettingsSchemaSource;
#line 27
struct _GSettingsSchema ;
#line 27 "/usr/include/glib-2.0/gio/gsettingsschema.h"
typedef struct _GSettingsSchema GSettingsSchema;
#line 28
struct _GSettingsSchemaKey ;
#line 28 "/usr/include/glib-2.0/gio/gsettingsschema.h"
typedef struct _GSettingsSchemaKey GSettingsSchemaKey;
#line 42 "/usr/include/glib-2.0/gio/gsettings.h"
struct _GSettingsPrivate ;
#line 42 "/usr/include/glib-2.0/gio/gsettings.h"
typedef struct _GSettingsPrivate GSettingsPrivate;
#line 43
struct _GSettingsClass ;
#line 43 "/usr/include/glib-2.0/gio/gsettings.h"
typedef struct _GSettingsClass GSettingsClass;
#line 45 "/usr/include/glib-2.0/gio/gsettings.h"
struct _GSettingsClass {
   GObjectClass parent_class ;
   void (*writable_changed)(GSettings * , gchar * ) ;
   void (*changed)(GSettings * , gchar * ) ;
   gboolean (*writable_change_event)(GSettings * , GQuark  ) ;
   gboolean (*change_event)(GSettings * , GQuark * , gint  ) ;
   gpointer padding[20] ;
};
#line 63 "/usr/include/glib-2.0/gio/gsettings.h"
struct _GSettings {
   GObject parent_instance ;
   GSettingsPrivate *priv ;
};
#line 235 "/usr/include/glib-2.0/gio/gsettings.h"
typedef GVariant *(*GSettingsBindSetMapping)(GValue * , GVariantType * , gpointer  );
#line 251 "/usr/include/glib-2.0/gio/gsettings.h"
typedef gboolean (*GSettingsBindGetMapping)(GValue * , GVariant * , gpointer  );
#line 275 "/usr/include/glib-2.0/gio/gsettings.h"
typedef gboolean (*GSettingsGetMapping)(GVariant * , gpointer * , gpointer  );
#line 297
enum __anonenum__389 {
    G_SETTINGS_BIND_DEFAULT = 0,
    G_SETTINGS_BIND_GET = 1,
    G_SETTINGS_BIND_SET = 2,
    G_SETTINGS_BIND_NO_SENSITIVITY = 4,
    G_SETTINGS_BIND_GET_NO_CHANGES = 8,
    G_SETTINGS_BIND_INVERT_BOOLEAN = 16
} ;
#line 305 "/usr/include/glib-2.0/gio/gsettings.h"
typedef enum __anonenum__389 GSettingsBindFlags;
#line 44 "/usr/include/glib-2.0/gio/gsimpleactiongroup.h"
struct _GSimpleActionGroupPrivate ;
#line 44 "/usr/include/glib-2.0/gio/gsimpleactiongroup.h"
typedef struct _GSimpleActionGroupPrivate GSimpleActionGroupPrivate;
#line 45
struct _GSimpleActionGroupClass ;
#line 45 "/usr/include/glib-2.0/gio/gsimpleactiongroup.h"
typedef struct _GSimpleActionGroupClass GSimpleActionGroupClass;
#line 54 "/usr/include/glib-2.0/gio/gsimpleactiongroup.h"
struct _GSimpleActionGroup {
   GObject parent_instance ;
   GSimpleActionGroupPrivate *priv ;
};
#line 62 "/usr/include/glib-2.0/gio/gsimpleactiongroup.h"
struct _GSimpleActionGroupClass {
   GObjectClass parent_class ;
   gpointer padding[12] ;
};
#line 44 "/usr/include/glib-2.0/gio/gsimpleasyncresult.h"
struct _GSimpleAsyncResultClass ;
#line 44 "/usr/include/glib-2.0/gio/gsimpleasyncresult.h"
typedef struct _GSimpleAsyncResultClass GSimpleAsyncResultClass;
#line 42 "/usr/include/glib-2.0/gio/gsimpleproxyresolver.h"
struct _GSimpleProxyResolver ;
#line 42 "/usr/include/glib-2.0/gio/gsimpleproxyresolver.h"
typedef struct _GSimpleProxyResolver GSimpleProxyResolver;
#line 43
struct _GSimpleProxyResolverPrivate ;
#line 43 "/usr/include/glib-2.0/gio/gsimpleproxyresolver.h"
typedef struct _GSimpleProxyResolverPrivate GSimpleProxyResolverPrivate;
#line 44
struct _GSimpleProxyResolverClass ;
#line 44 "/usr/include/glib-2.0/gio/gsimpleproxyresolver.h"
typedef struct _GSimpleProxyResolverClass GSimpleProxyResolverClass;
#line 46 "/usr/include/glib-2.0/gio/gsimpleproxyresolver.h"
struct _GSimpleProxyResolver {
   GObject parent_instance ;
   GSimpleProxyResolverPrivate *priv ;
};
#line 54 "/usr/include/glib-2.0/gio/gsimpleproxyresolver.h"
struct _GSimpleProxyResolverClass {
   GObjectClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 46 "/usr/include/glib-2.0/gio/gsocket.h"
struct _GSocketPrivate ;
#line 46 "/usr/include/glib-2.0/gio/gsocket.h"
typedef struct _GSocketPrivate GSocketPrivate;
#line 47
struct _GSocketClass ;
#line 47 "/usr/include/glib-2.0/gio/gsocket.h"
typedef struct _GSocketClass GSocketClass;
#line 49 "/usr/include/glib-2.0/gio/gsocket.h"
struct _GSocketClass {
   GObjectClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
   void (*_g_reserved6)(void) ;
   void (*_g_reserved7)(void) ;
   void (*_g_reserved8)(void) ;
   void (*_g_reserved9)(void) ;
   void (*_g_reserved10)(void) ;
};
#line 68 "/usr/include/glib-2.0/gio/gsocket.h"
struct _GSocket {
   GObject parent_instance ;
   GSocketPrivate *priv ;
};
#line 46 "/usr/include/glib-2.0/gio/gsocketclient.h"
struct _GSocketClientPrivate ;
#line 46 "/usr/include/glib-2.0/gio/gsocketclient.h"
typedef struct _GSocketClientPrivate GSocketClientPrivate;
#line 47
struct _GSocketClientClass ;
#line 47 "/usr/include/glib-2.0/gio/gsocketclient.h"
typedef struct _GSocketClientClass GSocketClientClass;
#line 49 "/usr/include/glib-2.0/gio/gsocketclient.h"
struct _GSocketClientClass {
   GObjectClass parent_class ;
   void (*event)(GSocketClient * , GSocketClientEvent  , GSocketConnectable * , GIOStream * ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
};
#line 65 "/usr/include/glib-2.0/gio/gsocketclient.h"
struct _GSocketClient {
   GObject parent_instance ;
   GSocketClientPrivate *priv ;
};
#line 40 "/usr/include/glib-2.0/gio/gsocketconnectable.h"
struct _GSocketConnectableIface ;
#line 40 "/usr/include/glib-2.0/gio/gsocketconnectable.h"
typedef struct _GSocketConnectableIface GSocketConnectableIface;
#line 53 "/usr/include/glib-2.0/gio/gsocketconnectable.h"
struct _GSocketConnectableIface {
   GTypeInterface g_iface ;
   GSocketAddressEnumerator *(*enumerate)(GSocketConnectable * ) ;
   GSocketAddressEnumerator *(*proxy_enumerate)(GSocketConnectable * ) ;
   gchar *(*to_string)(GSocketConnectable * ) ;
};
#line 49 "/usr/include/glib-2.0/gio/gsocketconnection.h"
struct _GSocketConnectionPrivate ;
#line 49 "/usr/include/glib-2.0/gio/gsocketconnection.h"
typedef struct _GSocketConnectionPrivate GSocketConnectionPrivate;
#line 50
struct _GSocketConnectionClass ;
#line 50 "/usr/include/glib-2.0/gio/gsocketconnection.h"
typedef struct _GSocketConnectionClass GSocketConnectionClass;
#line 52 "/usr/include/glib-2.0/gio/gsocketconnection.h"
struct _GSocketConnectionClass {
   GIOStreamClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
   void (*_g_reserved6)(void) ;
};
#line 65 "/usr/include/glib-2.0/gio/gsocketconnection.h"
struct _GSocketConnection {
   GIOStream parent_instance ;
   GSocketConnectionPrivate *priv ;
};
#line 47 "/usr/include/glib-2.0/gio/gsocketcontrolmessage.h"
struct _GSocketControlMessagePrivate ;
#line 47 "/usr/include/glib-2.0/gio/gsocketcontrolmessage.h"
typedef struct _GSocketControlMessagePrivate GSocketControlMessagePrivate;
#line 48
struct _GSocketControlMessageClass ;
#line 48 "/usr/include/glib-2.0/gio/gsocketcontrolmessage.h"
typedef struct _GSocketControlMessageClass GSocketControlMessageClass;
#line 61 "/usr/include/glib-2.0/gio/gsocketcontrolmessage.h"
struct _GSocketControlMessageClass {
   GObjectClass parent_class ;
   gsize (*get_size)(GSocketControlMessage * ) ;
   int (*get_level)(GSocketControlMessage * ) ;
   int (*get_type)(GSocketControlMessage * ) ;
   void (*serialize)(GSocketControlMessage * , gpointer  ) ;
   GSocketControlMessage *(*deserialize)(int  , int  , gsize  , gpointer  ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 85 "/usr/include/glib-2.0/gio/gsocketcontrolmessage.h"
struct _GSocketControlMessage {
   GObject parent_instance ;
   GSocketControlMessagePrivate *priv ;
};
#line 49 "/usr/include/glib-2.0/gio/gsocketlistener.h"
struct _GSocketListenerPrivate ;
#line 49 "/usr/include/glib-2.0/gio/gsocketlistener.h"
typedef struct _GSocketListenerPrivate GSocketListenerPrivate;
#line 50
struct _GSocketListenerClass ;
#line 50 "/usr/include/glib-2.0/gio/gsocketlistener.h"
typedef struct _GSocketListenerClass GSocketListenerClass;
#line 58 "/usr/include/glib-2.0/gio/gsocketlistener.h"
struct _GSocketListenerClass {
   GObjectClass parent_class ;
   void (*changed)(GSocketListener * ) ;
   void (*event)(GSocketListener * , GSocketListenerEvent  , GSocket * ) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
   void (*_g_reserved6)(void) ;
};
#line 76 "/usr/include/glib-2.0/gio/gsocketlistener.h"
struct _GSocketListener {
   GObject parent_instance ;
   GSocketListenerPrivate *priv ;
};
#line 46 "/usr/include/glib-2.0/gio/gsocketservice.h"
struct _GSocketServicePrivate ;
#line 46 "/usr/include/glib-2.0/gio/gsocketservice.h"
typedef struct _GSocketServicePrivate GSocketServicePrivate;
#line 47
struct _GSocketServiceClass ;
#line 47 "/usr/include/glib-2.0/gio/gsocketservice.h"
typedef struct _GSocketServiceClass GSocketServiceClass;
#line 55 "/usr/include/glib-2.0/gio/gsocketservice.h"
struct _GSocketServiceClass {
   GSocketListenerClass parent_class ;
   gboolean (*incoming)(GSocketService * , GSocketConnection * , GObject * ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
   void (*_g_reserved6)(void) ;
};
#line 72 "/usr/include/glib-2.0/gio/gsocketservice.h"
struct _GSocketService {
   GSocketListener parent_instance ;
   GSocketServicePrivate *priv ;
};
#line 37 "/usr/include/glib-2.0/gio/gtask.h"
struct _GTaskClass ;
#line 37 "/usr/include/glib-2.0/gio/gtask.h"
typedef struct _GTaskClass GTaskClass;
#line 113 "/usr/include/glib-2.0/gio/gtask.h"
typedef void (*GTaskThreadFunc)(GTask * , gpointer  , gpointer  , GCancellable * );
#line 44 "/usr/include/glib-2.0/gio/gtcpconnection.h"
struct _GTcpConnectionPrivate ;
#line 44 "/usr/include/glib-2.0/gio/gtcpconnection.h"
typedef struct _GTcpConnectionPrivate GTcpConnectionPrivate;
#line 45
struct _GTcpConnectionClass ;
#line 45 "/usr/include/glib-2.0/gio/gtcpconnection.h"
typedef struct _GTcpConnectionClass GTcpConnectionClass;
#line 47 "/usr/include/glib-2.0/gio/gtcpconnection.h"
struct _GTcpConnectionClass {
   GSocketConnectionClass parent_class ;
};
#line 52 "/usr/include/glib-2.0/gio/gtcpconnection.h"
struct _GTcpConnection {
   GSocketConnection parent_instance ;
   GTcpConnectionPrivate *priv ;
};
#line 44 "/usr/include/glib-2.0/gio/gtcpwrapperconnection.h"
struct _GTcpWrapperConnectionPrivate ;
#line 44 "/usr/include/glib-2.0/gio/gtcpwrapperconnection.h"
typedef struct _GTcpWrapperConnectionPrivate GTcpWrapperConnectionPrivate;
#line 45
struct _GTcpWrapperConnectionClass ;
#line 45 "/usr/include/glib-2.0/gio/gtcpwrapperconnection.h"
typedef struct _GTcpWrapperConnectionClass GTcpWrapperConnectionClass;
#line 47 "/usr/include/glib-2.0/gio/gtcpwrapperconnection.h"
struct _GTcpWrapperConnectionClass {
   GTcpConnectionClass parent_class ;
};
#line 52 "/usr/include/glib-2.0/gio/gtcpwrapperconnection.h"
struct _GTcpWrapperConnection {
   GTcpConnection parent_instance ;
   GTcpWrapperConnectionPrivate *priv ;
};
#line 44 "/usr/include/glib-2.0/gio/gthemedicon.h"
struct _GThemedIconClass ;
#line 44 "/usr/include/glib-2.0/gio/gthemedicon.h"
typedef struct _GThemedIconClass GThemedIconClass;
#line 49 "/usr/include/glib-2.0/gio/gthreadedsocketservice.h"
struct _GThreadedSocketServicePrivate ;
#line 49 "/usr/include/glib-2.0/gio/gthreadedsocketservice.h"
typedef struct _GThreadedSocketServicePrivate GThreadedSocketServicePrivate;
#line 50
struct _GThreadedSocketServiceClass ;
#line 50 "/usr/include/glib-2.0/gio/gthreadedsocketservice.h"
typedef struct _GThreadedSocketServiceClass GThreadedSocketServiceClass;
#line 52 "/usr/include/glib-2.0/gio/gthreadedsocketservice.h"
struct _GThreadedSocketServiceClass {
   GSocketServiceClass parent_class ;
   gboolean (*run)(GThreadedSocketService * , GSocketConnection * , GObject * ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 68 "/usr/include/glib-2.0/gio/gthreadedsocketservice.h"
struct _GThreadedSocketService {
   GSocketService parent_instance ;
   GThreadedSocketServicePrivate *priv ;
};
#line 44 "/usr/include/glib-2.0/gio/gtlsbackend.h"
struct _GTlsBackend ;
#line 44 "/usr/include/glib-2.0/gio/gtlsbackend.h"
typedef struct _GTlsBackend GTlsBackend;
#line 45
struct _GTlsBackendInterface ;
#line 45 "/usr/include/glib-2.0/gio/gtlsbackend.h"
typedef struct _GTlsBackendInterface GTlsBackendInterface;
#line 64 "/usr/include/glib-2.0/gio/gtlsbackend.h"
struct _GTlsBackendInterface {
   GTypeInterface g_iface ;
   gboolean (*supports_tls)(GTlsBackend * ) ;
   GType (*get_certificate_type)(void) ;
   GType (*get_client_connection_type)(void) ;
   GType (*get_server_connection_type)(void) ;
   GType (*get_file_database_type)(void) ;
   GTlsDatabase *(*get_default_database)(GTlsBackend * ) ;
   gboolean (*supports_dtls)(GTlsBackend * ) ;
   GType (*get_dtls_client_connection_type)(void) ;
   GType (*get_dtls_server_connection_type)(void) ;
};
#line 37 "/usr/include/glib-2.0/gio/gtlscertificate.h"
struct _GTlsCertificateClass ;
#line 37 "/usr/include/glib-2.0/gio/gtlscertificate.h"
typedef struct _GTlsCertificateClass GTlsCertificateClass;
#line 38
struct _GTlsCertificatePrivate ;
#line 38 "/usr/include/glib-2.0/gio/gtlscertificate.h"
typedef struct _GTlsCertificatePrivate GTlsCertificatePrivate;
#line 40 "/usr/include/glib-2.0/gio/gtlscertificate.h"
struct _GTlsCertificate {
   GObject parent_instance ;
   GTlsCertificatePrivate *priv ;
};
#line 46 "/usr/include/glib-2.0/gio/gtlscertificate.h"
struct _GTlsCertificateClass {
   GObjectClass parent_class ;
   GTlsCertificateFlags (*verify)(GTlsCertificate * , GSocketConnectable * , GTlsCertificate * ) ;
   gpointer padding[8] ;
};
#line 37 "/usr/include/glib-2.0/gio/gtlsconnection.h"
struct _GTlsConnectionClass ;
#line 37 "/usr/include/glib-2.0/gio/gtlsconnection.h"
typedef struct _GTlsConnectionClass GTlsConnectionClass;
#line 38
struct _GTlsConnectionPrivate ;
#line 38 "/usr/include/glib-2.0/gio/gtlsconnection.h"
typedef struct _GTlsConnectionPrivate GTlsConnectionPrivate;
#line 40 "/usr/include/glib-2.0/gio/gtlsconnection.h"
struct _GTlsConnection {
   GIOStream parent_instance ;
   GTlsConnectionPrivate *priv ;
};
#line 60 "/usr/include/glib-2.0/gio/gtlsconnection.h"
struct _GTlsConnectionClass {
   GIOStreamClass parent_class ;
   gboolean (*accept_certificate)(GTlsConnection * , GTlsCertificate * , GTlsCertificateFlags  ) ;
   gboolean (*handshake)(GTlsConnection * , GCancellable * , GError ** ) ;
   void (*handshake_async)(GTlsConnection * , int  , GCancellable * , GAsyncReadyCallback  ,
                           gpointer  ) ;
   gboolean (*handshake_finish)(GTlsConnection * , GAsyncResult * , GError ** ) ;
   gboolean (*get_binding_data)(GTlsConnection * , GTlsChannelBindingType  , GByteArray * ,
                                GError ** ) ;
   gchar *(*get_negotiated_protocol)(GTlsConnection * ) ;
   gpointer padding[6] ;
};
#line 35 "/usr/include/glib-2.0/gio/gtlsclientconnection.h"
struct _GTlsClientConnectionInterface ;
#line 35 "/usr/include/glib-2.0/gio/gtlsclientconnection.h"
typedef struct _GTlsClientConnectionInterface GTlsClientConnectionInterface;
#line 46 "/usr/include/glib-2.0/gio/gtlsclientconnection.h"
struct _GTlsClientConnectionInterface {
   GTypeInterface g_iface ;
   void (*copy_session_state)(GTlsClientConnection * , GTlsClientConnection * ) ;
};
#line 42 "/usr/include/glib-2.0/gio/gtlsdatabase.h"
struct _GTlsDatabaseClass ;
#line 42 "/usr/include/glib-2.0/gio/gtlsdatabase.h"
typedef struct _GTlsDatabaseClass GTlsDatabaseClass;
#line 43
struct _GTlsDatabasePrivate ;
#line 43 "/usr/include/glib-2.0/gio/gtlsdatabase.h"
typedef struct _GTlsDatabasePrivate GTlsDatabasePrivate;
#line 45 "/usr/include/glib-2.0/gio/gtlsdatabase.h"
struct _GTlsDatabase {
   GObject parent_instance ;
   GTlsDatabasePrivate *priv ;
};
#line 52 "/usr/include/glib-2.0/gio/gtlsdatabase.h"
struct _GTlsDatabaseClass {
   GObjectClass parent_class ;
   GTlsCertificateFlags (*verify_chain)(GTlsDatabase * , GTlsCertificate * , gchar * ,
                                        GSocketConnectable * , GTlsInteraction * ,
                                        GTlsDatabaseVerifyFlags  , GCancellable * ,
                                        GError ** ) ;
   void (*verify_chain_async)(GTlsDatabase * , GTlsCertificate * , gchar * , GSocketConnectable * ,
                              GTlsInteraction * , GTlsDatabaseVerifyFlags  , GCancellable * ,
                              GAsyncReadyCallback  , gpointer  ) ;
   GTlsCertificateFlags (*verify_chain_finish)(GTlsDatabase * , GAsyncResult * , GError ** ) ;
   gchar *(*create_certificate_handle)(GTlsDatabase * , GTlsCertificate * ) ;
   GTlsCertificate *(*lookup_certificate_for_handle)(GTlsDatabase * , gchar * , GTlsInteraction * ,
                                                     GTlsDatabaseLookupFlags  , GCancellable * ,
                                                     GError ** ) ;
   void (*lookup_certificate_for_handle_async)(GTlsDatabase * , gchar * , GTlsInteraction * ,
                                               GTlsDatabaseLookupFlags  , GCancellable * ,
                                               GAsyncReadyCallback  , gpointer  ) ;
   GTlsCertificate *(*lookup_certificate_for_handle_finish)(GTlsDatabase * , GAsyncResult * ,
                                                            GError ** ) ;
   GTlsCertificate *(*lookup_certificate_issuer)(GTlsDatabase * , GTlsCertificate * ,
                                                 GTlsInteraction * , GTlsDatabaseLookupFlags  ,
                                                 GCancellable * , GError ** ) ;
   void (*lookup_certificate_issuer_async)(GTlsDatabase * , GTlsCertificate * , GTlsInteraction * ,
                                           GTlsDatabaseLookupFlags  , GCancellable * ,
                                           GAsyncReadyCallback  , gpointer  ) ;
   GTlsCertificate *(*lookup_certificate_issuer_finish)(GTlsDatabase * , GAsyncResult * ,
                                                        GError ** ) ;
   GList *(*lookup_certificates_issued_by)(GTlsDatabase * , GByteArray * , GTlsInteraction * ,
                                           GTlsDatabaseLookupFlags  , GCancellable * ,
                                           GError ** ) ;
   void (*lookup_certificates_issued_by_async)(GTlsDatabase * , GByteArray * , GTlsInteraction * ,
                                               GTlsDatabaseLookupFlags  , GCancellable * ,
                                               GAsyncReadyCallback  , gpointer  ) ;
   GList *(*lookup_certificates_issued_by_finish)(GTlsDatabase * , GAsyncResult * ,
                                                  GError ** ) ;
   gpointer padding[16] ;
};
#line 31 "/usr/include/glib-2.0/gio/gtlsfiledatabase.h"
struct _GTlsFileDatabaseInterface ;
#line 31 "/usr/include/glib-2.0/gio/gtlsfiledatabase.h"
typedef struct _GTlsFileDatabaseInterface GTlsFileDatabaseInterface;
#line 40 "/usr/include/glib-2.0/gio/gtlsfiledatabase.h"
struct _GTlsFileDatabaseInterface {
   GTypeInterface g_iface ;
   gpointer padding[8] ;
};
#line 39 "/usr/include/glib-2.0/gio/gtlsinteraction.h"
struct _GTlsInteractionClass ;
#line 39 "/usr/include/glib-2.0/gio/gtlsinteraction.h"
typedef struct _GTlsInteractionClass GTlsInteractionClass;
#line 40
struct _GTlsInteractionPrivate ;
#line 40 "/usr/include/glib-2.0/gio/gtlsinteraction.h"
typedef struct _GTlsInteractionPrivate GTlsInteractionPrivate;
#line 42 "/usr/include/glib-2.0/gio/gtlsinteraction.h"
struct _GTlsInteraction {
   GObject parent_instance ;
   GTlsInteractionPrivate *priv ;
};
#line 49 "/usr/include/glib-2.0/gio/gtlsinteraction.h"
struct _GTlsInteractionClass {
   GObjectClass parent_class ;
   GTlsInteractionResult (*ask_password)(GTlsInteraction * , GTlsPassword * , GCancellable * ,
                                         GError ** ) ;
   void (*ask_password_async)(GTlsInteraction * , GTlsPassword * , GCancellable * ,
                              GAsyncReadyCallback  , gpointer  ) ;
   GTlsInteractionResult (*ask_password_finish)(GTlsInteraction * , GAsyncResult * ,
                                                GError ** ) ;
   GTlsInteractionResult (*request_certificate)(GTlsInteraction * , GTlsConnection * ,
                                                GTlsCertificateRequestFlags  , GCancellable * ,
                                                GError ** ) ;
   void (*request_certificate_async)(GTlsInteraction * , GTlsConnection * , GTlsCertificateRequestFlags  ,
                                     GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   GTlsInteractionResult (*request_certificate_finish)(GTlsInteraction * , GAsyncResult * ,
                                                       GError ** ) ;
   gpointer padding[21] ;
};
#line 39 "/usr/include/glib-2.0/gio/gtlspassword.h"
struct _GTlsPasswordClass ;
#line 39 "/usr/include/glib-2.0/gio/gtlspassword.h"
typedef struct _GTlsPasswordClass GTlsPasswordClass;
#line 40
struct _GTlsPasswordPrivate ;
#line 40 "/usr/include/glib-2.0/gio/gtlspassword.h"
typedef struct _GTlsPasswordPrivate GTlsPasswordPrivate;
#line 42 "/usr/include/glib-2.0/gio/gtlspassword.h"
struct _GTlsPassword {
   GObject parent_instance ;
   GTlsPasswordPrivate *priv ;
};
#line 58 "/usr/include/glib-2.0/gio/gtlspassword.h"
struct _GTlsPasswordClass {
   GObjectClass parent_class ;
   guchar *(*get_value)(GTlsPassword * , gsize * ) ;
   void (*set_value)(GTlsPassword * , guchar * , gssize  , GDestroyNotify  ) ;
   gchar *(*get_default_warning)(GTlsPassword * ) ;
   gpointer padding[4] ;
};
#line 43 "/usr/include/glib-2.0/gio/gtlsserverconnection.h"
struct _GTlsServerConnectionInterface ;
#line 43 "/usr/include/glib-2.0/gio/gtlsserverconnection.h"
typedef struct _GTlsServerConnectionInterface GTlsServerConnectionInterface;
#line 53 "/usr/include/glib-2.0/gio/gtlsserverconnection.h"
struct _GTlsServerConnectionInterface {
   GTypeInterface g_iface ;
};
#line 57 "/usr/include/glib-2.0/gio/gvfs.h"
typedef GFile *(*GVfsFileLookupFunc)(GVfs * , char const   * , gpointer  );
#line 74
struct _GVfsClass ;
#line 74 "/usr/include/glib-2.0/gio/gvfs.h"
typedef struct _GVfsClass GVfsClass;
#line 76 "/usr/include/glib-2.0/gio/gvfs.h"
struct _GVfs {
   GObject parent_instance ;
};
#line 81 "/usr/include/glib-2.0/gio/gvfs.h"
struct _GVfsClass {
   GObjectClass parent_class ;
   gboolean (*is_active)(GVfs * ) ;
   GFile *(*get_file_for_path)(GVfs * , char const   * ) ;
   GFile *(*get_file_for_uri)(GVfs * , char const   * ) ;
   gchar * const  *(*get_supported_uri_schemes)(GVfs * ) ;
   GFile *(*parse_name)(GVfs * , char const   * ) ;
   void (*local_file_add_info)(GVfs * , char const   * , guint64  , GFileAttributeMatcher * ,
                               GFileInfo * , GCancellable * , gpointer * , GDestroyNotify * ) ;
   void (*add_writable_namespaces)(GVfs * , GFileAttributeInfoList * ) ;
   gboolean (*local_file_set_attributes)(GVfs * , char const   * , GFileInfo * , GFileQueryInfoFlags  ,
                                         GCancellable * , GError ** ) ;
   void (*local_file_removed)(GVfs * , char const   * ) ;
   void (*local_file_moved)(GVfs * , char const   * , char const   * ) ;
   GIcon *(*deserialize_icon)(GVfs * , GVariant * ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
   void (*_g_reserved6)(void) ;
};
#line 124 "/usr/include/glib-2.0/gio/gvolume.h"
struct _GVolumeIface ;
#line 124 "/usr/include/glib-2.0/gio/gvolume.h"
typedef struct _GVolumeIface GVolumeIface;
#line 126 "/usr/include/glib-2.0/gio/gvolume.h"
struct _GVolumeIface {
   GTypeInterface g_iface ;
   void (*changed)(GVolume * ) ;
   void (*removed)(GVolume * ) ;
   char *(*get_name)(GVolume * ) ;
   GIcon *(*get_icon)(GVolume * ) ;
   char *(*get_uuid)(GVolume * ) ;
   GDrive *(*get_drive)(GVolume * ) ;
   GMount *(*get_mount)(GVolume * ) ;
   gboolean (*can_mount)(GVolume * ) ;
   gboolean (*can_eject)(GVolume * ) ;
   void (*mount_fn)(GVolume * , GMountMountFlags  , GMountOperation * , GCancellable * ,
                    GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*mount_finish)(GVolume * , GAsyncResult * , GError ** ) ;
   void (*eject)(GVolume * , GMountUnmountFlags  , GCancellable * , GAsyncReadyCallback  ,
                 gpointer  ) ;
   gboolean (*eject_finish)(GVolume * , GAsyncResult * , GError ** ) ;
   char *(*get_identifier)(GVolume * , char const   * ) ;
   char **(*enumerate_identifiers)(GVolume * ) ;
   gboolean (*should_automount)(GVolume * ) ;
   GFile *(*get_activation_root)(GVolume * ) ;
   void (*eject_with_operation)(GVolume * , GMountUnmountFlags  , GMountOperation * ,
                                GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*eject_with_operation_finish)(GVolume * , GAsyncResult * , GError ** ) ;
   gchar *(*get_sort_key)(GVolume * ) ;
   GIcon *(*get_symbolic_icon)(GVolume * ) ;
};
#line 40 "/usr/include/glib-2.0/gio/gzlibcompressor.h"
struct _GZlibCompressorClass ;
#line 40 "/usr/include/glib-2.0/gio/gzlibcompressor.h"
typedef struct _GZlibCompressorClass GZlibCompressorClass;
#line 42 "/usr/include/glib-2.0/gio/gzlibcompressor.h"
struct _GZlibCompressorClass {
   GObjectClass parent_class ;
};
#line 40 "/usr/include/glib-2.0/gio/gzlibdecompressor.h"
struct _GZlibDecompressorClass ;
#line 40 "/usr/include/glib-2.0/gio/gzlibdecompressor.h"
typedef struct _GZlibDecompressorClass GZlibDecompressorClass;
#line 42 "/usr/include/glib-2.0/gio/gzlibdecompressor.h"
struct _GZlibDecompressorClass {
   GObjectClass parent_class ;
};
#line 24 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GAction *GAction_autoptr;
#line 24 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GAction_listautoptr;
#line 24 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GAction_slistautoptr;
#line 24 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GAction_queueautoptr;
#line 25 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GActionMap *GActionMap_autoptr;
#line 25 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GActionMap_listautoptr;
#line 25 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GActionMap_slistautoptr;
#line 25 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GActionMap_queueautoptr;
#line 26 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GAppInfo *GAppInfo_autoptr;
#line 26 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GAppInfo_listautoptr;
#line 26 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GAppInfo_slistautoptr;
#line 26 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GAppInfo_queueautoptr;
#line 27 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GAppLaunchContext *GAppLaunchContext_autoptr;
#line 27 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GAppLaunchContext_listautoptr;
#line 27 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GAppLaunchContext_slistautoptr;
#line 27 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GAppLaunchContext_queueautoptr;
#line 28 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GAppInfoMonitor *GAppInfoMonitor_autoptr;
#line 28 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GAppInfoMonitor_listautoptr;
#line 28 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GAppInfoMonitor_slistautoptr;
#line 28 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GAppInfoMonitor_queueautoptr;
#line 29 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GApplicationCommandLine *GApplicationCommandLine_autoptr;
#line 29 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GApplicationCommandLine_listautoptr;
#line 29 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GApplicationCommandLine_slistautoptr;
#line 29 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GApplicationCommandLine_queueautoptr;
#line 30 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GApplication *GApplication_autoptr;
#line 30 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GApplication_listautoptr;
#line 30 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GApplication_slistautoptr;
#line 30 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GApplication_queueautoptr;
#line 31 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GAsyncInitable *GAsyncInitable_autoptr;
#line 31 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GAsyncInitable_listautoptr;
#line 31 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GAsyncInitable_slistautoptr;
#line 31 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GAsyncInitable_queueautoptr;
#line 32 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GAsyncResult *GAsyncResult_autoptr;
#line 32 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GAsyncResult_listautoptr;
#line 32 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GAsyncResult_slistautoptr;
#line 32 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GAsyncResult_queueautoptr;
#line 33 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GBufferedInputStream *GBufferedInputStream_autoptr;
#line 33 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GBufferedInputStream_listautoptr;
#line 33 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GBufferedInputStream_slistautoptr;
#line 33 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GBufferedInputStream_queueautoptr;
#line 34 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GBufferedOutputStream *GBufferedOutputStream_autoptr;
#line 34 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GBufferedOutputStream_listautoptr;
#line 34 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GBufferedOutputStream_slistautoptr;
#line 34 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GBufferedOutputStream_queueautoptr;
#line 35 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GBytesIcon *GBytesIcon_autoptr;
#line 35 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GBytesIcon_listautoptr;
#line 35 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GBytesIcon_slistautoptr;
#line 35 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GBytesIcon_queueautoptr;
#line 36 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GCancellable *GCancellable_autoptr;
#line 36 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GCancellable_listautoptr;
#line 36 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GCancellable_slistautoptr;
#line 36 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GCancellable_queueautoptr;
#line 37 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GCharsetConverter *GCharsetConverter_autoptr;
#line 37 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GCharsetConverter_listautoptr;
#line 37 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GCharsetConverter_slistautoptr;
#line 37 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GCharsetConverter_queueautoptr;
#line 38 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GConverter *GConverter_autoptr;
#line 38 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GConverter_listautoptr;
#line 38 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GConverter_slistautoptr;
#line 38 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GConverter_queueautoptr;
#line 39 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GConverterInputStream *GConverterInputStream_autoptr;
#line 39 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GConverterInputStream_listautoptr;
#line 39 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GConverterInputStream_slistautoptr;
#line 39 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GConverterInputStream_queueautoptr;
#line 40 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GConverterOutputStream *GConverterOutputStream_autoptr;
#line 40 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GConverterOutputStream_listautoptr;
#line 40 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GConverterOutputStream_slistautoptr;
#line 40 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GConverterOutputStream_queueautoptr;
#line 41 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GCredentials *GCredentials_autoptr;
#line 41 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GCredentials_listautoptr;
#line 41 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GCredentials_slistautoptr;
#line 41 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GCredentials_queueautoptr;
#line 42 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDatagramBased *GDatagramBased_autoptr;
#line 42 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDatagramBased_listautoptr;
#line 42 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDatagramBased_slistautoptr;
#line 42 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDatagramBased_queueautoptr;
#line 43 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDataInputStream *GDataInputStream_autoptr;
#line 43 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDataInputStream_listautoptr;
#line 43 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDataInputStream_slistautoptr;
#line 43 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDataInputStream_queueautoptr;
#line 44 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDataOutputStream *GDataOutputStream_autoptr;
#line 44 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDataOutputStream_listautoptr;
#line 44 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDataOutputStream_slistautoptr;
#line 44 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDataOutputStream_queueautoptr;
#line 45 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusActionGroup *GDBusActionGroup_autoptr;
#line 45 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusActionGroup_listautoptr;
#line 45 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusActionGroup_slistautoptr;
#line 45 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusActionGroup_queueautoptr;
#line 46 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusAuthObserver *GDBusAuthObserver_autoptr;
#line 46 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusAuthObserver_listautoptr;
#line 46 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusAuthObserver_slistautoptr;
#line 46 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusAuthObserver_queueautoptr;
#line 47 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusConnection *GDBusConnection_autoptr;
#line 47 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusConnection_listautoptr;
#line 47 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusConnection_slistautoptr;
#line 47 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusConnection_queueautoptr;
#line 48 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusInterface *GDBusInterface_autoptr;
#line 48 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusInterface_listautoptr;
#line 48 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusInterface_slistautoptr;
#line 48 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusInterface_queueautoptr;
#line 49 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusInterfaceSkeleton *GDBusInterfaceSkeleton_autoptr;
#line 49 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusInterfaceSkeleton_listautoptr;
#line 49 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusInterfaceSkeleton_slistautoptr;
#line 49 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusInterfaceSkeleton_queueautoptr;
#line 50 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusMenuModel *GDBusMenuModel_autoptr;
#line 50 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusMenuModel_listautoptr;
#line 50 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusMenuModel_slistautoptr;
#line 50 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusMenuModel_queueautoptr;
#line 51 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusMessage *GDBusMessage_autoptr;
#line 51 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusMessage_listautoptr;
#line 51 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusMessage_slistautoptr;
#line 51 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusMessage_queueautoptr;
#line 52 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusMethodInvocation *GDBusMethodInvocation_autoptr;
#line 52 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusMethodInvocation_listautoptr;
#line 52 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusMethodInvocation_slistautoptr;
#line 52 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusMethodInvocation_queueautoptr;
#line 53 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusNodeInfo *GDBusNodeInfo_autoptr;
#line 53 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusNodeInfo_listautoptr;
#line 53 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusNodeInfo_slistautoptr;
#line 53 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusNodeInfo_queueautoptr;
#line 54 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusObject *GDBusObject_autoptr;
#line 54 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusObject_listautoptr;
#line 54 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusObject_slistautoptr;
#line 54 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusObject_queueautoptr;
#line 55 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusObjectManagerClient *GDBusObjectManagerClient_autoptr;
#line 55 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusObjectManagerClient_listautoptr;
#line 55 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusObjectManagerClient_slistautoptr;
#line 55 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusObjectManagerClient_queueautoptr;
#line 56 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusObjectManager *GDBusObjectManager_autoptr;
#line 56 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusObjectManager_listautoptr;
#line 56 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusObjectManager_slistautoptr;
#line 56 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusObjectManager_queueautoptr;
#line 57 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusObjectManagerServer *GDBusObjectManagerServer_autoptr;
#line 57 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusObjectManagerServer_listautoptr;
#line 57 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusObjectManagerServer_slistautoptr;
#line 57 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusObjectManagerServer_queueautoptr;
#line 58 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusObjectProxy *GDBusObjectProxy_autoptr;
#line 58 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusObjectProxy_listautoptr;
#line 58 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusObjectProxy_slistautoptr;
#line 58 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusObjectProxy_queueautoptr;
#line 59 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusObjectSkeleton *GDBusObjectSkeleton_autoptr;
#line 59 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusObjectSkeleton_listautoptr;
#line 59 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusObjectSkeleton_slistautoptr;
#line 59 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusObjectSkeleton_queueautoptr;
#line 60 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusProxy *GDBusProxy_autoptr;
#line 60 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusProxy_listautoptr;
#line 60 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusProxy_slistautoptr;
#line 60 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusProxy_queueautoptr;
#line 61 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusServer *GDBusServer_autoptr;
#line 61 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusServer_listautoptr;
#line 61 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusServer_slistautoptr;
#line 61 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusServer_queueautoptr;
#line 62 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDrive *GDrive_autoptr;
#line 62 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDrive_listautoptr;
#line 62 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDrive_slistautoptr;
#line 62 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDrive_queueautoptr;
#line 63 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GEmblemedIcon *GEmblemedIcon_autoptr;
#line 63 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GEmblemedIcon_listautoptr;
#line 63 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GEmblemedIcon_slistautoptr;
#line 63 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GEmblemedIcon_queueautoptr;
#line 64 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GEmblem *GEmblem_autoptr;
#line 64 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GEmblem_listautoptr;
#line 64 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GEmblem_slistautoptr;
#line 64 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GEmblem_queueautoptr;
#line 65 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFileEnumerator *GFileEnumerator_autoptr;
#line 65 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFileEnumerator_listautoptr;
#line 65 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFileEnumerator_slistautoptr;
#line 65 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFileEnumerator_queueautoptr;
#line 66 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFile *GFile_autoptr;
#line 66 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFile_listautoptr;
#line 66 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFile_slistautoptr;
#line 66 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFile_queueautoptr;
#line 67 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFileAttributeInfoList *GFileAttributeInfoList_autoptr;
#line 67 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFileAttributeInfoList_listautoptr;
#line 67 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFileAttributeInfoList_slistautoptr;
#line 67 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFileAttributeInfoList_queueautoptr;
#line 68 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFileIcon *GFileIcon_autoptr;
#line 68 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFileIcon_listautoptr;
#line 68 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFileIcon_slistautoptr;
#line 68 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFileIcon_queueautoptr;
#line 69 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFileInfo *GFileInfo_autoptr;
#line 69 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFileInfo_listautoptr;
#line 69 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFileInfo_slistautoptr;
#line 69 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFileInfo_queueautoptr;
#line 70 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFileInputStream *GFileInputStream_autoptr;
#line 70 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFileInputStream_listautoptr;
#line 70 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFileInputStream_slistautoptr;
#line 70 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFileInputStream_queueautoptr;
#line 71 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFileIOStream *GFileIOStream_autoptr;
#line 71 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFileIOStream_listautoptr;
#line 71 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFileIOStream_slistautoptr;
#line 71 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFileIOStream_queueautoptr;
#line 72 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFileMonitor *GFileMonitor_autoptr;
#line 72 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFileMonitor_listautoptr;
#line 72 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFileMonitor_slistautoptr;
#line 72 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFileMonitor_queueautoptr;
#line 73 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFilenameCompleter *GFilenameCompleter_autoptr;
#line 73 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFilenameCompleter_listautoptr;
#line 73 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFilenameCompleter_slistautoptr;
#line 73 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFilenameCompleter_queueautoptr;
#line 74 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFileOutputStream *GFileOutputStream_autoptr;
#line 74 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFileOutputStream_listautoptr;
#line 74 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFileOutputStream_slistautoptr;
#line 74 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFileOutputStream_queueautoptr;
#line 75 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFilterInputStream *GFilterInputStream_autoptr;
#line 75 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFilterInputStream_listautoptr;
#line 75 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFilterInputStream_slistautoptr;
#line 75 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFilterInputStream_queueautoptr;
#line 76 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFilterOutputStream *GFilterOutputStream_autoptr;
#line 76 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFilterOutputStream_listautoptr;
#line 76 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFilterOutputStream_slistautoptr;
#line 76 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFilterOutputStream_queueautoptr;
#line 77 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GIcon *GIcon_autoptr;
#line 77 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GIcon_listautoptr;
#line 77 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GIcon_slistautoptr;
#line 77 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GIcon_queueautoptr;
#line 78 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GInetAddress *GInetAddress_autoptr;
#line 78 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GInetAddress_listautoptr;
#line 78 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GInetAddress_slistautoptr;
#line 78 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GInetAddress_queueautoptr;
#line 79 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GInetAddressMask *GInetAddressMask_autoptr;
#line 79 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GInetAddressMask_listautoptr;
#line 79 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GInetAddressMask_slistautoptr;
#line 79 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GInetAddressMask_queueautoptr;
#line 80 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GInetSocketAddress *GInetSocketAddress_autoptr;
#line 80 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GInetSocketAddress_listautoptr;
#line 80 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GInetSocketAddress_slistautoptr;
#line 80 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GInetSocketAddress_queueautoptr;
#line 81 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GInitable *GInitable_autoptr;
#line 81 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GInitable_listautoptr;
#line 81 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GInitable_slistautoptr;
#line 81 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GInitable_queueautoptr;
#line 82 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GInputStream *GInputStream_autoptr;
#line 82 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GInputStream_listautoptr;
#line 82 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GInputStream_slistautoptr;
#line 82 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GInputStream_queueautoptr;
#line 83 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GIOModule *GIOModule_autoptr;
#line 83 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GIOModule_listautoptr;
#line 83 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GIOModule_slistautoptr;
#line 83 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GIOModule_queueautoptr;
#line 84 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GIOStream *GIOStream_autoptr;
#line 84 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GIOStream_listautoptr;
#line 84 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GIOStream_slistautoptr;
#line 84 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GIOStream_queueautoptr;
#line 85 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GLoadableIcon *GLoadableIcon_autoptr;
#line 85 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GLoadableIcon_listautoptr;
#line 85 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GLoadableIcon_slistautoptr;
#line 85 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GLoadableIcon_queueautoptr;
#line 86 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GMemoryInputStream *GMemoryInputStream_autoptr;
#line 86 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GMemoryInputStream_listautoptr;
#line 86 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GMemoryInputStream_slistautoptr;
#line 86 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GMemoryInputStream_queueautoptr;
#line 87 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GMemoryOutputStream *GMemoryOutputStream_autoptr;
#line 87 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GMemoryOutputStream_listautoptr;
#line 87 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GMemoryOutputStream_slistautoptr;
#line 87 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GMemoryOutputStream_queueautoptr;
#line 88 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GMenu *GMenu_autoptr;
#line 88 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GMenu_listautoptr;
#line 88 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GMenu_slistautoptr;
#line 88 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GMenu_queueautoptr;
#line 89 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GMenuItem *GMenuItem_autoptr;
#line 89 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GMenuItem_listautoptr;
#line 89 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GMenuItem_slistautoptr;
#line 89 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GMenuItem_queueautoptr;
#line 90 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GMenuModel *GMenuModel_autoptr;
#line 90 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GMenuModel_listautoptr;
#line 90 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GMenuModel_slistautoptr;
#line 90 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GMenuModel_queueautoptr;
#line 91 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GMenuAttributeIter *GMenuAttributeIter_autoptr;
#line 91 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GMenuAttributeIter_listautoptr;
#line 91 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GMenuAttributeIter_slistautoptr;
#line 91 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GMenuAttributeIter_queueautoptr;
#line 92 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GMenuLinkIter *GMenuLinkIter_autoptr;
#line 92 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GMenuLinkIter_listautoptr;
#line 92 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GMenuLinkIter_slistautoptr;
#line 92 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GMenuLinkIter_queueautoptr;
#line 93 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GMount *GMount_autoptr;
#line 93 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GMount_listautoptr;
#line 93 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GMount_slistautoptr;
#line 93 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GMount_queueautoptr;
#line 94 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GMountOperation *GMountOperation_autoptr;
#line 94 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GMountOperation_listautoptr;
#line 94 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GMountOperation_slistautoptr;
#line 94 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GMountOperation_queueautoptr;
#line 95 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GNativeVolumeMonitor *GNativeVolumeMonitor_autoptr;
#line 95 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GNativeVolumeMonitor_listautoptr;
#line 95 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GNativeVolumeMonitor_slistautoptr;
#line 95 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GNativeVolumeMonitor_queueautoptr;
#line 96 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GNetworkAddress *GNetworkAddress_autoptr;
#line 96 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GNetworkAddress_listautoptr;
#line 96 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GNetworkAddress_slistautoptr;
#line 96 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GNetworkAddress_queueautoptr;
#line 97 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GNetworkMonitor *GNetworkMonitor_autoptr;
#line 97 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GNetworkMonitor_listautoptr;
#line 97 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GNetworkMonitor_slistautoptr;
#line 97 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GNetworkMonitor_queueautoptr;
#line 98 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GNetworkService *GNetworkService_autoptr;
#line 98 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GNetworkService_listautoptr;
#line 98 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GNetworkService_slistautoptr;
#line 98 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GNetworkService_queueautoptr;
#line 99 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GNotification *GNotification_autoptr;
#line 99 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GNotification_listautoptr;
#line 99 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GNotification_slistautoptr;
#line 99 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GNotification_queueautoptr;
#line 100 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GOutputStream *GOutputStream_autoptr;
#line 100 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GOutputStream_listautoptr;
#line 100 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GOutputStream_slistautoptr;
#line 100 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GOutputStream_queueautoptr;
#line 101 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GPermission *GPermission_autoptr;
#line 101 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GPermission_listautoptr;
#line 101 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GPermission_slistautoptr;
#line 101 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GPermission_queueautoptr;
#line 102 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GPollableInputStream *GPollableInputStream_autoptr;
#line 102 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GPollableInputStream_listautoptr;
#line 102 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GPollableInputStream_slistautoptr;
#line 102 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GPollableInputStream_queueautoptr;
#line 103 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GPollableOutputStream *GPollableOutputStream_autoptr;
#line 103 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GPollableOutputStream_listautoptr;
#line 103 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GPollableOutputStream_slistautoptr;
#line 103 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GPollableOutputStream_queueautoptr;
#line 104 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GPropertyAction *GPropertyAction_autoptr;
#line 104 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GPropertyAction_listautoptr;
#line 104 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GPropertyAction_slistautoptr;
#line 104 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GPropertyAction_queueautoptr;
#line 105 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GProxyAddressEnumerator *GProxyAddressEnumerator_autoptr;
#line 105 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GProxyAddressEnumerator_listautoptr;
#line 105 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GProxyAddressEnumerator_slistautoptr;
#line 105 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GProxyAddressEnumerator_queueautoptr;
#line 106 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GProxyAddress *GProxyAddress_autoptr;
#line 106 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GProxyAddress_listautoptr;
#line 106 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GProxyAddress_slistautoptr;
#line 106 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GProxyAddress_queueautoptr;
#line 107 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GProxy *GProxy_autoptr;
#line 107 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GProxy_listautoptr;
#line 107 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GProxy_slistautoptr;
#line 107 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GProxy_queueautoptr;
#line 108 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GProxyResolver *GProxyResolver_autoptr;
#line 108 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GProxyResolver_listautoptr;
#line 108 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GProxyResolver_slistautoptr;
#line 108 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GProxyResolver_queueautoptr;
#line 109 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GRemoteActionGroup *GRemoteActionGroup_autoptr;
#line 109 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GRemoteActionGroup_listautoptr;
#line 109 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GRemoteActionGroup_slistautoptr;
#line 109 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GRemoteActionGroup_queueautoptr;
#line 110 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GResolver *GResolver_autoptr;
#line 110 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GResolver_listautoptr;
#line 110 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GResolver_slistautoptr;
#line 110 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GResolver_queueautoptr;
#line 111 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GResource *GResource_autoptr;
#line 111 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GResource_listautoptr;
#line 111 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GResource_slistautoptr;
#line 111 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GResource_queueautoptr;
#line 112 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSeekable *GSeekable_autoptr;
#line 112 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSeekable_listautoptr;
#line 112 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSeekable_slistautoptr;
#line 112 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSeekable_queueautoptr;
#line 113 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSettingsBackend *GSettingsBackend_autoptr;
#line 113 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSettingsBackend_listautoptr;
#line 113 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSettingsBackend_slistautoptr;
#line 113 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSettingsBackend_queueautoptr;
#line 114 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSettingsSchema *GSettingsSchema_autoptr;
#line 114 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSettingsSchema_listautoptr;
#line 114 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSettingsSchema_slistautoptr;
#line 114 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSettingsSchema_queueautoptr;
#line 115 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSettingsSchemaKey *GSettingsSchemaKey_autoptr;
#line 115 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSettingsSchemaKey_listautoptr;
#line 115 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSettingsSchemaKey_slistautoptr;
#line 115 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSettingsSchemaKey_queueautoptr;
#line 116 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSettingsSchemaSource *GSettingsSchemaSource_autoptr;
#line 116 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSettingsSchemaSource_listautoptr;
#line 116 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSettingsSchemaSource_slistautoptr;
#line 116 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSettingsSchemaSource_queueautoptr;
#line 117 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSettings *GSettings_autoptr;
#line 117 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSettings_listautoptr;
#line 117 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSettings_slistautoptr;
#line 117 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSettings_queueautoptr;
#line 118 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSimpleActionGroup *GSimpleActionGroup_autoptr;
#line 118 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSimpleActionGroup_listautoptr;
#line 118 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSimpleActionGroup_slistautoptr;
#line 118 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSimpleActionGroup_queueautoptr;
#line 119 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSimpleAction *GSimpleAction_autoptr;
#line 119 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSimpleAction_listautoptr;
#line 119 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSimpleAction_slistautoptr;
#line 119 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSimpleAction_queueautoptr;
#line 120 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSimpleAsyncResult *GSimpleAsyncResult_autoptr;
#line 120 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSimpleAsyncResult_listautoptr;
#line 120 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSimpleAsyncResult_slistautoptr;
#line 120 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSimpleAsyncResult_queueautoptr;
#line 121 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSimplePermission *GSimplePermission_autoptr;
#line 121 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSimplePermission_listautoptr;
#line 121 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSimplePermission_slistautoptr;
#line 121 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSimplePermission_queueautoptr;
#line 122 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSimpleProxyResolver *GSimpleProxyResolver_autoptr;
#line 122 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSimpleProxyResolver_listautoptr;
#line 122 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSimpleProxyResolver_slistautoptr;
#line 122 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSimpleProxyResolver_queueautoptr;
#line 123 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSocketAddressEnumerator *GSocketAddressEnumerator_autoptr;
#line 123 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSocketAddressEnumerator_listautoptr;
#line 123 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSocketAddressEnumerator_slistautoptr;
#line 123 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSocketAddressEnumerator_queueautoptr;
#line 124 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSocketAddress *GSocketAddress_autoptr;
#line 124 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSocketAddress_listautoptr;
#line 124 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSocketAddress_slistautoptr;
#line 124 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSocketAddress_queueautoptr;
#line 125 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSocketClient *GSocketClient_autoptr;
#line 125 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSocketClient_listautoptr;
#line 125 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSocketClient_slistautoptr;
#line 125 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSocketClient_queueautoptr;
#line 126 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSocketConnectable *GSocketConnectable_autoptr;
#line 126 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSocketConnectable_listautoptr;
#line 126 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSocketConnectable_slistautoptr;
#line 126 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSocketConnectable_queueautoptr;
#line 127 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSocketConnection *GSocketConnection_autoptr;
#line 127 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSocketConnection_listautoptr;
#line 127 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSocketConnection_slistautoptr;
#line 127 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSocketConnection_queueautoptr;
#line 128 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSocketControlMessage *GSocketControlMessage_autoptr;
#line 128 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSocketControlMessage_listautoptr;
#line 128 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSocketControlMessage_slistautoptr;
#line 128 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSocketControlMessage_queueautoptr;
#line 129 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSocket *GSocket_autoptr;
#line 129 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSocket_listautoptr;
#line 129 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSocket_slistautoptr;
#line 129 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSocket_queueautoptr;
#line 130 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSocketListener *GSocketListener_autoptr;
#line 130 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSocketListener_listautoptr;
#line 130 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSocketListener_slistautoptr;
#line 130 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSocketListener_queueautoptr;
#line 131 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSocketService *GSocketService_autoptr;
#line 131 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSocketService_listautoptr;
#line 131 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSocketService_slistautoptr;
#line 131 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSocketService_queueautoptr;
#line 132 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSubprocess *GSubprocess_autoptr;
#line 132 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSubprocess_listautoptr;
#line 132 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSubprocess_slistautoptr;
#line 132 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSubprocess_queueautoptr;
#line 133 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSubprocessLauncher *GSubprocessLauncher_autoptr;
#line 133 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSubprocessLauncher_listautoptr;
#line 133 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSubprocessLauncher_slistautoptr;
#line 133 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSubprocessLauncher_queueautoptr;
#line 134 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTask *GTask_autoptr;
#line 134 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTask_listautoptr;
#line 134 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTask_slistautoptr;
#line 134 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTask_queueautoptr;
#line 135 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTcpConnection *GTcpConnection_autoptr;
#line 135 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTcpConnection_listautoptr;
#line 135 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTcpConnection_slistautoptr;
#line 135 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTcpConnection_queueautoptr;
#line 136 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTcpWrapperConnection *GTcpWrapperConnection_autoptr;
#line 136 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTcpWrapperConnection_listautoptr;
#line 136 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTcpWrapperConnection_slistautoptr;
#line 136 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTcpWrapperConnection_queueautoptr;
#line 137 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTestDBus *GTestDBus_autoptr;
#line 137 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTestDBus_listautoptr;
#line 137 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTestDBus_slistautoptr;
#line 137 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTestDBus_queueautoptr;
#line 138 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GThemedIcon *GThemedIcon_autoptr;
#line 138 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GThemedIcon_listautoptr;
#line 138 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GThemedIcon_slistautoptr;
#line 138 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GThemedIcon_queueautoptr;
#line 139 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GThreadedSocketService *GThreadedSocketService_autoptr;
#line 139 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GThreadedSocketService_listautoptr;
#line 139 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GThreadedSocketService_slistautoptr;
#line 139 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GThreadedSocketService_queueautoptr;
#line 140 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTlsBackend *GTlsBackend_autoptr;
#line 140 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTlsBackend_listautoptr;
#line 140 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTlsBackend_slistautoptr;
#line 140 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTlsBackend_queueautoptr;
#line 141 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTlsCertificate *GTlsCertificate_autoptr;
#line 141 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTlsCertificate_listautoptr;
#line 141 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTlsCertificate_slistautoptr;
#line 141 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTlsCertificate_queueautoptr;
#line 142 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTlsClientConnection *GTlsClientConnection_autoptr;
#line 142 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTlsClientConnection_listautoptr;
#line 142 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTlsClientConnection_slistautoptr;
#line 142 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTlsClientConnection_queueautoptr;
#line 143 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTlsConnection *GTlsConnection_autoptr;
#line 143 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTlsConnection_listautoptr;
#line 143 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTlsConnection_slistautoptr;
#line 143 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTlsConnection_queueautoptr;
#line 144 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTlsDatabase *GTlsDatabase_autoptr;
#line 144 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTlsDatabase_listautoptr;
#line 144 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTlsDatabase_slistautoptr;
#line 144 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTlsDatabase_queueautoptr;
#line 145 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTlsFileDatabase *GTlsFileDatabase_autoptr;
#line 145 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTlsFileDatabase_listautoptr;
#line 145 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTlsFileDatabase_slistautoptr;
#line 145 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTlsFileDatabase_queueautoptr;
#line 146 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTlsInteraction *GTlsInteraction_autoptr;
#line 146 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTlsInteraction_listautoptr;
#line 146 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTlsInteraction_slistautoptr;
#line 146 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTlsInteraction_queueautoptr;
#line 147 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTlsPassword *GTlsPassword_autoptr;
#line 147 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTlsPassword_listautoptr;
#line 147 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTlsPassword_slistautoptr;
#line 147 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTlsPassword_queueautoptr;
#line 148 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTlsServerConnection *GTlsServerConnection_autoptr;
#line 148 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTlsServerConnection_listautoptr;
#line 148 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTlsServerConnection_slistautoptr;
#line 148 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTlsServerConnection_queueautoptr;
#line 149 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GVfs *GVfs_autoptr;
#line 149 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GVfs_listautoptr;
#line 149 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GVfs_slistautoptr;
#line 149 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GVfs_queueautoptr;
#line 150 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GVolume *GVolume_autoptr;
#line 150 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GVolume_listautoptr;
#line 150 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GVolume_slistautoptr;
#line 150 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GVolume_queueautoptr;
#line 151 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GVolumeMonitor *GVolumeMonitor_autoptr;
#line 151 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GVolumeMonitor_listautoptr;
#line 151 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GVolumeMonitor_slistautoptr;
#line 151 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GVolumeMonitor_queueautoptr;
#line 152 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GZlibCompressor *GZlibCompressor_autoptr;
#line 152 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GZlibCompressor_listautoptr;
#line 152 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GZlibCompressor_slistautoptr;
#line 152 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GZlibCompressor_queueautoptr;
#line 153 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GZlibDecompressor *GZlibDecompressor_autoptr;
#line 153 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GZlibDecompressor_listautoptr;
#line 153 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GZlibDecompressor_slistautoptr;
#line 153 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GZlibDecompressor_queueautoptr;
#line 107 "/usr/include/cairo/cairo.h"
typedef int cairo_bool_t;
#line 124
struct _cairo ;
#line 124 "/usr/include/cairo/cairo.h"
typedef struct _cairo cairo_t;
#line 153
struct _cairo_surface ;
#line 153 "/usr/include/cairo/cairo.h"
typedef struct _cairo_surface cairo_surface_t;
#line 171
struct _cairo_device ;
#line 171 "/usr/include/cairo/cairo.h"
typedef struct _cairo_device cairo_device_t;
#line 192 "/usr/include/cairo/cairo.h"
struct _cairo_matrix {
   double xx ;
   double yx ;
   double xy ;
   double yy ;
   double x0 ;
   double y0 ;
};
#line 196 "/usr/include/cairo/cairo.h"
typedef struct _cairo_matrix cairo_matrix_t;
#line 220
struct _cairo_pattern ;
#line 220 "/usr/include/cairo/cairo.h"
typedef struct _cairo_pattern cairo_pattern_t;
#line 232 "/usr/include/cairo/cairo.h"
typedef void (*cairo_destroy_func_t)(void * );
#line 246 "/usr/include/cairo/cairo.h"
struct _cairo_user_data_key {
   int unused ;
};
#line 248 "/usr/include/cairo/cairo.h"
typedef struct _cairo_user_data_key cairo_user_data_key_t;
#line 314
enum _cairo_status {
    CAIRO_STATUS_SUCCESS = 0,
    CAIRO_STATUS_NO_MEMORY = 1,
    CAIRO_STATUS_INVALID_RESTORE = 2,
    CAIRO_STATUS_INVALID_POP_GROUP = 3,
    CAIRO_STATUS_NO_CURRENT_POINT = 4,
    CAIRO_STATUS_INVALID_MATRIX = 5,
    CAIRO_STATUS_INVALID_STATUS = 6,
    CAIRO_STATUS_NULL_POINTER = 7,
    CAIRO_STATUS_INVALID_STRING = 8,
    CAIRO_STATUS_INVALID_PATH_DATA = 9,
    CAIRO_STATUS_READ_ERROR = 10,
    CAIRO_STATUS_WRITE_ERROR = 11,
    CAIRO_STATUS_SURFACE_FINISHED = 12,
    CAIRO_STATUS_SURFACE_TYPE_MISMATCH = 13,
    CAIRO_STATUS_PATTERN_TYPE_MISMATCH = 14,
    CAIRO_STATUS_INVALID_CONTENT = 15,
    CAIRO_STATUS_INVALID_FORMAT = 16,
    CAIRO_STATUS_INVALID_VISUAL = 17,
    CAIRO_STATUS_FILE_NOT_FOUND = 18,
    CAIRO_STATUS_INVALID_DASH = 19,
    CAIRO_STATUS_INVALID_DSC_COMMENT = 20,
    CAIRO_STATUS_INVALID_INDEX = 21,
    CAIRO_STATUS_CLIP_NOT_REPRESENTABLE = 22,
    CAIRO_STATUS_TEMP_FILE_ERROR = 23,
    CAIRO_STATUS_INVALID_STRIDE = 24,
    CAIRO_STATUS_FONT_TYPE_MISMATCH = 25,
    CAIRO_STATUS_USER_FONT_IMMUTABLE = 26,
    CAIRO_STATUS_USER_FONT_ERROR = 27,
    CAIRO_STATUS_NEGATIVE_COUNT = 28,
    CAIRO_STATUS_INVALID_CLUSTERS = 29,
    CAIRO_STATUS_INVALID_SLANT = 30,
    CAIRO_STATUS_INVALID_WEIGHT = 31,
    CAIRO_STATUS_INVALID_SIZE = 32,
    CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED = 33,
    CAIRO_STATUS_DEVICE_TYPE_MISMATCH = 34,
    CAIRO_STATUS_DEVICE_ERROR = 35,
    CAIRO_STATUS_INVALID_MESH_CONSTRUCTION = 36,
    CAIRO_STATUS_DEVICE_FINISHED = 37,
    CAIRO_STATUS_JBIG2_GLOBAL_MISSING = 38,
    CAIRO_STATUS_PNG_ERROR = 39,
    CAIRO_STATUS_FREETYPE_ERROR = 40,
    CAIRO_STATUS_WIN32_GDI_ERROR = 41,
    CAIRO_STATUS_TAG_ERROR = 42,
    CAIRO_STATUS_LAST_STATUS = 43
} ;
#line 361 "/usr/include/cairo/cairo.h"
typedef enum _cairo_status cairo_status_t;
#line 379
enum _cairo_content {
    CAIRO_CONTENT_COLOR = 4096,
    CAIRO_CONTENT_ALPHA = 8192,
    CAIRO_CONTENT_COLOR_ALPHA = 12288
} ;
#line 383 "/usr/include/cairo/cairo.h"
typedef enum _cairo_content cairo_content_t;
#line 416
enum _cairo_format {
    CAIRO_FORMAT_INVALID = -1,
    CAIRO_FORMAT_ARGB32 = 0,
    CAIRO_FORMAT_RGB24 = 1,
    CAIRO_FORMAT_A8 = 2,
    CAIRO_FORMAT_A1 = 3,
    CAIRO_FORMAT_RGB16_565 = 4,
    CAIRO_FORMAT_RGB30 = 5
} ;
#line 424 "/usr/include/cairo/cairo.h"
typedef enum _cairo_format cairo_format_t;
#line 445 "/usr/include/cairo/cairo.h"
typedef cairo_status_t (*cairo_write_func_t)(void * , unsigned char const   * , unsigned int  );
#line 467 "/usr/include/cairo/cairo.h"
typedef cairo_status_t (*cairo_read_func_t)(void * , unsigned char * , unsigned int  );
#line 483 "/usr/include/cairo/cairo.h"
struct _cairo_rectangle_int {
   int x ;
   int y ;
   int width ;
   int height ;
};
#line 486 "/usr/include/cairo/cairo.h"
typedef struct _cairo_rectangle_int cairo_rectangle_int_t;
#line 613
enum _cairo_operator {
    CAIRO_OPERATOR_CLEAR = 0,
    CAIRO_OPERATOR_SOURCE = 1,
    CAIRO_OPERATOR_OVER = 2,
    CAIRO_OPERATOR_IN = 3,
    CAIRO_OPERATOR_OUT = 4,
    CAIRO_OPERATOR_ATOP = 5,
    CAIRO_OPERATOR_DEST = 6,
    CAIRO_OPERATOR_DEST_OVER = 7,
    CAIRO_OPERATOR_DEST_IN = 8,
    CAIRO_OPERATOR_DEST_OUT = 9,
    CAIRO_OPERATOR_DEST_ATOP = 10,
    CAIRO_OPERATOR_XOR = 11,
    CAIRO_OPERATOR_ADD = 12,
    CAIRO_OPERATOR_SATURATE = 13,
    CAIRO_OPERATOR_MULTIPLY = 14,
    CAIRO_OPERATOR_SCREEN = 15,
    CAIRO_OPERATOR_OVERLAY = 16,
    CAIRO_OPERATOR_DARKEN = 17,
    CAIRO_OPERATOR_LIGHTEN = 18,
    CAIRO_OPERATOR_COLOR_DODGE = 19,
    CAIRO_OPERATOR_COLOR_BURN = 20,
    CAIRO_OPERATOR_HARD_LIGHT = 21,
    CAIRO_OPERATOR_SOFT_LIGHT = 22,
    CAIRO_OPERATOR_DIFFERENCE = 23,
    CAIRO_OPERATOR_EXCLUSION = 24,
    CAIRO_OPERATOR_HSL_HUE = 25,
    CAIRO_OPERATOR_HSL_SATURATION = 26,
    CAIRO_OPERATOR_HSL_COLOR = 27,
    CAIRO_OPERATOR_HSL_LUMINOSITY = 28
} ;
#line 647 "/usr/include/cairo/cairo.h"
typedef enum _cairo_operator cairo_operator_t;
#line 709
enum _cairo_antialias {
    CAIRO_ANTIALIAS_DEFAULT = 0,
    CAIRO_ANTIALIAS_NONE = 1,
    CAIRO_ANTIALIAS_GRAY = 2,
    CAIRO_ANTIALIAS_SUBPIXEL = 3,
    CAIRO_ANTIALIAS_FAST = 4,
    CAIRO_ANTIALIAS_GOOD = 5,
    CAIRO_ANTIALIAS_BEST = 6
} ;
#line 721 "/usr/include/cairo/cairo.h"
typedef enum _cairo_antialias cairo_antialias_t;
#line 753
enum _cairo_fill_rule {
    CAIRO_FILL_RULE_WINDING = 0,
    CAIRO_FILL_RULE_EVEN_ODD = 1
} ;
#line 756 "/usr/include/cairo/cairo.h"
typedef enum _cairo_fill_rule cairo_fill_rule_t;
#line 776
enum _cairo_line_cap {
    CAIRO_LINE_CAP_BUTT = 0,
    CAIRO_LINE_CAP_ROUND = 1,
    CAIRO_LINE_CAP_SQUARE = 2
} ;
#line 780 "/usr/include/cairo/cairo.h"
typedef enum _cairo_line_cap cairo_line_cap_t;
#line 800
enum _cairo_line_join {
    CAIRO_LINE_JOIN_MITER = 0,
    CAIRO_LINE_JOIN_ROUND = 1,
    CAIRO_LINE_JOIN_BEVEL = 2
} ;
#line 804 "/usr/include/cairo/cairo.h"
typedef enum _cairo_line_join cairo_line_join_t;
#line 1002 "/usr/include/cairo/cairo.h"
struct _cairo_rectangle {
   double x ;
   double y ;
   double width ;
   double height ;
};
#line 1004 "/usr/include/cairo/cairo.h"
typedef struct _cairo_rectangle cairo_rectangle_t;
#line 1017 "/usr/include/cairo/cairo.h"
struct _cairo_rectangle_list {
   cairo_status_t status ;
   cairo_rectangle_t *rectangles ;
   int num_rectangles ;
};
#line 1021 "/usr/include/cairo/cairo.h"
typedef struct _cairo_rectangle_list cairo_rectangle_list_t;
#line 1059
struct _cairo_scaled_font ;
#line 1059 "/usr/include/cairo/cairo.h"
typedef struct _cairo_scaled_font cairo_scaled_font_t;
#line 1080
struct _cairo_font_face ;
#line 1080 "/usr/include/cairo/cairo.h"
typedef struct _cairo_font_face cairo_font_face_t;
#line 1108 "/usr/include/cairo/cairo.h"
struct __anonstruct_390 {
   unsigned long index ;
   double x ;
   double y ;
};
#line 1112 "/usr/include/cairo/cairo.h"
typedef struct __anonstruct_390 cairo_glyph_t;
#line 1140 "/usr/include/cairo/cairo.h"
struct __anonstruct_391 {
   int num_bytes ;
   int num_glyphs ;
};
#line 1143 "/usr/include/cairo/cairo.h"
typedef struct __anonstruct_391 cairo_text_cluster_t;
#line 1160
enum _cairo_text_cluster_flags {
    CAIRO_TEXT_CLUSTER_FLAG_BACKWARD = 1
} ;
#line 1162 "/usr/include/cairo/cairo.h"
typedef enum _cairo_text_cluster_flags cairo_text_cluster_flags_t;
#line 1193 "/usr/include/cairo/cairo.h"
struct __anonstruct_392 {
   double x_bearing ;
   double y_bearing ;
   double width ;
   double height ;
   double x_advance ;
   double y_advance ;
};
#line 1200 "/usr/include/cairo/cairo.h"
typedef struct __anonstruct_392 cairo_text_extents_t;
#line 1245 "/usr/include/cairo/cairo.h"
struct __anonstruct_393 {
   double ascent ;
   double descent ;
   double height ;
   double max_x_advance ;
   double max_y_advance ;
};
#line 1251 "/usr/include/cairo/cairo.h"
typedef struct __anonstruct_393 cairo_font_extents_t;
#line 1263
enum _cairo_font_slant {
    CAIRO_FONT_SLANT_NORMAL = 0,
    CAIRO_FONT_SLANT_ITALIC = 1,
    CAIRO_FONT_SLANT_OBLIQUE = 2
} ;
#line 1267 "/usr/include/cairo/cairo.h"
typedef enum _cairo_font_slant cairo_font_slant_t;
#line 1278
enum _cairo_font_weight {
    CAIRO_FONT_WEIGHT_NORMAL = 0,
    CAIRO_FONT_WEIGHT_BOLD = 1
} ;
#line 1281 "/usr/include/cairo/cairo.h"
typedef enum _cairo_font_weight cairo_font_weight_t;
#line 1302
enum _cairo_subpixel_order {
    CAIRO_SUBPIXEL_ORDER_DEFAULT = 0,
    CAIRO_SUBPIXEL_ORDER_RGB = 1,
    CAIRO_SUBPIXEL_ORDER_BGR = 2,
    CAIRO_SUBPIXEL_ORDER_VRGB = 3,
    CAIRO_SUBPIXEL_ORDER_VBGR = 4
} ;
#line 1308 "/usr/include/cairo/cairo.h"
typedef enum _cairo_subpixel_order cairo_subpixel_order_t;
#line 1334
enum _cairo_hint_style {
    CAIRO_HINT_STYLE_DEFAULT = 0,
    CAIRO_HINT_STYLE_NONE = 1,
    CAIRO_HINT_STYLE_SLIGHT = 2,
    CAIRO_HINT_STYLE_MEDIUM = 3,
    CAIRO_HINT_STYLE_FULL = 4
} ;
#line 1340 "/usr/include/cairo/cairo.h"
typedef enum _cairo_hint_style cairo_hint_style_t;
#line 1357
enum _cairo_hint_metrics {
    CAIRO_HINT_METRICS_DEFAULT = 0,
    CAIRO_HINT_METRICS_OFF = 1,
    CAIRO_HINT_METRICS_ON = 2
} ;
#line 1361 "/usr/include/cairo/cairo.h"
typedef enum _cairo_hint_metrics cairo_hint_metrics_t;
#line 1385
struct _cairo_font_options ;
#line 1385 "/usr/include/cairo/cairo.h"
typedef struct _cairo_font_options cairo_font_options_t;
#line 1572
enum _cairo_font_type {
    CAIRO_FONT_TYPE_TOY = 0,
    CAIRO_FONT_TYPE_FT = 1,
    CAIRO_FONT_TYPE_WIN32 = 2,
    CAIRO_FONT_TYPE_QUARTZ = 3,
    CAIRO_FONT_TYPE_USER = 4
} ;
#line 1578 "/usr/include/cairo/cairo.h"
typedef enum _cairo_font_type cairo_font_type_t;
#line 1729 "/usr/include/cairo/cairo.h"
typedef cairo_status_t (*cairo_user_scaled_font_init_func_t)(cairo_scaled_font_t * ,
                                                             cairo_t * , cairo_font_extents_t * );
#line 1776 "/usr/include/cairo/cairo.h"
typedef cairo_status_t (*cairo_user_scaled_font_render_glyph_func_t)(cairo_scaled_font_t * ,
                                                                     unsigned long  ,
                                                                     cairo_t * , cairo_text_extents_t * );
#line 1846 "/usr/include/cairo/cairo.h"
typedef cairo_status_t (*cairo_user_scaled_font_text_to_glyphs_func_t)(cairo_scaled_font_t * ,
                                                                       char const   * ,
                                                                       int  , cairo_glyph_t ** ,
                                                                       int * , cairo_text_cluster_t ** ,
                                                                       int * , cairo_text_cluster_flags_t * );
#line 1893 "/usr/include/cairo/cairo.h"
typedef cairo_status_t (*cairo_user_scaled_font_unicode_to_glyph_func_t)(cairo_scaled_font_t * ,
                                                                         unsigned long  ,
                                                                         unsigned long * );
#line 1993
enum _cairo_path_data_type {
    CAIRO_PATH_MOVE_TO = 0,
    CAIRO_PATH_LINE_TO = 1,
    CAIRO_PATH_CURVE_TO = 2,
    CAIRO_PATH_CLOSE_PATH = 3
} ;
#line 1998 "/usr/include/cairo/cairo.h"
typedef enum _cairo_path_data_type cairo_path_data_type_t;
#line 2068
union _cairo_path_data_t ;
#line 2068 "/usr/include/cairo/cairo.h"
typedef union _cairo_path_data_t cairo_path_data_t;
#line 2070 "/usr/include/cairo/cairo.h"
struct __anonstruct_394 {
   cairo_path_data_type_t type ;
   int length ;
};
#line 2074 "/usr/include/cairo/cairo.h"
struct __anonstruct_395 {
   double x ;
   double y ;
};
#line 2069 "/usr/include/cairo/cairo.h"
union _cairo_path_data_t {
   struct __anonstruct_394 header ;
   struct __anonstruct_395 point ;
};
#line 2100 "/usr/include/cairo/cairo.h"
struct cairo_path {
   cairo_status_t status ;
   cairo_path_data_t *data ;
   int num_data ;
};
#line 2104 "/usr/include/cairo/cairo.h"
typedef struct cairo_path cairo_path_t;
#line 2163
enum _cairo_device_type {
    CAIRO_DEVICE_TYPE_DRM = 0,
    CAIRO_DEVICE_TYPE_GL = 1,
    CAIRO_DEVICE_TYPE_SCRIPT = 2,
    CAIRO_DEVICE_TYPE_XCB = 3,
    CAIRO_DEVICE_TYPE_XLIB = 4,
    CAIRO_DEVICE_TYPE_XML = 5,
    CAIRO_DEVICE_TYPE_COGL = 6,
    CAIRO_DEVICE_TYPE_WIN32 = 7,
    CAIRO_DEVICE_TYPE_INVALID = -1
} ;
#line 2174 "/usr/include/cairo/cairo.h"
typedef enum _cairo_device_type cairo_device_type_t;
#line 2249
enum __anonenum__396 {
    CAIRO_SURFACE_OBSERVER_NORMAL = 0,
    CAIRO_SURFACE_OBSERVER_RECORD_OPERATIONS = 1
} ;
#line 2252 "/usr/include/cairo/cairo.h"
typedef enum __anonenum__396 cairo_surface_observer_mode_t;
#line 2258 "/usr/include/cairo/cairo.h"
typedef void (*cairo_surface_observer_callback_t)(cairo_surface_t * , cairo_surface_t * ,
                                                  void * );
#line 2397
enum _cairo_surface_type {
    CAIRO_SURFACE_TYPE_IMAGE = 0,
    CAIRO_SURFACE_TYPE_PDF = 1,
    CAIRO_SURFACE_TYPE_PS = 2,
    CAIRO_SURFACE_TYPE_XLIB = 3,
    CAIRO_SURFACE_TYPE_XCB = 4,
    CAIRO_SURFACE_TYPE_GLITZ = 5,
    CAIRO_SURFACE_TYPE_QUARTZ = 6,
    CAIRO_SURFACE_TYPE_WIN32 = 7,
    CAIRO_SURFACE_TYPE_BEOS = 8,
    CAIRO_SURFACE_TYPE_DIRECTFB = 9,
    CAIRO_SURFACE_TYPE_SVG = 10,
    CAIRO_SURFACE_TYPE_OS2 = 11,
    CAIRO_SURFACE_TYPE_WIN32_PRINTING = 12,
    CAIRO_SURFACE_TYPE_QUARTZ_IMAGE = 13,
    CAIRO_SURFACE_TYPE_SCRIPT = 14,
    CAIRO_SURFACE_TYPE_QT = 15,
    CAIRO_SURFACE_TYPE_RECORDING = 16,
    CAIRO_SURFACE_TYPE_VG = 17,
    CAIRO_SURFACE_TYPE_GL = 18,
    CAIRO_SURFACE_TYPE_DRM = 19,
    CAIRO_SURFACE_TYPE_TEE = 20,
    CAIRO_SURFACE_TYPE_XML = 21,
    CAIRO_SURFACE_TYPE_SKIA = 22,
    CAIRO_SURFACE_TYPE_SUBSURFACE = 23,
    CAIRO_SURFACE_TYPE_COGL = 24
} ;
#line 2423 "/usr/include/cairo/cairo.h"
typedef enum _cairo_surface_type cairo_surface_type_t;
#line 2629 "/usr/include/cairo/cairo.h"
typedef cairo_surface_t *(*cairo_raster_source_acquire_func_t)(cairo_pattern_t * ,
                                                               void * , cairo_surface_t * ,
                                                               cairo_rectangle_int_t * );
#line 2648 "/usr/include/cairo/cairo.h"
typedef void (*cairo_raster_source_release_func_t)(cairo_pattern_t * , void * , cairo_surface_t * );
#line 2669 "/usr/include/cairo/cairo.h"
typedef cairo_status_t (*cairo_raster_source_snapshot_func_t)(cairo_pattern_t * ,
                                                              void * );
#line 2687 "/usr/include/cairo/cairo.h"
typedef cairo_status_t (*cairo_raster_source_copy_func_t)(cairo_pattern_t * , void * ,
                                                          cairo_pattern_t * );
#line 2702 "/usr/include/cairo/cairo.h"
typedef void (*cairo_raster_source_finish_func_t)(cairo_pattern_t * , void * );
#line 2824
enum _cairo_pattern_type {
    CAIRO_PATTERN_TYPE_SOLID = 0,
    CAIRO_PATTERN_TYPE_SURFACE = 1,
    CAIRO_PATTERN_TYPE_LINEAR = 2,
    CAIRO_PATTERN_TYPE_RADIAL = 3,
    CAIRO_PATTERN_TYPE_MESH = 4,
    CAIRO_PATTERN_TYPE_RASTER_SOURCE = 5
} ;
#line 2831 "/usr/include/cairo/cairo.h"
typedef enum _cairo_pattern_type cairo_pattern_type_t;
#line 2916
enum _cairo_extend {
    CAIRO_EXTEND_NONE = 0,
    CAIRO_EXTEND_REPEAT = 1,
    CAIRO_EXTEND_REFLECT = 2,
    CAIRO_EXTEND_PAD = 3
} ;
#line 2921 "/usr/include/cairo/cairo.h"
typedef enum _cairo_extend cairo_extend_t;
#line 2949
enum _cairo_filter {
    CAIRO_FILTER_FAST = 0,
    CAIRO_FILTER_GOOD = 1,
    CAIRO_FILTER_BEST = 2,
    CAIRO_FILTER_NEAREST = 3,
    CAIRO_FILTER_BILINEAR = 4,
    CAIRO_FILTER_GAUSSIAN = 5
} ;
#line 2956 "/usr/include/cairo/cairo.h"
typedef enum _cairo_filter cairo_filter_t;
#line 3078
struct _cairo_region ;
#line 3078 "/usr/include/cairo/cairo.h"
typedef struct _cairo_region cairo_region_t;
#line 3091
enum _cairo_region_overlap {
    CAIRO_REGION_OVERLAP_IN = 0,
    CAIRO_REGION_OVERLAP_OUT = 1,
    CAIRO_REGION_OVERLAP_PART = 2
} ;
#line 3095 "/usr/include/cairo/cairo.h"
typedef enum _cairo_region_overlap cairo_region_overlap_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 43 "/usr/include/stdint.h"
typedef __int_least8_t int_least8_t;
#line 44 "/usr/include/stdint.h"
typedef __int_least16_t int_least16_t;
#line 45 "/usr/include/stdint.h"
typedef __int_least32_t int_least32_t;
#line 46 "/usr/include/stdint.h"
typedef __int_least64_t int_least64_t;
#line 49 "/usr/include/stdint.h"
typedef __uint_least8_t uint_least8_t;
#line 50 "/usr/include/stdint.h"
typedef __uint_least16_t uint_least16_t;
#line 51 "/usr/include/stdint.h"
typedef __uint_least32_t uint_least32_t;
#line 52 "/usr/include/stdint.h"
typedef __uint_least64_t uint_least64_t;
#line 58 "/usr/include/stdint.h"
typedef signed char int_fast8_t;
#line 60 "/usr/include/stdint.h"
typedef long int_fast16_t;
#line 61 "/usr/include/stdint.h"
typedef long int_fast32_t;
#line 62 "/usr/include/stdint.h"
typedef long int_fast64_t;
#line 71 "/usr/include/stdint.h"
typedef unsigned char uint_fast8_t;
#line 73 "/usr/include/stdint.h"
typedef unsigned long uint_fast16_t;
#line 74 "/usr/include/stdint.h"
typedef unsigned long uint_fast32_t;
#line 75 "/usr/include/stdint.h"
typedef unsigned long uint_fast64_t;
#line 90 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 101 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 102 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 97 "/usr/include/harfbuzz/hb-common.h"
typedef int hb_bool_t;
#line 106 "/usr/include/harfbuzz/hb-common.h"
typedef uint32_t hb_codepoint_t;
#line 115 "/usr/include/harfbuzz/hb-common.h"
typedef int32_t hb_position_t;
#line 122 "/usr/include/harfbuzz/hb-common.h"
typedef uint32_t hb_mask_t;
#line 124 "/usr/include/harfbuzz/hb-common.h"
union _hb_var_int_t {
   uint32_t u32 ;
   int32_t i32 ;
   uint16_t u16[2] ;
   int16_t i16[2] ;
   uint8_t u8[4] ;
   int8_t i8[4] ;
};
#line 131 "/usr/include/harfbuzz/hb-common.h"
typedef union _hb_var_int_t hb_var_int_t;
#line 147 "/usr/include/harfbuzz/hb-common.h"
typedef uint32_t hb_tag_t;
#line 193
enum __anonenum__397 {
    HB_DIRECTION_INVALID = 0,
    HB_DIRECTION_LTR = 4,
    HB_DIRECTION_RTL = 5,
    HB_DIRECTION_TTB = 6,
    HB_DIRECTION_BTT = 7
} ;
#line 199 "/usr/include/harfbuzz/hb-common.h"
typedef enum __anonenum__397 hb_direction_t;
#line 266
struct hb_language_impl_t ;
#line 266 "/usr/include/harfbuzz/hb-common.h"
typedef struct hb_language_impl_t *hb_language_t;
#line 447
enum __anonenum__398 {
    HB_SCRIPT_COMMON = 1517910393,
    HB_SCRIPT_INHERITED = 1516858984,
    HB_SCRIPT_UNKNOWN = 1517976186,
    HB_SCRIPT_ARABIC = 1098015074,
    HB_SCRIPT_ARMENIAN = 1098018158,
    HB_SCRIPT_BENGALI = 1113943655,
    HB_SCRIPT_CYRILLIC = 1132032620,
    HB_SCRIPT_DEVANAGARI = 1147500129,
    HB_SCRIPT_GEORGIAN = 1197830002,
    HB_SCRIPT_GREEK = 1198679403,
    HB_SCRIPT_GUJARATI = 1198877298,
    HB_SCRIPT_GURMUKHI = 1198879349,
    HB_SCRIPT_HANGUL = 1214344807,
    HB_SCRIPT_HAN = 1214344809,
    HB_SCRIPT_HEBREW = 1214603890,
    HB_SCRIPT_HIRAGANA = 1214870113,
    HB_SCRIPT_KANNADA = 1265525857,
    HB_SCRIPT_KATAKANA = 1264676449,
    HB_SCRIPT_LAO = 1281453935,
    HB_SCRIPT_LATIN = 1281455214,
    HB_SCRIPT_MALAYALAM = 1298954605,
    HB_SCRIPT_ORIYA = 1332902241,
    HB_SCRIPT_TAMIL = 1415671148,
    HB_SCRIPT_TELUGU = 1415933045,
    HB_SCRIPT_THAI = 1416126825,
    HB_SCRIPT_TIBETAN = 1416192628,
    HB_SCRIPT_BOPOMOFO = 1114599535,
    HB_SCRIPT_BRAILLE = 1114792297,
    HB_SCRIPT_CANADIAN_SYLLABICS = 1130458739,
    HB_SCRIPT_CHEROKEE = 1130915186,
    HB_SCRIPT_ETHIOPIC = 1165256809,
    HB_SCRIPT_KHMER = 1265134962,
    HB_SCRIPT_MONGOLIAN = 1299148391,
    HB_SCRIPT_MYANMAR = 1299803506,
    HB_SCRIPT_OGHAM = 1332175213,
    HB_SCRIPT_RUNIC = 1383427698,
    HB_SCRIPT_SINHALA = 1399418472,
    HB_SCRIPT_SYRIAC = 1400468067,
    HB_SCRIPT_THAANA = 1416126817,
    HB_SCRIPT_YI = 1500080489,
    HB_SCRIPT_DESERET = 1148416628,
    HB_SCRIPT_GOTHIC = 1198486632,
    HB_SCRIPT_OLD_ITALIC = 1232363884,
    HB_SCRIPT_BUHID = 1114990692,
    HB_SCRIPT_HANUNOO = 1214344815,
    HB_SCRIPT_TAGALOG = 1416064103,
    HB_SCRIPT_TAGBANWA = 1415669602,
    HB_SCRIPT_CYPRIOT = 1131442804,
    HB_SCRIPT_LIMBU = 1281977698,
    HB_SCRIPT_LINEAR_B = 1281977954,
    HB_SCRIPT_OSMANYA = 1332964705,
    HB_SCRIPT_SHAVIAN = 1399349623,
    HB_SCRIPT_TAI_LE = 1415670885,
    HB_SCRIPT_UGARITIC = 1432838514,
    HB_SCRIPT_BUGINESE = 1114990441,
    HB_SCRIPT_COPTIC = 1131376756,
    HB_SCRIPT_GLAGOLITIC = 1198285159,
    HB_SCRIPT_KHAROSHTHI = 1265131890,
    HB_SCRIPT_NEW_TAI_LUE = 1415670901,
    HB_SCRIPT_OLD_PERSIAN = 1483761007,
    HB_SCRIPT_SYLOTI_NAGRI = 1400466543,
    HB_SCRIPT_TIFINAGH = 1415999079,
    HB_SCRIPT_BALINESE = 1113681001,
    HB_SCRIPT_CUNEIFORM = 1483961720,
    HB_SCRIPT_NKO = 1315663727,
    HB_SCRIPT_PHAGS_PA = 1349017959,
    HB_SCRIPT_PHOENICIAN = 1349021304,
    HB_SCRIPT_CARIAN = 1130459753,
    HB_SCRIPT_CHAM = 1130914157,
    HB_SCRIPT_KAYAH_LI = 1264675945,
    HB_SCRIPT_LEPCHA = 1281716323,
    HB_SCRIPT_LYCIAN = 1283023721,
    HB_SCRIPT_LYDIAN = 1283023977,
    HB_SCRIPT_OL_CHIKI = 1332503403,
    HB_SCRIPT_REJANG = 1382706791,
    HB_SCRIPT_SAURASHTRA = 1398895986,
    HB_SCRIPT_SUNDANESE = 1400204900,
    HB_SCRIPT_VAI = 1449224553,
    HB_SCRIPT_AVESTAN = 1098281844,
    HB_SCRIPT_BAMUM = 1113681269,
    HB_SCRIPT_EGYPTIAN_HIEROGLYPHS = 1164409200,
    HB_SCRIPT_IMPERIAL_ARAMAIC = 1098018153,
    HB_SCRIPT_INSCRIPTIONAL_PAHLAVI = 1349020777,
    HB_SCRIPT_INSCRIPTIONAL_PARTHIAN = 1349678185,
    HB_SCRIPT_JAVANESE = 1247901281,
    HB_SCRIPT_KAITHI = 1265920105,
    HB_SCRIPT_LISU = 1281979253,
    HB_SCRIPT_MEETEI_MAYEK = 1299473769,
    HB_SCRIPT_OLD_SOUTH_ARABIAN = 1398895202,
    HB_SCRIPT_OLD_TURKIC = 1332898664,
    HB_SCRIPT_SAMARITAN = 1398893938,
    HB_SCRIPT_TAI_THAM = 1281453665,
    HB_SCRIPT_TAI_VIET = 1415673460,
    HB_SCRIPT_BATAK = 1113683051,
    HB_SCRIPT_BRAHMI = 1114792296,
    HB_SCRIPT_MANDAIC = 1298230884,
    HB_SCRIPT_CHAKMA = 1130457965,
    HB_SCRIPT_MEROITIC_CURSIVE = 1298494051,
    HB_SCRIPT_MEROITIC_HIEROGLYPHS = 1298494063,
    HB_SCRIPT_MIAO = 1349284452,
    HB_SCRIPT_SHARADA = 1399353956,
    HB_SCRIPT_SORA_SOMPENG = 1399812705,
    HB_SCRIPT_TAKRI = 1415670642,
    HB_SCRIPT_BASSA_VAH = 1113682803,
    HB_SCRIPT_CAUCASIAN_ALBANIAN = 1097295970,
    HB_SCRIPT_DUPLOYAN = 1148547180,
    HB_SCRIPT_ELBASAN = 1164730977,
    HB_SCRIPT_GRANTHA = 1198678382,
    HB_SCRIPT_KHOJKI = 1265135466,
    HB_SCRIPT_KHUDAWADI = 1399418468,
    HB_SCRIPT_LINEAR_A = 1281977953,
    HB_SCRIPT_MAHAJANI = 1298229354,
    HB_SCRIPT_MANICHAEAN = 1298230889,
    HB_SCRIPT_MENDE_KIKAKUI = 1298493028,
    HB_SCRIPT_MODI = 1299145833,
    HB_SCRIPT_MRO = 1299345263,
    HB_SCRIPT_NABATAEAN = 1315070324,
    HB_SCRIPT_OLD_NORTH_ARABIAN = 1315009122,
    HB_SCRIPT_OLD_PERMIC = 1348825709,
    HB_SCRIPT_PAHAWH_HMONG = 1215131239,
    HB_SCRIPT_PALMYRENE = 1348562029,
    HB_SCRIPT_PAU_CIN_HAU = 1348564323,
    HB_SCRIPT_PSALTER_PAHLAVI = 1349020784,
    HB_SCRIPT_SIDDHAM = 1399415908,
    HB_SCRIPT_TIRHUTA = 1416196712,
    HB_SCRIPT_WARANG_CITI = 1466004065,
    HB_SCRIPT_AHOM = 1097363309,
    HB_SCRIPT_ANATOLIAN_HIEROGLYPHS = 1215067511,
    HB_SCRIPT_HATRAN = 1214346354,
    HB_SCRIPT_MULTANI = 1299541108,
    HB_SCRIPT_OLD_HUNGARIAN = 1215655527,
    HB_SCRIPT_SIGNWRITING = 1399287415,
    HB_SCRIPT_ADLAM = 1097100397,
    HB_SCRIPT_BHAIKSUKI = 1114139507,
    HB_SCRIPT_MARCHEN = 1298231907,
    HB_SCRIPT_OSAGE = 1332963173,
    HB_SCRIPT_TANGUT = 1415671399,
    HB_SCRIPT_NEWA = 1315272545,
    HB_SCRIPT_MASARAM_GONDI = 1198485101,
    HB_SCRIPT_NUSHU = 1316186229,
    HB_SCRIPT_SOYOMBO = 1399814511,
    HB_SCRIPT_ZANABAZAR_SQUARE = 1516334690,
    HB_SCRIPT_DOGRA = 1148151666,
    HB_SCRIPT_GUNJALA_GONDI = 1198485095,
    HB_SCRIPT_HANIFI_ROHINGYA = 1383032935,
    HB_SCRIPT_MAKASAR = 1298230113,
    HB_SCRIPT_MEDEFAIDRIN = 1298490470,
    HB_SCRIPT_OLD_SOGDIAN = 1399809903,
    HB_SCRIPT_SOGDIAN = 1399809892,
    HB_SCRIPT_ELYMAIC = 1164736877,
    HB_SCRIPT_NANDINAGARI = 1315008100,
    HB_SCRIPT_NYIAKENG_PUACHUE_HMONG = 1215131248,
    HB_SCRIPT_WANCHO = 1466132591,
    HB_SCRIPT_CHORASMIAN = 1130918515,
    HB_SCRIPT_DIVES_AKURU = 1147756907,
    HB_SCRIPT_KHITAN_SMALL_SCRIPT = 1265202291,
    HB_SCRIPT_YEZIDI = 1499822697,
    HB_SCRIPT_INVALID = 0,
    _HB_SCRIPT_MAX_VALUE = 2147483647,
    _HB_SCRIPT_MAX_VALUE_SIGNED = 2147483647
} ;
#line 659 "/usr/include/harfbuzz/hb-common.h"
typedef enum __anonenum__398 hb_script_t;
#line 685 "/usr/include/harfbuzz/hb-common.h"
struct hb_user_data_key_t {
   char unused ;
};
#line 688 "/usr/include/harfbuzz/hb-common.h"
typedef struct hb_user_data_key_t hb_user_data_key_t;
#line 690 "/usr/include/harfbuzz/hb-common.h"
typedef void (*hb_destroy_func_t)(void * );
#line 723 "/usr/include/harfbuzz/hb-common.h"
struct hb_feature_t {
   hb_tag_t tag ;
   uint32_t value ;
   unsigned int start ;
   unsigned int end ;
};
#line 728 "/usr/include/harfbuzz/hb-common.h"
typedef struct hb_feature_t hb_feature_t;
#line 749 "/usr/include/harfbuzz/hb-common.h"
struct hb_variation_t {
   hb_tag_t tag ;
   float value ;
};
#line 752 "/usr/include/harfbuzz/hb-common.h"
typedef struct hb_variation_t hb_variation_t;
#line 770 "/usr/include/harfbuzz/hb-common.h"
typedef uint32_t hb_color_t;
#line 67 "/usr/include/harfbuzz/hb-blob.h"
enum __anonenum__399 {
    HB_MEMORY_MODE_DUPLICATE = 0,
    HB_MEMORY_MODE_READONLY = 1,
    HB_MEMORY_MODE_WRITABLE = 2,
    HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE = 3
} ;
#line 72 "/usr/include/harfbuzz/hb-blob.h"
typedef enum __anonenum__399 hb_memory_mode_t;
#line 82
struct hb_blob_t ;
#line 82 "/usr/include/harfbuzz/hb-blob.h"
typedef struct hb_blob_t hb_blob_t;
#line 89 "/usr/include/harfbuzz/hb-unicode.h"
enum __anonenum__400 {
    HB_UNICODE_GENERAL_CATEGORY_CONTROL = 0,
    HB_UNICODE_GENERAL_CATEGORY_FORMAT = 1,
    HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED = 2,
    HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE = 3,
    HB_UNICODE_GENERAL_CATEGORY_SURROGATE = 4,
    HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER = 5,
    HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER = 6,
    HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER = 7,
    HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER = 8,
    HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER = 9,
    HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK = 10,
    HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK = 11,
    HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK = 12,
    HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER = 13,
    HB_UNICODE_GENERAL_CATEGORY_LETTER_NUMBER = 14,
    HB_UNICODE_GENERAL_CATEGORY_OTHER_NUMBER = 15,
    HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION = 16,
    HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION = 17,
    HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION = 18,
    HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION = 19,
    HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION = 20,
    HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION = 21,
    HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION = 22,
    HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL = 23,
    HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL = 24,
    HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL = 25,
    HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL = 26,
    HB_UNICODE_GENERAL_CATEGORY_LINE_SEPARATOR = 27,
    HB_UNICODE_GENERAL_CATEGORY_PARAGRAPH_SEPARATOR = 28,
    HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR = 29
} ;
#line 121 "/usr/include/harfbuzz/hb-unicode.h"
typedef enum __anonenum__400 hb_unicode_general_category_t;
#line 191
enum __anonenum__401 {
    HB_UNICODE_COMBINING_CLASS_NOT_REORDERED = 0,
    HB_UNICODE_COMBINING_CLASS_OVERLAY = 1,
    HB_UNICODE_COMBINING_CLASS_NUKTA = 7,
    HB_UNICODE_COMBINING_CLASS_KANA_VOICING = 8,
    HB_UNICODE_COMBINING_CLASS_VIRAMA = 9,
    HB_UNICODE_COMBINING_CLASS_CCC10 = 10,
    HB_UNICODE_COMBINING_CLASS_CCC11 = 11,
    HB_UNICODE_COMBINING_CLASS_CCC12 = 12,
    HB_UNICODE_COMBINING_CLASS_CCC13 = 13,
    HB_UNICODE_COMBINING_CLASS_CCC14 = 14,
    HB_UNICODE_COMBINING_CLASS_CCC15 = 15,
    HB_UNICODE_COMBINING_CLASS_CCC16 = 16,
    HB_UNICODE_COMBINING_CLASS_CCC17 = 17,
    HB_UNICODE_COMBINING_CLASS_CCC18 = 18,
    HB_UNICODE_COMBINING_CLASS_CCC19 = 19,
    HB_UNICODE_COMBINING_CLASS_CCC20 = 20,
    HB_UNICODE_COMBINING_CLASS_CCC21 = 21,
    HB_UNICODE_COMBINING_CLASS_CCC22 = 22,
    HB_UNICODE_COMBINING_CLASS_CCC23 = 23,
    HB_UNICODE_COMBINING_CLASS_CCC24 = 24,
    HB_UNICODE_COMBINING_CLASS_CCC25 = 25,
    HB_UNICODE_COMBINING_CLASS_CCC26 = 26,
    HB_UNICODE_COMBINING_CLASS_CCC27 = 27,
    HB_UNICODE_COMBINING_CLASS_CCC28 = 28,
    HB_UNICODE_COMBINING_CLASS_CCC29 = 29,
    HB_UNICODE_COMBINING_CLASS_CCC30 = 30,
    HB_UNICODE_COMBINING_CLASS_CCC31 = 31,
    HB_UNICODE_COMBINING_CLASS_CCC32 = 32,
    HB_UNICODE_COMBINING_CLASS_CCC33 = 33,
    HB_UNICODE_COMBINING_CLASS_CCC34 = 34,
    HB_UNICODE_COMBINING_CLASS_CCC35 = 35,
    HB_UNICODE_COMBINING_CLASS_CCC36 = 36,
    HB_UNICODE_COMBINING_CLASS_CCC84 = 84,
    HB_UNICODE_COMBINING_CLASS_CCC91 = 91,
    HB_UNICODE_COMBINING_CLASS_CCC103 = 103,
    HB_UNICODE_COMBINING_CLASS_CCC107 = 107,
    HB_UNICODE_COMBINING_CLASS_CCC118 = 118,
    HB_UNICODE_COMBINING_CLASS_CCC122 = 122,
    HB_UNICODE_COMBINING_CLASS_CCC129 = 129,
    HB_UNICODE_COMBINING_CLASS_CCC130 = 130,
    HB_UNICODE_COMBINING_CLASS_CCC133 = 132,
    HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW_LEFT = 200,
    HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW = 202,
    HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE = 214,
    HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE_RIGHT = 216,
    HB_UNICODE_COMBINING_CLASS_BELOW_LEFT = 218,
    HB_UNICODE_COMBINING_CLASS_BELOW = 220,
    HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT = 222,
    HB_UNICODE_COMBINING_CLASS_LEFT = 224,
    HB_UNICODE_COMBINING_CLASS_RIGHT = 226,
    HB_UNICODE_COMBINING_CLASS_ABOVE_LEFT = 228,
    HB_UNICODE_COMBINING_CLASS_ABOVE = 230,
    HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT = 232,
    HB_UNICODE_COMBINING_CLASS_DOUBLE_BELOW = 233,
    HB_UNICODE_COMBINING_CLASS_DOUBLE_ABOVE = 234,
    HB_UNICODE_COMBINING_CLASS_IOTA_SUBSCRIPT = 240,
    HB_UNICODE_COMBINING_CLASS_INVALID = 255
} ;
#line 268 "/usr/include/harfbuzz/hb-unicode.h"
typedef enum __anonenum__401 hb_unicode_combining_class_t;
#line 287
struct hb_unicode_funcs_t ;
#line 287 "/usr/include/harfbuzz/hb-unicode.h"
typedef struct hb_unicode_funcs_t hb_unicode_funcs_t;
#line 352 "/usr/include/harfbuzz/hb-unicode.h"
typedef hb_unicode_combining_class_t (*hb_unicode_combining_class_func_t)(hb_unicode_funcs_t * ,
                                                                          hb_codepoint_t  ,
                                                                          void * );
#line 370 "/usr/include/harfbuzz/hb-unicode.h"
typedef hb_unicode_general_category_t (*hb_unicode_general_category_func_t)(hb_unicode_funcs_t * ,
                                                                            hb_codepoint_t  ,
                                                                            void * );
#line 392 "/usr/include/harfbuzz/hb-unicode.h"
typedef hb_codepoint_t (*hb_unicode_mirroring_func_t)(hb_unicode_funcs_t * , hb_codepoint_t  ,
                                                      void * );
#line 410 "/usr/include/harfbuzz/hb-unicode.h"
typedef hb_script_t (*hb_unicode_script_func_t)(hb_unicode_funcs_t * , hb_codepoint_t  ,
                                                void * );
#line 433 "/usr/include/harfbuzz/hb-unicode.h"
typedef hb_bool_t (*hb_unicode_compose_func_t)(hb_unicode_funcs_t * , hb_codepoint_t  ,
                                               hb_codepoint_t  , hb_codepoint_t * ,
                                               void * );
#line 457 "/usr/include/harfbuzz/hb-unicode.h"
typedef hb_bool_t (*hb_unicode_decompose_func_t)(hb_unicode_funcs_t * , hb_codepoint_t  ,
                                                 hb_codepoint_t * , hb_codepoint_t * ,
                                                 void * );
#line 53 "/usr/include/harfbuzz/hb-set.h"
struct hb_set_t ;
#line 53 "/usr/include/harfbuzz/hb-set.h"
typedef struct hb_set_t hb_set_t;
#line 55 "/usr/include/harfbuzz/hb-face.h"
struct hb_face_t ;
#line 55 "/usr/include/harfbuzz/hb-face.h"
typedef struct hb_face_t hb_face_t;
#line 61 "/usr/include/harfbuzz/hb-face.h"
typedef hb_blob_t *(*hb_reference_table_func_t)(hb_face_t * , hb_tag_t  , void * );
#line 41 "/usr/include/harfbuzz/hb-font.h"
struct hb_font_t ;
#line 41 "/usr/include/harfbuzz/hb-font.h"
typedef struct hb_font_t hb_font_t;
#line 61
struct hb_font_funcs_t ;
#line 61 "/usr/include/harfbuzz/hb-font.h"
typedef struct hb_font_funcs_t hb_font_funcs_t;
#line 108 "/usr/include/harfbuzz/hb-font.h"
struct hb_font_extents_t {
   hb_position_t ascender ;
   hb_position_t descender ;
   hb_position_t line_gap ;
   hb_position_t reserved9 ;
   hb_position_t reserved8 ;
   hb_position_t reserved7 ;
   hb_position_t reserved6 ;
   hb_position_t reserved5 ;
   hb_position_t reserved4 ;
   hb_position_t reserved3 ;
   hb_position_t reserved2 ;
   hb_position_t reserved1 ;
};
#line 122 "/usr/include/harfbuzz/hb-font.h"
typedef struct hb_font_extents_t hb_font_extents_t;
#line 135 "/usr/include/harfbuzz/hb-font.h"
struct hb_glyph_extents_t {
   hb_position_t x_bearing ;
   hb_position_t y_bearing ;
   hb_position_t width ;
   hb_position_t height ;
};
#line 140 "/usr/include/harfbuzz/hb-font.h"
typedef struct hb_glyph_extents_t hb_glyph_extents_t;
#line 144 "/usr/include/harfbuzz/hb-font.h"
typedef hb_bool_t (*hb_font_get_font_extents_func_t)(hb_font_t * , void * , hb_font_extents_t * ,
                                                     void * );
#line 158 "/usr/include/harfbuzz/hb-font.h"
typedef hb_font_get_font_extents_func_t hb_font_get_font_h_extents_func_t;
#line 170 "/usr/include/harfbuzz/hb-font.h"
typedef hb_font_get_font_extents_func_t hb_font_get_font_v_extents_func_t;
#line 182 "/usr/include/harfbuzz/hb-font.h"
typedef hb_bool_t (*hb_font_get_nominal_glyph_func_t)(hb_font_t * , void * , hb_codepoint_t  ,
                                                      hb_codepoint_t * , void * );
#line 197 "/usr/include/harfbuzz/hb-font.h"
typedef hb_bool_t (*hb_font_get_variation_glyph_func_t)(hb_font_t * , void * , hb_codepoint_t  ,
                                                        hb_codepoint_t  , hb_codepoint_t * ,
                                                        void * );
#line 213 "/usr/include/harfbuzz/hb-font.h"
typedef unsigned int (*hb_font_get_nominal_glyphs_func_t)(hb_font_t * , void * , unsigned int  ,
                                                          hb_codepoint_t * , unsigned int  ,
                                                          hb_codepoint_t * , unsigned int  ,
                                                          void * );
#line 230 "/usr/include/harfbuzz/hb-font.h"
typedef hb_position_t (*hb_font_get_glyph_advance_func_t)(hb_font_t * , void * , hb_codepoint_t  ,
                                                          void * );
#line 244 "/usr/include/harfbuzz/hb-font.h"
typedef hb_font_get_glyph_advance_func_t hb_font_get_glyph_h_advance_func_t;
#line 256 "/usr/include/harfbuzz/hb-font.h"
typedef hb_font_get_glyph_advance_func_t hb_font_get_glyph_v_advance_func_t;
#line 266 "/usr/include/harfbuzz/hb-font.h"
typedef void (*hb_font_get_glyph_advances_func_t)(hb_font_t * , void * , unsigned int  ,
                                                  hb_codepoint_t * , unsigned int  ,
                                                  hb_position_t * , unsigned int  ,
                                                  void * );
#line 283 "/usr/include/harfbuzz/hb-font.h"
typedef hb_font_get_glyph_advances_func_t hb_font_get_glyph_h_advances_func_t;
#line 294 "/usr/include/harfbuzz/hb-font.h"
typedef hb_font_get_glyph_advances_func_t hb_font_get_glyph_v_advances_func_t;
#line 306 "/usr/include/harfbuzz/hb-font.h"
typedef hb_bool_t (*hb_font_get_glyph_origin_func_t)(hb_font_t * , void * , hb_codepoint_t  ,
                                                     hb_position_t * , hb_position_t * ,
                                                     void * );
#line 321 "/usr/include/harfbuzz/hb-font.h"
typedef hb_font_get_glyph_origin_func_t hb_font_get_glyph_h_origin_func_t;
#line 333 "/usr/include/harfbuzz/hb-font.h"
typedef hb_font_get_glyph_origin_func_t hb_font_get_glyph_v_origin_func_t;
#line 335 "/usr/include/harfbuzz/hb-font.h"
typedef hb_position_t (*hb_font_get_glyph_kerning_func_t)(hb_font_t * , void * , hb_codepoint_t  ,
                                                          hb_codepoint_t  , void * );
#line 338 "/usr/include/harfbuzz/hb-font.h"
typedef hb_font_get_glyph_kerning_func_t hb_font_get_glyph_h_kerning_func_t;
#line 350 "/usr/include/harfbuzz/hb-font.h"
typedef hb_bool_t (*hb_font_get_glyph_extents_func_t)(hb_font_t * , void * , hb_codepoint_t  ,
                                                      hb_glyph_extents_t * , void * );
#line 365 "/usr/include/harfbuzz/hb-font.h"
typedef hb_bool_t (*hb_font_get_glyph_contour_point_func_t)(hb_font_t * , void * ,
                                                            hb_codepoint_t  , unsigned int  ,
                                                            hb_position_t * , hb_position_t * ,
                                                            void * );
#line 380 "/usr/include/harfbuzz/hb-font.h"
typedef hb_bool_t (*hb_font_get_glyph_name_func_t)(hb_font_t * , void * , hb_codepoint_t  ,
                                                   char * , unsigned int  , void * );
#line 394 "/usr/include/harfbuzz/hb-font.h"
typedef hb_bool_t (*hb_font_get_glyph_from_name_func_t)(hb_font_t * , void * , char const   * ,
                                                        int  , hb_codepoint_t * ,
                                                        void * );
#line 62 "/usr/include/harfbuzz/hb-buffer.h"
struct hb_glyph_info_t {
   hb_codepoint_t codepoint ;
   hb_mask_t mask ;
   uint32_t cluster ;
   hb_var_int_t var1 ;
   hb_var_int_t var2 ;
};
#line 72 "/usr/include/harfbuzz/hb-buffer.h"
typedef struct hb_glyph_info_t hb_glyph_info_t;
#line 95
enum __anonenum__402 {
    HB_GLYPH_FLAG_UNSAFE_TO_BREAK = 1,
    HB_GLYPH_FLAG_DEFINED = 1
} ;
#line 99 "/usr/include/harfbuzz/hb-buffer.h"
typedef enum __anonenum__402 hb_glyph_flags_t;
#line 124 "/usr/include/harfbuzz/hb-buffer.h"
struct hb_glyph_position_t {
   hb_position_t x_advance ;
   hb_position_t y_advance ;
   hb_position_t x_offset ;
   hb_position_t y_offset ;
   hb_var_int_t var ;
};
#line 132 "/usr/include/harfbuzz/hb-buffer.h"
typedef struct hb_glyph_position_t hb_glyph_position_t;
#line 144 "/usr/include/harfbuzz/hb-buffer.h"
struct hb_segment_properties_t {
   hb_direction_t direction ;
   hb_script_t script ;
   hb_language_t language ;
   void *reserved1 ;
   void *reserved2 ;
};
#line 151 "/usr/include/harfbuzz/hb-buffer.h"
typedef struct hb_segment_properties_t hb_segment_properties_t;
#line 175
struct hb_buffer_t ;
#line 175 "/usr/include/harfbuzz/hb-buffer.h"
typedef struct hb_buffer_t hb_buffer_t;
#line 207
enum __anonenum__403 {
    HB_BUFFER_CONTENT_TYPE_INVALID = 0,
    HB_BUFFER_CONTENT_TYPE_UNICODE = 1,
    HB_BUFFER_CONTENT_TYPE_GLYPHS = 2
} ;
#line 211 "/usr/include/harfbuzz/hb-buffer.h"
typedef enum __anonenum__403 hb_buffer_content_type_t;
#line 293
enum __anonenum__404 {
    HB_BUFFER_FLAG_DEFAULT = 0,
    HB_BUFFER_FLAG_BOT = 1,
    HB_BUFFER_FLAG_EOT = 2,
    HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES = 4,
    HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES = 8,
    HB_BUFFER_FLAG_DO_NOT_INSERT_DOTTED_CIRCLE = 16
} ;
#line 300 "/usr/include/harfbuzz/hb-buffer.h"
typedef enum __anonenum__404 hb_buffer_flags_t;
#line 337
enum __anonenum__405 {
    HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES = 0,
    HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS = 1,
    HB_BUFFER_CLUSTER_LEVEL_CHARACTERS = 2,
    HB_BUFFER_CLUSTER_LEVEL_DEFAULT = 0
} ;
#line 342 "/usr/include/harfbuzz/hb-buffer.h"
typedef enum __anonenum__405 hb_buffer_cluster_level_t;
#line 493
enum __anonenum__406 {
    HB_BUFFER_SERIALIZE_FLAG_DEFAULT = 0,
    HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS = 1,
    HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS = 2,
    HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES = 4,
    HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS = 8,
    HB_BUFFER_SERIALIZE_FLAG_GLYPH_FLAGS = 16,
    HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES = 32
} ;
#line 501 "/usr/include/harfbuzz/hb-buffer.h"
typedef enum __anonenum__406 hb_buffer_serialize_flags_t;
#line 514
enum __anonenum__407 {
    HB_BUFFER_SERIALIZE_FORMAT_TEXT = 1413830740,
    HB_BUFFER_SERIALIZE_FORMAT_JSON = 1246973774,
    HB_BUFFER_SERIALIZE_FORMAT_INVALID = 0
} ;
#line 518 "/usr/include/harfbuzz/hb-buffer.h"
typedef enum __anonenum__407 hb_buffer_serialize_format_t;
#line 582
enum __anonenum__408 {
    HB_BUFFER_DIFF_FLAG_EQUAL = 0,
    HB_BUFFER_DIFF_FLAG_CONTENT_TYPE_MISMATCH = 1,
    HB_BUFFER_DIFF_FLAG_LENGTH_MISMATCH = 2,
    HB_BUFFER_DIFF_FLAG_NOTDEF_PRESENT = 4,
    HB_BUFFER_DIFF_FLAG_DOTTED_CIRCLE_PRESENT = 8,
    HB_BUFFER_DIFF_FLAG_CODEPOINT_MISMATCH = 16,
    HB_BUFFER_DIFF_FLAG_CLUSTER_MISMATCH = 32,
    HB_BUFFER_DIFF_FLAG_GLYPH_FLAGS_MISMATCH = 64,
    HB_BUFFER_DIFF_FLAG_POSITION_MISMATCH = 128
} ;
#line 607 "/usr/include/harfbuzz/hb-buffer.h"
typedef enum __anonenum__408 hb_buffer_diff_flags_t;
#line 621 "/usr/include/harfbuzz/hb-buffer.h"
typedef hb_bool_t (*hb_buffer_message_func_t)(hb_buffer_t * , hb_font_t * , char const   * ,
                                              void * );
#line 61 "/usr/include/harfbuzz/hb-deprecated.h"
typedef hb_bool_t (*hb_font_get_glyph_func_t)(hb_font_t * , void * , hb_codepoint_t  ,
                                              hb_codepoint_t  , hb_codepoint_t * ,
                                              void * );
#line 79 "/usr/include/harfbuzz/hb-deprecated.h"
typedef unsigned int (*hb_unicode_eastasian_width_func_t)(hb_unicode_funcs_t * , hb_codepoint_t  ,
                                                          void * );
#line 131 "/usr/include/harfbuzz/hb-deprecated.h"
typedef unsigned int (*hb_unicode_decompose_compatibility_func_t)(hb_unicode_funcs_t * ,
                                                                  hb_codepoint_t  ,
                                                                  hb_codepoint_t * ,
                                                                  void * );
#line 168 "/usr/include/harfbuzz/hb-deprecated.h"
typedef hb_font_get_glyph_kerning_func_t hb_font_get_glyph_v_kerning_func_t;
#line 50 "/usr/include/harfbuzz/hb-map.h"
struct hb_map_t ;
#line 50 "/usr/include/harfbuzz/hb-map.h"
typedef struct hb_map_t hb_map_t;
#line 53 "/usr/include/harfbuzz/hb-shape-plan.h"
struct hb_shape_plan_t ;
#line 53 "/usr/include/harfbuzz/hb-shape-plan.h"
typedef struct hb_shape_plan_t hb_shape_plan_t;
#line 44 "/usr/include/pango-1.0/pango/pango-coverage.h"
struct _PangoCoverage ;
#line 44 "/usr/include/pango-1.0/pango/pango-coverage.h"
typedef struct _PangoCoverage PangoCoverage;
#line 67
enum __anonenum__409 {
    PANGO_COVERAGE_NONE = 0,
    PANGO_COVERAGE_FALLBACK = 1,
    PANGO_COVERAGE_APPROXIMATE = 2,
    PANGO_COVERAGE_EXACT = 3
} ;
#line 72 "/usr/include/pango-1.0/pango/pango-coverage.h"
typedef enum __anonenum__409 PangoCoverageLevel;
#line 104 "/usr/include/pango-1.0/pango/pango-coverage.h"
typedef PangoCoverage *PangoCoverage_autoptr;
#line 104 "/usr/include/pango-1.0/pango/pango-coverage.h"
typedef GList *PangoCoverage_listautoptr;
#line 104 "/usr/include/pango-1.0/pango/pango-coverage.h"
typedef GSList *PangoCoverage_slistautoptr;
#line 104 "/usr/include/pango-1.0/pango/pango-coverage.h"
typedef GQueue *PangoCoverage_queueautoptr;
#line 32 "/usr/include/pango-1.0/pango/pango-types.h"
struct _PangoLogAttr ;
#line 32 "/usr/include/pango-1.0/pango/pango-types.h"
typedef struct _PangoLogAttr PangoLogAttr;
#line 35
struct _PangoEngineLang ;
#line 35 "/usr/include/pango-1.0/pango/pango-types.h"
typedef struct _PangoEngineLang PangoEngineLang;
#line 36
struct _PangoEngineShape ;
#line 36 "/usr/include/pango-1.0/pango/pango-types.h"
typedef struct _PangoEngineShape PangoEngineShape;
#line 39
struct _PangoFont ;
#line 39 "/usr/include/pango-1.0/pango/pango-types.h"
typedef struct _PangoFont PangoFont;
#line 40
struct _PangoFontMap ;
#line 40 "/usr/include/pango-1.0/pango/pango-types.h"
typedef struct _PangoFontMap PangoFontMap;
#line 42
struct _PangoRectangle ;
#line 42 "/usr/include/pango-1.0/pango/pango-types.h"
typedef struct _PangoRectangle PangoRectangle;
#line 44
struct _PangoContext ;
#line 44 "/usr/include/pango-1.0/pango/pango-types.h"
typedef struct _PangoContext PangoContext;
#line 46
struct _PangoLanguage ;
#line 46 "/usr/include/pango-1.0/pango/pango-types.h"
typedef struct _PangoLanguage PangoLanguage;
#line 54 "/usr/include/pango-1.0/pango/pango-types.h"
typedef guint32 PangoGlyph;
#line 169 "/usr/include/pango-1.0/pango/pango-types.h"
struct _PangoRectangle {
   int x ;
   int y ;
   int width ;
   int height ;
};
#line 53 "/usr/include/pango-1.0/pango/pango-gravity.h"
enum __anonenum__410 {
    PANGO_GRAVITY_SOUTH = 0,
    PANGO_GRAVITY_EAST = 1,
    PANGO_GRAVITY_NORTH = 2,
    PANGO_GRAVITY_WEST = 3,
    PANGO_GRAVITY_AUTO = 4
} ;
#line 59 "/usr/include/pango-1.0/pango/pango-gravity.h"
typedef enum __anonenum__410 PangoGravity;
#line 81
enum __anonenum__411 {
    PANGO_GRAVITY_HINT_NATURAL = 0,
    PANGO_GRAVITY_HINT_STRONG = 1,
    PANGO_GRAVITY_HINT_LINE = 2
} ;
#line 85 "/usr/include/pango-1.0/pango/pango-gravity.h"
typedef enum __anonenum__411 PangoGravityHint;
#line 30 "/usr/include/pango-1.0/pango/pango-matrix.h"
struct _PangoMatrix ;
#line 30 "/usr/include/pango-1.0/pango/pango-matrix.h"
typedef struct _PangoMatrix PangoMatrix;
#line 53 "/usr/include/pango-1.0/pango/pango-matrix.h"
struct _PangoMatrix {
   double xx ;
   double xy ;
   double yx ;
   double yy ;
   double x0 ;
   double y0 ;
};
#line 35 "/usr/include/pango-1.0/pango/pango-script.h"
struct _PangoScriptIter ;
#line 35 "/usr/include/pango-1.0/pango/pango-script.h"
typedef struct _PangoScriptIter PangoScriptIter;
#line 170
enum __anonenum__412 {
    PANGO_SCRIPT_INVALID_CODE = -1,
    PANGO_SCRIPT_COMMON = 0,
    PANGO_SCRIPT_INHERITED = 1,
    PANGO_SCRIPT_ARABIC = 2,
    PANGO_SCRIPT_ARMENIAN = 3,
    PANGO_SCRIPT_BENGALI = 4,
    PANGO_SCRIPT_BOPOMOFO = 5,
    PANGO_SCRIPT_CHEROKEE = 6,
    PANGO_SCRIPT_COPTIC = 7,
    PANGO_SCRIPT_CYRILLIC = 8,
    PANGO_SCRIPT_DESERET = 9,
    PANGO_SCRIPT_DEVANAGARI = 10,
    PANGO_SCRIPT_ETHIOPIC = 11,
    PANGO_SCRIPT_GEORGIAN = 12,
    PANGO_SCRIPT_GOTHIC = 13,
    PANGO_SCRIPT_GREEK = 14,
    PANGO_SCRIPT_GUJARATI = 15,
    PANGO_SCRIPT_GURMUKHI = 16,
    PANGO_SCRIPT_HAN = 17,
    PANGO_SCRIPT_HANGUL = 18,
    PANGO_SCRIPT_HEBREW = 19,
    PANGO_SCRIPT_HIRAGANA = 20,
    PANGO_SCRIPT_KANNADA = 21,
    PANGO_SCRIPT_KATAKANA = 22,
    PANGO_SCRIPT_KHMER = 23,
    PANGO_SCRIPT_LAO = 24,
    PANGO_SCRIPT_LATIN = 25,
    PANGO_SCRIPT_MALAYALAM = 26,
    PANGO_SCRIPT_MONGOLIAN = 27,
    PANGO_SCRIPT_MYANMAR = 28,
    PANGO_SCRIPT_OGHAM = 29,
    PANGO_SCRIPT_OLD_ITALIC = 30,
    PANGO_SCRIPT_ORIYA = 31,
    PANGO_SCRIPT_RUNIC = 32,
    PANGO_SCRIPT_SINHALA = 33,
    PANGO_SCRIPT_SYRIAC = 34,
    PANGO_SCRIPT_TAMIL = 35,
    PANGO_SCRIPT_TELUGU = 36,
    PANGO_SCRIPT_THAANA = 37,
    PANGO_SCRIPT_THAI = 38,
    PANGO_SCRIPT_TIBETAN = 39,
    PANGO_SCRIPT_CANADIAN_ABORIGINAL = 40,
    PANGO_SCRIPT_YI = 41,
    PANGO_SCRIPT_TAGALOG = 42,
    PANGO_SCRIPT_HANUNOO = 43,
    PANGO_SCRIPT_BUHID = 44,
    PANGO_SCRIPT_TAGBANWA = 45,
    PANGO_SCRIPT_BRAILLE = 46,
    PANGO_SCRIPT_CYPRIOT = 47,
    PANGO_SCRIPT_LIMBU = 48,
    PANGO_SCRIPT_OSMANYA = 49,
    PANGO_SCRIPT_SHAVIAN = 50,
    PANGO_SCRIPT_LINEAR_B = 51,
    PANGO_SCRIPT_TAI_LE = 52,
    PANGO_SCRIPT_UGARITIC = 53,
    PANGO_SCRIPT_NEW_TAI_LUE = 54,
    PANGO_SCRIPT_BUGINESE = 55,
    PANGO_SCRIPT_GLAGOLITIC = 56,
    PANGO_SCRIPT_TIFINAGH = 57,
    PANGO_SCRIPT_SYLOTI_NAGRI = 58,
    PANGO_SCRIPT_OLD_PERSIAN = 59,
    PANGO_SCRIPT_KHAROSHTHI = 60,
    PANGO_SCRIPT_UNKNOWN = 61,
    PANGO_SCRIPT_BALINESE = 62,
    PANGO_SCRIPT_CUNEIFORM = 63,
    PANGO_SCRIPT_PHOENICIAN = 64,
    PANGO_SCRIPT_PHAGS_PA = 65,
    PANGO_SCRIPT_NKO = 66,
    PANGO_SCRIPT_KAYAH_LI = 67,
    PANGO_SCRIPT_LEPCHA = 68,
    PANGO_SCRIPT_REJANG = 69,
    PANGO_SCRIPT_SUNDANESE = 70,
    PANGO_SCRIPT_SAURASHTRA = 71,
    PANGO_SCRIPT_CHAM = 72,
    PANGO_SCRIPT_OL_CHIKI = 73,
    PANGO_SCRIPT_VAI = 74,
    PANGO_SCRIPT_CARIAN = 75,
    PANGO_SCRIPT_LYCIAN = 76,
    PANGO_SCRIPT_LYDIAN = 77,
    PANGO_SCRIPT_BATAK = 78,
    PANGO_SCRIPT_BRAHMI = 79,
    PANGO_SCRIPT_MANDAIC = 80,
    PANGO_SCRIPT_CHAKMA = 81,
    PANGO_SCRIPT_MEROITIC_CURSIVE = 82,
    PANGO_SCRIPT_MEROITIC_HIEROGLYPHS = 83,
    PANGO_SCRIPT_MIAO = 84,
    PANGO_SCRIPT_SHARADA = 85,
    PANGO_SCRIPT_SORA_SOMPENG = 86,
    PANGO_SCRIPT_TAKRI = 87,
    PANGO_SCRIPT_BASSA_VAH = 88,
    PANGO_SCRIPT_CAUCASIAN_ALBANIAN = 89,
    PANGO_SCRIPT_DUPLOYAN = 90,
    PANGO_SCRIPT_ELBASAN = 91,
    PANGO_SCRIPT_GRANTHA = 92,
    PANGO_SCRIPT_KHOJKI = 93,
    PANGO_SCRIPT_KHUDAWADI = 94,
    PANGO_SCRIPT_LINEAR_A = 95,
    PANGO_SCRIPT_MAHAJANI = 96,
    PANGO_SCRIPT_MANICHAEAN = 97,
    PANGO_SCRIPT_MENDE_KIKAKUI = 98,
    PANGO_SCRIPT_MODI = 99,
    PANGO_SCRIPT_MRO = 100,
    PANGO_SCRIPT_NABATAEAN = 101,
    PANGO_SCRIPT_OLD_NORTH_ARABIAN = 102,
    PANGO_SCRIPT_OLD_PERMIC = 103,
    PANGO_SCRIPT_PAHAWH_HMONG = 104,
    PANGO_SCRIPT_PALMYRENE = 105,
    PANGO_SCRIPT_PAU_CIN_HAU = 106,
    PANGO_SCRIPT_PSALTER_PAHLAVI = 107,
    PANGO_SCRIPT_SIDDHAM = 108,
    PANGO_SCRIPT_TIRHUTA = 109,
    PANGO_SCRIPT_WARANG_CITI = 110,
    PANGO_SCRIPT_AHOM = 111,
    PANGO_SCRIPT_ANATOLIAN_HIEROGLYPHS = 112,
    PANGO_SCRIPT_HATRAN = 113,
    PANGO_SCRIPT_MULTANI = 114,
    PANGO_SCRIPT_OLD_HUNGARIAN = 115,
    PANGO_SCRIPT_SIGNWRITING = 116
} ;
#line 305 "/usr/include/pango-1.0/pango/pango-script.h"
typedef enum __anonenum__412 PangoScript;
#line 60 "/usr/include/pango-1.0/pango/pango-direction.h"
enum __anonenum__413 {
    PANGO_DIRECTION_LTR = 0,
    PANGO_DIRECTION_RTL = 1,
    PANGO_DIRECTION_TTB_LTR = 2,
    PANGO_DIRECTION_TTB_RTL = 3,
    PANGO_DIRECTION_WEAK_LTR = 4,
    PANGO_DIRECTION_WEAK_RTL = 5,
    PANGO_DIRECTION_NEUTRAL = 6
} ;
#line 68 "/usr/include/pango-1.0/pango/pango-direction.h"
typedef enum __anonenum__413 PangoDirection;
#line 68 "/usr/include/pango-1.0/pango/pango-bidi-type.h"
enum __anonenum__414 {
    PANGO_BIDI_TYPE_L = 0,
    PANGO_BIDI_TYPE_LRE = 1,
    PANGO_BIDI_TYPE_LRO = 2,
    PANGO_BIDI_TYPE_R = 3,
    PANGO_BIDI_TYPE_AL = 4,
    PANGO_BIDI_TYPE_RLE = 5,
    PANGO_BIDI_TYPE_RLO = 6,
    PANGO_BIDI_TYPE_PDF = 7,
    PANGO_BIDI_TYPE_EN = 8,
    PANGO_BIDI_TYPE_ES = 9,
    PANGO_BIDI_TYPE_ET = 10,
    PANGO_BIDI_TYPE_AN = 11,
    PANGO_BIDI_TYPE_CS = 12,
    PANGO_BIDI_TYPE_NSM = 13,
    PANGO_BIDI_TYPE_BN = 14,
    PANGO_BIDI_TYPE_B = 15,
    PANGO_BIDI_TYPE_S = 16,
    PANGO_BIDI_TYPE_WS = 17,
    PANGO_BIDI_TYPE_ON = 18,
    PANGO_BIDI_TYPE_LRI = 19,
    PANGO_BIDI_TYPE_RLI = 20,
    PANGO_BIDI_TYPE_FSI = 21,
    PANGO_BIDI_TYPE_PDI = 22
} ;
#line 99 "/usr/include/pango-1.0/pango/pango-bidi-type.h"
typedef enum __anonenum__414 PangoBidiType;
#line 43 "/usr/include/pango-1.0/pango/pango-font.h"
struct _PangoFontDescription ;
#line 43 "/usr/include/pango-1.0/pango/pango-font.h"
typedef struct _PangoFontDescription PangoFontDescription;
#line 64
struct _PangoFontMetrics ;
#line 64 "/usr/include/pango-1.0/pango/pango-font.h"
typedef struct _PangoFontMetrics PangoFontMetrics;
#line 74
enum __anonenum__415 {
    PANGO_STYLE_NORMAL = 0,
    PANGO_STYLE_OBLIQUE = 1,
    PANGO_STYLE_ITALIC = 2
} ;
#line 78 "/usr/include/pango-1.0/pango/pango-font.h"
typedef enum __anonenum__415 PangoStyle;
#line 100
enum __anonenum__416 {
    PANGO_VARIANT_NORMAL = 0,
    PANGO_VARIANT_SMALL_CAPS = 1,
    PANGO_VARIANT_ALL_SMALL_CAPS = 2,
    PANGO_VARIANT_PETITE_CAPS = 3,
    PANGO_VARIANT_ALL_PETITE_CAPS = 4,
    PANGO_VARIANT_UNICASE = 5,
    PANGO_VARIANT_TITLE_CAPS = 6
} ;
#line 108 "/usr/include/pango-1.0/pango/pango-font.h"
typedef enum __anonenum__416 PangoVariant;
#line 130
enum __anonenum__417 {
    PANGO_WEIGHT_THIN = 100,
    PANGO_WEIGHT_ULTRALIGHT = 200,
    PANGO_WEIGHT_LIGHT = 300,
    PANGO_WEIGHT_SEMILIGHT = 350,
    PANGO_WEIGHT_BOOK = 380,
    PANGO_WEIGHT_NORMAL = 400,
    PANGO_WEIGHT_MEDIUM = 500,
    PANGO_WEIGHT_SEMIBOLD = 600,
    PANGO_WEIGHT_BOLD = 700,
    PANGO_WEIGHT_ULTRABOLD = 800,
    PANGO_WEIGHT_HEAVY = 900,
    PANGO_WEIGHT_ULTRAHEAVY = 1000
} ;
#line 143 "/usr/include/pango-1.0/pango/pango-font.h"
typedef enum __anonenum__417 PangoWeight;
#line 160
enum __anonenum__418 {
    PANGO_STRETCH_ULTRA_CONDENSED = 0,
    PANGO_STRETCH_EXTRA_CONDENSED = 1,
    PANGO_STRETCH_CONDENSED = 2,
    PANGO_STRETCH_SEMI_CONDENSED = 3,
    PANGO_STRETCH_NORMAL = 4,
    PANGO_STRETCH_SEMI_EXPANDED = 5,
    PANGO_STRETCH_EXPANDED = 6,
    PANGO_STRETCH_EXTRA_EXPANDED = 7,
    PANGO_STRETCH_ULTRA_EXPANDED = 8
} ;
#line 170 "/usr/include/pango-1.0/pango/pango-font.h"
typedef enum __anonenum__418 PangoStretch;
#line 186
enum __anonenum__419 {
    PANGO_FONT_MASK_FAMILY = 1,
    PANGO_FONT_MASK_STYLE = 2,
    PANGO_FONT_MASK_VARIANT = 4,
    PANGO_FONT_MASK_WEIGHT = 8,
    PANGO_FONT_MASK_STRETCH = 16,
    PANGO_FONT_MASK_SIZE = 32,
    PANGO_FONT_MASK_GRAVITY = 64,
    PANGO_FONT_MASK_VARIATIONS = 128
} ;
#line 195 "/usr/include/pango-1.0/pango/pango-font.h"
typedef enum __anonenum__419 PangoFontMask;
#line 352 "/usr/include/pango-1.0/pango/pango-font.h"
struct _PangoFontMetrics {
   guint ref_count ;
   int ascent ;
   int descent ;
   int height ;
   int approximate_char_width ;
   int approximate_digit_width ;
   int underline_position ;
   int underline_thickness ;
   int strikethrough_position ;
   int strikethrough_thickness ;
};
#line 405
struct _PangoFontFace ;
#line 405 "/usr/include/pango-1.0/pango/pango-font.h"
typedef struct _PangoFontFace PangoFontFace;
#line 406
struct _PangoFontFamily ;
#line 406 "/usr/include/pango-1.0/pango/pango-font.h"
typedef struct _PangoFontFamily PangoFontFamily;
#line 407
struct _PangoFontFamilyClass ;
#line 407 "/usr/include/pango-1.0/pango/pango-font.h"
typedef struct _PangoFontFamilyClass PangoFontFamilyClass;
#line 420 "/usr/include/pango-1.0/pango/pango-font.h"
struct _PangoFontFamily {
   GObject parent_instance ;
};
#line 425 "/usr/include/pango-1.0/pango/pango-font.h"
struct _PangoFontFamilyClass {
   GObjectClass parent_class ;
   void (*list_faces)(PangoFontFamily * , PangoFontFace *** , int * ) ;
   char const   *(*get_name)(PangoFontFamily * ) ;
   gboolean (*is_monospace)(PangoFontFamily * ) ;
   gboolean (*is_variable)(PangoFontFamily * ) ;
   PangoFontFace *(*get_face)(PangoFontFamily * , char const   * ) ;
   void (*_pango_reserved2)(void) ;
};
#line 480
struct _PangoFontFaceClass ;
#line 480 "/usr/include/pango-1.0/pango/pango-font.h"
typedef struct _PangoFontFaceClass PangoFontFaceClass;
#line 490 "/usr/include/pango-1.0/pango/pango-font.h"
struct _PangoFontFace {
   GObject parent_instance ;
};
#line 495 "/usr/include/pango-1.0/pango/pango-font.h"
struct _PangoFontFaceClass {
   GObjectClass parent_class ;
   char const   *(*get_face_name)(PangoFontFace * ) ;
   PangoFontDescription *(*describe)(PangoFontFace * ) ;
   void (*list_sizes)(PangoFontFace * , int ** , int * ) ;
   gboolean (*is_synthesized)(PangoFontFace * ) ;
   PangoFontFamily *(*get_family)(PangoFontFace * ) ;
   void (*_pango_reserved3)(void) ;
   void (*_pango_reserved4)(void) ;
};
#line 556 "/usr/include/pango-1.0/pango/pango-font.h"
struct _PangoFont {
   GObject parent_instance ;
};
#line 561
struct _PangoFontClass ;
#line 561 "/usr/include/pango-1.0/pango/pango-font.h"
typedef struct _PangoFontClass PangoFontClass;
#line 562 "/usr/include/pango-1.0/pango/pango-font.h"
struct _PangoFontClass {
   GObjectClass parent_class ;
   PangoFontDescription *(*describe)(PangoFont * ) ;
   PangoCoverage *(*get_coverage)(PangoFont * , PangoLanguage * ) ;
   void (*get_glyph_extents)(PangoFont * , PangoGlyph  , PangoRectangle * , PangoRectangle * ) ;
   PangoFontMetrics *(*get_metrics)(PangoFont * , PangoLanguage * ) ;
   PangoFontMap *(*get_font_map)(PangoFont * ) ;
   PangoFontDescription *(*describe_absolute)(PangoFont * ) ;
   void (*get_features)(PangoFont * , hb_feature_t * , guint  , guint * ) ;
   hb_font_t *(*create_hb_font)(PangoFont * ) ;
};
#line 692 "/usr/include/pango-1.0/pango/pango-font.h"
typedef PangoFontFamily *PangoFontFamily_autoptr;
#line 692 "/usr/include/pango-1.0/pango/pango-font.h"
typedef GList *PangoFontFamily_listautoptr;
#line 692 "/usr/include/pango-1.0/pango/pango-font.h"
typedef GSList *PangoFontFamily_slistautoptr;
#line 692 "/usr/include/pango-1.0/pango/pango-font.h"
typedef GQueue *PangoFontFamily_queueautoptr;
#line 693 "/usr/include/pango-1.0/pango/pango-font.h"
typedef PangoFontFace *PangoFontFace_autoptr;
#line 693 "/usr/include/pango-1.0/pango/pango-font.h"
typedef GList *PangoFontFace_listautoptr;
#line 693 "/usr/include/pango-1.0/pango/pango-font.h"
typedef GSList *PangoFontFace_slistautoptr;
#line 693 "/usr/include/pango-1.0/pango/pango-font.h"
typedef GQueue *PangoFontFace_queueautoptr;
#line 694 "/usr/include/pango-1.0/pango/pango-font.h"
typedef PangoFont *PangoFont_autoptr;
#line 694 "/usr/include/pango-1.0/pango/pango-font.h"
typedef GList *PangoFont_listautoptr;
#line 694 "/usr/include/pango-1.0/pango/pango-font.h"
typedef GSList *PangoFont_slistautoptr;
#line 694 "/usr/include/pango-1.0/pango/pango-font.h"
typedef GQueue *PangoFont_queueautoptr;
#line 695 "/usr/include/pango-1.0/pango/pango-font.h"
typedef PangoFontDescription *PangoFontDescription_autoptr;
#line 695 "/usr/include/pango-1.0/pango/pango-font.h"
typedef GList *PangoFontDescription_listautoptr;
#line 695 "/usr/include/pango-1.0/pango/pango-font.h"
typedef GSList *PangoFontDescription_slistautoptr;
#line 695 "/usr/include/pango-1.0/pango/pango-font.h"
typedef GQueue *PangoFontDescription_queueautoptr;
#line 31 "/usr/include/pango-1.0/pango/pango-color.h"
struct _PangoColor ;
#line 31 "/usr/include/pango-1.0/pango/pango-color.h"
typedef struct _PangoColor PangoColor;
#line 42 "/usr/include/pango-1.0/pango/pango-color.h"
struct _PangoColor {
   guint16 red ;
   guint16 green ;
   guint16 blue ;
};
#line 32 "/usr/include/pango-1.0/pango/pango-attributes.h"
struct _PangoAttribute ;
#line 32 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef struct _PangoAttribute PangoAttribute;
#line 33
struct _PangoAttrClass ;
#line 33 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef struct _PangoAttrClass PangoAttrClass;
#line 35
struct _PangoAttrString ;
#line 35 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef struct _PangoAttrString PangoAttrString;
#line 36
struct _PangoAttrLanguage ;
#line 36 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef struct _PangoAttrLanguage PangoAttrLanguage;
#line 37
struct _PangoAttrInt ;
#line 37 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef struct _PangoAttrInt PangoAttrInt;
#line 38
struct _PangoAttrSize ;
#line 38 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef struct _PangoAttrSize PangoAttrSize;
#line 39
struct _PangoAttrFloat ;
#line 39 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef struct _PangoAttrFloat PangoAttrFloat;
#line 40
struct _PangoAttrColor ;
#line 40 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef struct _PangoAttrColor PangoAttrColor;
#line 41
struct _PangoAttrFontDesc ;
#line 41 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef struct _PangoAttrFontDesc PangoAttrFontDesc;
#line 42
struct _PangoAttrShape ;
#line 42 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef struct _PangoAttrShape PangoAttrShape;
#line 43
struct _PangoAttrFontFeatures ;
#line 43 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef struct _PangoAttrFontFeatures PangoAttrFontFeatures;
#line 92
enum __anonenum__420 {
    PANGO_ATTR_INVALID = 0,
    PANGO_ATTR_LANGUAGE = 1,
    PANGO_ATTR_FAMILY = 2,
    PANGO_ATTR_STYLE = 3,
    PANGO_ATTR_WEIGHT = 4,
    PANGO_ATTR_VARIANT = 5,
    PANGO_ATTR_STRETCH = 6,
    PANGO_ATTR_SIZE = 7,
    PANGO_ATTR_FONT_DESC = 8,
    PANGO_ATTR_FOREGROUND = 9,
    PANGO_ATTR_BACKGROUND = 10,
    PANGO_ATTR_UNDERLINE = 11,
    PANGO_ATTR_STRIKETHROUGH = 12,
    PANGO_ATTR_RISE = 13,
    PANGO_ATTR_SHAPE = 14,
    PANGO_ATTR_SCALE = 15,
    PANGO_ATTR_FALLBACK = 16,
    PANGO_ATTR_LETTER_SPACING = 17,
    PANGO_ATTR_UNDERLINE_COLOR = 18,
    PANGO_ATTR_STRIKETHROUGH_COLOR = 19,
    PANGO_ATTR_ABSOLUTE_SIZE = 20,
    PANGO_ATTR_GRAVITY = 21,
    PANGO_ATTR_GRAVITY_HINT = 22,
    PANGO_ATTR_FONT_FEATURES = 23,
    PANGO_ATTR_FOREGROUND_ALPHA = 24,
    PANGO_ATTR_BACKGROUND_ALPHA = 25,
    PANGO_ATTR_ALLOW_BREAKS = 26,
    PANGO_ATTR_SHOW = 27,
    PANGO_ATTR_INSERT_HYPHENS = 28,
    PANGO_ATTR_OVERLINE = 29,
    PANGO_ATTR_OVERLINE_COLOR = 30,
    PANGO_ATTR_LINE_HEIGHT = 31,
    PANGO_ATTR_ABSOLUTE_LINE_HEIGHT = 32,
    PANGO_ATTR_TEXT_TRANSFORM = 33,
    PANGO_ATTR_WORD = 34,
    PANGO_ATTR_SENTENCE = 35,
    PANGO_ATTR_BASELINE_SHIFT = 36,
    PANGO_ATTR_FONT_SCALE = 37
} ;
#line 132 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef enum __anonenum__420 PangoAttrType;
#line 166
enum __anonenum__421 {
    PANGO_UNDERLINE_NONE = 0,
    PANGO_UNDERLINE_SINGLE = 1,
    PANGO_UNDERLINE_DOUBLE = 2,
    PANGO_UNDERLINE_LOW = 3,
    PANGO_UNDERLINE_ERROR = 4,
    PANGO_UNDERLINE_SINGLE_LINE = 5,
    PANGO_UNDERLINE_DOUBLE_LINE = 6,
    PANGO_UNDERLINE_ERROR_LINE = 7
} ;
#line 175 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef enum __anonenum__421 PangoUnderline;
#line 189
enum __anonenum__422 {
    PANGO_OVERLINE_NONE = 0,
    PANGO_OVERLINE_SINGLE = 1
} ;
#line 192 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef enum __anonenum__422 PangoOverline;
#line 207
enum __anonenum__423 {
    PANGO_SHOW_NONE = 0,
    PANGO_SHOW_SPACES = 1,
    PANGO_SHOW_LINE_BREAKS = 2,
    PANGO_SHOW_IGNORABLES = 4
} ;
#line 212 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef enum __anonenum__423 PangoShowFlags;
#line 226
enum __anonenum__424 {
    PANGO_TEXT_TRANSFORM_NONE = 0,
    PANGO_TEXT_TRANSFORM_LOWERCASE = 1,
    PANGO_TEXT_TRANSFORM_UPPERCASE = 2,
    PANGO_TEXT_TRANSFORM_CAPITALIZE = 3
} ;
#line 231 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef enum __anonenum__424 PangoTextTransform;
#line 245
enum __anonenum__425 {
    PANGO_BASELINE_SHIFT_NONE = 0,
    PANGO_BASELINE_SHIFT_SUPERSCRIPT = 1,
    PANGO_BASELINE_SHIFT_SUBSCRIPT = 2
} ;
#line 249 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef enum __anonenum__425 PangoBaselineShift;
#line 263
enum __anonenum__426 {
    PANGO_FONT_SCALE_NONE = 0,
    PANGO_FONT_SCALE_SUPERSCRIPT = 1,
    PANGO_FONT_SCALE_SUBSCRIPT = 2,
    PANGO_FONT_SCALE_SMALL_CAPS = 3
} ;
#line 268 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef enum __anonenum__426 PangoFontScale;
#line 306 "/usr/include/pango-1.0/pango/pango-attributes.h"
struct _PangoAttribute {
   PangoAttrClass *klass ;
   guint start_index ;
   guint end_index ;
};
#line 323 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef gboolean (*PangoAttrFilterFunc)(PangoAttribute * , gpointer  );
#line 334 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef gpointer (*PangoAttrDataCopyFunc)(gconstpointer  );
#line 352 "/usr/include/pango-1.0/pango/pango-attributes.h"
struct _PangoAttrClass {
   PangoAttrType type ;
   PangoAttribute *(*copy)(PangoAttribute * ) ;
   void (*destroy)(PangoAttribute * ) ;
   gboolean (*equal)(PangoAttribute * , PangoAttribute * ) ;
};
#line 369 "/usr/include/pango-1.0/pango/pango-attributes.h"
struct _PangoAttrString {
   PangoAttribute attr ;
   char *value ;
};
#line 382 "/usr/include/pango-1.0/pango/pango-attributes.h"
struct _PangoAttrLanguage {
   PangoAttribute attr ;
   PangoLanguage *value ;
};
#line 395 "/usr/include/pango-1.0/pango/pango-attributes.h"
struct _PangoAttrInt {
   PangoAttribute attr ;
   int value ;
};
#line 408 "/usr/include/pango-1.0/pango/pango-attributes.h"
struct _PangoAttrFloat {
   PangoAttribute attr ;
   double value ;
};
#line 421 "/usr/include/pango-1.0/pango/pango-attributes.h"
struct _PangoAttrColor {
   PangoAttribute attr ;
   PangoColor color ;
};
#line 440 "/usr/include/pango-1.0/pango/pango-attributes.h"
struct _PangoAttrSize {
   PangoAttribute attr ;
   int size ;
   guint absolute ;
};
#line 459 "/usr/include/pango-1.0/pango/pango-attributes.h"
struct _PangoAttrShape {
   PangoAttribute attr ;
   PangoRectangle ink_rect ;
   PangoRectangle logical_rect ;
   gpointer data ;
   PangoAttrDataCopyFunc copy_func ;
   GDestroyNotify destroy_func ;
};
#line 478 "/usr/include/pango-1.0/pango/pango-attributes.h"
struct _PangoAttrFontDesc {
   PangoAttribute attr ;
   PangoFontDescription *desc ;
};
#line 494 "/usr/include/pango-1.0/pango/pango-attributes.h"
struct _PangoAttrFontFeatures {
   PangoAttribute attr ;
   gchar *features ;
};
#line 634
struct _PangoAttrList ;
#line 634 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef struct _PangoAttrList PangoAttrList;
#line 635
struct _PangoAttrIterator ;
#line 635 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef struct _PangoAttrIterator PangoAttrIterator;
#line 742 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef PangoAttribute *PangoAttribute_autoptr;
#line 742 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef GList *PangoAttribute_listautoptr;
#line 742 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef GSList *PangoAttribute_slistautoptr;
#line 742 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef GQueue *PangoAttribute_queueautoptr;
#line 743 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef PangoAttrList *PangoAttrList_autoptr;
#line 743 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef GList *PangoAttrList_listautoptr;
#line 743 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef GSList *PangoAttrList_slistautoptr;
#line 743 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef GQueue *PangoAttrList_queueautoptr;
#line 744 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef PangoAttrIterator *PangoAttrIterator_autoptr;
#line 744 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef GList *PangoAttrIterator_listautoptr;
#line 744 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef GSList *PangoAttrIterator_slistautoptr;
#line 744 "/usr/include/pango-1.0/pango/pango-attributes.h"
typedef GQueue *PangoAttrIterator_queueautoptr;
#line 30 "/usr/include/pango-1.0/pango/pango-item.h"
struct _PangoAnalysis ;
#line 30 "/usr/include/pango-1.0/pango/pango-item.h"
typedef struct _PangoAnalysis PangoAnalysis;
#line 31
struct _PangoItem ;
#line 31 "/usr/include/pango-1.0/pango/pango-item.h"
typedef struct _PangoItem PangoItem;
#line 77 "/usr/include/pango-1.0/pango/pango-item.h"
struct _PangoAnalysis {
   PangoEngineShape *shape_engine ;
   PangoEngineLang *lang_engine ;
   PangoFont *font ;
   guint8 level ;
   guint8 gravity ;
   guint8 flags ;
   guint8 script ;
   PangoLanguage *language ;
   GSList *extra_attrs ;
};
#line 111 "/usr/include/pango-1.0/pango/pango-item.h"
struct _PangoItem {
   int offset ;
   int length ;
   int num_chars ;
   PangoAnalysis analysis ;
};
#line 83 "/usr/include/pango-1.0/pango/pango-break.h"
struct _PangoLogAttr {
   guint is_line_break ;
   guint is_mandatory_break ;
   guint is_char_break ;
   guint is_white ;
   guint is_cursor_position ;
   guint is_word_start ;
   guint is_word_end ;
   guint is_sentence_boundary ;
   guint is_sentence_start ;
   guint is_sentence_end ;
   guint backspace_deletes_character ;
   guint is_expandable_space ;
   guint is_word_boundary ;
   guint break_inserts_hyphen ;
   guint break_removes_preceding ;
   guint reserved ;
};
#line 47 "/usr/include/pango-1.0/pango/pango-fontset.h"
struct _PangoFontset ;
#line 47 "/usr/include/pango-1.0/pango/pango-fontset.h"
typedef struct _PangoFontset PangoFontset;
#line 48
struct _PangoFontsetClass ;
#line 48 "/usr/include/pango-1.0/pango/pango-fontset.h"
typedef struct _PangoFontsetClass PangoFontsetClass;
#line 64 "/usr/include/pango-1.0/pango/pango-fontset.h"
typedef gboolean (*PangoFontsetForeachFunc)(PangoFontset * , PangoFont * , gpointer  );
#line 78 "/usr/include/pango-1.0/pango/pango-fontset.h"
struct _PangoFontset {
   GObject parent_instance ;
};
#line 97 "/usr/include/pango-1.0/pango/pango-fontset.h"
struct _PangoFontsetClass {
   GObjectClass parent_class ;
   PangoFont *(*get_font)(PangoFontset * , guint  ) ;
   PangoFontMetrics *(*get_metrics)(PangoFontset * ) ;
   PangoLanguage *(*get_language)(PangoFontset * ) ;
   void (*foreach)(PangoFontset * , PangoFontsetForeachFunc  , gpointer  ) ;
   void (*_pango_reserved1)(void) ;
   void (*_pango_reserved2)(void) ;
   void (*_pango_reserved3)(void) ;
   void (*_pango_reserved4)(void) ;
};
#line 38 "/usr/include/pango-1.0/pango/pango-fontmap.h"
struct _PangoFontMapClass ;
#line 38 "/usr/include/pango-1.0/pango/pango-fontmap.h"
typedef struct _PangoFontMapClass PangoFontMapClass;
#line 49 "/usr/include/pango-1.0/pango/pango-fontmap.h"
struct _PangoFontMap {
   GObject parent_instance ;
};
#line 72 "/usr/include/pango-1.0/pango/pango-fontmap.h"
struct _PangoFontMapClass {
   GObjectClass parent_class ;
   PangoFont *(*load_font)(PangoFontMap * , PangoContext * , PangoFontDescription * ) ;
   void (*list_families)(PangoFontMap * , PangoFontFamily *** , int * ) ;
   PangoFontset *(*load_fontset)(PangoFontMap * , PangoContext * , PangoFontDescription * ,
                                 PangoLanguage * ) ;
   char const   *shape_engine_type ;
   guint (*get_serial)(PangoFontMap * ) ;
   void (*changed)(PangoFontMap * ) ;
   PangoFontFamily *(*get_family)(PangoFontMap * , char const   * ) ;
   PangoFontFace *(*get_face)(PangoFontMap * , PangoFont * ) ;
};
#line 128 "/usr/include/pango-1.0/pango/pango-fontmap.h"
typedef PangoFontMap *PangoFontMap_autoptr;
#line 128 "/usr/include/pango-1.0/pango/pango-fontmap.h"
typedef GList *PangoFontMap_listautoptr;
#line 128 "/usr/include/pango-1.0/pango/pango-fontmap.h"
typedef GSList *PangoFontMap_slistautoptr;
#line 128 "/usr/include/pango-1.0/pango/pango-fontmap.h"
typedef GQueue *PangoFontMap_queueautoptr;
#line 33 "/usr/include/pango-1.0/pango/pango-context.h"
struct _PangoContextClass ;
#line 33 "/usr/include/pango-1.0/pango/pango-context.h"
typedef struct _PangoContextClass PangoContextClass;
#line 31 "/usr/include/pango-1.0/pango/pango-glyph.h"
struct _PangoGlyphGeometry ;
#line 31 "/usr/include/pango-1.0/pango/pango-glyph.h"
typedef struct _PangoGlyphGeometry PangoGlyphGeometry;
#line 32
struct _PangoGlyphVisAttr ;
#line 32 "/usr/include/pango-1.0/pango/pango-glyph.h"
typedef struct _PangoGlyphVisAttr PangoGlyphVisAttr;
#line 33
struct _PangoGlyphInfo ;
#line 33 "/usr/include/pango-1.0/pango/pango-glyph.h"
typedef struct _PangoGlyphInfo PangoGlyphInfo;
#line 34
struct _PangoGlyphString ;
#line 34 "/usr/include/pango-1.0/pango/pango-glyph.h"
typedef struct _PangoGlyphString PangoGlyphString;
#line 52 "/usr/include/pango-1.0/pango/pango-glyph.h"
typedef gint32 PangoGlyphUnit;
#line 78 "/usr/include/pango-1.0/pango/pango-glyph.h"
struct _PangoGlyphGeometry {
   PangoGlyphUnit width ;
   PangoGlyphUnit x_offset ;
   PangoGlyphUnit y_offset ;
};
#line 103 "/usr/include/pango-1.0/pango/pango-glyph.h"
struct _PangoGlyphVisAttr {
   guint is_cluster_start ;
   guint is_color ;
};
#line 120 "/usr/include/pango-1.0/pango/pango-glyph.h"
struct _PangoGlyphInfo {
   PangoGlyph glyph ;
   PangoGlyphGeometry geometry ;
   PangoGlyphVisAttr attr ;
};
#line 140 "/usr/include/pango-1.0/pango/pango-glyph.h"
struct _PangoGlyphString {
   int num_glyphs ;
   PangoGlyphInfo *glyphs ;
   int *log_clusters ;
   int space ;
};
#line 230
enum __anonenum__427 {
    PANGO_SHAPE_NONE = 0,
    PANGO_SHAPE_ROUND_POSITIONS = 1
} ;
#line 233 "/usr/include/pango-1.0/pango/pango-glyph.h"
typedef enum __anonenum__427 PangoShapeFlags;
#line 57 "/usr/include/pango-1.0/pango/pango-engine.h"
struct _PangoEngine ;
#line 57 "/usr/include/pango-1.0/pango/pango-engine.h"
typedef struct _PangoEngine PangoEngine;
#line 58
struct _PangoEngineClass ;
#line 58 "/usr/include/pango-1.0/pango/pango-engine.h"
typedef struct _PangoEngineClass PangoEngineClass;
#line 68 "/usr/include/pango-1.0/pango/pango-engine.h"
struct _PangoEngine {
   GObject parent_instance ;
};
#line 81 "/usr/include/pango-1.0/pango/pango-engine.h"
struct _PangoEngineClass {
   GObjectClass parent_class ;
};
#line 107
struct _PangoEngineLangClass ;
#line 107 "/usr/include/pango-1.0/pango/pango-engine.h"
typedef struct _PangoEngineLangClass PangoEngineLangClass;
#line 121 "/usr/include/pango-1.0/pango/pango-engine.h"
struct _PangoEngineLang {
   PangoEngine parent_instance ;
};
#line 140 "/usr/include/pango-1.0/pango/pango-engine.h"
struct _PangoEngineLangClass {
   PangoEngineClass parent_class ;
   void (*script_break)(PangoEngineLang * , char const   * , int  , PangoAnalysis * ,
                        PangoLogAttr * , int  ) ;
};
#line 174
struct _PangoEngineShapeClass ;
#line 174 "/usr/include/pango-1.0/pango/pango-engine.h"
typedef struct _PangoEngineShapeClass PangoEngineShapeClass;
#line 190 "/usr/include/pango-1.0/pango/pango-engine.h"
struct _PangoEngineShape {
   PangoEngine parent_instance ;
};
#line 222 "/usr/include/pango-1.0/pango/pango-engine.h"
struct _PangoEngineShapeClass {
   PangoEngineClass parent_class ;
   void (*script_shape)(PangoEngineShape * , PangoFont * , char const   * , unsigned int  ,
                        PangoAnalysis * , PangoGlyphString * , char const   * , unsigned int  ) ;
   PangoCoverageLevel (*covers)(PangoEngineShape * , PangoFont * , PangoLanguage * ,
                                gunichar  ) ;
};
#line 245
struct _PangoEngineInfo ;
#line 245 "/usr/include/pango-1.0/pango/pango-engine.h"
typedef struct _PangoEngineInfo PangoEngineInfo;
#line 246
struct _PangoEngineScriptInfo ;
#line 246 "/usr/include/pango-1.0/pango/pango-engine.h"
typedef struct _PangoEngineScriptInfo PangoEngineScriptInfo;
#line 267 "/usr/include/pango-1.0/pango/pango-engine.h"
struct _PangoEngineScriptInfo {
   PangoScript script ;
   gchar *langs ;
};
#line 286 "/usr/include/pango-1.0/pango/pango-engine.h"
struct _PangoEngineInfo {
   gchar *id ;
   gchar *engine_type ;
   gchar *render_type ;
   PangoEngineScriptInfo *scripts ;
   gint n_scripts ;
};
#line 46 "/usr/include/pango-1.0/pango/pango-fontset-simple.h"
struct _PangoFontsetSimple ;
#line 46 "/usr/include/pango-1.0/pango/pango-fontset-simple.h"
typedef struct _PangoFontsetSimple PangoFontsetSimple;
#line 47
struct _PangoFontsetSimpleClass ;
#line 47 "/usr/include/pango-1.0/pango/pango-fontset-simple.h"
typedef struct _PangoFontsetSimpleClass PangoFontsetSimpleClass;
#line 50 "/usr/include/pango-1.0/pango/pango-glyph-item.h"
struct _PangoGlyphItem ;
#line 50 "/usr/include/pango-1.0/pango/pango-glyph-item.h"
typedef struct _PangoGlyphItem PangoGlyphItem;
#line 52 "/usr/include/pango-1.0/pango/pango-glyph-item.h"
struct _PangoGlyphItem {
   PangoItem *item ;
   PangoGlyphString *glyphs ;
   int y_offset ;
   int start_x_offset ;
   int end_x_offset ;
};
#line 135
struct _PangoGlyphItemIter ;
#line 135 "/usr/include/pango-1.0/pango/pango-glyph-item.h"
typedef struct _PangoGlyphItemIter PangoGlyphItemIter;
#line 137 "/usr/include/pango-1.0/pango/pango-glyph-item.h"
struct _PangoGlyphItemIter {
   PangoGlyphItem *glyph_item ;
   gchar *text ;
   int start_glyph ;
   int start_index ;
   int start_char ;
   int end_glyph ;
   int end_index ;
   int end_char ;
};
#line 29 "/usr/include/pango-1.0/pango/pango-tabs.h"
struct _PangoTabArray ;
#line 29 "/usr/include/pango-1.0/pango/pango-tabs.h"
typedef struct _PangoTabArray PangoTabArray;
#line 45
enum __anonenum__428 {
    PANGO_TAB_LEFT = 0,
    PANGO_TAB_RIGHT = 1,
    PANGO_TAB_CENTER = 2,
    PANGO_TAB_DECIMAL = 3
} ;
#line 51 "/usr/include/pango-1.0/pango/pango-tabs.h"
typedef enum __anonenum__428 PangoTabAlign;
#line 113 "/usr/include/pango-1.0/pango/pango-tabs.h"
typedef PangoTabArray *PangoTabArray_autoptr;
#line 113 "/usr/include/pango-1.0/pango/pango-tabs.h"
typedef GList *PangoTabArray_listautoptr;
#line 113 "/usr/include/pango-1.0/pango/pango-tabs.h"
typedef GSList *PangoTabArray_slistautoptr;
#line 113 "/usr/include/pango-1.0/pango/pango-tabs.h"
typedef GQueue *PangoTabArray_queueautoptr;
#line 32 "/usr/include/pango-1.0/pango/pango-layout.h"
struct _PangoLayout ;
#line 32 "/usr/include/pango-1.0/pango/pango-layout.h"
typedef struct _PangoLayout PangoLayout;
#line 33
struct _PangoLayoutClass ;
#line 33 "/usr/include/pango-1.0/pango/pango-layout.h"
typedef struct _PangoLayoutClass PangoLayoutClass;
#line 34
struct _PangoLayoutLine ;
#line 34 "/usr/include/pango-1.0/pango/pango-layout.h"
typedef struct _PangoLayoutLine PangoLayoutLine;
#line 44 "/usr/include/pango-1.0/pango/pango-layout.h"
typedef PangoGlyphItem PangoLayoutRun;
#line 61
enum __anonenum__429 {
    PANGO_ALIGN_LEFT = 0,
    PANGO_ALIGN_CENTER = 1,
    PANGO_ALIGN_RIGHT = 2
} ;
#line 65 "/usr/include/pango-1.0/pango/pango-layout.h"
typedef enum __anonenum__429 PangoAlignment;
#line 82
enum __anonenum__430 {
    PANGO_WRAP_WORD = 0,
    PANGO_WRAP_CHAR = 1,
    PANGO_WRAP_WORD_CHAR = 2
} ;
#line 86 "/usr/include/pango-1.0/pango/pango-layout.h"
typedef enum __anonenum__430 PangoWrapMode;
#line 102
enum __anonenum__431 {
    PANGO_ELLIPSIZE_NONE = 0,
    PANGO_ELLIPSIZE_START = 1,
    PANGO_ELLIPSIZE_MIDDLE = 2,
    PANGO_ELLIPSIZE_END = 3
} ;
#line 107 "/usr/include/pango-1.0/pango/pango-layout.h"
typedef enum __anonenum__431 PangoEllipsizeMode;
#line 126 "/usr/include/pango-1.0/pango/pango-layout.h"
struct _PangoLayoutLine {
   PangoLayout *layout ;
   gint start_index ;
   gint length ;
   GSList *runs ;
   guint is_paragraph_start ;
   guint resolved_dir ;
};
#line 366
enum __anonenum__432 {
    PANGO_LAYOUT_SERIALIZE_DEFAULT = 0,
    PANGO_LAYOUT_SERIALIZE_CONTEXT = 1,
    PANGO_LAYOUT_SERIALIZE_OUTPUT = 2
} ;
#line 370 "/usr/include/pango-1.0/pango/pango-layout.h"
typedef enum __anonenum__432 PangoLayoutSerializeFlags;
#line 397
enum __anonenum__433 {
    PANGO_LAYOUT_DESERIALIZE_INVALID = 0,
    PANGO_LAYOUT_DESERIALIZE_INVALID_VALUE = 1,
    PANGO_LAYOUT_DESERIALIZE_MISSING_VALUE = 2
} ;
#line 401 "/usr/include/pango-1.0/pango/pango-layout.h"
typedef enum __anonenum__433 PangoLayoutDeserializeError;
#line 418
enum __anonenum__434 {
    PANGO_LAYOUT_DESERIALIZE_DEFAULT = 0,
    PANGO_LAYOUT_DESERIALIZE_CONTEXT = 1
} ;
#line 421 "/usr/include/pango-1.0/pango/pango-layout.h"
typedef enum __anonenum__434 PangoLayoutDeserializeFlags;
#line 478
struct _PangoLayoutIter ;
#line 478 "/usr/include/pango-1.0/pango/pango-layout.h"
typedef struct _PangoLayoutIter PangoLayoutIter;
#line 548 "/usr/include/pango-1.0/pango/pango-layout.h"
typedef PangoLayout *PangoLayout_autoptr;
#line 548 "/usr/include/pango-1.0/pango/pango-layout.h"
typedef GList *PangoLayout_listautoptr;
#line 548 "/usr/include/pango-1.0/pango/pango-layout.h"
typedef GSList *PangoLayout_slistautoptr;
#line 548 "/usr/include/pango-1.0/pango/pango-layout.h"
typedef GQueue *PangoLayout_queueautoptr;
#line 549 "/usr/include/pango-1.0/pango/pango-layout.h"
typedef PangoLayoutIter *PangoLayoutIter_autoptr;
#line 549 "/usr/include/pango-1.0/pango/pango-layout.h"
typedef GList *PangoLayoutIter_listautoptr;
#line 549 "/usr/include/pango-1.0/pango/pango-layout.h"
typedef GSList *PangoLayoutIter_slistautoptr;
#line 549 "/usr/include/pango-1.0/pango/pango-layout.h"
typedef GQueue *PangoLayoutIter_queueautoptr;
#line 35 "/usr/include/pango-1.0/pango/pango-renderer.h"
struct _PangoRenderer ;
#line 35 "/usr/include/pango-1.0/pango/pango-renderer.h"
typedef struct _PangoRenderer PangoRenderer;
#line 36
struct _PangoRendererClass ;
#line 36 "/usr/include/pango-1.0/pango/pango-renderer.h"
typedef struct _PangoRendererClass PangoRendererClass;
#line 37
struct _PangoRendererPrivate ;
#line 37 "/usr/include/pango-1.0/pango/pango-renderer.h"
typedef struct _PangoRendererPrivate PangoRendererPrivate;
#line 53
enum __anonenum__435 {
    PANGO_RENDER_PART_FOREGROUND = 0,
    PANGO_RENDER_PART_BACKGROUND = 1,
    PANGO_RENDER_PART_UNDERLINE = 2,
    PANGO_RENDER_PART_STRIKETHROUGH = 3,
    PANGO_RENDER_PART_OVERLINE = 4
} ;
#line 60 "/usr/include/pango-1.0/pango/pango-renderer.h"
typedef enum __anonenum__435 PangoRenderPart;
#line 77 "/usr/include/pango-1.0/pango/pango-renderer.h"
struct _PangoRenderer {
   GObject parent_instance ;
   PangoUnderline underline ;
   gboolean strikethrough ;
   int active_count ;
   PangoMatrix *matrix ;
   PangoRendererPrivate *priv ;
};
#line 131 "/usr/include/pango-1.0/pango/pango-renderer.h"
struct _PangoRendererClass {
   GObjectClass parent_class ;
   void (*draw_glyphs)(PangoRenderer * , PangoFont * , PangoGlyphString * , int  ,
                       int  ) ;
   void (*draw_rectangle)(PangoRenderer * , PangoRenderPart  , int  , int  , int  ,
                          int  ) ;
   void (*draw_error_underline)(PangoRenderer * , int  , int  , int  , int  ) ;
   void (*draw_shape)(PangoRenderer * , PangoAttrShape * , int  , int  ) ;
   void (*draw_trapezoid)(PangoRenderer * , PangoRenderPart  , double  , double  ,
                          double  , double  , double  , double  ) ;
   void (*draw_glyph)(PangoRenderer * , PangoFont * , PangoGlyph  , double  , double  ) ;
   void (*part_changed)(PangoRenderer * , PangoRenderPart  ) ;
   void (*begin)(PangoRenderer * ) ;
   void (*end)(PangoRenderer * ) ;
   void (*prepare_run)(PangoRenderer * , PangoLayoutRun * ) ;
   void (*draw_glyph_item)(PangoRenderer * , char const   * , PangoGlyphItem * , int  ,
                           int  ) ;
   void (*_pango_reserved2)(void) ;
   void (*_pango_reserved3)(void) ;
   void (*_pango_reserved4)(void) ;
};
#line 68 "/usr/include/gtk-2.0/gdk/gdktypes.h"
struct _GdkPoint ;
#line 68 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef struct _GdkPoint GdkPoint;
#line 69
struct _GdkRectangle ;
#line 69 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef struct _GdkRectangle GdkRectangle;
#line 70
struct _GdkSegment ;
#line 70 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef struct _GdkSegment GdkSegment;
#line 71
struct _GdkSpan ;
#line 71 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef struct _GdkSpan GdkSpan;
#line 78 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef guint32 GdkWChar;
#line 80
struct _GdkAtom ;
#line 80 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef struct _GdkAtom *GdkAtom;
#line 97 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef guint32 GdkNativeWindow;
#line 102
struct _GdkColor ;
#line 102 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef struct _GdkColor GdkColor;
#line 103
struct _GdkColormap ;
#line 103 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef struct _GdkColormap GdkColormap;
#line 104
struct _GdkCursor ;
#line 104 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef struct _GdkCursor GdkCursor;
#line 105
struct _GdkFont ;
#line 105 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef struct _GdkFont GdkFont;
#line 106
struct _GdkGC ;
#line 106 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef struct _GdkGC GdkGC;
#line 107
struct _GdkImage ;
#line 107 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef struct _GdkImage GdkImage;
#line 108
struct _GdkRegion ;
#line 108 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef struct _GdkRegion GdkRegion;
#line 109
struct _GdkVisual ;
#line 109 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef struct _GdkVisual GdkVisual;
#line 111
struct _GdkDrawable ;
#line 111 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef struct _GdkDrawable GdkDrawable;
#line 112 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef struct _GdkDrawable GdkBitmap;
#line 113 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef struct _GdkDrawable GdkPixmap;
#line 114 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef struct _GdkDrawable GdkWindow;
#line 115
struct _GdkDisplay ;
#line 115 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef struct _GdkDisplay GdkDisplay;
#line 116
struct _GdkScreen ;
#line 116 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef struct _GdkScreen GdkScreen;
#line 118
enum __anonenum__436 {
    GDK_LSB_FIRST = 0,
    GDK_MSB_FIRST = 1
} ;
#line 122 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef enum __anonenum__436 GdkByteOrder;
#line 126
enum __anonenum__437 {
    GDK_SHIFT_MASK = 1,
    GDK_LOCK_MASK = 2,
    GDK_CONTROL_MASK = 4,
    GDK_MOD1_MASK = 8,
    GDK_MOD2_MASK = 16,
    GDK_MOD3_MASK = 32,
    GDK_MOD4_MASK = 64,
    GDK_MOD5_MASK = 128,
    GDK_BUTTON1_MASK = 256,
    GDK_BUTTON2_MASK = 512,
    GDK_BUTTON3_MASK = 1024,
    GDK_BUTTON4_MASK = 2048,
    GDK_BUTTON5_MASK = 4096,
    GDK_SUPER_MASK = 67108864,
    GDK_HYPER_MASK = 134217728,
    GDK_META_MASK = 268435456,
    GDK_RELEASE_MASK = 1073741824,
    GDK_MODIFIER_MASK = 1543512063
} ;
#line 153 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef enum __anonenum__437 GdkModifierType;
#line 155
enum __anonenum__438 {
    GDK_INPUT_READ = 1,
    GDK_INPUT_WRITE = 2,
    GDK_INPUT_EXCEPTION = 4
} ;
#line 160 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef enum __anonenum__438 GdkInputCondition;
#line 162
enum __anonenum__439 {
    GDK_OK = 0,
    GDK_ERROR = -1,
    GDK_ERROR_PARAM = -2,
    GDK_ERROR_FILE = -3,
    GDK_ERROR_MEM = -4
} ;
#line 169 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef enum __anonenum__439 GdkStatus;
#line 175
enum __anonenum__440 {
    GDK_GRAB_SUCCESS = 0,
    GDK_GRAB_ALREADY_GRABBED = 1,
    GDK_GRAB_INVALID_TIME = 2,
    GDK_GRAB_NOT_VIEWABLE = 3,
    GDK_GRAB_FROZEN = 4
} ;
#line 182 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef enum __anonenum__440 GdkGrabStatus;
#line 184 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef void (*GdkInputFunction)(gpointer  , gint  , GdkInputCondition  );
#line 190 "/usr/include/gtk-2.0/gdk/gdktypes.h"
typedef void (*GdkDestroyNotify)(gpointer  );
#line 194 "/usr/include/gtk-2.0/gdk/gdktypes.h"
struct _GdkPoint {
   gint x ;
   gint y ;
};
#line 200 "/usr/include/gtk-2.0/gdk/gdktypes.h"
struct _GdkRectangle {
   gint x ;
   gint y ;
   gint width ;
   gint height ;
};
#line 208 "/usr/include/gtk-2.0/gdk/gdktypes.h"
struct _GdkSegment {
   gint x1 ;
   gint y1 ;
   gint x2 ;
   gint y2 ;
};
#line 216 "/usr/include/gtk-2.0/gdk/gdktypes.h"
struct _GdkSpan {
   gint x ;
   gint y ;
   gint width ;
};
#line 46 "/usr/include/gtk-2.0/gdk/gdkcolor.h"
struct _GdkColor {
   guint32 pixel ;
   guint16 red ;
   guint16 green ;
   guint16 blue ;
};
#line 57
struct _GdkColormapClass ;
#line 57 "/usr/include/gtk-2.0/gdk/gdkcolor.h"
typedef struct _GdkColormapClass GdkColormapClass;
#line 68 "/usr/include/gtk-2.0/gdk/gdkcolor.h"
struct _GdkColormap {
   GObject parent_instance ;
   gint size ;
   GdkColor *colors ;
   GdkVisual *visual ;
   gpointer windowing_data ;
};
#line 83 "/usr/include/gtk-2.0/gdk/gdkcolor.h"
struct _GdkColormapClass {
   GObjectClass parent_class ;
};
#line 38 "/usr/include/gtk-2.0/gdk/gdkdnd.h"
struct _GdkDragContext ;
#line 38 "/usr/include/gtk-2.0/gdk/gdkdnd.h"
typedef struct _GdkDragContext GdkDragContext;
#line 40
enum __anonenum__441 {
    GDK_ACTION_DEFAULT = 1,
    GDK_ACTION_COPY = 2,
    GDK_ACTION_MOVE = 4,
    GDK_ACTION_LINK = 8,
    GDK_ACTION_PRIVATE = 16,
    GDK_ACTION_ASK = 32
} ;
#line 48 "/usr/include/gtk-2.0/gdk/gdkdnd.h"
typedef enum __anonenum__441 GdkDragAction;
#line 50
enum __anonenum__442 {
    GDK_DRAG_PROTO_MOTIF = 0,
    GDK_DRAG_PROTO_XDND = 1,
    GDK_DRAG_PROTO_ROOTWIN = 2,
    GDK_DRAG_PROTO_NONE = 3,
    GDK_DRAG_PROTO_WIN32_DROPFILES = 4,
    GDK_DRAG_PROTO_OLE2 = 5,
    GDK_DRAG_PROTO_LOCAL = 6
} ;
#line 60 "/usr/include/gtk-2.0/gdk/gdkdnd.h"
typedef enum __anonenum__442 GdkDragProtocol;
#line 66
struct _GdkDragContextClass ;
#line 66 "/usr/include/gtk-2.0/gdk/gdkdnd.h"
typedef struct _GdkDragContextClass GdkDragContextClass;
#line 75 "/usr/include/gtk-2.0/gdk/gdkdnd.h"
struct _GdkDragContext {
   GObject parent_instance ;
   GdkDragProtocol protocol ;
   gboolean is_source ;
   GdkWindow *source_window ;
   GdkWindow *dest_window ;
   GList *targets ;
   GdkDragAction actions ;
   GdkDragAction suggested_action ;
   GdkDragAction action ;
   guint32 start_time ;
   gpointer windowing_data ;
};
#line 99 "/usr/include/gtk-2.0/gdk/gdkdnd.h"
struct _GdkDragContextClass {
   GObjectClass parent_class ;
};
#line 45 "/usr/include/gtk-2.0/gdk/gdkinput.h"
struct _GdkDeviceKey ;
#line 45 "/usr/include/gtk-2.0/gdk/gdkinput.h"
typedef struct _GdkDeviceKey GdkDeviceKey;
#line 46
struct _GdkDeviceAxis ;
#line 46 "/usr/include/gtk-2.0/gdk/gdkinput.h"
typedef struct _GdkDeviceAxis GdkDeviceAxis;
#line 47
struct _GdkDevice ;
#line 47 "/usr/include/gtk-2.0/gdk/gdkinput.h"
typedef struct _GdkDevice GdkDevice;
#line 48
struct _GdkDeviceClass ;
#line 48 "/usr/include/gtk-2.0/gdk/gdkinput.h"
typedef struct _GdkDeviceClass GdkDeviceClass;
#line 49
struct _GdkTimeCoord ;
#line 49 "/usr/include/gtk-2.0/gdk/gdkinput.h"
typedef struct _GdkTimeCoord GdkTimeCoord;
#line 51
enum __anonenum__443 {
    GDK_EXTENSION_EVENTS_NONE = 0,
    GDK_EXTENSION_EVENTS_ALL = 1,
    GDK_EXTENSION_EVENTS_CURSOR = 2
} ;
#line 56 "/usr/include/gtk-2.0/gdk/gdkinput.h"
typedef enum __anonenum__443 GdkExtensionMode;
#line 58
enum __anonenum__444 {
    GDK_SOURCE_MOUSE = 0,
    GDK_SOURCE_PEN = 1,
    GDK_SOURCE_ERASER = 2,
    GDK_SOURCE_CURSOR = 3
} ;
#line 64 "/usr/include/gtk-2.0/gdk/gdkinput.h"
typedef enum __anonenum__444 GdkInputSource;
#line 66
enum __anonenum__445 {
    GDK_MODE_DISABLED = 0,
    GDK_MODE_SCREEN = 1,
    GDK_MODE_WINDOW = 2
} ;
#line 71 "/usr/include/gtk-2.0/gdk/gdkinput.h"
typedef enum __anonenum__445 GdkInputMode;
#line 73
enum __anonenum__446 {
    GDK_AXIS_IGNORE = 0,
    GDK_AXIS_X = 1,
    GDK_AXIS_Y = 2,
    GDK_AXIS_PRESSURE = 3,
    GDK_AXIS_XTILT = 4,
    GDK_AXIS_YTILT = 5,
    GDK_AXIS_WHEEL = 6,
    GDK_AXIS_LAST = 7
} ;
#line 83 "/usr/include/gtk-2.0/gdk/gdkinput.h"
typedef enum __anonenum__446 GdkAxisUse;
#line 85 "/usr/include/gtk-2.0/gdk/gdkinput.h"
struct _GdkDeviceKey {
   guint keyval ;
   GdkModifierType modifiers ;
};
#line 91 "/usr/include/gtk-2.0/gdk/gdkinput.h"
struct _GdkDeviceAxis {
   GdkAxisUse use ;
   gdouble min ;
   gdouble max ;
};
#line 98 "/usr/include/gtk-2.0/gdk/gdkinput.h"
struct _GdkDevice {
   GObject parent_instance ;
   gchar *name ;
   GdkInputSource source ;
   GdkInputMode mode ;
   gboolean has_cursor ;
   gint num_axes ;
   GdkDeviceAxis *axes ;
   gint num_keys ;
   GdkDeviceKey *keys ;
};
#line 120 "/usr/include/gtk-2.0/gdk/gdkinput.h"
struct _GdkTimeCoord {
   guint32 time ;
   gdouble axes[128] ;
};
#line 47 "/usr/include/gtk-2.0/gdk/gdkevents.h"
struct _GdkEventAny ;
#line 47 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef struct _GdkEventAny GdkEventAny;
#line 48
struct _GdkEventExpose ;
#line 48 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef struct _GdkEventExpose GdkEventExpose;
#line 49
struct _GdkEventNoExpose ;
#line 49 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef struct _GdkEventNoExpose GdkEventNoExpose;
#line 50
struct _GdkEventVisibility ;
#line 50 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef struct _GdkEventVisibility GdkEventVisibility;
#line 51
struct _GdkEventMotion ;
#line 51 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef struct _GdkEventMotion GdkEventMotion;
#line 52
struct _GdkEventButton ;
#line 52 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef struct _GdkEventButton GdkEventButton;
#line 53
struct _GdkEventScroll ;
#line 53 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef struct _GdkEventScroll GdkEventScroll;
#line 54
struct _GdkEventKey ;
#line 54 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef struct _GdkEventKey GdkEventKey;
#line 55
struct _GdkEventFocus ;
#line 55 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef struct _GdkEventFocus GdkEventFocus;
#line 56
struct _GdkEventCrossing ;
#line 56 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef struct _GdkEventCrossing GdkEventCrossing;
#line 57
struct _GdkEventConfigure ;
#line 57 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef struct _GdkEventConfigure GdkEventConfigure;
#line 58
struct _GdkEventProperty ;
#line 58 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef struct _GdkEventProperty GdkEventProperty;
#line 59
struct _GdkEventSelection ;
#line 59 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef struct _GdkEventSelection GdkEventSelection;
#line 60
struct _GdkEventOwnerChange ;
#line 60 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef struct _GdkEventOwnerChange GdkEventOwnerChange;
#line 61
struct _GdkEventProximity ;
#line 61 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef struct _GdkEventProximity GdkEventProximity;
#line 62
struct _GdkEventClient ;
#line 62 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef struct _GdkEventClient GdkEventClient;
#line 63
struct _GdkEventDND ;
#line 63 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef struct _GdkEventDND GdkEventDND;
#line 64
struct _GdkEventWindowState ;
#line 64 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef struct _GdkEventWindowState GdkEventWindowState;
#line 65
struct _GdkEventSetting ;
#line 65 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef struct _GdkEventSetting GdkEventSetting;
#line 66
struct _GdkEventGrabBroken ;
#line 66 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef struct _GdkEventGrabBroken GdkEventGrabBroken;
#line 68
union _GdkEvent ;
#line 68 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef union _GdkEvent GdkEvent;
#line 70 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef void (*GdkEventFunc)(GdkEvent * , gpointer  );
#line 75 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef void GdkXEvent;
#line 79
enum __anonenum__447 {
    GDK_FILTER_CONTINUE = 0,
    GDK_FILTER_TRANSLATE = 1,
    GDK_FILTER_REMOVE = 2
} ;
#line 85 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef enum __anonenum__447 GdkFilterReturn;
#line 87 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef GdkFilterReturn (*GdkFilterFunc)(GdkXEvent * , GdkEvent * , gpointer  );
#line 115
enum __anonenum__448 {
    GDK_NOTHING = -1,
    GDK_DELETE = 0,
    GDK_DESTROY = 1,
    GDK_EXPOSE = 2,
    GDK_MOTION_NOTIFY = 3,
    GDK_BUTTON_PRESS = 4,
    GDK_2BUTTON_PRESS = 5,
    GDK_3BUTTON_PRESS = 6,
    GDK_BUTTON_RELEASE = 7,
    GDK_KEY_PRESS = 8,
    GDK_KEY_RELEASE = 9,
    GDK_ENTER_NOTIFY = 10,
    GDK_LEAVE_NOTIFY = 11,
    GDK_FOCUS_CHANGE = 12,
    GDK_CONFIGURE = 13,
    GDK_MAP = 14,
    GDK_UNMAP = 15,
    GDK_PROPERTY_NOTIFY = 16,
    GDK_SELECTION_CLEAR = 17,
    GDK_SELECTION_REQUEST = 18,
    GDK_SELECTION_NOTIFY = 19,
    GDK_PROXIMITY_IN = 20,
    GDK_PROXIMITY_OUT = 21,
    GDK_DRAG_ENTER = 22,
    GDK_DRAG_LEAVE = 23,
    GDK_DRAG_MOTION = 24,
    GDK_DRAG_STATUS = 25,
    GDK_DROP_START = 26,
    GDK_DROP_FINISHED = 27,
    GDK_CLIENT_EVENT = 28,
    GDK_VISIBILITY_NOTIFY = 29,
    GDK_NO_EXPOSE = 30,
    GDK_SCROLL = 31,
    GDK_WINDOW_STATE = 32,
    GDK_SETTING = 33,
    GDK_OWNER_CHANGE = 34,
    GDK_GRAB_BROKEN = 35,
    GDK_DAMAGE = 36,
    GDK_EVENT_LAST = 37
} ;
#line 156 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef enum __anonenum__448 GdkEventType;
#line 161
enum __anonenum__449 {
    GDK_EXPOSURE_MASK = 2,
    GDK_POINTER_MOTION_MASK = 4,
    GDK_POINTER_MOTION_HINT_MASK = 8,
    GDK_BUTTON_MOTION_MASK = 16,
    GDK_BUTTON1_MOTION_MASK = 32,
    GDK_BUTTON2_MOTION_MASK = 64,
    GDK_BUTTON3_MOTION_MASK = 128,
    GDK_BUTTON_PRESS_MASK = 256,
    GDK_BUTTON_RELEASE_MASK = 512,
    GDK_KEY_PRESS_MASK = 1024,
    GDK_KEY_RELEASE_MASK = 2048,
    GDK_ENTER_NOTIFY_MASK = 4096,
    GDK_LEAVE_NOTIFY_MASK = 8192,
    GDK_FOCUS_CHANGE_MASK = 16384,
    GDK_STRUCTURE_MASK = 32768,
    GDK_PROPERTY_CHANGE_MASK = 65536,
    GDK_VISIBILITY_NOTIFY_MASK = 131072,
    GDK_PROXIMITY_IN_MASK = 262144,
    GDK_PROXIMITY_OUT_MASK = 524288,
    GDK_SUBSTRUCTURE_MASK = 1048576,
    GDK_SCROLL_MASK = 2097152,
    GDK_ALL_EVENTS_MASK = 4194302
} ;
#line 185 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef enum __anonenum__449 GdkEventMask;
#line 187
enum __anonenum__450 {
    GDK_VISIBILITY_UNOBSCURED = 0,
    GDK_VISIBILITY_PARTIAL = 1,
    GDK_VISIBILITY_FULLY_OBSCURED = 2
} ;
#line 192 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef enum __anonenum__450 GdkVisibilityState;
#line 194
enum __anonenum__451 {
    GDK_SCROLL_UP = 0,
    GDK_SCROLL_DOWN = 1,
    GDK_SCROLL_LEFT = 2,
    GDK_SCROLL_RIGHT = 3
} ;
#line 200 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef enum __anonenum__451 GdkScrollDirection;
#line 210
enum __anonenum__452 {
    GDK_NOTIFY_ANCESTOR = 0,
    GDK_NOTIFY_VIRTUAL = 1,
    GDK_NOTIFY_INFERIOR = 2,
    GDK_NOTIFY_NONLINEAR = 3,
    GDK_NOTIFY_NONLINEAR_VIRTUAL = 4,
    GDK_NOTIFY_UNKNOWN = 5
} ;
#line 218 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef enum __anonenum__452 GdkNotifyType;
#line 225
enum __anonenum__453 {
    GDK_CROSSING_NORMAL = 0,
    GDK_CROSSING_GRAB = 1,
    GDK_CROSSING_UNGRAB = 2,
    GDK_CROSSING_GTK_GRAB = 3,
    GDK_CROSSING_GTK_UNGRAB = 4,
    GDK_CROSSING_STATE_CHANGED = 5
} ;
#line 233 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef enum __anonenum__453 GdkCrossingMode;
#line 235
enum __anonenum__454 {
    GDK_PROPERTY_NEW_VALUE = 0,
    GDK_PROPERTY_DELETE = 1
} ;
#line 239 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef enum __anonenum__454 GdkPropertyState;
#line 241
enum __anonenum__455 {
    GDK_WINDOW_STATE_WITHDRAWN = 1,
    GDK_WINDOW_STATE_ICONIFIED = 2,
    GDK_WINDOW_STATE_MAXIMIZED = 4,
    GDK_WINDOW_STATE_STICKY = 8,
    GDK_WINDOW_STATE_FULLSCREEN = 16,
    GDK_WINDOW_STATE_ABOVE = 32,
    GDK_WINDOW_STATE_BELOW = 64
} ;
#line 250 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef enum __anonenum__455 GdkWindowState;
#line 252
enum __anonenum__456 {
    GDK_SETTING_ACTION_NEW = 0,
    GDK_SETTING_ACTION_CHANGED = 1,
    GDK_SETTING_ACTION_DELETED = 2
} ;
#line 257 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef enum __anonenum__456 GdkSettingAction;
#line 259
enum __anonenum__457 {
    GDK_OWNER_CHANGE_NEW_OWNER = 0,
    GDK_OWNER_CHANGE_DESTROY = 1,
    GDK_OWNER_CHANGE_CLOSE = 2
} ;
#line 264 "/usr/include/gtk-2.0/gdk/gdkevents.h"
typedef enum __anonenum__457 GdkOwnerChange;
#line 266 "/usr/include/gtk-2.0/gdk/gdkevents.h"
struct _GdkEventAny {
   GdkEventType type ;
   GdkWindow *window ;
   gint8 send_event ;
};
#line 273 "/usr/include/gtk-2.0/gdk/gdkevents.h"
struct _GdkEventExpose {
   GdkEventType type ;
   GdkWindow *window ;
   gint8 send_event ;
   GdkRectangle area ;
   GdkRegion *region ;
   gint count ;
};
#line 283 "/usr/include/gtk-2.0/gdk/gdkevents.h"
struct _GdkEventNoExpose {
   GdkEventType type ;
   GdkWindow *window ;
   gint8 send_event ;
};
#line 290 "/usr/include/gtk-2.0/gdk/gdkevents.h"
struct _GdkEventVisibility {
   GdkEventType type ;
   GdkWindow *window ;
   gint8 send_event ;
   GdkVisibilityState state ;
};
#line 298 "/usr/include/gtk-2.0/gdk/gdkevents.h"
struct _GdkEventMotion {
   GdkEventType type ;
   GdkWindow *window ;
   gint8 send_event ;
   guint32 time ;
   gdouble x ;
   gdouble y ;
   gdouble *axes ;
   guint state ;
   gint16 is_hint ;
   GdkDevice *device ;
   gdouble x_root ;
   gdouble y_root ;
};
#line 313 "/usr/include/gtk-2.0/gdk/gdkevents.h"
struct _GdkEventButton {
   GdkEventType type ;
   GdkWindow *window ;
   gint8 send_event ;
   guint32 time ;
   gdouble x ;
   gdouble y ;
   gdouble *axes ;
   guint state ;
   guint button ;
   GdkDevice *device ;
   gdouble x_root ;
   gdouble y_root ;
};
#line 328 "/usr/include/gtk-2.0/gdk/gdkevents.h"
struct _GdkEventScroll {
   GdkEventType type ;
   GdkWindow *window ;
   gint8 send_event ;
   guint32 time ;
   gdouble x ;
   gdouble y ;
   guint state ;
   GdkScrollDirection direction ;
   GdkDevice *device ;
   gdouble x_root ;
   gdouble y_root ;
};
#line 342 "/usr/include/gtk-2.0/gdk/gdkevents.h"
struct _GdkEventKey {
   GdkEventType type ;
   GdkWindow *window ;
   gint8 send_event ;
   guint32 time ;
   guint state ;
   guint keyval ;
   gint length ;
   gchar *string ;
   guint16 hardware_keycode ;
   guint8 group ;
   guint is_modifier ;
};
#line 357 "/usr/include/gtk-2.0/gdk/gdkevents.h"
struct _GdkEventCrossing {
   GdkEventType type ;
   GdkWindow *window ;
   gint8 send_event ;
   GdkWindow *subwindow ;
   guint32 time ;
   gdouble x ;
   gdouble y ;
   gdouble x_root ;
   gdouble y_root ;
   GdkCrossingMode mode ;
   GdkNotifyType detail ;
   gboolean focus ;
   guint state ;
};
#line 374 "/usr/include/gtk-2.0/gdk/gdkevents.h"
struct _GdkEventFocus {
   GdkEventType type ;
   GdkWindow *window ;
   gint8 send_event ;
   gint16 in ;
};
#line 382 "/usr/include/gtk-2.0/gdk/gdkevents.h"
struct _GdkEventConfigure {
   GdkEventType type ;
   GdkWindow *window ;
   gint8 send_event ;
   gint x ;
   gint y ;
   gint width ;
   gint height ;
};
#line 392 "/usr/include/gtk-2.0/gdk/gdkevents.h"
struct _GdkEventProperty {
   GdkEventType type ;
   GdkWindow *window ;
   gint8 send_event ;
   GdkAtom atom ;
   guint32 time ;
   guint state ;
};
#line 402 "/usr/include/gtk-2.0/gdk/gdkevents.h"
struct _GdkEventSelection {
   GdkEventType type ;
   GdkWindow *window ;
   gint8 send_event ;
   GdkAtom selection ;
   GdkAtom target ;
   GdkAtom property ;
   guint32 time ;
   GdkNativeWindow requestor ;
};
#line 414 "/usr/include/gtk-2.0/gdk/gdkevents.h"
struct _GdkEventOwnerChange {
   GdkEventType type ;
   GdkWindow *window ;
   gint8 send_event ;
   GdkNativeWindow owner ;
   GdkOwnerChange reason ;
   GdkAtom selection ;
   guint32 time ;
   guint32 selection_time ;
};
#line 429 "/usr/include/gtk-2.0/gdk/gdkevents.h"
struct _GdkEventProximity {
   GdkEventType type ;
   GdkWindow *window ;
   gint8 send_event ;
   guint32 time ;
   GdkDevice *device ;
};
#line 445 "/usr/include/gtk-2.0/gdk/gdkevents.h"
union __anonunion_458 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 438 "/usr/include/gtk-2.0/gdk/gdkevents.h"
struct _GdkEventClient {
   GdkEventType type ;
   GdkWindow *window ;
   gint8 send_event ;
   GdkAtom message_type ;
   gushort data_format ;
   union __anonunion_458 data ;
};
#line 452 "/usr/include/gtk-2.0/gdk/gdkevents.h"
struct _GdkEventSetting {
   GdkEventType type ;
   GdkWindow *window ;
   gint8 send_event ;
   GdkSettingAction action ;
   char *name ;
};
#line 461 "/usr/include/gtk-2.0/gdk/gdkevents.h"
struct _GdkEventWindowState {
   GdkEventType type ;
   GdkWindow *window ;
   gint8 send_event ;
   GdkWindowState changed_mask ;
   GdkWindowState new_window_state ;
};
#line 470 "/usr/include/gtk-2.0/gdk/gdkevents.h"
struct _GdkEventGrabBroken {
   GdkEventType type ;
   GdkWindow *window ;
   gint8 send_event ;
   gboolean keyboard ;
   gboolean implicit ;
   GdkWindow *grab_window ;
};
#line 481 "/usr/include/gtk-2.0/gdk/gdkevents.h"
struct _GdkEventDND {
   GdkEventType type ;
   GdkWindow *window ;
   gint8 send_event ;
   GdkDragContext *context ;
   guint32 time ;
   gshort x_root ;
   gshort y_root ;
};
#line 491 "/usr/include/gtk-2.0/gdk/gdkevents.h"
union _GdkEvent {
   GdkEventType type ;
   GdkEventAny any ;
   GdkEventExpose expose ;
   GdkEventNoExpose no_expose ;
   GdkEventVisibility visibility ;
   GdkEventMotion motion ;
   GdkEventButton button ;
   GdkEventScroll scroll ;
   GdkEventKey key ;
   GdkEventCrossing crossing ;
   GdkEventFocus focus_change ;
   GdkEventConfigure configure ;
   GdkEventProperty property ;
   GdkEventSelection selection ;
   GdkEventOwnerChange owner_change ;
   GdkEventProximity proximity ;
   GdkEventClient client ;
   GdkEventDND dnd ;
   GdkEventWindowState window_state ;
   GdkEventSetting setting ;
   GdkEventGrabBroken grab_broken ;
};
#line 36 "/usr/include/gtk-2.0/gdk/gdkdisplay.h"
struct _GdkDisplayClass ;
#line 36 "/usr/include/gtk-2.0/gdk/gdkdisplay.h"
typedef struct _GdkDisplayClass GdkDisplayClass;
#line 37
struct _GdkDisplayPointerHooks ;
#line 37 "/usr/include/gtk-2.0/gdk/gdkdisplay.h"
typedef struct _GdkDisplayPointerHooks GdkDisplayPointerHooks;
#line 47 "/usr/include/gtk-2.0/gdk/gdkdisplay.h"
struct __anonstruct_459 {
   GdkWindow *window ;
   GdkWindow *native_window ;
   gulong serial ;
   gboolean owner_events ;
   guint32 time ;
};
#line 54 "/usr/include/gtk-2.0/gdk/gdkdisplay.h"
typedef struct __anonstruct_459 GdkKeyboardGrabInfo;
#line 63 "/usr/include/gtk-2.0/gdk/gdkdisplay.h"
struct __anonstruct_460 {
   GdkWindow *toplevel_under_pointer ;
   GdkWindow *window_under_pointer ;
   gdouble toplevel_x ;
   gdouble toplevel_y ;
   guint32 state ;
   guint32 button ;
   gulong motion_hint_serial ;
};
#line 71 "/usr/include/gtk-2.0/gdk/gdkdisplay.h"
typedef struct __anonstruct_460 GdkPointerWindowInfo;
#line 73 "/usr/include/gtk-2.0/gdk/gdkdisplay.h"
struct _GdkDisplay {
   GObject parent_instance ;
   GList *queued_events ;
   GList *queued_tail ;
   guint32 button_click_time[2] ;
   GdkWindow *button_window[2] ;
   gint button_number[2] ;
   guint double_click_time ;
   GdkDevice *core_pointer ;
   GdkDisplayPointerHooks *pointer_hooks ;
   guint closed ;
   guint ignore_core_events ;
   guint double_click_distance ;
   gint button_x[2] ;
   gint button_y[2] ;
   GList *pointer_grabs ;
   GdkKeyboardGrabInfo keyboard_grab ;
   GdkPointerWindowInfo pointer_info ;
   guint32 last_event_time ;
};
#line 108 "/usr/include/gtk-2.0/gdk/gdkdisplay.h"
struct _GdkDisplayClass {
   GObjectClass parent_class ;
   gchar *(*get_display_name)(GdkDisplay * ) ;
   gint (*get_n_screens)(GdkDisplay * ) ;
   GdkScreen *(*get_screen)(GdkDisplay * , gint  ) ;
   GdkScreen *(*get_default_screen)(GdkDisplay * ) ;
   void (*closed)(GdkDisplay * , gboolean  ) ;
};
#line 124 "/usr/include/gtk-2.0/gdk/gdkdisplay.h"
struct _GdkDisplayPointerHooks {
   void (*get_pointer)(GdkDisplay * , GdkScreen ** , gint * , gint * , GdkModifierType * ) ;
   GdkWindow *(*window_get_pointer)(GdkDisplay * , GdkWindow * , gint * , gint * ,
                                    GdkModifierType * ) ;
   GdkWindow *(*window_at_pointer)(GdkDisplay * , gint * , gint * ) ;
};
#line 37 "/usr/include/gtk-2.0/gdk/gdkscreen.h"
struct _GdkScreenClass ;
#line 37 "/usr/include/gtk-2.0/gdk/gdkscreen.h"
typedef struct _GdkScreenClass GdkScreenClass;
#line 46 "/usr/include/gtk-2.0/gdk/gdkscreen.h"
struct _GdkScreen {
   GObject parent_instance ;
   guint closed ;
   GdkGC *normal_gcs[32] ;
   GdkGC *exposure_gcs[32] ;
   GdkGC *subwindow_gcs[32] ;
   cairo_font_options_t *font_options ;
   double resolution ;
};
#line 60 "/usr/include/gtk-2.0/gdk/gdkscreen.h"
struct _GdkScreenClass {
   GObjectClass parent_class ;
   void (*size_changed)(GdkScreen * ) ;
   void (*composited_changed)(GdkScreen * ) ;
   void (*monitors_changed)(GdkScreen * ) ;
};
#line 42 "/usr/include/gtk-2.0/gdk/gdkapplaunchcontext.h"
struct GdkAppLaunchContext ;
#line 42 "/usr/include/gtk-2.0/gdk/gdkapplaunchcontext.h"
typedef struct GdkAppLaunchContext GdkAppLaunchContext;
#line 43
struct GdkAppLaunchContextClass ;
#line 43 "/usr/include/gtk-2.0/gdk/gdkapplaunchcontext.h"
typedef struct GdkAppLaunchContextClass GdkAppLaunchContextClass;
#line 44
struct GdkAppLaunchContextPrivate ;
#line 44 "/usr/include/gtk-2.0/gdk/gdkapplaunchcontext.h"
typedef struct GdkAppLaunchContextPrivate GdkAppLaunchContextPrivate;
#line 46 "/usr/include/gtk-2.0/gdk/gdkapplaunchcontext.h"
struct GdkAppLaunchContext {
   GAppLaunchContext parent_instance ;
   GdkAppLaunchContextPrivate *priv ;
};
#line 53 "/usr/include/gtk-2.0/gdk/gdkapplaunchcontext.h"
struct GdkAppLaunchContextClass {
   GAppLaunchContextClass parent_class ;
};
#line 38 "/usr/include/gtk-2.0/gdk/gdkrgb.h"
struct _GdkRgbCmap ;
#line 38 "/usr/include/gtk-2.0/gdk/gdkrgb.h"
typedef struct _GdkRgbCmap GdkRgbCmap;
#line 40
enum __anonenum__461 {
    GDK_RGB_DITHER_NONE = 0,
    GDK_RGB_DITHER_NORMAL = 1,
    GDK_RGB_DITHER_MAX = 2
} ;
#line 45 "/usr/include/gtk-2.0/gdk/gdkrgb.h"
typedef enum __anonenum__461 GdkRgbDither;
#line 49 "/usr/include/gtk-2.0/gdk/gdkrgb.h"
struct _GdkRgbCmap {
   guint32 colors[256] ;
   gint n_colors ;
   GSList *info_list ;
};
#line 65 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h"
enum __anonenum__462 {
    GDK_PIXBUF_ALPHA_BILEVEL = 0,
    GDK_PIXBUF_ALPHA_FULL = 1
} ;
#line 69 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h"
typedef enum __anonenum__462 GdkPixbufAlphaMode;
#line 83
enum __anonenum__463 {
    GDK_COLORSPACE_RGB = 0
} ;
#line 85 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h"
typedef enum __anonenum__463 GdkColorspace;
#line 89
struct _GdkPixbuf ;
#line 89 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h"
typedef struct _GdkPixbuf GdkPixbuf;
#line 110 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h"
typedef void (*GdkPixbufDestroyNotify)(guchar * , gpointer  );
#line 139
enum __anonenum__464 {
    GDK_PIXBUF_ERROR_CORRUPT_IMAGE = 0,
    GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY = 1,
    GDK_PIXBUF_ERROR_BAD_OPTION = 2,
    GDK_PIXBUF_ERROR_UNKNOWN_TYPE = 3,
    GDK_PIXBUF_ERROR_UNSUPPORTED_OPERATION = 4,
    GDK_PIXBUF_ERROR_FAILED = 5,
    GDK_PIXBUF_ERROR_INCOMPLETE_ANIMATION = 6
} ;
#line 152 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h"
typedef enum __anonenum__464 GdkPixbufError;
#line 367 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h"
typedef gboolean (*GdkPixbufSaveFunc)(gchar * , gsize  , GError ** , gpointer  );
#line 73 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-transform.h"
enum __anonenum__465 {
    GDK_INTERP_NEAREST = 0,
    GDK_INTERP_TILES = 1,
    GDK_INTERP_BILINEAR = 2,
    GDK_INTERP_HYPER = 3
} ;
#line 78 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-transform.h"
typedef enum __anonenum__465 GdkInterpType;
#line 91
enum __anonenum__466 {
    GDK_PIXBUF_ROTATE_NONE = 0,
    GDK_PIXBUF_ROTATE_COUNTERCLOCKWISE = 90,
    GDK_PIXBUF_ROTATE_UPSIDEDOWN = 180,
    GDK_PIXBUF_ROTATE_CLOCKWISE = 270
} ;
#line 96 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-transform.h"
typedef enum __anonenum__466 GdkPixbufRotation;
#line 39 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-animation.h"
struct _GdkPixbufAnimation ;
#line 39 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-animation.h"
typedef struct _GdkPixbufAnimation GdkPixbufAnimation;
#line 42
struct _GdkPixbufAnimationIter ;
#line 42 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-animation.h"
typedef struct _GdkPixbufAnimationIter GdkPixbufAnimationIter;
#line 38 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-simple-anim.h"
struct _GdkPixbufSimpleAnim ;
#line 38 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-simple-anim.h"
typedef struct _GdkPixbufSimpleAnim GdkPixbufSimpleAnim;
#line 39
struct _GdkPixbufSimpleAnimClass ;
#line 39 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-simple-anim.h"
typedef struct _GdkPixbufSimpleAnimClass GdkPixbufSimpleAnimClass;
#line 42 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-io.h"
struct _GdkPixbufFormat ;
#line 42 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-io.h"
typedef struct _GdkPixbufFormat GdkPixbufFormat;
#line 46 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-loader.h"
struct _GdkPixbufLoader ;
#line 46 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-loader.h"
typedef struct _GdkPixbufLoader GdkPixbufLoader;
#line 47 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-loader.h"
struct _GdkPixbufLoader {
   GObject parent_instance ;
   gpointer priv ;
};
#line 55
struct _GdkPixbufLoaderClass ;
#line 55 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-loader.h"
typedef struct _GdkPixbufLoaderClass GdkPixbufLoaderClass;
#line 56 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-loader.h"
struct _GdkPixbufLoaderClass {
   GObjectClass parent_class ;
   void (*size_prepared)(GdkPixbufLoader * , int  , int  ) ;
   void (*area_prepared)(GdkPixbufLoader * ) ;
   void (*area_updated)(GdkPixbufLoader * , int  , int  , int  , int  ) ;
   void (*closed)(GdkPixbufLoader * ) ;
};
#line 29 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GdkPixbuf *GdkPixbuf_autoptr;
#line 29 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GList *GdkPixbuf_listautoptr;
#line 29 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GSList *GdkPixbuf_slistautoptr;
#line 29 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GQueue *GdkPixbuf_queueautoptr;
#line 30 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GdkPixbufAnimation *GdkPixbufAnimation_autoptr;
#line 30 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GList *GdkPixbufAnimation_listautoptr;
#line 30 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GSList *GdkPixbufAnimation_slistautoptr;
#line 30 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GQueue *GdkPixbufAnimation_queueautoptr;
#line 31 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GdkPixbufAnimationIter *GdkPixbufAnimationIter_autoptr;
#line 31 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GList *GdkPixbufAnimationIter_listautoptr;
#line 31 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GSList *GdkPixbufAnimationIter_slistautoptr;
#line 31 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GQueue *GdkPixbufAnimationIter_queueautoptr;
#line 32 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GdkPixbufLoader *GdkPixbufLoader_autoptr;
#line 32 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GList *GdkPixbufLoader_listautoptr;
#line 32 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GSList *GdkPixbufLoader_slistautoptr;
#line 32 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GQueue *GdkPixbufLoader_queueautoptr;
#line 33 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GdkPixbufSimpleAnim *GdkPixbufSimpleAnim_autoptr;
#line 33 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GList *GdkPixbufSimpleAnim_listautoptr;
#line 33 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GSList *GdkPixbufSimpleAnim_slistautoptr;
#line 33 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GQueue *GdkPixbufSimpleAnim_queueautoptr;
#line 41 "/usr/include/pango-1.0/pango/pangocairo.h"
struct _PangoCairoFont ;
#line 41 "/usr/include/pango-1.0/pango/pangocairo.h"
typedef struct _PangoCairoFont PangoCairoFont;
#line 68
struct _PangoCairoFontMap ;
#line 68 "/usr/include/pango-1.0/pango/pangocairo.h"
typedef struct _PangoCairoFontMap PangoCairoFontMap;
#line 94 "/usr/include/pango-1.0/pango/pangocairo.h"
typedef void (*PangoCairoShapeRendererFunc)(cairo_t * , PangoAttrShape * , gboolean  ,
                                            gpointer  );
#line 43 "/usr/include/gtk-2.0/gdk/gdkcursor.h"
enum __anonenum__467 {
    GDK_X_CURSOR = 0,
    GDK_ARROW = 2,
    GDK_BASED_ARROW_DOWN = 4,
    GDK_BASED_ARROW_UP = 6,
    GDK_BOAT = 8,
    GDK_BOGOSITY = 10,
    GDK_BOTTOM_LEFT_CORNER = 12,
    GDK_BOTTOM_RIGHT_CORNER = 14,
    GDK_BOTTOM_SIDE = 16,
    GDK_BOTTOM_TEE = 18,
    GDK_BOX_SPIRAL = 20,
    GDK_CENTER_PTR = 22,
    GDK_CIRCLE = 24,
    GDK_CLOCK = 26,
    GDK_COFFEE_MUG = 28,
    GDK_CROSS = 30,
    GDK_CROSS_REVERSE = 32,
    GDK_CROSSHAIR = 34,
    GDK_DIAMOND_CROSS = 36,
    GDK_DOT = 38,
    GDK_DOTBOX = 40,
    GDK_DOUBLE_ARROW = 42,
    GDK_DRAFT_LARGE = 44,
    GDK_DRAFT_SMALL = 46,
    GDK_DRAPED_BOX = 48,
    GDK_EXCHANGE = 50,
    GDK_FLEUR = 52,
    GDK_GOBBLER = 54,
    GDK_GUMBY = 56,
    GDK_HAND1 = 58,
    GDK_HAND2 = 60,
    GDK_HEART = 62,
    GDK_ICON = 64,
    GDK_IRON_CROSS = 66,
    GDK_LEFT_PTR = 68,
    GDK_LEFT_SIDE = 70,
    GDK_LEFT_TEE = 72,
    GDK_LEFTBUTTON = 74,
    GDK_LL_ANGLE = 76,
    GDK_LR_ANGLE = 78,
    GDK_MAN = 80,
    GDK_MIDDLEBUTTON = 82,
    GDK_MOUSE = 84,
    GDK_PENCIL = 86,
    GDK_PIRATE = 88,
    GDK_PLUS = 90,
    GDK_QUESTION_ARROW = 92,
    GDK_RIGHT_PTR = 94,
    GDK_RIGHT_SIDE = 96,
    GDK_RIGHT_TEE = 98,
    GDK_RIGHTBUTTON = 100,
    GDK_RTL_LOGO = 102,
    GDK_SAILBOAT = 104,
    GDK_SB_DOWN_ARROW = 106,
    GDK_SB_H_DOUBLE_ARROW = 108,
    GDK_SB_LEFT_ARROW = 110,
    GDK_SB_RIGHT_ARROW = 112,
    GDK_SB_UP_ARROW = 114,
    GDK_SB_V_DOUBLE_ARROW = 116,
    GDK_SHUTTLE = 118,
    GDK_SIZING = 120,
    GDK_SPIDER = 122,
    GDK_SPRAYCAN = 124,
    GDK_STAR = 126,
    GDK_TARGET = 128,
    GDK_TCROSS = 130,
    GDK_TOP_LEFT_ARROW = 132,
    GDK_TOP_LEFT_CORNER = 134,
    GDK_TOP_RIGHT_CORNER = 136,
    GDK_TOP_SIDE = 138,
    GDK_TOP_TEE = 140,
    GDK_TREK = 142,
    GDK_UL_ANGLE = 144,
    GDK_UMBRELLA = 146,
    GDK_UR_ANGLE = 148,
    GDK_WATCH = 150,
    GDK_XTERM = 152,
    GDK_LAST_CURSOR = 153,
    GDK_BLANK_CURSOR = -2,
    GDK_CURSOR_IS_PIXMAP = -1
} ;
#line 125 "/usr/include/gtk-2.0/gdk/gdkcursor.h"
typedef enum __anonenum__467 GdkCursorType;
#line 127 "/usr/include/gtk-2.0/gdk/gdkcursor.h"
struct _GdkCursor {
   GdkCursorType type ;
   guint ref_count ;
};
#line 39 "/usr/include/gtk-2.0/gdk/gdkdisplaymanager.h"
struct _GdkDisplayManager ;
#line 39 "/usr/include/gtk-2.0/gdk/gdkdisplaymanager.h"
typedef struct _GdkDisplayManager GdkDisplayManager;
#line 40
struct _GdkDisplayManagerClass ;
#line 40 "/usr/include/gtk-2.0/gdk/gdkdisplaymanager.h"
typedef struct _GdkDisplayManagerClass GdkDisplayManagerClass;
#line 49 "/usr/include/gtk-2.0/gdk/gdkdisplaymanager.h"
struct _GdkDisplayManagerClass {
   GObjectClass parent_class ;
   void (*display_opened)(GdkDisplayManager * , GdkDisplay * ) ;
};
#line 39 "/usr/include/gtk-2.0/gdk/gdkgc.h"
struct _GdkGCValues ;
#line 39 "/usr/include/gtk-2.0/gdk/gdkgc.h"
typedef struct _GdkGCValues GdkGCValues;
#line 40
struct _GdkGCClass ;
#line 40 "/usr/include/gtk-2.0/gdk/gdkgc.h"
typedef struct _GdkGCClass GdkGCClass;
#line 48
enum __anonenum__468 {
    GDK_CAP_NOT_LAST = 0,
    GDK_CAP_BUTT = 1,
    GDK_CAP_ROUND = 2,
    GDK_CAP_PROJECTING = 3
} ;
#line 54 "/usr/include/gtk-2.0/gdk/gdkgc.h"
typedef enum __anonenum__468 GdkCapStyle;
#line 62
enum __anonenum__469 {
    GDK_SOLID = 0,
    GDK_TILED = 1,
    GDK_STIPPLED = 2,
    GDK_OPAQUE_STIPPLED = 3
} ;
#line 68 "/usr/include/gtk-2.0/gdk/gdkgc.h"
typedef enum __anonenum__469 GdkFill;
#line 88
enum __anonenum__470 {
    GDK_COPY = 0,
    GDK_INVERT = 1,
    GDK_XOR = 2,
    GDK_CLEAR = 3,
    GDK_AND = 4,
    GDK_AND_REVERSE = 5,
    GDK_AND_INVERT = 6,
    GDK_NOOP = 7,
    GDK_OR = 8,
    GDK_EQUIV = 9,
    GDK_OR_REVERSE = 10,
    GDK_COPY_INVERT = 11,
    GDK_OR_INVERT = 12,
    GDK_NAND = 13,
    GDK_NOR = 14,
    GDK_SET = 15
} ;
#line 106 "/usr/include/gtk-2.0/gdk/gdkgc.h"
typedef enum __anonenum__470 GdkFunction;
#line 113
enum __anonenum__471 {
    GDK_JOIN_MITER = 0,
    GDK_JOIN_ROUND = 1,
    GDK_JOIN_BEVEL = 2
} ;
#line 118 "/usr/include/gtk-2.0/gdk/gdkgc.h"
typedef enum __anonenum__471 GdkJoinStyle;
#line 125
enum __anonenum__472 {
    GDK_LINE_SOLID = 0,
    GDK_LINE_ON_OFF_DASH = 1,
    GDK_LINE_DOUBLE_DASH = 2
} ;
#line 130 "/usr/include/gtk-2.0/gdk/gdkgc.h"
typedef enum __anonenum__472 GdkLineStyle;
#line 132
enum __anonenum__473 {
    GDK_CLIP_BY_CHILDREN = 0,
    GDK_INCLUDE_INFERIORS = 1
} ;
#line 136 "/usr/include/gtk-2.0/gdk/gdkgc.h"
typedef enum __anonenum__473 GdkSubwindowMode;
#line 138
enum __anonenum__474 {
    GDK_GC_FOREGROUND = 1,
    GDK_GC_BACKGROUND = 2,
    GDK_GC_FONT = 4,
    GDK_GC_FUNCTION = 8,
    GDK_GC_FILL = 16,
    GDK_GC_TILE = 32,
    GDK_GC_STIPPLE = 64,
    GDK_GC_CLIP_MASK = 128,
    GDK_GC_SUBWINDOW = 256,
    GDK_GC_TS_X_ORIGIN = 512,
    GDK_GC_TS_Y_ORIGIN = 1024,
    GDK_GC_CLIP_X_ORIGIN = 2048,
    GDK_GC_CLIP_Y_ORIGIN = 4096,
    GDK_GC_EXPOSURES = 8192,
    GDK_GC_LINE_WIDTH = 16384,
    GDK_GC_LINE_STYLE = 32768,
    GDK_GC_CAP_STYLE = 65536,
    GDK_GC_JOIN_STYLE = 131072
} ;
#line 158 "/usr/include/gtk-2.0/gdk/gdkgc.h"
typedef enum __anonenum__474 GdkGCValuesMask;
#line 160 "/usr/include/gtk-2.0/gdk/gdkgc.h"
struct _GdkGCValues {
   GdkColor foreground ;
   GdkColor background ;
   GdkFont *font ;
   GdkFunction function ;
   GdkFill fill ;
   GdkPixmap *tile ;
   GdkPixmap *stipple ;
   GdkPixmap *clip_mask ;
   GdkSubwindowMode subwindow_mode ;
   gint ts_x_origin ;
   gint ts_y_origin ;
   gint clip_x_origin ;
   gint clip_y_origin ;
   gint graphics_exposures ;
   gint line_width ;
   GdkLineStyle line_style ;
   GdkCapStyle cap_style ;
   GdkJoinStyle join_style ;
};
#line 189 "/usr/include/gtk-2.0/gdk/gdkgc.h"
struct _GdkGC {
   GObject parent_instance ;
   gint clip_x_origin ;
   gint clip_y_origin ;
   gint ts_x_origin ;
   gint ts_y_origin ;
   GdkColormap *colormap ;
};
#line 201 "/usr/include/gtk-2.0/gdk/gdkgc.h"
struct _GdkGCClass {
   GObjectClass parent_class ;
   void (*get_values)(GdkGC * , GdkGCValues * ) ;
   void (*set_values)(GdkGC * , GdkGCValues * , GdkGCValuesMask  ) ;
   void (*set_dashes)(GdkGC * , gint  , gint8 [] , gint  ) ;
   void (*_gdk_reserved1)(void) ;
   void (*_gdk_reserved2)(void) ;
   void (*_gdk_reserved3)(void) ;
   void (*_gdk_reserved4)(void) ;
};
#line 43 "/usr/include/gtk-2.0/gdk/gdkdrawable.h"
struct _GdkDrawableClass ;
#line 43 "/usr/include/gtk-2.0/gdk/gdkdrawable.h"
typedef struct _GdkDrawableClass GdkDrawableClass;
#line 44
struct _GdkTrapezoid ;
#line 44 "/usr/include/gtk-2.0/gdk/gdkdrawable.h"
typedef struct _GdkTrapezoid GdkTrapezoid;
#line 53 "/usr/include/gtk-2.0/gdk/gdkdrawable.h"
struct _GdkDrawable {
   GObject parent_instance ;
};
#line 58 "/usr/include/gtk-2.0/gdk/gdkdrawable.h"
struct _GdkDrawableClass {
   GObjectClass parent_class ;
   GdkGC *(*create_gc)(GdkDrawable * , GdkGCValues * , GdkGCValuesMask  ) ;
   void (*draw_rectangle)(GdkDrawable * , GdkGC * , gboolean  , gint  , gint  , gint  ,
                          gint  ) ;
   void (*draw_arc)(GdkDrawable * , GdkGC * , gboolean  , gint  , gint  , gint  ,
                    gint  , gint  , gint  ) ;
   void (*draw_polygon)(GdkDrawable * , GdkGC * , gboolean  , GdkPoint * , gint  ) ;
   void (*draw_text)(GdkDrawable * , GdkFont * , GdkGC * , gint  , gint  , gchar * ,
                     gint  ) ;
   void (*draw_text_wc)(GdkDrawable * , GdkFont * , GdkGC * , gint  , gint  , GdkWChar * ,
                        gint  ) ;
   void (*draw_drawable)(GdkDrawable * , GdkGC * , GdkDrawable * , gint  , gint  ,
                         gint  , gint  , gint  , gint  ) ;
   void (*draw_points)(GdkDrawable * , GdkGC * , GdkPoint * , gint  ) ;
   void (*draw_segments)(GdkDrawable * , GdkGC * , GdkSegment * , gint  ) ;
   void (*draw_lines)(GdkDrawable * , GdkGC * , GdkPoint * , gint  ) ;
   void (*draw_glyphs)(GdkDrawable * , GdkGC * , PangoFont * , gint  , gint  , PangoGlyphString * ) ;
   void (*draw_image)(GdkDrawable * , GdkGC * , GdkImage * , gint  , gint  , gint  ,
                      gint  , gint  , gint  ) ;
   gint (*get_depth)(GdkDrawable * ) ;
   void (*get_size)(GdkDrawable * , gint * , gint * ) ;
   void (*set_colormap)(GdkDrawable * , GdkColormap * ) ;
   GdkColormap *(*get_colormap)(GdkDrawable * ) ;
   GdkVisual *(*get_visual)(GdkDrawable * ) ;
   GdkScreen *(*get_screen)(GdkDrawable * ) ;
   GdkImage *(*get_image)(GdkDrawable * , gint  , gint  , gint  , gint  ) ;
   GdkRegion *(*get_clip_region)(GdkDrawable * ) ;
   GdkRegion *(*get_visible_region)(GdkDrawable * ) ;
   GdkDrawable *(*get_composite_drawable)(GdkDrawable * , gint  , gint  , gint  ,
                                          gint  , gint * , gint * ) ;
   void (*draw_pixbuf)(GdkDrawable * , GdkGC * , GdkPixbuf * , gint  , gint  , gint  ,
                       gint  , gint  , gint  , GdkRgbDither  , gint  , gint  ) ;
   GdkImage *(*_copy_to_image)(GdkDrawable * , GdkImage * , gint  , gint  , gint  ,
                               gint  , gint  , gint  ) ;
   void (*draw_glyphs_transformed)(GdkDrawable * , GdkGC * , PangoMatrix * , PangoFont * ,
                                   gint  , gint  , PangoGlyphString * ) ;
   void (*draw_trapezoids)(GdkDrawable * , GdkGC * , GdkTrapezoid * , gint  ) ;
   cairo_surface_t *(*ref_cairo_surface)(GdkDrawable * ) ;
   GdkDrawable *(*get_source_drawable)(GdkDrawable * ) ;
   void (*set_cairo_clip)(GdkDrawable * , cairo_t * ) ;
   cairo_surface_t *(*create_cairo_surface)(GdkDrawable * , int  , int  ) ;
   void (*draw_drawable_with_src)(GdkDrawable * , GdkGC * , GdkDrawable * , gint  ,
                                  gint  , gint  , gint  , gint  , gint  , GdkDrawable * ) ;
   void (*_gdk_reserved7)(void) ;
   void (*_gdk_reserved9)(void) ;
   void (*_gdk_reserved10)(void) ;
   void (*_gdk_reserved11)(void) ;
   void (*_gdk_reserved12)(void) ;
   void (*_gdk_reserved13)(void) ;
   void (*_gdk_reserved14)(void) ;
   void (*_gdk_reserved15)(void) ;
};
#line 234 "/usr/include/gtk-2.0/gdk/gdkdrawable.h"
struct _GdkTrapezoid {
   double y1 ;
   double x11 ;
   double x21 ;
   double y2 ;
   double x12 ;
   double x22 ;
};
#line 43 "/usr/include/gtk-2.0/gdk/gdkfont.h"
enum __anonenum__475 {
    GDK_FONT_FONT = 0,
    GDK_FONT_FONTSET = 1
} ;
#line 47 "/usr/include/gtk-2.0/gdk/gdkfont.h"
typedef enum __anonenum__475 GdkFontType;
#line 49 "/usr/include/gtk-2.0/gdk/gdkfont.h"
struct _GdkFont {
   GdkFontType type ;
   gint ascent ;
   gint descent ;
};
#line 49 "/usr/include/gtk-2.0/gdk/gdkimage.h"
enum __anonenum__476 {
    GDK_IMAGE_NORMAL = 0,
    GDK_IMAGE_SHARED = 1,
    GDK_IMAGE_FASTEST = 2
} ;
#line 54 "/usr/include/gtk-2.0/gdk/gdkimage.h"
typedef enum __anonenum__476 GdkImageType;
#line 56
struct _GdkImageClass ;
#line 56 "/usr/include/gtk-2.0/gdk/gdkimage.h"
typedef struct _GdkImageClass GdkImageClass;
#line 65 "/usr/include/gtk-2.0/gdk/gdkimage.h"
struct _GdkImage {
   GObject parent_instance ;
   GdkImageType type ;
   GdkVisual *visual ;
   GdkByteOrder byte_order ;
   gint width ;
   gint height ;
   guint16 depth ;
   guint16 bpp ;
   guint16 bpl ;
   guint16 bits_per_pixel ;
   gpointer mem ;
   GdkColormap *colormap ;
   gpointer windowing_data ;
};
#line 88 "/usr/include/gtk-2.0/gdk/gdkimage.h"
struct _GdkImageClass {
   GObjectClass parent_class ;
};
#line 38 "/usr/include/gtk-2.0/gdk/gdkkeys.h"
struct _GdkKeymapKey ;
#line 38 "/usr/include/gtk-2.0/gdk/gdkkeys.h"
typedef struct _GdkKeymapKey GdkKeymapKey;
#line 41 "/usr/include/gtk-2.0/gdk/gdkkeys.h"
struct _GdkKeymapKey {
   guint keycode ;
   gint group ;
   gint level ;
};
#line 56
struct _GdkKeymap ;
#line 56 "/usr/include/gtk-2.0/gdk/gdkkeys.h"
typedef struct _GdkKeymap GdkKeymap;
#line 57
struct _GdkKeymapClass ;
#line 57 "/usr/include/gtk-2.0/gdk/gdkkeys.h"
typedef struct _GdkKeymapClass GdkKeymapClass;
#line 66 "/usr/include/gtk-2.0/gdk/gdkkeys.h"
struct _GdkKeymap {
   GObject parent_instance ;
   GdkDisplay *display ;
};
#line 72 "/usr/include/gtk-2.0/gdk/gdkkeys.h"
struct _GdkKeymapClass {
   GObjectClass parent_class ;
   void (*direction_changed)(GdkKeymap * ) ;
   void (*keys_changed)(GdkKeymap * ) ;
   void (*state_changed)(GdkKeymap * ) ;
};
#line 33 "/usr/include/gtk-2.0/gdk/gdkpango.h"
struct _GdkPangoRenderer ;
#line 33 "/usr/include/gtk-2.0/gdk/gdkpango.h"
typedef struct _GdkPangoRenderer GdkPangoRenderer;
#line 34
struct _GdkPangoRendererClass ;
#line 34 "/usr/include/gtk-2.0/gdk/gdkpango.h"
typedef struct _GdkPangoRendererClass GdkPangoRendererClass;
#line 35
struct _GdkPangoRendererPrivate ;
#line 35 "/usr/include/gtk-2.0/gdk/gdkpango.h"
typedef struct _GdkPangoRendererPrivate GdkPangoRendererPrivate;
#line 68 "/usr/include/gtk-2.0/gdk/gdkpango.h"
struct _GdkPangoRenderer {
   PangoRenderer parent_instance ;
   GdkPangoRendererPrivate *priv ;
};
#line 83 "/usr/include/gtk-2.0/gdk/gdkpango.h"
struct _GdkPangoRendererClass {
   PangoRendererClass parent_class ;
};
#line 138
struct _GdkPangoAttrStipple ;
#line 138 "/usr/include/gtk-2.0/gdk/gdkpango.h"
typedef struct _GdkPangoAttrStipple GdkPangoAttrStipple;
#line 139
struct _GdkPangoAttrEmbossed ;
#line 139 "/usr/include/gtk-2.0/gdk/gdkpango.h"
typedef struct _GdkPangoAttrEmbossed GdkPangoAttrEmbossed;
#line 140
struct _GdkPangoAttrEmbossColor ;
#line 140 "/usr/include/gtk-2.0/gdk/gdkpango.h"
typedef struct _GdkPangoAttrEmbossColor GdkPangoAttrEmbossColor;
#line 142 "/usr/include/gtk-2.0/gdk/gdkpango.h"
struct _GdkPangoAttrStipple {
   PangoAttribute attr ;
   GdkBitmap *stipple ;
};
#line 148 "/usr/include/gtk-2.0/gdk/gdkpango.h"
struct _GdkPangoAttrEmbossed {
   PangoAttribute attr ;
   gboolean embossed ;
};
#line 154 "/usr/include/gtk-2.0/gdk/gdkpango.h"
struct _GdkPangoAttrEmbossColor {
   PangoAttribute attr ;
   PangoColor color ;
};
#line 39 "/usr/include/gtk-2.0/gdk/gdkpixmap.h"
struct _GdkPixmapObject ;
#line 39 "/usr/include/gtk-2.0/gdk/gdkpixmap.h"
typedef struct _GdkPixmapObject GdkPixmapObject;
#line 40
struct _GdkPixmapObjectClass ;
#line 40 "/usr/include/gtk-2.0/gdk/gdkpixmap.h"
typedef struct _GdkPixmapObjectClass GdkPixmapObjectClass;
#line 50 "/usr/include/gtk-2.0/gdk/gdkpixmap.h"
struct _GdkPixmapObject {
   GdkDrawable parent_instance ;
   GdkDrawable *impl ;
   gint depth ;
};
#line 59 "/usr/include/gtk-2.0/gdk/gdkpixmap.h"
struct _GdkPixmapObjectClass {
   GdkDrawableClass parent_class ;
};
#line 38 "/usr/include/gtk-2.0/gdk/gdkproperty.h"
enum __anonenum__477 {
    GDK_PROP_MODE_REPLACE = 0,
    GDK_PROP_MODE_PREPEND = 1,
    GDK_PROP_MODE_APPEND = 2
} ;
#line 43 "/usr/include/gtk-2.0/gdk/gdkproperty.h"
typedef enum __anonenum__477 GdkPropMode;
#line 43 "/usr/include/gtk-2.0/gdk/gdkregion.h"
enum __anonenum__478 {
    GDK_EVEN_ODD_RULE = 0,
    GDK_WINDING_RULE = 1
} ;
#line 47 "/usr/include/gtk-2.0/gdk/gdkregion.h"
typedef enum __anonenum__478 GdkFillRule;
#line 55
enum __anonenum__479 {
    GDK_OVERLAP_RECTANGLE_IN = 0,
    GDK_OVERLAP_RECTANGLE_OUT = 1,
    GDK_OVERLAP_RECTANGLE_PART = 2
} ;
#line 60 "/usr/include/gtk-2.0/gdk/gdkregion.h"
typedef enum __anonenum__479 GdkOverlapType;
#line 63 "/usr/include/gtk-2.0/gdk/gdkregion.h"
typedef void (*GdkSpanFunc)(GdkSpan * , gpointer  );
#line 60 "/usr/include/gtk-2.0/gdk/gdkselection.h"
typedef GdkAtom GdkSelection;
#line 61 "/usr/include/gtk-2.0/gdk/gdkselection.h"
typedef GdkAtom GdkTarget;
#line 62 "/usr/include/gtk-2.0/gdk/gdkselection.h"
typedef GdkAtom GdkSelectionType;
#line 40 "/usr/include/gtk-2.0/gdk/gdkwindow.h"
struct _GdkGeometry ;
#line 40 "/usr/include/gtk-2.0/gdk/gdkwindow.h"
typedef struct _GdkGeometry GdkGeometry;
#line 41
struct _GdkWindowAttr ;
#line 41 "/usr/include/gtk-2.0/gdk/gdkwindow.h"
typedef struct _GdkWindowAttr GdkWindowAttr;
#line 42
struct _GdkPointerHooks ;
#line 42 "/usr/include/gtk-2.0/gdk/gdkwindow.h"
typedef struct _GdkPointerHooks GdkPointerHooks;
#line 43
struct _GdkWindowRedirect ;
#line 43 "/usr/include/gtk-2.0/gdk/gdkwindow.h"
typedef struct _GdkWindowRedirect GdkWindowRedirect;
#line 54
enum __anonenum__480 {
    GDK_INPUT_OUTPUT = 0,
    GDK_INPUT_ONLY = 1
} ;
#line 58 "/usr/include/gtk-2.0/gdk/gdkwindow.h"
typedef enum __anonenum__480 GdkWindowClass;
#line 73
enum __anonenum__481 {
    GDK_WINDOW_ROOT = 0,
    GDK_WINDOW_TOPLEVEL = 1,
    GDK_WINDOW_CHILD = 2,
    GDK_WINDOW_DIALOG = 3,
    GDK_WINDOW_TEMP = 4,
    GDK_WINDOW_FOREIGN = 5,
    GDK_WINDOW_OFFSCREEN = 6
} ;
#line 82 "/usr/include/gtk-2.0/gdk/gdkwindow.h"
typedef enum __anonenum__481 GdkWindowType;
#line 92
enum __anonenum__482 {
    GDK_WA_TITLE = 2,
    GDK_WA_X = 4,
    GDK_WA_Y = 8,
    GDK_WA_CURSOR = 16,
    GDK_WA_COLORMAP = 32,
    GDK_WA_VISUAL = 64,
    GDK_WA_WMCLASS = 128,
    GDK_WA_NOREDIR = 256,
    GDK_WA_TYPE_HINT = 512
} ;
#line 103 "/usr/include/gtk-2.0/gdk/gdkwindow.h"
typedef enum __anonenum__482 GdkWindowAttributesType;
#line 107
enum __anonenum__483 {
    GDK_HINT_POS = 1,
    GDK_HINT_MIN_SIZE = 2,
    GDK_HINT_MAX_SIZE = 4,
    GDK_HINT_BASE_SIZE = 8,
    GDK_HINT_ASPECT = 16,
    GDK_HINT_RESIZE_INC = 32,
    GDK_HINT_WIN_GRAVITY = 64,
    GDK_HINT_USER_POS = 128,
    GDK_HINT_USER_SIZE = 256
} ;
#line 118 "/usr/include/gtk-2.0/gdk/gdkwindow.h"
typedef enum __anonenum__483 GdkWindowHints;
#line 133
enum __anonenum__484 {
    GDK_WINDOW_TYPE_HINT_NORMAL = 0,
    GDK_WINDOW_TYPE_HINT_DIALOG = 1,
    GDK_WINDOW_TYPE_HINT_MENU = 2,
    GDK_WINDOW_TYPE_HINT_TOOLBAR = 3,
    GDK_WINDOW_TYPE_HINT_SPLASHSCREEN = 4,
    GDK_WINDOW_TYPE_HINT_UTILITY = 5,
    GDK_WINDOW_TYPE_HINT_DOCK = 6,
    GDK_WINDOW_TYPE_HINT_DESKTOP = 7,
    GDK_WINDOW_TYPE_HINT_DROPDOWN_MENU = 8,
    GDK_WINDOW_TYPE_HINT_POPUP_MENU = 9,
    GDK_WINDOW_TYPE_HINT_TOOLTIP = 10,
    GDK_WINDOW_TYPE_HINT_NOTIFICATION = 11,
    GDK_WINDOW_TYPE_HINT_COMBO = 12,
    GDK_WINDOW_TYPE_HINT_DND = 13
} ;
#line 149 "/usr/include/gtk-2.0/gdk/gdkwindow.h"
typedef enum __anonenum__484 GdkWindowTypeHint;
#line 156
enum __anonenum__485 {
    GDK_DECOR_ALL = 1,
    GDK_DECOR_BORDER = 2,
    GDK_DECOR_RESIZEH = 4,
    GDK_DECOR_TITLE = 8,
    GDK_DECOR_MENU = 16,
    GDK_DECOR_MINIMIZE = 32,
    GDK_DECOR_MAXIMIZE = 64
} ;
#line 165 "/usr/include/gtk-2.0/gdk/gdkwindow.h"
typedef enum __anonenum__485 GdkWMDecoration;
#line 167
enum __anonenum__486 {
    GDK_FUNC_ALL = 1,
    GDK_FUNC_RESIZE = 2,
    GDK_FUNC_MOVE = 4,
    GDK_FUNC_MINIMIZE = 8,
    GDK_FUNC_MAXIMIZE = 16,
    GDK_FUNC_CLOSE = 32
} ;
#line 175 "/usr/include/gtk-2.0/gdk/gdkwindow.h"
typedef enum __anonenum__486 GdkWMFunction;
#line 181
enum __anonenum__487 {
    GDK_GRAVITY_NORTH_WEST = 1,
    GDK_GRAVITY_NORTH = 2,
    GDK_GRAVITY_NORTH_EAST = 3,
    GDK_GRAVITY_WEST = 4,
    GDK_GRAVITY_CENTER = 5,
    GDK_GRAVITY_EAST = 6,
    GDK_GRAVITY_SOUTH_WEST = 7,
    GDK_GRAVITY_SOUTH = 8,
    GDK_GRAVITY_SOUTH_EAST = 9,
    GDK_GRAVITY_STATIC = 10
} ;
#line 193 "/usr/include/gtk-2.0/gdk/gdkwindow.h"
typedef enum __anonenum__487 GdkGravity;
#line 196
enum __anonenum__488 {
    GDK_WINDOW_EDGE_NORTH_WEST = 0,
    GDK_WINDOW_EDGE_NORTH = 1,
    GDK_WINDOW_EDGE_NORTH_EAST = 2,
    GDK_WINDOW_EDGE_WEST = 3,
    GDK_WINDOW_EDGE_EAST = 4,
    GDK_WINDOW_EDGE_SOUTH_WEST = 5,
    GDK_WINDOW_EDGE_SOUTH = 6,
    GDK_WINDOW_EDGE_SOUTH_EAST = 7
} ;
#line 206 "/usr/include/gtk-2.0/gdk/gdkwindow.h"
typedef enum __anonenum__488 GdkWindowEdge;
#line 208 "/usr/include/gtk-2.0/gdk/gdkwindow.h"
struct _GdkWindowAttr {
   gchar *title ;
   gint event_mask ;
   gint x ;
   gint y ;
   gint width ;
   gint height ;
   GdkWindowClass wclass ;
   GdkVisual *visual ;
   GdkColormap *colormap ;
   GdkWindowType window_type ;
   GdkCursor *cursor ;
   gchar *wmclass_name ;
   gchar *wmclass_class ;
   gboolean override_redirect ;
   GdkWindowTypeHint type_hint ;
};
#line 226 "/usr/include/gtk-2.0/gdk/gdkwindow.h"
struct _GdkGeometry {
   gint min_width ;
   gint min_height ;
   gint max_width ;
   gint max_height ;
   gint base_width ;
   gint base_height ;
   gint width_inc ;
   gint height_inc ;
   gdouble min_aspect ;
   gdouble max_aspect ;
   GdkGravity win_gravity ;
};
#line 241 "/usr/include/gtk-2.0/gdk/gdkwindow.h"
struct _GdkPointerHooks {
   GdkWindow *(*get_pointer)(GdkWindow * , gint * , gint * , GdkModifierType * ) ;
   GdkWindow *(*window_at_pointer)(GdkScreen * , gint * , gint * ) ;
};
#line 252
struct _GdkWindowObject ;
#line 252 "/usr/include/gtk-2.0/gdk/gdkwindow.h"
typedef struct _GdkWindowObject GdkWindowObject;
#line 253
struct _GdkWindowObjectClass ;
#line 253 "/usr/include/gtk-2.0/gdk/gdkwindow.h"
typedef struct _GdkWindowObjectClass GdkWindowObjectClass;
#line 272 "/usr/include/gtk-2.0/gdk/gdkwindow.h"
struct _GdkWindowObject {
   GdkDrawable parent_instance ;
   GdkDrawable *impl ;
   GdkWindowObject *parent ;
   gpointer user_data ;
   gint x ;
   gint y ;
   gint extension_events ;
   GList *filters ;
   GList *children ;
   GdkColor bg_color ;
   GdkPixmap *bg_pixmap ;
   GSList *paint_stack ;
   GdkRegion *update_area ;
   guint update_freeze_count ;
   guint8 window_type ;
   guint8 depth ;
   guint8 resize_count ;
   GdkWindowState state ;
   guint guffaw_gravity ;
   guint input_only ;
   guint modal_hint ;
   guint composited ;
   guint destroyed ;
   guint accept_focus ;
   guint focus_on_map ;
   guint shaped ;
   GdkEventMask event_mask ;
   guint update_and_descendants_freeze_count ;
   GdkWindowRedirect *redirect ;
};
#line 324 "/usr/include/gtk-2.0/gdk/gdkwindow.h"
struct _GdkWindowObjectClass {
   GdkDrawableClass parent_class ;
};
#line 45 "/usr/include/gtk-2.0/gdk/gdkvisual.h"
struct _GdkVisualClass ;
#line 45 "/usr/include/gtk-2.0/gdk/gdkvisual.h"
typedef struct _GdkVisualClass GdkVisualClass;
#line 55
enum __anonenum__489 {
    GDK_VISUAL_STATIC_GRAY = 0,
    GDK_VISUAL_GRAYSCALE = 1,
    GDK_VISUAL_STATIC_COLOR = 2,
    GDK_VISUAL_PSEUDO_COLOR = 3,
    GDK_VISUAL_TRUE_COLOR = 4,
    GDK_VISUAL_DIRECT_COLOR = 5
} ;
#line 63 "/usr/include/gtk-2.0/gdk/gdkvisual.h"
typedef enum __anonenum__489 GdkVisualType;
#line 77 "/usr/include/gtk-2.0/gdk/gdkvisual.h"
struct _GdkVisual {
   GObject parent_instance ;
   GdkVisualType type ;
   gint depth ;
   GdkByteOrder byte_order ;
   gint colormap_size ;
   gint bits_per_rgb ;
   guint32 red_mask ;
   gint red_shift ;
   gint red_prec ;
   guint32 green_mask ;
   gint green_shift ;
   gint green_prec ;
   guint32 blue_mask ;
   gint blue_shift ;
   gint blue_prec ;
};
#line 39 "/usr/include/gtk-2.0/gtk/gtkenums.h"
enum __anonenum__490 {
    GTK_ANCHOR_CENTER = 0,
    GTK_ANCHOR_NORTH = 1,
    GTK_ANCHOR_NORTH_WEST = 2,
    GTK_ANCHOR_NORTH_EAST = 3,
    GTK_ANCHOR_SOUTH = 4,
    GTK_ANCHOR_SOUTH_WEST = 5,
    GTK_ANCHOR_SOUTH_EAST = 6,
    GTK_ANCHOR_WEST = 7,
    GTK_ANCHOR_EAST = 8,
    GTK_ANCHOR_N = 1,
    GTK_ANCHOR_NW = 2,
    GTK_ANCHOR_NE = 3,
    GTK_ANCHOR_S = 4,
    GTK_ANCHOR_SW = 5,
    GTK_ANCHOR_SE = 6,
    GTK_ANCHOR_W = 7,
    GTK_ANCHOR_E = 8
} ;
#line 58 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__490 GtkAnchorType;
#line 61
enum __anonenum__491 {
    GTK_ARROWS_BOTH = 0,
    GTK_ARROWS_START = 1,
    GTK_ARROWS_END = 2
} ;
#line 66 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__491 GtkArrowPlacement;
#line 69
enum __anonenum__492 {
    GTK_ARROW_UP = 0,
    GTK_ARROW_DOWN = 1,
    GTK_ARROW_LEFT = 2,
    GTK_ARROW_RIGHT = 3,
    GTK_ARROW_NONE = 4
} ;
#line 76 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__492 GtkArrowType;
#line 79
enum __anonenum__493 {
    GTK_EXPAND = 1,
    GTK_SHRINK = 2,
    GTK_FILL = 4
} ;
#line 84 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__493 GtkAttachOptions;
#line 87
enum __anonenum__494 {
    GTK_BUTTONBOX_DEFAULT_STYLE = 0,
    GTK_BUTTONBOX_SPREAD = 1,
    GTK_BUTTONBOX_EDGE = 2,
    GTK_BUTTONBOX_START = 3,
    GTK_BUTTONBOX_END = 4,
    GTK_BUTTONBOX_CENTER = 5
} ;
#line 95 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__494 GtkButtonBoxStyle;
#line 99
enum __anonenum__495 {
    GTK_CURVE_TYPE_LINEAR = 0,
    GTK_CURVE_TYPE_SPLINE = 1,
    GTK_CURVE_TYPE_FREE = 2
} ;
#line 104 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__495 GtkCurveType;
#line 107
enum __anonenum__496 {
    GTK_DELETE_CHARS = 0,
    GTK_DELETE_WORD_ENDS = 1,
    GTK_DELETE_WORDS = 2,
    GTK_DELETE_DISPLAY_LINES = 3,
    GTK_DELETE_DISPLAY_LINE_ENDS = 4,
    GTK_DELETE_PARAGRAPH_ENDS = 5,
    GTK_DELETE_PARAGRAPHS = 6,
    GTK_DELETE_WHITESPACE = 7
} ;
#line 119 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__496 GtkDeleteType;
#line 122
enum __anonenum__497 {
    GTK_DIR_TAB_FORWARD = 0,
    GTK_DIR_TAB_BACKWARD = 1,
    GTK_DIR_UP = 2,
    GTK_DIR_DOWN = 3,
    GTK_DIR_LEFT = 4,
    GTK_DIR_RIGHT = 5
} ;
#line 130 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__497 GtkDirectionType;
#line 133
enum __anonenum__498 {
    GTK_EXPANDER_COLLAPSED = 0,
    GTK_EXPANDER_SEMI_COLLAPSED = 1,
    GTK_EXPANDER_SEMI_EXPANDED = 2,
    GTK_EXPANDER_EXPANDED = 3
} ;
#line 139 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__498 GtkExpanderStyle;
#line 142
enum __anonenum__499 {
    GTK_ICON_SIZE_INVALID = 0,
    GTK_ICON_SIZE_MENU = 1,
    GTK_ICON_SIZE_SMALL_TOOLBAR = 2,
    GTK_ICON_SIZE_LARGE_TOOLBAR = 3,
    GTK_ICON_SIZE_BUTTON = 4,
    GTK_ICON_SIZE_DND = 5,
    GTK_ICON_SIZE_DIALOG = 6
} ;
#line 151 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__499 GtkIconSize;
#line 154
enum __anonenum__500 {
    GTK_SENSITIVITY_AUTO = 0,
    GTK_SENSITIVITY_ON = 1,
    GTK_SENSITIVITY_OFF = 2
} ;
#line 159 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__500 GtkSensitivityType;
#line 163
enum __anonenum__501 {
    GTK_SIDE_TOP = 0,
    GTK_SIDE_BOTTOM = 1,
    GTK_SIDE_LEFT = 2,
    GTK_SIDE_RIGHT = 3
} ;
#line 169 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__501 GtkSideType;
#line 173
enum __anonenum__502 {
    GTK_TEXT_DIR_NONE = 0,
    GTK_TEXT_DIR_LTR = 1,
    GTK_TEXT_DIR_RTL = 2
} ;
#line 178 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__502 GtkTextDirection;
#line 181
enum __anonenum__503 {
    GTK_JUSTIFY_LEFT = 0,
    GTK_JUSTIFY_RIGHT = 1,
    GTK_JUSTIFY_CENTER = 2,
    GTK_JUSTIFY_FILL = 3
} ;
#line 187 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__503 GtkJustification;
#line 191
enum __anonenum__504 {
    GTK_MATCH_ALL = 0,
    GTK_MATCH_ALL_TAIL = 1,
    GTK_MATCH_HEAD = 2,
    GTK_MATCH_TAIL = 3,
    GTK_MATCH_EXACT = 4,
    GTK_MATCH_LAST = 5
} ;
#line 199 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__504 GtkMatchType;
#line 203
enum __anonenum__505 {
    GTK_MENU_DIR_PARENT = 0,
    GTK_MENU_DIR_CHILD = 1,
    GTK_MENU_DIR_NEXT = 2,
    GTK_MENU_DIR_PREV = 3
} ;
#line 209 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__505 GtkMenuDirectionType;
#line 221
enum __anonenum__506 {
    GTK_MESSAGE_INFO = 0,
    GTK_MESSAGE_WARNING = 1,
    GTK_MESSAGE_QUESTION = 2,
    GTK_MESSAGE_ERROR = 3,
    GTK_MESSAGE_OTHER = 4
} ;
#line 228 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__506 GtkMessageType;
#line 230
enum __anonenum__507 {
    GTK_PIXELS = 0,
    GTK_INCHES = 1,
    GTK_CENTIMETERS = 2
} ;
#line 235 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__507 GtkMetricType;
#line 237
enum __anonenum__508 {
    GTK_MOVEMENT_LOGICAL_POSITIONS = 0,
    GTK_MOVEMENT_VISUAL_POSITIONS = 1,
    GTK_MOVEMENT_WORDS = 2,
    GTK_MOVEMENT_DISPLAY_LINES = 3,
    GTK_MOVEMENT_DISPLAY_LINE_ENDS = 4,
    GTK_MOVEMENT_PARAGRAPHS = 5,
    GTK_MOVEMENT_PARAGRAPH_ENDS = 6,
    GTK_MOVEMENT_PAGES = 7,
    GTK_MOVEMENT_BUFFER_ENDS = 8,
    GTK_MOVEMENT_HORIZONTAL_PAGES = 9
} ;
#line 249 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__508 GtkMovementStep;
#line 251
enum __anonenum__509 {
    GTK_SCROLL_STEPS = 0,
    GTK_SCROLL_PAGES = 1,
    GTK_SCROLL_ENDS = 2,
    GTK_SCROLL_HORIZONTAL_STEPS = 3,
    GTK_SCROLL_HORIZONTAL_PAGES = 4,
    GTK_SCROLL_HORIZONTAL_ENDS = 5
} ;
#line 259 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__509 GtkScrollStep;
#line 262
enum __anonenum__510 {
    GTK_ORIENTATION_HORIZONTAL = 0,
    GTK_ORIENTATION_VERTICAL = 1
} ;
#line 266 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__510 GtkOrientation;
#line 269
enum __anonenum__511 {
    GTK_CORNER_TOP_LEFT = 0,
    GTK_CORNER_BOTTOM_LEFT = 1,
    GTK_CORNER_TOP_RIGHT = 2,
    GTK_CORNER_BOTTOM_RIGHT = 3
} ;
#line 275 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__511 GtkCornerType;
#line 278
enum __anonenum__512 {
    GTK_PACK_START = 0,
    GTK_PACK_END = 1
} ;
#line 282 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__512 GtkPackType;
#line 285
enum __anonenum__513 {
    GTK_PATH_PRIO_LOWEST = 0,
    GTK_PATH_PRIO_GTK = 4,
    GTK_PATH_PRIO_APPLICATION = 8,
    GTK_PATH_PRIO_THEME = 10,
    GTK_PATH_PRIO_RC = 12,
    GTK_PATH_PRIO_HIGHEST = 15
} ;
#line 293 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__513 GtkPathPriorityType;
#line 297
enum __anonenum__514 {
    GTK_PATH_WIDGET = 0,
    GTK_PATH_WIDGET_CLASS = 1,
    GTK_PATH_CLASS = 2
} ;
#line 302 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__514 GtkPathType;
#line 305
enum __anonenum__515 {
    GTK_POLICY_ALWAYS = 0,
    GTK_POLICY_AUTOMATIC = 1,
    GTK_POLICY_NEVER = 2
} ;
#line 310 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__515 GtkPolicyType;
#line 312
enum __anonenum__516 {
    GTK_POS_LEFT = 0,
    GTK_POS_RIGHT = 1,
    GTK_POS_TOP = 2,
    GTK_POS_BOTTOM = 3
} ;
#line 318 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__516 GtkPositionType;
#line 321
enum __anonenum__517 {
    GTK_PREVIEW_COLOR = 0,
    GTK_PREVIEW_GRAYSCALE = 1
} ;
#line 325 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__517 GtkPreviewType;
#line 329
enum __anonenum__518 {
    GTK_RELIEF_NORMAL = 0,
    GTK_RELIEF_HALF = 1,
    GTK_RELIEF_NONE = 2
} ;
#line 334 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__518 GtkReliefStyle;
#line 337
enum __anonenum__519 {
    GTK_RESIZE_PARENT = 0,
    GTK_RESIZE_QUEUE = 1,
    GTK_RESIZE_IMMEDIATE = 2
} ;
#line 342 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__519 GtkResizeMode;
#line 346
enum __anonenum__520 {
    GTK_RUN_FIRST = 1,
    GTK_RUN_LAST = 2,
    GTK_RUN_BOTH = 3,
    GTK_RUN_NO_RECURSE = 8,
    GTK_RUN_ACTION = 32,
    GTK_RUN_NO_HOOKS = 64
} ;
#line 354 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__520 GtkSignalRunType;
#line 358
enum __anonenum__521 {
    GTK_SCROLL_NONE = 0,
    GTK_SCROLL_JUMP = 1,
    GTK_SCROLL_STEP_BACKWARD = 2,
    GTK_SCROLL_STEP_FORWARD = 3,
    GTK_SCROLL_PAGE_BACKWARD = 4,
    GTK_SCROLL_PAGE_FORWARD = 5,
    GTK_SCROLL_STEP_UP = 6,
    GTK_SCROLL_STEP_DOWN = 7,
    GTK_SCROLL_PAGE_UP = 8,
    GTK_SCROLL_PAGE_DOWN = 9,
    GTK_SCROLL_STEP_LEFT = 10,
    GTK_SCROLL_STEP_RIGHT = 11,
    GTK_SCROLL_PAGE_LEFT = 12,
    GTK_SCROLL_PAGE_RIGHT = 13,
    GTK_SCROLL_START = 14,
    GTK_SCROLL_END = 15
} ;
#line 376 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__521 GtkScrollType;
#line 379
enum __anonenum__522 {
    GTK_SELECTION_NONE = 0,
    GTK_SELECTION_SINGLE = 1,
    GTK_SELECTION_BROWSE = 2,
    GTK_SELECTION_MULTIPLE = 3,
    GTK_SELECTION_EXTENDED = 3
} ;
#line 386 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__522 GtkSelectionMode;
#line 389
enum __anonenum__523 {
    GTK_SHADOW_NONE = 0,
    GTK_SHADOW_IN = 1,
    GTK_SHADOW_OUT = 2,
    GTK_SHADOW_ETCHED_IN = 3,
    GTK_SHADOW_ETCHED_OUT = 4
} ;
#line 396 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__523 GtkShadowType;
#line 399
enum __anonenum__524 {
    GTK_STATE_NORMAL = 0,
    GTK_STATE_ACTIVE = 1,
    GTK_STATE_PRELIGHT = 2,
    GTK_STATE_SELECTED = 3,
    GTK_STATE_INSENSITIVE = 4
} ;
#line 406 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__524 GtkStateType;
#line 410
enum __anonenum__525 {
    GTK_DIRECTION_LEFT = 0,
    GTK_DIRECTION_RIGHT = 1
} ;
#line 414 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__525 GtkSubmenuDirection;
#line 417
enum __anonenum__526 {
    GTK_TOP_BOTTOM = 0,
    GTK_LEFT_RIGHT = 1
} ;
#line 421 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__526 GtkSubmenuPlacement;
#line 425
enum __anonenum__527 {
    GTK_TOOLBAR_ICONS = 0,
    GTK_TOOLBAR_TEXT = 1,
    GTK_TOOLBAR_BOTH = 2,
    GTK_TOOLBAR_BOTH_HORIZ = 3
} ;
#line 431 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__527 GtkToolbarStyle;
#line 434
enum __anonenum__528 {
    GTK_UPDATE_CONTINUOUS = 0,
    GTK_UPDATE_DISCONTINUOUS = 1,
    GTK_UPDATE_DELAYED = 2
} ;
#line 439 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__528 GtkUpdateType;
#line 442
enum __anonenum__529 {
    GTK_VISIBILITY_NONE = 0,
    GTK_VISIBILITY_PARTIAL = 1,
    GTK_VISIBILITY_FULL = 2
} ;
#line 447 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__529 GtkVisibility;
#line 450
enum __anonenum__530 {
    GTK_WIN_POS_NONE = 0,
    GTK_WIN_POS_CENTER = 1,
    GTK_WIN_POS_MOUSE = 2,
    GTK_WIN_POS_CENTER_ALWAYS = 3,
    GTK_WIN_POS_CENTER_ON_PARENT = 4
} ;
#line 457 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__530 GtkWindowPosition;
#line 460
enum __anonenum__531 {
    GTK_WINDOW_TOPLEVEL = 0,
    GTK_WINDOW_POPUP = 1
} ;
#line 464 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__531 GtkWindowType;
#line 467
enum __anonenum__532 {
    GTK_WRAP_NONE = 0,
    GTK_WRAP_CHAR = 1,
    GTK_WRAP_WORD = 2,
    GTK_WRAP_WORD_CHAR = 3
} ;
#line 473 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__532 GtkWrapMode;
#line 476
enum __anonenum__533 {
    GTK_SORT_ASCENDING = 0,
    GTK_SORT_DESCENDING = 1
} ;
#line 480 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__533 GtkSortType;
#line 483
enum __anonenum__534 {
    GTK_IM_PREEDIT_NOTHING = 0,
    GTK_IM_PREEDIT_CALLBACK = 1,
    GTK_IM_PREEDIT_NONE = 2
} ;
#line 488 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__534 GtkIMPreeditStyle;
#line 490
enum __anonenum__535 {
    GTK_IM_STATUS_NOTHING = 0,
    GTK_IM_STATUS_CALLBACK = 1,
    GTK_IM_STATUS_NONE = 2
} ;
#line 495 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__535 GtkIMStatusStyle;
#line 497
enum __anonenum__536 {
    GTK_PACK_DIRECTION_LTR = 0,
    GTK_PACK_DIRECTION_RTL = 1,
    GTK_PACK_DIRECTION_TTB = 2,
    GTK_PACK_DIRECTION_BTT = 3
} ;
#line 503 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__536 GtkPackDirection;
#line 505
enum __anonenum__537 {
    GTK_PRINT_PAGES_ALL = 0,
    GTK_PRINT_PAGES_CURRENT = 1,
    GTK_PRINT_PAGES_RANGES = 2,
    GTK_PRINT_PAGES_SELECTION = 3
} ;
#line 511 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__537 GtkPrintPages;
#line 513
enum __anonenum__538 {
    GTK_PAGE_SET_ALL = 0,
    GTK_PAGE_SET_EVEN = 1,
    GTK_PAGE_SET_ODD = 2
} ;
#line 518 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__538 GtkPageSet;
#line 520
enum __anonenum__539 {
    GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_TOP_TO_BOTTOM = 0,
    GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_BOTTOM_TO_TOP = 1,
    GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_TOP_TO_BOTTOM = 2,
    GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_BOTTOM_TO_TOP = 3,
    GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_LEFT_TO_RIGHT = 4,
    GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_RIGHT_TO_LEFT = 5,
    GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_LEFT_TO_RIGHT = 6,
    GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_RIGHT_TO_LEFT = 7
} ;
#line 530 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__539 GtkNumberUpLayout;
#line 532
enum __anonenum__540 {
    GTK_PAGE_ORIENTATION_PORTRAIT = 0,
    GTK_PAGE_ORIENTATION_LANDSCAPE = 1,
    GTK_PAGE_ORIENTATION_REVERSE_PORTRAIT = 2,
    GTK_PAGE_ORIENTATION_REVERSE_LANDSCAPE = 3
} ;
#line 538 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__540 GtkPageOrientation;
#line 540
enum __anonenum__541 {
    GTK_PRINT_QUALITY_LOW = 0,
    GTK_PRINT_QUALITY_NORMAL = 1,
    GTK_PRINT_QUALITY_HIGH = 2,
    GTK_PRINT_QUALITY_DRAFT = 3
} ;
#line 546 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__541 GtkPrintQuality;
#line 548
enum __anonenum__542 {
    GTK_PRINT_DUPLEX_SIMPLEX = 0,
    GTK_PRINT_DUPLEX_HORIZONTAL = 1,
    GTK_PRINT_DUPLEX_VERTICAL = 2
} ;
#line 553 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__542 GtkPrintDuplex;
#line 556
enum __anonenum__543 {
    GTK_UNIT_PIXEL = 0,
    GTK_UNIT_POINTS = 1,
    GTK_UNIT_INCH = 2,
    GTK_UNIT_MM = 3
} ;
#line 562 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__543 GtkUnit;
#line 564
enum __anonenum__544 {
    GTK_TREE_VIEW_GRID_LINES_NONE = 0,
    GTK_TREE_VIEW_GRID_LINES_HORIZONTAL = 1,
    GTK_TREE_VIEW_GRID_LINES_VERTICAL = 2,
    GTK_TREE_VIEW_GRID_LINES_BOTH = 3
} ;
#line 570 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__544 GtkTreeViewGridLines;
#line 572
enum __anonenum__545 {
    GTK_DRAG_RESULT_SUCCESS = 0,
    GTK_DRAG_RESULT_NO_TARGET = 1,
    GTK_DRAG_RESULT_USER_CANCELLED = 2,
    GTK_DRAG_RESULT_TIMEOUT_EXPIRED = 3,
    GTK_DRAG_RESULT_GRAB_BROKEN = 4,
    GTK_DRAG_RESULT_ERROR = 5
} ;
#line 580 "/usr/include/gtk-2.0/gtk/gtkenums.h"
typedef enum __anonenum__545 GtkDragResult;
#line 51 "/usr/include/gtk-2.0/gtk/gtkaccelgroup.h"
enum __anonenum__546 {
    GTK_ACCEL_VISIBLE = 1,
    GTK_ACCEL_LOCKED = 2,
    GTK_ACCEL_MASK = 7
} ;
#line 56 "/usr/include/gtk-2.0/gtk/gtkaccelgroup.h"
typedef enum __anonenum__546 GtkAccelFlags;
#line 60
struct _GtkAccelGroup ;
#line 60 "/usr/include/gtk-2.0/gtk/gtkaccelgroup.h"
typedef struct _GtkAccelGroup GtkAccelGroup;
#line 61
struct _GtkAccelGroupClass ;
#line 61 "/usr/include/gtk-2.0/gtk/gtkaccelgroup.h"
typedef struct _GtkAccelGroupClass GtkAccelGroupClass;
#line 62
struct _GtkAccelKey ;
#line 62 "/usr/include/gtk-2.0/gtk/gtkaccelgroup.h"
typedef struct _GtkAccelKey GtkAccelKey;
#line 63
struct _GtkAccelGroupEntry ;
#line 63 "/usr/include/gtk-2.0/gtk/gtkaccelgroup.h"
typedef struct _GtkAccelGroupEntry GtkAccelGroupEntry;
#line 64 "/usr/include/gtk-2.0/gtk/gtkaccelgroup.h"
typedef gboolean (*GtkAccelGroupActivate)(GtkAccelGroup * , GObject * , guint  , GdkModifierType  );
#line 77 "/usr/include/gtk-2.0/gtk/gtkaccelgroup.h"
typedef gboolean (*GtkAccelGroupFindFunc)(GtkAccelKey * , GClosure * , gpointer  );
#line 86 "/usr/include/gtk-2.0/gtk/gtkaccelgroup.h"
struct _GtkAccelGroup {
   GObject parent ;
   guint lock_count ;
   GdkModifierType modifier_mask ;
   GSList *acceleratables ;
   guint n_accels ;
   GtkAccelGroupEntry *priv_accels ;
};
#line 97 "/usr/include/gtk-2.0/gtk/gtkaccelgroup.h"
struct _GtkAccelGroupClass {
   GObjectClass parent_class ;
   void (*accel_changed)(GtkAccelGroup * , guint  , GdkModifierType  , GClosure * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 113 "/usr/include/gtk-2.0/gtk/gtkaccelgroup.h"
struct _GtkAccelKey {
   guint accel_key ;
   GdkModifierType accel_mods ;
   guint accel_flags ;
};
#line 187 "/usr/include/gtk-2.0/gtk/gtkaccelgroup.h"
struct _GtkAccelGroupEntry {
   GtkAccelKey key ;
   GClosure *closure ;
   GQuark accel_path_quark ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtktypeutils.h"
struct _GtkArg ;
#line 48 "/usr/include/gtk-2.0/gtk/gtktypeutils.h"
typedef struct _GtkArg GtkArg;
#line 49
struct _GtkObject ;
#line 49 "/usr/include/gtk-2.0/gtk/gtktypeutils.h"
typedef struct _GtkObject GtkObject;
#line 51 "/usr/include/gtk-2.0/gtk/gtktypeutils.h"
typedef gboolean (*GtkFunction)(gpointer  );
#line 52 "/usr/include/gtk-2.0/gtk/gtktypeutils.h"
typedef void (*GtkCallbackMarshal)(GtkObject * , gpointer  , guint  , GtkArg * );
#line 61 "/usr/include/gtk-2.0/gtk/gtktypeutils.h"
typedef gchar *(*GtkTranslateFunc)(gchar * , gpointer  );
#line 94 "/usr/include/gtk-2.0/gtk/gtktypeutils.h"
typedef GType GtkFundamentalType;
#line 119 "/usr/include/gtk-2.0/gtk/gtktypeutils.h"
typedef GType GtkType;
#line 120 "/usr/include/gtk-2.0/gtk/gtktypeutils.h"
typedef GTypeInstance GtkTypeObject;
#line 121 "/usr/include/gtk-2.0/gtk/gtktypeutils.h"
typedef GTypeClass GtkTypeClass;
#line 122 "/usr/include/gtk-2.0/gtk/gtktypeutils.h"
typedef GBaseInitFunc GtkClassInitFunc;
#line 123 "/usr/include/gtk-2.0/gtk/gtktypeutils.h"
typedef GInstanceInitFunc GtkObjectInitFunc;
#line 124 "/usr/include/gtk-2.0/gtk/gtktypeutils.h"
typedef GSignalCMarshaller GtkSignalMarshaller;
#line 126 "/usr/include/gtk-2.0/gtk/gtktypeutils.h"
typedef void (*GtkDestroyNotify)(gpointer  );
#line 127 "/usr/include/gtk-2.0/gtk/gtktypeutils.h"
typedef void (*GtkSignalFunc)(void);
#line 165 "/usr/include/gtk-2.0/gtk/gtktypeutils.h"
struct __anonstruct_548 {
   GCallback f ;
   gpointer d ;
};
#line 149 "/usr/include/gtk-2.0/gtk/gtktypeutils.h"
union __anonunion_547 {
   gchar char_data ;
   guchar uchar_data ;
   gboolean bool_data ;
   gint int_data ;
   guint uint_data ;
   glong long_data ;
   gulong ulong_data ;
   gfloat float_data ;
   gdouble double_data ;
   gchar *string_data ;
   GtkObject *object_data ;
   gpointer pointer_data ;
   struct __anonstruct_548 signal_data ;
};
#line 138 "/usr/include/gtk-2.0/gtk/gtktypeutils.h"
struct _GtkArg {
   GType type ;
   gchar *name ;
   union __anonunion_547 d ;
};
#line 222
struct _GtkTypeInfo ;
#line 222 "/usr/include/gtk-2.0/gtk/gtktypeutils.h"
typedef struct _GtkTypeInfo GtkTypeInfo;
#line 224 "/usr/include/gtk-2.0/gtk/gtktypeutils.h"
struct _GtkTypeInfo {
   gchar *type_name ;
   guint object_size ;
   guint class_size ;
   GtkClassInitFunc class_init_func ;
   GtkObjectInitFunc object_init_func ;
   gpointer reserved_1 ;
   gpointer reserved_2 ;
   GtkClassInitFunc base_class_init_func ;
};
#line 251 "/usr/include/gtk-2.0/gtk/gtktypeutils.h"
typedef GEnumValue GtkEnumValue;
#line 252 "/usr/include/gtk-2.0/gtk/gtktypeutils.h"
typedef GFlagsValue GtkFlagValue;
#line 38 "/usr/include/gtk-2.0/gtk/gtkdebug.h"
enum __anonenum__549 {
    GTK_DEBUG_MISC = 1,
    GTK_DEBUG_PLUGSOCKET = 2,
    GTK_DEBUG_TEXT = 4,
    GTK_DEBUG_TREE = 8,
    GTK_DEBUG_UPDATES = 16,
    GTK_DEBUG_KEYBINDINGS = 32,
    GTK_DEBUG_MULTIHEAD = 64,
    GTK_DEBUG_MODULES = 128,
    GTK_DEBUG_GEOMETRY = 256,
    GTK_DEBUG_ICONTHEME = 512,
    GTK_DEBUG_PRINTING = 1024,
    GTK_DEBUG_BUILDER = 2048
} ;
#line 51 "/usr/include/gtk-2.0/gtk/gtkdebug.h"
typedef enum __anonenum__549 GtkDebugFlag;
#line 83 "/usr/include/gtk-2.0/gtk/gtkobject.h"
enum __anonenum__550 {
    GTK_IN_DESTRUCTION = 1,
    GTK_FLOATING = 2,
    GTK_RESERVED_1 = 4,
    GTK_RESERVED_2 = 8
} ;
#line 89 "/usr/include/gtk-2.0/gtk/gtkobject.h"
typedef enum __anonenum__550 GtkObjectFlags;
#line 104
struct _GtkObjectClass ;
#line 104 "/usr/include/gtk-2.0/gtk/gtkobject.h"
typedef struct _GtkObjectClass GtkObjectClass;
#line 107 "/usr/include/gtk-2.0/gtk/gtkobject.h"
struct _GtkObject {
   GInitiallyUnowned parent_instance ;
   guint32 flags ;
};
#line 119 "/usr/include/gtk-2.0/gtk/gtkobject.h"
struct _GtkObjectClass {
   GInitiallyUnownedClass parent_class ;
   void (*set_arg)(GtkObject * , GtkArg * , guint  ) ;
   void (*get_arg)(GtkObject * , GtkArg * , guint  ) ;
   void (*destroy)(GtkObject * ) ;
};
#line 226
enum __anonenum__551 {
    GTK_ARG_READABLE = 1,
    GTK_ARG_WRITABLE = 2,
    GTK_ARG_CONSTRUCT = 4,
    GTK_ARG_CONSTRUCT_ONLY = 8,
    GTK_ARG_CHILD_ARG = 16
} ;
#line 233 "/usr/include/gtk-2.0/gtk/gtkobject.h"
typedef enum __anonenum__551 GtkArgFlags;
#line 48 "/usr/include/gtk-2.0/gtk/gtkadjustment.h"
struct _GtkAdjustment ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkadjustment.h"
typedef struct _GtkAdjustment GtkAdjustment;
#line 49
struct _GtkAdjustmentClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkadjustment.h"
typedef struct _GtkAdjustmentClass GtkAdjustmentClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkadjustment.h"
struct _GtkAdjustment {
   GtkObject parent_instance ;
   gdouble lower ;
   gdouble upper ;
   gdouble value ;
   gdouble step_increment ;
   gdouble page_increment ;
   gdouble page_size ;
};
#line 63 "/usr/include/gtk-2.0/gtk/gtkadjustment.h"
struct _GtkAdjustmentClass {
   GtkObjectClass parent_class ;
   void (*changed)(GtkAdjustment * ) ;
   void (*value_changed)(GtkAdjustment * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 53 "/usr/include/gtk-2.0/gtk/gtkstyle.h"
struct _GtkBorder ;
#line 53 "/usr/include/gtk-2.0/gtk/gtkstyle.h"
typedef struct _GtkBorder GtkBorder;
#line 54
struct _GtkStyle ;
#line 54 "/usr/include/gtk-2.0/gtk/gtkstyle.h"
typedef struct _GtkStyle GtkStyle;
#line 55
struct _GtkStyleClass ;
#line 55 "/usr/include/gtk-2.0/gtk/gtkstyle.h"
typedef struct _GtkStyleClass GtkStyleClass;
#line 56
struct _GtkThemeEngine ;
#line 56 "/usr/include/gtk-2.0/gtk/gtkstyle.h"
typedef struct _GtkThemeEngine GtkThemeEngine;
#line 57
struct _GtkRcStyle ;
#line 57 "/usr/include/gtk-2.0/gtk/gtkstyle.h"
typedef struct _GtkRcStyle GtkRcStyle;
#line 58
struct _GtkIconSet ;
#line 58 "/usr/include/gtk-2.0/gtk/gtkstyle.h"
typedef struct _GtkIconSet GtkIconSet;
#line 59
struct _GtkIconSource ;
#line 59 "/usr/include/gtk-2.0/gtk/gtkstyle.h"
typedef struct _GtkIconSource GtkIconSource;
#line 60
struct _GtkRcProperty ;
#line 60 "/usr/include/gtk-2.0/gtk/gtkstyle.h"
typedef struct _GtkRcProperty GtkRcProperty;
#line 61
struct _GtkSettings ;
#line 61 "/usr/include/gtk-2.0/gtk/gtkstyle.h"
typedef struct _GtkSettings GtkSettings;
#line 62 "/usr/include/gtk-2.0/gtk/gtkstyle.h"
typedef gboolean (*GtkRcPropertyParser)(GParamSpec * , GString * , GValue * );
#line 69
struct _GtkWidget ;
#line 69 "/usr/include/gtk-2.0/gtk/gtkstyle.h"
typedef struct _GtkWidget GtkWidget;
#line 73 "/usr/include/gtk-2.0/gtk/gtkstyle.h"
struct _GtkStyle {
   GObject parent_instance ;
   GdkColor fg[5] ;
   GdkColor bg[5] ;
   GdkColor light[5] ;
   GdkColor dark[5] ;
   GdkColor mid[5] ;
   GdkColor text[5] ;
   GdkColor base[5] ;
   GdkColor text_aa[5] ;
   GdkColor black ;
   GdkColor white ;
   PangoFontDescription *font_desc ;
   gint xthickness ;
   gint ythickness ;
   GdkGC *fg_gc[5] ;
   GdkGC *bg_gc[5] ;
   GdkGC *light_gc[5] ;
   GdkGC *dark_gc[5] ;
   GdkGC *mid_gc[5] ;
   GdkGC *text_gc[5] ;
   GdkGC *base_gc[5] ;
   GdkGC *text_aa_gc[5] ;
   GdkGC *black_gc ;
   GdkGC *white_gc ;
   GdkPixmap *bg_pixmap[5] ;
   gint attach_count ;
   gint depth ;
   GdkColormap *colormap ;
   GdkFont *private_font ;
   PangoFontDescription *private_font_desc ;
   GtkRcStyle *rc_style ;
   GSList *styles ;
   GArray *property_cache ;
   GSList *icon_factories ;
};
#line 125 "/usr/include/gtk-2.0/gtk/gtkstyle.h"
struct _GtkStyleClass {
   GObjectClass parent_class ;
   void (*realize)(GtkStyle * ) ;
   void (*unrealize)(GtkStyle * ) ;
   void (*copy)(GtkStyle * , GtkStyle * ) ;
   GtkStyle *(*clone)(GtkStyle * ) ;
   void (*init_from_rc)(GtkStyle * , GtkRcStyle * ) ;
   void (*set_background)(GtkStyle * , GdkWindow * , GtkStateType  ) ;
   GdkPixbuf *(*render_icon)(GtkStyle * , GtkIconSource * , GtkTextDirection  , GtkStateType  ,
                             GtkIconSize  , GtkWidget * , gchar * ) ;
   void (*draw_hline)(GtkStyle * , GdkWindow * , GtkStateType  , GdkRectangle * ,
                      GtkWidget * , gchar * , gint  , gint  , gint  ) ;
   void (*draw_vline)(GtkStyle * , GdkWindow * , GtkStateType  , GdkRectangle * ,
                      GtkWidget * , gchar * , gint  , gint  , gint  ) ;
   void (*draw_shadow)(GtkStyle * , GdkWindow * , GtkStateType  , GtkShadowType  ,
                       GdkRectangle * , GtkWidget * , gchar * , gint  , gint  , gint  ,
                       gint  ) ;
   void (*draw_polygon)(GtkStyle * , GdkWindow * , GtkStateType  , GtkShadowType  ,
                        GdkRectangle * , GtkWidget * , gchar * , GdkPoint * , gint  ,
                        gboolean  ) ;
   void (*draw_arrow)(GtkStyle * , GdkWindow * , GtkStateType  , GtkShadowType  ,
                      GdkRectangle * , GtkWidget * , gchar * , GtkArrowType  , gboolean  ,
                      gint  , gint  , gint  , gint  ) ;
   void (*draw_diamond)(GtkStyle * , GdkWindow * , GtkStateType  , GtkShadowType  ,
                        GdkRectangle * , GtkWidget * , gchar * , gint  , gint  , gint  ,
                        gint  ) ;
   void (*draw_string)(GtkStyle * , GdkWindow * , GtkStateType  , GdkRectangle * ,
                       GtkWidget * , gchar * , gint  , gint  , gchar * ) ;
   void (*draw_box)(GtkStyle * , GdkWindow * , GtkStateType  , GtkShadowType  , GdkRectangle * ,
                    GtkWidget * , gchar * , gint  , gint  , gint  , gint  ) ;
   void (*draw_flat_box)(GtkStyle * , GdkWindow * , GtkStateType  , GtkShadowType  ,
                         GdkRectangle * , GtkWidget * , gchar * , gint  , gint  ,
                         gint  , gint  ) ;
   void (*draw_check)(GtkStyle * , GdkWindow * , GtkStateType  , GtkShadowType  ,
                      GdkRectangle * , GtkWidget * , gchar * , gint  , gint  , gint  ,
                      gint  ) ;
   void (*draw_option)(GtkStyle * , GdkWindow * , GtkStateType  , GtkShadowType  ,
                       GdkRectangle * , GtkWidget * , gchar * , gint  , gint  , gint  ,
                       gint  ) ;
   void (*draw_tab)(GtkStyle * , GdkWindow * , GtkStateType  , GtkShadowType  , GdkRectangle * ,
                    GtkWidget * , gchar * , gint  , gint  , gint  , gint  ) ;
   void (*draw_shadow_gap)(GtkStyle * , GdkWindow * , GtkStateType  , GtkShadowType  ,
                           GdkRectangle * , GtkWidget * , gchar * , gint  , gint  ,
                           gint  , gint  , GtkPositionType  , gint  , gint  ) ;
   void (*draw_box_gap)(GtkStyle * , GdkWindow * , GtkStateType  , GtkShadowType  ,
                        GdkRectangle * , GtkWidget * , gchar * , gint  , gint  , gint  ,
                        gint  , GtkPositionType  , gint  , gint  ) ;
   void (*draw_extension)(GtkStyle * , GdkWindow * , GtkStateType  , GtkShadowType  ,
                          GdkRectangle * , GtkWidget * , gchar * , gint  , gint  ,
                          gint  , gint  , GtkPositionType  ) ;
   void (*draw_focus)(GtkStyle * , GdkWindow * , GtkStateType  , GdkRectangle * ,
                      GtkWidget * , gchar * , gint  , gint  , gint  , gint  ) ;
   void (*draw_slider)(GtkStyle * , GdkWindow * , GtkStateType  , GtkShadowType  ,
                       GdkRectangle * , GtkWidget * , gchar * , gint  , gint  , gint  ,
                       gint  , GtkOrientation  ) ;
   void (*draw_handle)(GtkStyle * , GdkWindow * , GtkStateType  , GtkShadowType  ,
                       GdkRectangle * , GtkWidget * , gchar * , gint  , gint  , gint  ,
                       gint  , GtkOrientation  ) ;
   void (*draw_expander)(GtkStyle * , GdkWindow * , GtkStateType  , GdkRectangle * ,
                         GtkWidget * , gchar * , gint  , gint  , GtkExpanderStyle  ) ;
   void (*draw_layout)(GtkStyle * , GdkWindow * , GtkStateType  , gboolean  , GdkRectangle * ,
                       GtkWidget * , gchar * , gint  , gint  , PangoLayout * ) ;
   void (*draw_resize_grip)(GtkStyle * , GdkWindow * , GtkStateType  , GdkRectangle * ,
                            GtkWidget * , gchar * , GdkWindowEdge  , gint  , gint  ,
                            gint  , gint  ) ;
   void (*draw_spinner)(GtkStyle * , GdkWindow * , GtkStateType  , GdkRectangle * ,
                        GtkWidget * , gchar * , guint  , gint  , gint  , gint  , gint  ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
   void (*_gtk_reserved5)(void) ;
   void (*_gtk_reserved6)(void) ;
   void (*_gtk_reserved7)(void) ;
   void (*_gtk_reserved8)(void) ;
   void (*_gtk_reserved9)(void) ;
   void (*_gtk_reserved10)(void) ;
   void (*_gtk_reserved11)(void) ;
};
#line 432 "/usr/include/gtk-2.0/gtk/gtkstyle.h"
struct _GtkBorder {
   gint left ;
   gint right ;
   gint top ;
   gint bottom ;
};
#line 40 "/usr/include/gtk-2.0/gtk/gtkrc.h"
struct _GtkIconFactory ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkrc.h"
typedef struct _GtkIconFactory GtkIconFactory;
#line 41
struct _GtkRcContext ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkrc.h"
typedef struct _GtkRcContext GtkRcContext;
#line 43
struct _GtkRcStyleClass ;
#line 43 "/usr/include/gtk-2.0/gtk/gtkrc.h"
typedef struct _GtkRcStyleClass GtkRcStyleClass;
#line 52
enum __anonenum__552 {
    GTK_RC_FG = 1,
    GTK_RC_BG = 2,
    GTK_RC_TEXT = 4,
    GTK_RC_BASE = 8
} ;
#line 58 "/usr/include/gtk-2.0/gtk/gtkrc.h"
typedef enum __anonenum__552 GtkRcFlags;
#line 60 "/usr/include/gtk-2.0/gtk/gtkrc.h"
struct _GtkRcStyle {
   GObject parent_instance ;
   gchar *name ;
   gchar *bg_pixmap_name[5] ;
   PangoFontDescription *font_desc ;
   GtkRcFlags color_flags[5] ;
   GdkColor fg[5] ;
   GdkColor bg[5] ;
   GdkColor text[5] ;
   GdkColor base[5] ;
   gint xthickness ;
   gint ythickness ;
   GArray *rc_properties ;
   GSList *rc_style_lists ;
   GSList *icon_factories ;
   guint engine_specified ;
};
#line 90 "/usr/include/gtk-2.0/gtk/gtkrc.h"
struct _GtkRcStyleClass {
   GObjectClass parent_class ;
   GtkRcStyle *(*create_rc_style)(GtkRcStyle * ) ;
   guint (*parse)(GtkRcStyle * , GtkSettings * , GScanner * ) ;
   void (*merge)(GtkRcStyle * , GtkRcStyle * ) ;
   GtkStyle *(*create_style)(GtkRcStyle * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 188
enum __anonenum__553 {
    GTK_RC_TOKEN_INVALID = 270,
    GTK_RC_TOKEN_INCLUDE = 271,
    GTK_RC_TOKEN_NORMAL = 272,
    GTK_RC_TOKEN_ACTIVE = 273,
    GTK_RC_TOKEN_PRELIGHT = 274,
    GTK_RC_TOKEN_SELECTED = 275,
    GTK_RC_TOKEN_INSENSITIVE = 276,
    GTK_RC_TOKEN_FG = 277,
    GTK_RC_TOKEN_BG = 278,
    GTK_RC_TOKEN_TEXT = 279,
    GTK_RC_TOKEN_BASE = 280,
    GTK_RC_TOKEN_XTHICKNESS = 281,
    GTK_RC_TOKEN_YTHICKNESS = 282,
    GTK_RC_TOKEN_FONT = 283,
    GTK_RC_TOKEN_FONTSET = 284,
    GTK_RC_TOKEN_FONT_NAME = 285,
    GTK_RC_TOKEN_BG_PIXMAP = 286,
    GTK_RC_TOKEN_PIXMAP_PATH = 287,
    GTK_RC_TOKEN_STYLE = 288,
    GTK_RC_TOKEN_BINDING = 289,
    GTK_RC_TOKEN_BIND = 290,
    GTK_RC_TOKEN_WIDGET = 291,
    GTK_RC_TOKEN_WIDGET_CLASS = 292,
    GTK_RC_TOKEN_CLASS = 293,
    GTK_RC_TOKEN_LOWEST = 294,
    GTK_RC_TOKEN_GTK = 295,
    GTK_RC_TOKEN_APPLICATION = 296,
    GTK_RC_TOKEN_THEME = 297,
    GTK_RC_TOKEN_RC = 298,
    GTK_RC_TOKEN_HIGHEST = 299,
    GTK_RC_TOKEN_ENGINE = 300,
    GTK_RC_TOKEN_MODULE_PATH = 301,
    GTK_RC_TOKEN_IM_MODULE_PATH = 302,
    GTK_RC_TOKEN_IM_MODULE_FILE = 303,
    GTK_RC_TOKEN_STOCK = 304,
    GTK_RC_TOKEN_LTR = 305,
    GTK_RC_TOKEN_RTL = 306,
    GTK_RC_TOKEN_COLOR = 307,
    GTK_RC_TOKEN_UNBIND = 308,
    GTK_RC_TOKEN_LAST = 309
} ;
#line 229 "/usr/include/gtk-2.0/gtk/gtkrc.h"
typedef enum __anonenum__553 GtkRcTokenType;
#line 245 "/usr/include/gtk-2.0/gtk/gtkrc.h"
struct _GtkRcProperty {
   GQuark type_name ;
   GQuark property_name ;
   gchar *origin ;
   GValue value ;
};
#line 41 "/usr/include/gtk-2.0/gtk/gtksettings.h"
struct _GtkSettingsClass ;
#line 41 "/usr/include/gtk-2.0/gtk/gtksettings.h"
typedef struct _GtkSettingsClass GtkSettingsClass;
#line 42
struct _GtkSettingsValue ;
#line 42 "/usr/include/gtk-2.0/gtk/gtksettings.h"
typedef struct _GtkSettingsValue GtkSettingsValue;
#line 43
struct _GtkSettingsPropertyValue ;
#line 43 "/usr/include/gtk-2.0/gtk/gtksettings.h"
typedef struct _GtkSettingsPropertyValue GtkSettingsPropertyValue;
#line 47 "/usr/include/gtk-2.0/gtk/gtksettings.h"
struct _GtkSettings {
   GObject parent_instance ;
   GData *queued_settings ;
   GtkSettingsPropertyValue *property_values ;
   GtkRcContext *rc_context ;
   GdkScreen *screen ;
};
#line 58 "/usr/include/gtk-2.0/gtk/gtksettings.h"
struct _GtkSettingsClass {
   GObjectClass parent_class ;
};
#line 63 "/usr/include/gtk-2.0/gtk/gtksettings.h"
struct _GtkSettingsValue {
   gchar *origin ;
   GValue value ;
};
#line 148 "/usr/include/atk-1.0/atk/atkstate.h"
enum __anonenum__554 {
    ATK_STATE_INVALID = 0,
    ATK_STATE_ACTIVE = 1,
    ATK_STATE_ARMED = 2,
    ATK_STATE_BUSY = 3,
    ATK_STATE_CHECKED = 4,
    ATK_STATE_DEFUNCT = 5,
    ATK_STATE_EDITABLE = 6,
    ATK_STATE_ENABLED = 7,
    ATK_STATE_EXPANDABLE = 8,
    ATK_STATE_EXPANDED = 9,
    ATK_STATE_FOCUSABLE = 10,
    ATK_STATE_FOCUSED = 11,
    ATK_STATE_HORIZONTAL = 12,
    ATK_STATE_ICONIFIED = 13,
    ATK_STATE_MODAL = 14,
    ATK_STATE_MULTI_LINE = 15,
    ATK_STATE_MULTISELECTABLE = 16,
    ATK_STATE_OPAQUE = 17,
    ATK_STATE_PRESSED = 18,
    ATK_STATE_RESIZABLE = 19,
    ATK_STATE_SELECTABLE = 20,
    ATK_STATE_SELECTED = 21,
    ATK_STATE_SENSITIVE = 22,
    ATK_STATE_SHOWING = 23,
    ATK_STATE_SINGLE_LINE = 24,
    ATK_STATE_STALE = 25,
    ATK_STATE_TRANSIENT = 26,
    ATK_STATE_VERTICAL = 27,
    ATK_STATE_VISIBLE = 28,
    ATK_STATE_MANAGES_DESCENDANTS = 29,
    ATK_STATE_INDETERMINATE = 30,
    ATK_STATE_TRUNCATED = 31,
    ATK_STATE_REQUIRED = 32,
    ATK_STATE_INVALID_ENTRY = 33,
    ATK_STATE_SUPPORTS_AUTOCOMPLETION = 34,
    ATK_STATE_SELECTABLE_TEXT = 35,
    ATK_STATE_DEFAULT = 36,
    ATK_STATE_ANIMATED = 37,
    ATK_STATE_VISITED = 38,
    ATK_STATE_CHECKABLE = 39,
    ATK_STATE_HAS_POPUP = 40,
    ATK_STATE_HAS_TOOLTIP = 41,
    ATK_STATE_READ_ONLY = 42,
    ATK_STATE_LAST_DEFINED = 43
} ;
#line 194 "/usr/include/atk-1.0/atk/atkstate.h"
typedef enum __anonenum__554 AtkStateType;
#line 196 "/usr/include/atk-1.0/atk/atkstate.h"
typedef guint64 AtkState;
#line 87 "/usr/include/atk-1.0/atk/atkrelationtype.h"
enum __anonenum__555 {
    ATK_RELATION_NULL = 0,
    ATK_RELATION_CONTROLLED_BY = 1,
    ATK_RELATION_CONTROLLER_FOR = 2,
    ATK_RELATION_LABEL_FOR = 3,
    ATK_RELATION_LABELLED_BY = 4,
    ATK_RELATION_MEMBER_OF = 5,
    ATK_RELATION_NODE_CHILD_OF = 6,
    ATK_RELATION_FLOWS_TO = 7,
    ATK_RELATION_FLOWS_FROM = 8,
    ATK_RELATION_SUBWINDOW_OF = 9,
    ATK_RELATION_EMBEDS = 10,
    ATK_RELATION_EMBEDDED_BY = 11,
    ATK_RELATION_POPUP_FOR = 12,
    ATK_RELATION_PARENT_WINDOW_OF = 13,
    ATK_RELATION_DESCRIBED_BY = 14,
    ATK_RELATION_DESCRIPTION_FOR = 15,
    ATK_RELATION_NODE_PARENT_OF = 16,
    ATK_RELATION_DETAILS = 17,
    ATK_RELATION_DETAILS_FOR = 18,
    ATK_RELATION_ERROR_MESSAGE = 19,
    ATK_RELATION_ERROR_FOR = 20,
    ATK_RELATION_LAST_DEFINED = 21
} ;
#line 111 "/usr/include/atk-1.0/atk/atkrelationtype.h"
typedef enum __anonenum__555 AtkRelationType;
#line 246 "/usr/include/atk-1.0/atk/atkobject.h"
enum __anonenum__556 {
    ATK_ROLE_INVALID = 0,
    ATK_ROLE_ACCEL_LABEL = 1,
    ATK_ROLE_ALERT = 2,
    ATK_ROLE_ANIMATION = 3,
    ATK_ROLE_ARROW = 4,
    ATK_ROLE_CALENDAR = 5,
    ATK_ROLE_CANVAS = 6,
    ATK_ROLE_CHECK_BOX = 7,
    ATK_ROLE_CHECK_MENU_ITEM = 8,
    ATK_ROLE_COLOR_CHOOSER = 9,
    ATK_ROLE_COLUMN_HEADER = 10,
    ATK_ROLE_COMBO_BOX = 11,
    ATK_ROLE_DATE_EDITOR = 12,
    ATK_ROLE_DESKTOP_ICON = 13,
    ATK_ROLE_DESKTOP_FRAME = 14,
    ATK_ROLE_DIAL = 15,
    ATK_ROLE_DIALOG = 16,
    ATK_ROLE_DIRECTORY_PANE = 17,
    ATK_ROLE_DRAWING_AREA = 18,
    ATK_ROLE_FILE_CHOOSER = 19,
    ATK_ROLE_FILLER = 20,
    ATK_ROLE_FONT_CHOOSER = 21,
    ATK_ROLE_FRAME = 22,
    ATK_ROLE_GLASS_PANE = 23,
    ATK_ROLE_HTML_CONTAINER = 24,
    ATK_ROLE_ICON = 25,
    ATK_ROLE_IMAGE = 26,
    ATK_ROLE_INTERNAL_FRAME = 27,
    ATK_ROLE_LABEL = 28,
    ATK_ROLE_LAYERED_PANE = 29,
    ATK_ROLE_LIST = 30,
    ATK_ROLE_LIST_ITEM = 31,
    ATK_ROLE_MENU = 32,
    ATK_ROLE_MENU_BAR = 33,
    ATK_ROLE_MENU_ITEM = 34,
    ATK_ROLE_OPTION_PANE = 35,
    ATK_ROLE_PAGE_TAB = 36,
    ATK_ROLE_PAGE_TAB_LIST = 37,
    ATK_ROLE_PANEL = 38,
    ATK_ROLE_PASSWORD_TEXT = 39,
    ATK_ROLE_POPUP_MENU = 40,
    ATK_ROLE_PROGRESS_BAR = 41,
    ATK_ROLE_PUSH_BUTTON = 42,
    ATK_ROLE_RADIO_BUTTON = 43,
    ATK_ROLE_RADIO_MENU_ITEM = 44,
    ATK_ROLE_ROOT_PANE = 45,
    ATK_ROLE_ROW_HEADER = 46,
    ATK_ROLE_SCROLL_BAR = 47,
    ATK_ROLE_SCROLL_PANE = 48,
    ATK_ROLE_SEPARATOR = 49,
    ATK_ROLE_SLIDER = 50,
    ATK_ROLE_SPLIT_PANE = 51,
    ATK_ROLE_SPIN_BUTTON = 52,
    ATK_ROLE_STATUSBAR = 53,
    ATK_ROLE_TABLE = 54,
    ATK_ROLE_TABLE_CELL = 55,
    ATK_ROLE_TABLE_COLUMN_HEADER = 56,
    ATK_ROLE_TABLE_ROW_HEADER = 57,
    ATK_ROLE_TEAR_OFF_MENU_ITEM = 58,
    ATK_ROLE_TERMINAL = 59,
    ATK_ROLE_TEXT = 60,
    ATK_ROLE_TOGGLE_BUTTON = 61,
    ATK_ROLE_TOOL_BAR = 62,
    ATK_ROLE_TOOL_TIP = 63,
    ATK_ROLE_TREE = 64,
    ATK_ROLE_TREE_TABLE = 65,
    ATK_ROLE_UNKNOWN = 66,
    ATK_ROLE_VIEWPORT = 67,
    ATK_ROLE_WINDOW = 68,
    ATK_ROLE_HEADER = 69,
    ATK_ROLE_FOOTER = 70,
    ATK_ROLE_PARAGRAPH = 71,
    ATK_ROLE_RULER = 72,
    ATK_ROLE_APPLICATION = 73,
    ATK_ROLE_AUTOCOMPLETE = 74,
    ATK_ROLE_EDITBAR = 75,
    ATK_ROLE_EMBEDDED = 76,
    ATK_ROLE_ENTRY = 77,
    ATK_ROLE_CHART = 78,
    ATK_ROLE_CAPTION = 79,
    ATK_ROLE_DOCUMENT_FRAME = 80,
    ATK_ROLE_HEADING = 81,
    ATK_ROLE_PAGE = 82,
    ATK_ROLE_SECTION = 83,
    ATK_ROLE_REDUNDANT_OBJECT = 84,
    ATK_ROLE_FORM = 85,
    ATK_ROLE_LINK = 86,
    ATK_ROLE_INPUT_METHOD_WINDOW = 87,
    ATK_ROLE_TABLE_ROW = 88,
    ATK_ROLE_TREE_ITEM = 89,
    ATK_ROLE_DOCUMENT_SPREADSHEET = 90,
    ATK_ROLE_DOCUMENT_PRESENTATION = 91,
    ATK_ROLE_DOCUMENT_TEXT = 92,
    ATK_ROLE_DOCUMENT_WEB = 93,
    ATK_ROLE_DOCUMENT_EMAIL = 94,
    ATK_ROLE_COMMENT = 95,
    ATK_ROLE_LIST_BOX = 96,
    ATK_ROLE_GROUPING = 97,
    ATK_ROLE_IMAGE_MAP = 98,
    ATK_ROLE_NOTIFICATION = 99,
    ATK_ROLE_INFO_BAR = 100,
    ATK_ROLE_LEVEL_BAR = 101,
    ATK_ROLE_TITLE_BAR = 102,
    ATK_ROLE_BLOCK_QUOTE = 103,
    ATK_ROLE_AUDIO = 104,
    ATK_ROLE_VIDEO = 105,
    ATK_ROLE_DEFINITION = 106,
    ATK_ROLE_ARTICLE = 107,
    ATK_ROLE_LANDMARK = 108,
    ATK_ROLE_LOG = 109,
    ATK_ROLE_MARQUEE = 110,
    ATK_ROLE_MATH = 111,
    ATK_ROLE_RATING = 112,
    ATK_ROLE_TIMER = 113,
    ATK_ROLE_DESCRIPTION_LIST = 114,
    ATK_ROLE_DESCRIPTION_TERM = 115,
    ATK_ROLE_DESCRIPTION_VALUE = 116,
    ATK_ROLE_STATIC = 117,
    ATK_ROLE_MATH_FRACTION = 118,
    ATK_ROLE_MATH_ROOT = 119,
    ATK_ROLE_SUBSCRIPT = 120,
    ATK_ROLE_SUPERSCRIPT = 121,
    ATK_ROLE_FOOTNOTE = 122,
    ATK_ROLE_CONTENT_DELETION = 123,
    ATK_ROLE_CONTENT_INSERTION = 124,
    ATK_ROLE_MARK = 125,
    ATK_ROLE_SUGGESTION = 126,
    ATK_ROLE_LAST_DEFINED = 127
} ;
#line 376 "/usr/include/atk-1.0/atk/atkobject.h"
typedef enum __anonenum__556 AtkRole;
#line 395
enum __anonenum__557 {
    ATK_LAYER_INVALID = 0,
    ATK_LAYER_BACKGROUND = 1,
    ATK_LAYER_CANVAS = 2,
    ATK_LAYER_WIDGET = 3,
    ATK_LAYER_MDI = 4,
    ATK_LAYER_POPUP = 5,
    ATK_LAYER_OVERLAY = 6,
    ATK_LAYER_WINDOW = 7
} ;
#line 405 "/usr/include/atk-1.0/atk/atkobject.h"
typedef enum __anonenum__557 AtkLayer;
#line 416 "/usr/include/atk-1.0/atk/atkobject.h"
typedef GSList AtkAttributeSet;
#line 435
struct _AtkAttribute ;
#line 435 "/usr/include/atk-1.0/atk/atkobject.h"
typedef struct _AtkAttribute AtkAttribute;
#line 437 "/usr/include/atk-1.0/atk/atkobject.h"
struct _AtkAttribute {
   gchar *name ;
   gchar *value ;
};
#line 455
struct _AtkImplementor ;
#line 455 "/usr/include/atk-1.0/atk/atkobject.h"
typedef struct _AtkImplementor AtkImplementor;
#line 456
struct _AtkImplementorIface ;
#line 456 "/usr/include/atk-1.0/atk/atkobject.h"
typedef struct _AtkImplementorIface AtkImplementorIface;
#line 459
struct _AtkObject ;
#line 459 "/usr/include/atk-1.0/atk/atkobject.h"
typedef struct _AtkObject AtkObject;
#line 460
struct _AtkObjectClass ;
#line 460 "/usr/include/atk-1.0/atk/atkobject.h"
typedef struct _AtkObjectClass AtkObjectClass;
#line 461
struct _AtkRelationSet ;
#line 461 "/usr/include/atk-1.0/atk/atkobject.h"
typedef struct _AtkRelationSet AtkRelationSet;
#line 462
struct _AtkStateSet ;
#line 462 "/usr/include/atk-1.0/atk/atkobject.h"
typedef struct _AtkStateSet AtkStateSet;
#line 475 "/usr/include/atk-1.0/atk/atkobject.h"
struct _AtkPropertyValues {
   gchar *property_name ;
   GValue old_value ;
   GValue new_value ;
};
#line 482 "/usr/include/atk-1.0/atk/atkobject.h"
typedef struct _AtkPropertyValues AtkPropertyValues;
#line 494 "/usr/include/atk-1.0/atk/atkobject.h"
typedef gboolean (*AtkFunction)(gpointer  );
#line 519 "/usr/include/atk-1.0/atk/atkobject.h"
typedef void (*AtkPropertyChangeHandler)(AtkObject * , AtkPropertyValues * );
#line 522 "/usr/include/atk-1.0/atk/atkobject.h"
struct _AtkObject {
   GObject parent ;
   gchar *description ;
   gchar *name ;
   AtkObject *accessible_parent ;
   AtkRole role ;
   AtkRelationSet *relation_set ;
   AtkLayer layer ;
};
#line 549 "/usr/include/atk-1.0/atk/atkobject.h"
struct _AtkObjectClass {
   GObjectClass parent ;
   gchar *(*get_name)(AtkObject * ) ;
   gchar *(*get_description)(AtkObject * ) ;
   AtkObject *(*get_parent)(AtkObject * ) ;
   gint (*get_n_children)(AtkObject * ) ;
   AtkObject *(*ref_child)(AtkObject * , gint  ) ;
   gint (*get_index_in_parent)(AtkObject * ) ;
   AtkRelationSet *(*ref_relation_set)(AtkObject * ) ;
   AtkRole (*get_role)(AtkObject * ) ;
   AtkLayer (*get_layer)(AtkObject * ) ;
   gint (*get_mdi_zorder)(AtkObject * ) ;
   AtkStateSet *(*ref_state_set)(AtkObject * ) ;
   void (*set_name)(AtkObject * , gchar * ) ;
   void (*set_description)(AtkObject * , gchar * ) ;
   void (*set_parent)(AtkObject * , AtkObject * ) ;
   void (*set_role)(AtkObject * , AtkRole  ) ;
   guint (*connect_property_change_handler)(AtkObject * , AtkPropertyChangeHandler * ) ;
   void (*remove_property_change_handler)(AtkObject * , guint  ) ;
   void (*initialize)(AtkObject * , gpointer  ) ;
   void (*children_changed)(AtkObject * , guint  , gpointer  ) ;
   void (*focus_event)(AtkObject * , gboolean  ) ;
   void (*property_change)(AtkObject * , AtkPropertyValues * ) ;
   void (*state_change)(AtkObject * , gchar * , gboolean  ) ;
   void (*visible_data_changed)(AtkObject * ) ;
   void (*active_descendant_changed)(AtkObject * , gpointer * ) ;
   AtkAttributeSet *(*get_attributes)(AtkObject * ) ;
   gchar *(*get_object_locale)(AtkObject * ) ;
   AtkFunction pad1 ;
};
#line 694 "/usr/include/atk-1.0/atk/atkobject.h"
struct _AtkImplementorIface {
   GTypeInterface parent ;
   AtkObject *(*ref_accessible)(AtkImplementor * ) ;
};
#line 42 "/usr/include/atk-1.0/atk/atkaction.h"
struct _AtkAction ;
#line 42 "/usr/include/atk-1.0/atk/atkaction.h"
typedef struct _AtkAction AtkAction;
#line 44
struct _AtkActionIface ;
#line 44 "/usr/include/atk-1.0/atk/atkaction.h"
typedef struct _AtkActionIface AtkActionIface;
#line 62 "/usr/include/atk-1.0/atk/atkaction.h"
struct _AtkActionIface {
   GTypeInterface parent ;
   gboolean (*do_action)(AtkAction * , gint  ) ;
   gint (*get_n_actions)(AtkAction * ) ;
   gchar *(*get_description)(AtkAction * , gint  ) ;
   gchar *(*get_name)(AtkAction * , gint  ) ;
   gchar *(*get_keybinding)(AtkAction * , gint  ) ;
   gboolean (*set_description)(AtkAction * , gint  , gchar * ) ;
   gchar *(*get_localized_name)(AtkAction * , gint  ) ;
};
#line 41 "/usr/include/atk-1.0/atk/atkutil.h"
struct _AtkUtil ;
#line 41 "/usr/include/atk-1.0/atk/atkutil.h"
typedef struct _AtkUtil AtkUtil;
#line 42
struct _AtkUtilClass ;
#line 42 "/usr/include/atk-1.0/atk/atkutil.h"
typedef struct _AtkUtilClass AtkUtilClass;
#line 43
struct _AtkKeyEventStruct ;
#line 43 "/usr/include/atk-1.0/atk/atkutil.h"
typedef struct _AtkKeyEventStruct AtkKeyEventStruct;
#line 59 "/usr/include/atk-1.0/atk/atkutil.h"
typedef void (*AtkEventListener)(AtkObject * );
#line 69 "/usr/include/atk-1.0/atk/atkutil.h"
typedef void (*AtkEventListenerInit)(void);
#line 86 "/usr/include/atk-1.0/atk/atkutil.h"
typedef gint (*AtkKeySnoopFunc)(AtkKeyEventStruct * , gpointer  );
#line 110 "/usr/include/atk-1.0/atk/atkutil.h"
struct _AtkKeyEventStruct {
   gint type ;
   guint state ;
   guint keyval ;
   gint length ;
   gchar *string ;
   guint16 keycode ;
   guint32 timestamp ;
};
#line 128
enum __anonenum__558 {
    ATK_KEY_EVENT_PRESS = 0,
    ATK_KEY_EVENT_RELEASE = 1,
    ATK_KEY_EVENT_LAST_DEFINED = 2
} ;
#line 133 "/usr/include/atk-1.0/atk/atkutil.h"
typedef enum __anonenum__558 AtkKeyEventType;
#line 135 "/usr/include/atk-1.0/atk/atkutil.h"
struct _AtkUtil {
   GObject parent ;
};
#line 160 "/usr/include/atk-1.0/atk/atkutil.h"
struct _AtkUtilClass {
   GObjectClass parent ;
   guint (*add_global_event_listener)(GSignalEmissionHook  , gchar * ) ;
   void (*remove_global_event_listener)(guint  ) ;
   guint (*add_key_event_listener)(AtkKeySnoopFunc  , gpointer  ) ;
   void (*remove_key_event_listener)(guint  ) ;
   AtkObject *(*get_root)(void) ;
   gchar *(*get_toolkit_name)(void) ;
   gchar *(*get_toolkit_version)(void) ;
};
#line 187
enum __anonenum__559 {
    ATK_XY_SCREEN = 0,
    ATK_XY_WINDOW = 1,
    ATK_XY_PARENT = 2
} ;
#line 191 "/usr/include/atk-1.0/atk/atkutil.h"
typedef enum __anonenum__559 AtkCoordType;
#line 54 "/usr/include/atk-1.0/atk/atkcomponent.h"
enum __anonenum__560 {
    ATK_SCROLL_TOP_LEFT = 0,
    ATK_SCROLL_BOTTOM_RIGHT = 1,
    ATK_SCROLL_TOP_EDGE = 2,
    ATK_SCROLL_BOTTOM_EDGE = 3,
    ATK_SCROLL_LEFT_EDGE = 4,
    ATK_SCROLL_RIGHT_EDGE = 5,
    ATK_SCROLL_ANYWHERE = 6
} ;
#line 62 "/usr/include/atk-1.0/atk/atkcomponent.h"
typedef enum __anonenum__560 AtkScrollType;
#line 71
struct _AtkComponent ;
#line 71 "/usr/include/atk-1.0/atk/atkcomponent.h"
typedef struct _AtkComponent AtkComponent;
#line 73
struct _AtkComponentIface ;
#line 73 "/usr/include/atk-1.0/atk/atkcomponent.h"
typedef struct _AtkComponentIface AtkComponentIface;
#line 88 "/usr/include/atk-1.0/atk/atkcomponent.h"
typedef void (*AtkFocusHandler)(AtkObject * , gboolean  );
#line 90
struct _AtkRectangle ;
#line 90 "/usr/include/atk-1.0/atk/atkcomponent.h"
typedef struct _AtkRectangle AtkRectangle;
#line 102 "/usr/include/atk-1.0/atk/atkcomponent.h"
struct _AtkRectangle {
   gint x ;
   gint y ;
   gint width ;
   gint height ;
};
#line 146 "/usr/include/atk-1.0/atk/atkcomponent.h"
struct _AtkComponentIface {
   GTypeInterface parent ;
   guint (*add_focus_handler)(AtkComponent * , AtkFocusHandler  ) ;
   gboolean (*contains)(AtkComponent * , gint  , gint  , AtkCoordType  ) ;
   AtkObject *(*ref_accessible_at_point)(AtkComponent * , gint  , gint  , AtkCoordType  ) ;
   void (*get_extents)(AtkComponent * , gint * , gint * , gint * , gint * , AtkCoordType  ) ;
   void (*get_position)(AtkComponent * , gint * , gint * , AtkCoordType  ) ;
   void (*get_size)(AtkComponent * , gint * , gint * ) ;
   gboolean (*grab_focus)(AtkComponent * ) ;
   void (*remove_focus_handler)(AtkComponent * , guint  ) ;
   gboolean (*set_extents)(AtkComponent * , gint  , gint  , gint  , gint  , AtkCoordType  ) ;
   gboolean (*set_position)(AtkComponent * , gint  , gint  , AtkCoordType  ) ;
   gboolean (*set_size)(AtkComponent * , gint  , gint  ) ;
   AtkLayer (*get_layer)(AtkComponent * ) ;
   gint (*get_mdi_zorder)(AtkComponent * ) ;
   void (*bounds_changed)(AtkComponent * , AtkRectangle * ) ;
   gdouble (*get_alpha)(AtkComponent * ) ;
   gboolean (*scroll_to)(AtkComponent * , AtkScrollType  ) ;
   gboolean (*scroll_to_point)(AtkComponent * , AtkCoordType  , gint  , gint  ) ;
};
#line 45 "/usr/include/atk-1.0/atk/atkdocument.h"
struct _AtkDocument ;
#line 45 "/usr/include/atk-1.0/atk/atkdocument.h"
typedef struct _AtkDocument AtkDocument;
#line 47
struct _AtkDocumentIface ;
#line 47 "/usr/include/atk-1.0/atk/atkdocument.h"
typedef struct _AtkDocumentIface AtkDocumentIface;
#line 68 "/usr/include/atk-1.0/atk/atkdocument.h"
struct _AtkDocumentIface {
   GTypeInterface parent ;
   gchar *(*get_document_type)(AtkDocument * ) ;
   gpointer (*get_document)(AtkDocument * ) ;
   gchar *(*get_document_locale)(AtkDocument * ) ;
   AtkAttributeSet *(*get_document_attributes)(AtkDocument * ) ;
   gchar *(*get_document_attribute_value)(AtkDocument * , gchar * ) ;
   gboolean (*set_document_attribute)(AtkDocument * , gchar * , gchar * ) ;
   gint (*get_current_page_number)(AtkDocument * ) ;
   gint (*get_page_count)(AtkDocument * ) ;
};
#line 69 "/usr/include/atk-1.0/atk/atktext.h"
enum __anonenum__561 {
    ATK_TEXT_ATTR_INVALID = 0,
    ATK_TEXT_ATTR_LEFT_MARGIN = 1,
    ATK_TEXT_ATTR_RIGHT_MARGIN = 2,
    ATK_TEXT_ATTR_INDENT = 3,
    ATK_TEXT_ATTR_INVISIBLE = 4,
    ATK_TEXT_ATTR_EDITABLE = 5,
    ATK_TEXT_ATTR_PIXELS_ABOVE_LINES = 6,
    ATK_TEXT_ATTR_PIXELS_BELOW_LINES = 7,
    ATK_TEXT_ATTR_PIXELS_INSIDE_WRAP = 8,
    ATK_TEXT_ATTR_BG_FULL_HEIGHT = 9,
    ATK_TEXT_ATTR_RISE = 10,
    ATK_TEXT_ATTR_UNDERLINE = 11,
    ATK_TEXT_ATTR_STRIKETHROUGH = 12,
    ATK_TEXT_ATTR_SIZE = 13,
    ATK_TEXT_ATTR_SCALE = 14,
    ATK_TEXT_ATTR_WEIGHT = 15,
    ATK_TEXT_ATTR_LANGUAGE = 16,
    ATK_TEXT_ATTR_FAMILY_NAME = 17,
    ATK_TEXT_ATTR_BG_COLOR = 18,
    ATK_TEXT_ATTR_FG_COLOR = 19,
    ATK_TEXT_ATTR_BG_STIPPLE = 20,
    ATK_TEXT_ATTR_FG_STIPPLE = 21,
    ATK_TEXT_ATTR_WRAP_MODE = 22,
    ATK_TEXT_ATTR_DIRECTION = 23,
    ATK_TEXT_ATTR_JUSTIFICATION = 24,
    ATK_TEXT_ATTR_STRETCH = 25,
    ATK_TEXT_ATTR_VARIANT = 26,
    ATK_TEXT_ATTR_STYLE = 27,
    ATK_TEXT_ATTR_TEXT_POSITION = 28,
    ATK_TEXT_ATTR_LAST_DEFINED = 29
} ;
#line 101 "/usr/include/atk-1.0/atk/atktext.h"
typedef enum __anonenum__561 AtkTextAttribute;
#line 114
struct _AtkText ;
#line 114 "/usr/include/atk-1.0/atk/atktext.h"
typedef struct _AtkText AtkText;
#line 116
struct _AtkTextIface ;
#line 116 "/usr/include/atk-1.0/atk/atktext.h"
typedef struct _AtkTextIface AtkTextIface;
#line 140
enum __anonenum__562 {
    ATK_TEXT_BOUNDARY_CHAR = 0,
    ATK_TEXT_BOUNDARY_WORD_START = 1,
    ATK_TEXT_BOUNDARY_WORD_END = 2,
    ATK_TEXT_BOUNDARY_SENTENCE_START = 3,
    ATK_TEXT_BOUNDARY_SENTENCE_END = 4,
    ATK_TEXT_BOUNDARY_LINE_START = 5,
    ATK_TEXT_BOUNDARY_LINE_END = 6
} ;
#line 148 "/usr/include/atk-1.0/atk/atktext.h"
typedef enum __anonenum__562 AtkTextBoundary;
#line 170
enum __anonenum__563 {
    ATK_TEXT_GRANULARITY_CHAR = 0,
    ATK_TEXT_GRANULARITY_WORD = 1,
    ATK_TEXT_GRANULARITY_SENTENCE = 2,
    ATK_TEXT_GRANULARITY_LINE = 3,
    ATK_TEXT_GRANULARITY_PARAGRAPH = 4
} ;
#line 176 "/usr/include/atk-1.0/atk/atktext.h"
typedef enum __anonenum__563 AtkTextGranularity;
#line 188
struct _AtkTextRectangle ;
#line 188 "/usr/include/atk-1.0/atk/atktext.h"
typedef struct _AtkTextRectangle AtkTextRectangle;
#line 190 "/usr/include/atk-1.0/atk/atktext.h"
struct _AtkTextRectangle {
   gint x ;
   gint y ;
   gint width ;
   gint height ;
};
#line 206
struct _AtkTextRange ;
#line 206 "/usr/include/atk-1.0/atk/atktext.h"
typedef struct _AtkTextRange AtkTextRange;
#line 208 "/usr/include/atk-1.0/atk/atktext.h"
struct _AtkTextRange {
   AtkTextRectangle bounds ;
   gint start_offset ;
   gint end_offset ;
   gchar *content ;
};
#line 227
enum __anonenum__564 {
    ATK_TEXT_CLIP_NONE = 0,
    ATK_TEXT_CLIP_MIN = 1,
    ATK_TEXT_CLIP_MAX = 2,
    ATK_TEXT_CLIP_BOTH = 3
} ;
#line 232 "/usr/include/atk-1.0/atk/atktext.h"
typedef enum __anonenum__564 AtkTextClipType;
#line 250 "/usr/include/atk-1.0/atk/atktext.h"
struct _AtkTextIface {
   GTypeInterface parent ;
   gchar *(*get_text)(AtkText * , gint  , gint  ) ;
   gchar *(*get_text_after_offset)(AtkText * , gint  , AtkTextBoundary  , gint * ,
                                   gint * ) ;
   gchar *(*get_text_at_offset)(AtkText * , gint  , AtkTextBoundary  , gint * , gint * ) ;
   gunichar (*get_character_at_offset)(AtkText * , gint  ) ;
   gchar *(*get_text_before_offset)(AtkText * , gint  , AtkTextBoundary  , gint * ,
                                    gint * ) ;
   gint (*get_caret_offset)(AtkText * ) ;
   AtkAttributeSet *(*get_run_attributes)(AtkText * , gint  , gint * , gint * ) ;
   AtkAttributeSet *(*get_default_attributes)(AtkText * ) ;
   void (*get_character_extents)(AtkText * , gint  , gint * , gint * , gint * , gint * ,
                                 AtkCoordType  ) ;
   gint (*get_character_count)(AtkText * ) ;
   gint (*get_offset_at_point)(AtkText * , gint  , gint  , AtkCoordType  ) ;
   gint (*get_n_selections)(AtkText * ) ;
   gchar *(*get_selection)(AtkText * , gint  , gint * , gint * ) ;
   gboolean (*add_selection)(AtkText * , gint  , gint  ) ;
   gboolean (*remove_selection)(AtkText * , gint  ) ;
   gboolean (*set_selection)(AtkText * , gint  , gint  , gint  ) ;
   gboolean (*set_caret_offset)(AtkText * , gint  ) ;
   void (*text_changed)(AtkText * , gint  , gint  ) ;
   void (*text_caret_moved)(AtkText * , gint  ) ;
   void (*text_selection_changed)(AtkText * ) ;
   void (*text_attributes_changed)(AtkText * ) ;
   void (*get_range_extents)(AtkText * , gint  , gint  , AtkCoordType  , AtkTextRectangle * ) ;
   AtkTextRange **(*get_bounded_ranges)(AtkText * , AtkTextRectangle * , AtkCoordType  ,
                                        AtkTextClipType  , AtkTextClipType  ) ;
   gchar *(*get_string_at_offset)(AtkText * , gint  , AtkTextGranularity  , gint * ,
                                  gint * ) ;
   gboolean (*scroll_substring_to)(AtkText * , gint  , gint  , AtkScrollType  ) ;
   gboolean (*scroll_substring_to_point)(AtkText * , gint  , gint  , AtkCoordType  ,
                                         gint  , gint  ) ;
};
#line 44 "/usr/include/atk-1.0/atk/atkeditabletext.h"
struct _AtkEditableText ;
#line 44 "/usr/include/atk-1.0/atk/atkeditabletext.h"
typedef struct _AtkEditableText AtkEditableText;
#line 46
struct _AtkEditableTextIface ;
#line 46 "/usr/include/atk-1.0/atk/atkeditabletext.h"
typedef struct _AtkEditableTextIface AtkEditableTextIface;
#line 48 "/usr/include/atk-1.0/atk/atkeditabletext.h"
struct _AtkEditableTextIface {
   GTypeInterface parent_interface ;
   gboolean (*set_run_attributes)(AtkEditableText * , AtkAttributeSet * , gint  ,
                                  gint  ) ;
   void (*set_text_contents)(AtkEditableText * , gchar * ) ;
   void (*insert_text)(AtkEditableText * , gchar * , gint  , gint * ) ;
   void (*copy_text)(AtkEditableText * , gint  , gint  ) ;
   void (*cut_text)(AtkEditableText * , gint  , gint  ) ;
   void (*delete_text)(AtkEditableText * , gint  , gint  ) ;
   void (*paste_text)(AtkEditableText * , gint  ) ;
};
#line 42 "/usr/include/atk-1.0/atk/atkgobjectaccessible.h"
struct _AtkGObjectAccessible ;
#line 42 "/usr/include/atk-1.0/atk/atkgobjectaccessible.h"
typedef struct _AtkGObjectAccessible AtkGObjectAccessible;
#line 43
struct _AtkGObjectAccessibleClass ;
#line 43 "/usr/include/atk-1.0/atk/atkgobjectaccessible.h"
typedef struct _AtkGObjectAccessibleClass AtkGObjectAccessibleClass;
#line 45 "/usr/include/atk-1.0/atk/atkgobjectaccessible.h"
struct _AtkGObjectAccessible {
   AtkObject parent ;
};
#line 53 "/usr/include/atk-1.0/atk/atkgobjectaccessible.h"
struct _AtkGObjectAccessibleClass {
   AtkObjectClass parent_class ;
   AtkFunction pad1 ;
   AtkFunction pad2 ;
};
#line 43 "/usr/include/atk-1.0/atk/atkhyperlink.h"
enum __anonenum__565 {
    ATK_HYPERLINK_IS_INLINE = 1
} ;
#line 46 "/usr/include/atk-1.0/atk/atkhyperlink.h"
typedef enum __anonenum__565 AtkHyperlinkStateFlags;
#line 55
struct _AtkHyperlink ;
#line 55 "/usr/include/atk-1.0/atk/atkhyperlink.h"
typedef struct _AtkHyperlink AtkHyperlink;
#line 56
struct _AtkHyperlinkClass ;
#line 56 "/usr/include/atk-1.0/atk/atkhyperlink.h"
typedef struct _AtkHyperlinkClass AtkHyperlinkClass;
#line 58 "/usr/include/atk-1.0/atk/atkhyperlink.h"
struct _AtkHyperlink {
   GObject parent ;
};
#line 63 "/usr/include/atk-1.0/atk/atkhyperlink.h"
struct _AtkHyperlinkClass {
   GObjectClass parent ;
   gchar *(*get_uri)(AtkHyperlink * , gint  ) ;
   AtkObject *(*get_object)(AtkHyperlink * , gint  ) ;
   gint (*get_end_index)(AtkHyperlink * ) ;
   gint (*get_start_index)(AtkHyperlink * ) ;
   gboolean (*is_valid)(AtkHyperlink * ) ;
   gint (*get_n_anchors)(AtkHyperlink * ) ;
   guint (*link_state)(AtkHyperlink * ) ;
   gboolean (*is_selected_link)(AtkHyperlink * ) ;
   void (*link_activated)(AtkHyperlink * ) ;
   AtkFunction pad1 ;
};
#line 49 "/usr/include/atk-1.0/atk/atkhyperlinkimpl.h"
struct _AtkHyperlinkImpl ;
#line 49 "/usr/include/atk-1.0/atk/atkhyperlinkimpl.h"
typedef struct _AtkHyperlinkImpl AtkHyperlinkImpl;
#line 51
struct _AtkHyperlinkImplIface ;
#line 51 "/usr/include/atk-1.0/atk/atkhyperlinkimpl.h"
typedef struct _AtkHyperlinkImplIface AtkHyperlinkImplIface;
#line 53 "/usr/include/atk-1.0/atk/atkhyperlinkimpl.h"
struct _AtkHyperlinkImplIface {
   GTypeInterface parent ;
   AtkHyperlink *(*get_hyperlink)(AtkHyperlinkImpl * ) ;
};
#line 44 "/usr/include/atk-1.0/atk/atkhypertext.h"
struct _AtkHypertext ;
#line 44 "/usr/include/atk-1.0/atk/atkhypertext.h"
typedef struct _AtkHypertext AtkHypertext;
#line 46
struct _AtkHypertextIface ;
#line 46 "/usr/include/atk-1.0/atk/atkhypertext.h"
typedef struct _AtkHypertextIface AtkHypertextIface;
#line 48 "/usr/include/atk-1.0/atk/atkhypertext.h"
struct _AtkHypertextIface {
   GTypeInterface parent ;
   AtkHyperlink *(*get_link)(AtkHypertext * , gint  ) ;
   gint (*get_n_links)(AtkHypertext * ) ;
   gint (*get_link_index)(AtkHypertext * , gint  ) ;
   void (*link_selected)(AtkHypertext * , gint  ) ;
};
#line 45 "/usr/include/atk-1.0/atk/atkimage.h"
struct _AtkImage ;
#line 45 "/usr/include/atk-1.0/atk/atkimage.h"
typedef struct _AtkImage AtkImage;
#line 47
struct _AtkImageIface ;
#line 47 "/usr/include/atk-1.0/atk/atkimage.h"
typedef struct _AtkImageIface AtkImageIface;
#line 49 "/usr/include/atk-1.0/atk/atkimage.h"
struct _AtkImageIface {
   GTypeInterface parent ;
   void (*get_image_position)(AtkImage * , gint * , gint * , AtkCoordType  ) ;
   gchar *(*get_image_description)(AtkImage * ) ;
   void (*get_image_size)(AtkImage * , gint * , gint * ) ;
   gboolean (*set_image_description)(AtkImage * , gchar * ) ;
   gchar *(*get_image_locale)(AtkImage * ) ;
};
#line 38 "/usr/include/atk-1.0/atk/atknoopobject.h"
struct _AtkNoOpObject ;
#line 38 "/usr/include/atk-1.0/atk/atknoopobject.h"
typedef struct _AtkNoOpObject AtkNoOpObject;
#line 39
struct _AtkNoOpObjectClass ;
#line 39 "/usr/include/atk-1.0/atk/atknoopobject.h"
typedef struct _AtkNoOpObjectClass AtkNoOpObjectClass;
#line 41 "/usr/include/atk-1.0/atk/atknoopobject.h"
struct _AtkNoOpObject {
   AtkObject parent ;
};
#line 49 "/usr/include/atk-1.0/atk/atknoopobject.h"
struct _AtkNoOpObjectClass {
   AtkObjectClass parent_class ;
};
#line 39 "/usr/include/atk-1.0/atk/atkobjectfactory.h"
struct _AtkObjectFactory ;
#line 39 "/usr/include/atk-1.0/atk/atkobjectfactory.h"
typedef struct _AtkObjectFactory AtkObjectFactory;
#line 40
struct _AtkObjectFactoryClass ;
#line 40 "/usr/include/atk-1.0/atk/atkobjectfactory.h"
typedef struct _AtkObjectFactoryClass AtkObjectFactoryClass;
#line 42 "/usr/include/atk-1.0/atk/atkobjectfactory.h"
struct _AtkObjectFactory {
   GObject parent ;
};
#line 47 "/usr/include/atk-1.0/atk/atkobjectfactory.h"
struct _AtkObjectFactoryClass {
   GObjectClass parent_class ;
   AtkObject *(*create_accessible)(GObject * ) ;
   void (*invalidate)(AtkObjectFactory * ) ;
   GType (*get_accessible_type)(void) ;
   AtkFunction pad1 ;
   AtkFunction pad2 ;
};
#line 38 "/usr/include/atk-1.0/atk/atknoopobjectfactory.h"
struct _AtkNoOpObjectFactory ;
#line 38 "/usr/include/atk-1.0/atk/atknoopobjectfactory.h"
typedef struct _AtkNoOpObjectFactory AtkNoOpObjectFactory;
#line 39
struct _AtkNoOpObjectFactoryClass ;
#line 39 "/usr/include/atk-1.0/atk/atknoopobjectfactory.h"
typedef struct _AtkNoOpObjectFactoryClass AtkNoOpObjectFactoryClass;
#line 41 "/usr/include/atk-1.0/atk/atknoopobjectfactory.h"
struct _AtkNoOpObjectFactory {
   AtkObjectFactory parent ;
};
#line 46 "/usr/include/atk-1.0/atk/atknoopobjectfactory.h"
struct _AtkNoOpObjectFactoryClass {
   AtkObjectFactoryClass parent_class ;
};
#line 38 "/usr/include/atk-1.0/atk/atkplug.h"
struct _AtkPlug ;
#line 38 "/usr/include/atk-1.0/atk/atkplug.h"
typedef struct _AtkPlug AtkPlug;
#line 39
struct _AtkPlugClass ;
#line 39 "/usr/include/atk-1.0/atk/atkplug.h"
typedef struct _AtkPlugClass AtkPlugClass;
#line 41 "/usr/include/atk-1.0/atk/atkplug.h"
struct _AtkPlug {
   AtkObject parent ;
};
#line 49 "/usr/include/atk-1.0/atk/atkplug.h"
struct _AtkPlugClass {
   AtkObjectClass parent_class ;
   gchar *(*get_object_id)(AtkPlug * ) ;
};
#line 35 "/usr/include/atk-1.0/atk/atkrange.h"
struct _AtkRange ;
#line 35 "/usr/include/atk-1.0/atk/atkrange.h"
typedef struct _AtkRange AtkRange;
#line 39 "/usr/include/atk-1.0/atk/atkregistry.h"
struct _AtkRegistry {
   GObject parent ;
   GHashTable *factory_type_registry ;
   GHashTable *factory_singleton_cache ;
};
#line 46 "/usr/include/atk-1.0/atk/atkregistry.h"
struct _AtkRegistryClass {
   GObjectClass parent_class ;
};
#line 51 "/usr/include/atk-1.0/atk/atkregistry.h"
typedef struct _AtkRegistry AtkRegistry;
#line 52 "/usr/include/atk-1.0/atk/atkregistry.h"
typedef struct _AtkRegistryClass AtkRegistryClass;
#line 46 "/usr/include/atk-1.0/atk/atkrelation.h"
struct _AtkRelation ;
#line 46 "/usr/include/atk-1.0/atk/atkrelation.h"
typedef struct _AtkRelation AtkRelation;
#line 47
struct _AtkRelationClass ;
#line 47 "/usr/include/atk-1.0/atk/atkrelation.h"
typedef struct _AtkRelationClass AtkRelationClass;
#line 49 "/usr/include/atk-1.0/atk/atkrelation.h"
struct _AtkRelation {
   GObject parent ;
   GPtrArray *target ;
   AtkRelationType relationship ;
};
#line 57 "/usr/include/atk-1.0/atk/atkrelation.h"
struct _AtkRelationClass {
   GObjectClass parent ;
};
#line 40 "/usr/include/atk-1.0/atk/atkrelationset.h"
struct _AtkRelationSetClass ;
#line 40 "/usr/include/atk-1.0/atk/atkrelationset.h"
typedef struct _AtkRelationSetClass AtkRelationSetClass;
#line 43 "/usr/include/atk-1.0/atk/atkrelationset.h"
struct _AtkRelationSet {
   GObject parent ;
   GPtrArray *relations ;
};
#line 50 "/usr/include/atk-1.0/atk/atkrelationset.h"
struct _AtkRelationSetClass {
   GObjectClass parent ;
   AtkFunction pad1 ;
   AtkFunction pad2 ;
};
#line 45 "/usr/include/atk-1.0/atk/atkselection.h"
struct _AtkSelection ;
#line 45 "/usr/include/atk-1.0/atk/atkselection.h"
typedef struct _AtkSelection AtkSelection;
#line 47
struct _AtkSelectionIface ;
#line 47 "/usr/include/atk-1.0/atk/atkselection.h"
typedef struct _AtkSelectionIface AtkSelectionIface;
#line 49 "/usr/include/atk-1.0/atk/atkselection.h"
struct _AtkSelectionIface {
   GTypeInterface parent ;
   gboolean (*add_selection)(AtkSelection * , gint  ) ;
   gboolean (*clear_selection)(AtkSelection * ) ;
   AtkObject *(*ref_selection)(AtkSelection * , gint  ) ;
   gint (*get_selection_count)(AtkSelection * ) ;
   gboolean (*is_child_selected)(AtkSelection * , gint  ) ;
   gboolean (*remove_selection)(AtkSelection * , gint  ) ;
   gboolean (*select_all_selection)(AtkSelection * ) ;
   void (*selection_changed)(AtkSelection * ) ;
};
#line 38 "/usr/include/atk-1.0/atk/atksocket.h"
struct _AtkSocket ;
#line 38 "/usr/include/atk-1.0/atk/atksocket.h"
typedef struct _AtkSocket AtkSocket;
#line 39
struct _AtkSocketClass ;
#line 39 "/usr/include/atk-1.0/atk/atksocket.h"
typedef struct _AtkSocketClass AtkSocketClass;
#line 41 "/usr/include/atk-1.0/atk/atksocket.h"
struct _AtkSocket {
   AtkObject parent ;
   gchar *embedded_plug_id ;
};
#line 52 "/usr/include/atk-1.0/atk/atksocket.h"
struct _AtkSocketClass {
   AtkObjectClass parent_class ;
   void (*embed)(AtkSocket * , gchar * ) ;
};
#line 40 "/usr/include/atk-1.0/atk/atkstateset.h"
struct _AtkStateSetClass ;
#line 40 "/usr/include/atk-1.0/atk/atkstateset.h"
typedef struct _AtkStateSetClass AtkStateSetClass;
#line 43 "/usr/include/atk-1.0/atk/atkstateset.h"
struct _AtkStateSet {
   GObject parent ;
};
#line 49 "/usr/include/atk-1.0/atk/atkstateset.h"
struct _AtkStateSetClass {
   GObjectClass parent ;
};
#line 38 "/usr/include/atk-1.0/atk/atkstreamablecontent.h"
struct _AtkStreamableContent ;
#line 38 "/usr/include/atk-1.0/atk/atkstreamablecontent.h"
typedef struct _AtkStreamableContent AtkStreamableContent;
#line 40
struct _AtkStreamableContentIface ;
#line 40 "/usr/include/atk-1.0/atk/atkstreamablecontent.h"
typedef struct _AtkStreamableContentIface AtkStreamableContentIface;
#line 42 "/usr/include/atk-1.0/atk/atkstreamablecontent.h"
struct _AtkStreamableContentIface {
   GTypeInterface parent ;
   gint (*get_n_mime_types)(AtkStreamableContent * ) ;
   gchar *(*get_mime_type)(AtkStreamableContent * , gint  ) ;
   GIOChannel *(*get_stream)(AtkStreamableContent * , gchar * ) ;
   gchar *(*get_uri)(AtkStreamableContent * , gchar * ) ;
   AtkFunction pad1 ;
   AtkFunction pad2 ;
   AtkFunction pad3 ;
};
#line 38 "/usr/include/atk-1.0/atk/atktable.h"
struct _AtkTable ;
#line 38 "/usr/include/atk-1.0/atk/atktable.h"
typedef struct _AtkTable AtkTable;
#line 40
struct _AtkTableIface ;
#line 40 "/usr/include/atk-1.0/atk/atktable.h"
typedef struct _AtkTableIface AtkTableIface;
#line 42 "/usr/include/atk-1.0/atk/atktable.h"
struct _AtkTableIface {
   GTypeInterface parent ;
   AtkObject *(*ref_at)(AtkTable * , gint  , gint  ) ;
   gint (*get_index_at)(AtkTable * , gint  , gint  ) ;
   gint (*get_column_at_index)(AtkTable * , gint  ) ;
   gint (*get_row_at_index)(AtkTable * , gint  ) ;
   gint (*get_n_columns)(AtkTable * ) ;
   gint (*get_n_rows)(AtkTable * ) ;
   gint (*get_column_extent_at)(AtkTable * , gint  , gint  ) ;
   gint (*get_row_extent_at)(AtkTable * , gint  , gint  ) ;
   AtkObject *(*get_caption)(AtkTable * ) ;
   gchar *(*get_column_description)(AtkTable * , gint  ) ;
   AtkObject *(*get_column_header)(AtkTable * , gint  ) ;
   gchar *(*get_row_description)(AtkTable * , gint  ) ;
   AtkObject *(*get_row_header)(AtkTable * , gint  ) ;
   AtkObject *(*get_summary)(AtkTable * ) ;
   void (*set_caption)(AtkTable * , AtkObject * ) ;
   void (*set_column_description)(AtkTable * , gint  , gchar * ) ;
   void (*set_column_header)(AtkTable * , gint  , AtkObject * ) ;
   void (*set_row_description)(AtkTable * , gint  , gchar * ) ;
   void (*set_row_header)(AtkTable * , gint  , AtkObject * ) ;
   void (*set_summary)(AtkTable * , AtkObject * ) ;
   gint (*get_selected_columns)(AtkTable * , gint ** ) ;
   gint (*get_selected_rows)(AtkTable * , gint ** ) ;
   gboolean (*is_column_selected)(AtkTable * , gint  ) ;
   gboolean (*is_row_selected)(AtkTable * , gint  ) ;
   gboolean (*is_selected)(AtkTable * , gint  , gint  ) ;
   gboolean (*add_row_selection)(AtkTable * , gint  ) ;
   gboolean (*remove_row_selection)(AtkTable * , gint  ) ;
   gboolean (*add_column_selection)(AtkTable * , gint  ) ;
   gboolean (*remove_column_selection)(AtkTable * , gint  ) ;
   void (*row_inserted)(AtkTable * , gint  , gint  ) ;
   void (*column_inserted)(AtkTable * , gint  , gint  ) ;
   void (*row_deleted)(AtkTable * , gint  , gint  ) ;
   void (*column_deleted)(AtkTable * , gint  , gint  ) ;
   void (*row_reordered)(AtkTable * ) ;
   void (*column_reordered)(AtkTable * ) ;
   void (*model_changed)(AtkTable * ) ;
};
#line 38 "/usr/include/atk-1.0/atk/atktablecell.h"
struct _AtkTableCell ;
#line 38 "/usr/include/atk-1.0/atk/atktablecell.h"
typedef struct _AtkTableCell AtkTableCell;
#line 40
struct _AtkTableCellIface ;
#line 40 "/usr/include/atk-1.0/atk/atktablecell.h"
typedef struct _AtkTableCellIface AtkTableCellIface;
#line 63 "/usr/include/atk-1.0/atk/atktablecell.h"
struct _AtkTableCellIface {
   GTypeInterface parent ;
   gint (*get_column_span)(AtkTableCell * ) ;
   GPtrArray *(*get_column_header_cells)(AtkTableCell * ) ;
   gboolean (*get_position)(AtkTableCell * , gint * , gint * ) ;
   gint (*get_row_span)(AtkTableCell * ) ;
   GPtrArray *(*get_row_header_cells)(AtkTableCell * ) ;
   gboolean (*get_row_column_span)(AtkTableCell * , gint * , gint * , gint * , gint * ) ;
   AtkObject *(*get_table)(AtkTableCell * ) ;
};
#line 65 "/usr/include/atk-1.0/atk/atkmisc.h"
struct _AtkMisc ;
#line 65 "/usr/include/atk-1.0/atk/atkmisc.h"
typedef struct _AtkMisc AtkMisc;
#line 66
struct _AtkMiscClass ;
#line 66 "/usr/include/atk-1.0/atk/atkmisc.h"
typedef struct _AtkMiscClass AtkMiscClass;
#line 69 "/usr/include/atk-1.0/atk/atkmisc.h"
struct _AtkMisc {
   GObject parent ;
};
#line 92 "/usr/include/atk-1.0/atk/atkmisc.h"
struct _AtkMiscClass {
   GObjectClass parent ;
   void (*threads_enter)(AtkMisc * ) ;
   void (*threads_leave)(AtkMisc * ) ;
   gpointer vfuncs[32] ;
};
#line 39 "/usr/include/atk-1.0/atk/atkvalue.h"
struct _AtkValue ;
#line 39 "/usr/include/atk-1.0/atk/atkvalue.h"
typedef struct _AtkValue AtkValue;
#line 41
struct _AtkValueIface ;
#line 41 "/usr/include/atk-1.0/atk/atkvalue.h"
typedef struct _AtkValueIface AtkValueIface;
#line 51
enum __anonenum__566 {
    ATK_VALUE_VERY_WEAK = 0,
    ATK_VALUE_WEAK = 1,
    ATK_VALUE_ACCEPTABLE = 2,
    ATK_VALUE_STRONG = 3,
    ATK_VALUE_VERY_STRONG = 4,
    ATK_VALUE_VERY_LOW = 5,
    ATK_VALUE_LOW = 6,
    ATK_VALUE_MEDIUM = 7,
    ATK_VALUE_HIGH = 8,
    ATK_VALUE_VERY_HIGH = 9,
    ATK_VALUE_VERY_BAD = 10,
    ATK_VALUE_BAD = 11,
    ATK_VALUE_GOOD = 12,
    ATK_VALUE_VERY_GOOD = 13,
    ATK_VALUE_BEST = 14,
    ATK_VALUE_LAST_DEFINED = 15
} ;
#line 69 "/usr/include/atk-1.0/atk/atkvalue.h"
typedef enum __anonenum__566 AtkValueType;
#line 95 "/usr/include/atk-1.0/atk/atkvalue.h"
struct _AtkValueIface {
   GTypeInterface parent ;
   void (*get_current_value)(AtkValue * , GValue * ) ;
   void (*get_maximum_value)(AtkValue * , GValue * ) ;
   void (*get_minimum_value)(AtkValue * , GValue * ) ;
   gboolean (*set_current_value)(AtkValue * , GValue * ) ;
   void (*get_minimum_increment)(AtkValue * , GValue * ) ;
   void (*get_value_and_text)(AtkValue * , gdouble * , gchar ** ) ;
   AtkRange *(*get_range)(AtkValue * ) ;
   gdouble (*get_increment)(AtkValue * ) ;
   GSList *(*get_sub_ranges)(AtkValue * ) ;
   void (*set_value)(AtkValue * , gdouble  ) ;
};
#line 41 "/usr/include/atk-1.0/atk/atkwindow.h"
struct _AtkWindow ;
#line 41 "/usr/include/atk-1.0/atk/atkwindow.h"
typedef struct _AtkWindow AtkWindow;
#line 42
struct _AtkWindowIface ;
#line 42 "/usr/include/atk-1.0/atk/atkwindow.h"
typedef struct _AtkWindowIface AtkWindowIface;
#line 44 "/usr/include/atk-1.0/atk/atkwindow.h"
struct _AtkWindowIface {
   GTypeInterface parent ;
};
#line 101 "/usr/include/gtk-2.0/gtk/gtkwidget.h"
enum __anonenum__567 {
    GTK_TOPLEVEL = 16,
    GTK_NO_WINDOW = 32,
    GTK_REALIZED = 64,
    GTK_MAPPED = 128,
    GTK_VISIBLE = 256,
    GTK_SENSITIVE = 512,
    GTK_PARENT_SENSITIVE = 1024,
    GTK_CAN_FOCUS = 2048,
    GTK_HAS_FOCUS = 4096,
    GTK_CAN_DEFAULT = 8192,
    GTK_HAS_DEFAULT = 16384,
    GTK_HAS_GRAB = 32768,
    GTK_RC_STYLE = 65536,
    GTK_COMPOSITE_CHILD = 131072,
    GTK_NO_REPARENT = 262144,
    GTK_APP_PAINTABLE = 524288,
    GTK_RECEIVES_DEFAULT = 1048576,
    GTK_DOUBLE_BUFFERED = 2097152,
    GTK_NO_SHOW_ALL = 4194304
} ;
#line 124 "/usr/include/gtk-2.0/gtk/gtkwidget.h"
typedef enum __anonenum__567 GtkWidgetFlags;
#line 127
enum __anonenum__568 {
    GTK_WIDGET_HELP_TOOLTIP = 0,
    GTK_WIDGET_HELP_WHATS_THIS = 1
} ;
#line 131 "/usr/include/gtk-2.0/gtk/gtkwidget.h"
typedef enum __anonenum__568 GtkWidgetHelpType;
#line 478
struct _GtkRequisition ;
#line 478 "/usr/include/gtk-2.0/gtk/gtkwidget.h"
typedef struct _GtkRequisition GtkRequisition;
#line 479
struct _GtkSelectionData ;
#line 479 "/usr/include/gtk-2.0/gtk/gtkwidget.h"
typedef struct _GtkSelectionData GtkSelectionData;
#line 480
struct _GtkWidgetClass ;
#line 480 "/usr/include/gtk-2.0/gtk/gtkwidget.h"
typedef struct _GtkWidgetClass GtkWidgetClass;
#line 481
struct _GtkWidgetAuxInfo ;
#line 481 "/usr/include/gtk-2.0/gtk/gtkwidget.h"
typedef struct _GtkWidgetAuxInfo GtkWidgetAuxInfo;
#line 482
struct _GtkWidgetShapeInfo ;
#line 482 "/usr/include/gtk-2.0/gtk/gtkwidget.h"
typedef struct _GtkWidgetShapeInfo GtkWidgetShapeInfo;
#line 483
struct _GtkClipboard ;
#line 483 "/usr/include/gtk-2.0/gtk/gtkwidget.h"
typedef struct _GtkClipboard GtkClipboard;
#line 484
struct _GtkTooltip ;
#line 484 "/usr/include/gtk-2.0/gtk/gtkwidget.h"
typedef struct _GtkTooltip GtkTooltip;
#line 485
struct _GtkWindow ;
#line 485 "/usr/include/gtk-2.0/gtk/gtkwidget.h"
typedef struct _GtkWindow GtkWindow;
#line 498 "/usr/include/gtk-2.0/gtk/gtkwidget.h"
typedef GdkRectangle GtkAllocation;
#line 508 "/usr/include/gtk-2.0/gtk/gtkwidget.h"
typedef void (*GtkCallback)(GtkWidget * , gpointer  );
#line 519 "/usr/include/gtk-2.0/gtk/gtkwidget.h"
struct _GtkRequisition {
   gint width ;
   gint height ;
};
#line 530 "/usr/include/gtk-2.0/gtk/gtkwidget.h"
struct _GtkWidget {
   GtkObject object ;
   guint16 private_flags ;
   guint8 state ;
   guint8 saved_state ;
   gchar *name ;
   GtkStyle *style ;
   GtkRequisition requisition ;
   GtkAllocation allocation ;
   GdkWindow *window ;
   GtkWidget *parent ;
};
#line 614 "/usr/include/gtk-2.0/gtk/gtkwidget.h"
struct _GtkWidgetClass {
   GtkObjectClass parent_class ;
   guint activate_signal ;
   guint set_scroll_adjustments_signal ;
   void (*dispatch_child_properties_changed)(GtkWidget * , guint  , GParamSpec ** ) ;
   void (*show)(GtkWidget * ) ;
   void (*show_all)(GtkWidget * ) ;
   void (*hide)(GtkWidget * ) ;
   void (*hide_all)(GtkWidget * ) ;
   void (*map)(GtkWidget * ) ;
   void (*unmap)(GtkWidget * ) ;
   void (*realize)(GtkWidget * ) ;
   void (*unrealize)(GtkWidget * ) ;
   void (*size_request)(GtkWidget * , GtkRequisition * ) ;
   void (*size_allocate)(GtkWidget * , GtkAllocation * ) ;
   void (*state_changed)(GtkWidget * , GtkStateType  ) ;
   void (*parent_set)(GtkWidget * , GtkWidget * ) ;
   void (*hierarchy_changed)(GtkWidget * , GtkWidget * ) ;
   void (*style_set)(GtkWidget * , GtkStyle * ) ;
   void (*direction_changed)(GtkWidget * , GtkTextDirection  ) ;
   void (*grab_notify)(GtkWidget * , gboolean  ) ;
   void (*child_notify)(GtkWidget * , GParamSpec * ) ;
   gboolean (*mnemonic_activate)(GtkWidget * , gboolean  ) ;
   void (*grab_focus)(GtkWidget * ) ;
   gboolean (*focus)(GtkWidget * , GtkDirectionType  ) ;
   gboolean (*event)(GtkWidget * , GdkEvent * ) ;
   gboolean (*button_press_event)(GtkWidget * , GdkEventButton * ) ;
   gboolean (*button_release_event)(GtkWidget * , GdkEventButton * ) ;
   gboolean (*scroll_event)(GtkWidget * , GdkEventScroll * ) ;
   gboolean (*motion_notify_event)(GtkWidget * , GdkEventMotion * ) ;
   gboolean (*delete_event)(GtkWidget * , GdkEventAny * ) ;
   gboolean (*destroy_event)(GtkWidget * , GdkEventAny * ) ;
   gboolean (*expose_event)(GtkWidget * , GdkEventExpose * ) ;
   gboolean (*key_press_event)(GtkWidget * , GdkEventKey * ) ;
   gboolean (*key_release_event)(GtkWidget * , GdkEventKey * ) ;
   gboolean (*enter_notify_event)(GtkWidget * , GdkEventCrossing * ) ;
   gboolean (*leave_notify_event)(GtkWidget * , GdkEventCrossing * ) ;
   gboolean (*configure_event)(GtkWidget * , GdkEventConfigure * ) ;
   gboolean (*focus_in_event)(GtkWidget * , GdkEventFocus * ) ;
   gboolean (*focus_out_event)(GtkWidget * , GdkEventFocus * ) ;
   gboolean (*map_event)(GtkWidget * , GdkEventAny * ) ;
   gboolean (*unmap_event)(GtkWidget * , GdkEventAny * ) ;
   gboolean (*property_notify_event)(GtkWidget * , GdkEventProperty * ) ;
   gboolean (*selection_clear_event)(GtkWidget * , GdkEventSelection * ) ;
   gboolean (*selection_request_event)(GtkWidget * , GdkEventSelection * ) ;
   gboolean (*selection_notify_event)(GtkWidget * , GdkEventSelection * ) ;
   gboolean (*proximity_in_event)(GtkWidget * , GdkEventProximity * ) ;
   gboolean (*proximity_out_event)(GtkWidget * , GdkEventProximity * ) ;
   gboolean (*visibility_notify_event)(GtkWidget * , GdkEventVisibility * ) ;
   gboolean (*client_event)(GtkWidget * , GdkEventClient * ) ;
   gboolean (*no_expose_event)(GtkWidget * , GdkEventAny * ) ;
   gboolean (*window_state_event)(GtkWidget * , GdkEventWindowState * ) ;
   void (*selection_get)(GtkWidget * , GtkSelectionData * , guint  , guint  ) ;
   void (*selection_received)(GtkWidget * , GtkSelectionData * , guint  ) ;
   void (*drag_begin)(GtkWidget * , GdkDragContext * ) ;
   void (*drag_end)(GtkWidget * , GdkDragContext * ) ;
   void (*drag_data_get)(GtkWidget * , GdkDragContext * , GtkSelectionData * , guint  ,
                         guint  ) ;
   void (*drag_data_delete)(GtkWidget * , GdkDragContext * ) ;
   void (*drag_leave)(GtkWidget * , GdkDragContext * , guint  ) ;
   gboolean (*drag_motion)(GtkWidget * , GdkDragContext * , gint  , gint  , guint  ) ;
   gboolean (*drag_drop)(GtkWidget * , GdkDragContext * , gint  , gint  , guint  ) ;
   void (*drag_data_received)(GtkWidget * , GdkDragContext * , gint  , gint  , GtkSelectionData * ,
                              guint  , guint  ) ;
   gboolean (*popup_menu)(GtkWidget * ) ;
   gboolean (*show_help)(GtkWidget * , GtkWidgetHelpType  ) ;
   AtkObject *(*get_accessible)(GtkWidget * ) ;
   void (*screen_changed)(GtkWidget * , GdkScreen * ) ;
   gboolean (*can_activate_accel)(GtkWidget * , guint  ) ;
   gboolean (*grab_broken_event)(GtkWidget * , GdkEventGrabBroken * ) ;
   void (*composited_changed)(GtkWidget * ) ;
   gboolean (*query_tooltip)(GtkWidget * , gint  , gint  , gboolean  , GtkTooltip * ) ;
   void (*_gtk_reserved5)(void) ;
   void (*_gtk_reserved6)(void) ;
   void (*_gtk_reserved7)(void) ;
};
#line 816 "/usr/include/gtk-2.0/gtk/gtkwidget.h"
struct _GtkWidgetAuxInfo {
   gint x ;
   gint y ;
   gint width ;
   gint height ;
   guint x_set ;
   guint y_set ;
};
#line 826 "/usr/include/gtk-2.0/gtk/gtkwidget.h"
struct _GtkWidgetShapeInfo {
   gint16 offset_x ;
   gint16 offset_y ;
   GdkBitmap *shape_mask ;
};
#line 51 "/usr/include/gtk-2.0/gtk/gtkcontainer.h"
struct _GtkContainer ;
#line 51 "/usr/include/gtk-2.0/gtk/gtkcontainer.h"
typedef struct _GtkContainer GtkContainer;
#line 52
struct _GtkContainerClass ;
#line 52 "/usr/include/gtk-2.0/gtk/gtkcontainer.h"
typedef struct _GtkContainerClass GtkContainerClass;
#line 54 "/usr/include/gtk-2.0/gtk/gtkcontainer.h"
struct _GtkContainer {
   GtkWidget widget ;
   GtkWidget *focus_child ;
   guint border_width ;
   guint need_resize ;
   guint resize_mode ;
   guint reallocate_redraws ;
   guint has_focus_chain ;
};
#line 69 "/usr/include/gtk-2.0/gtk/gtkcontainer.h"
struct _GtkContainerClass {
   GtkWidgetClass parent_class ;
   void (*add)(GtkContainer * , GtkWidget * ) ;
   void (*remove)(GtkContainer * , GtkWidget * ) ;
   void (*check_resize)(GtkContainer * ) ;
   void (*forall)(GtkContainer * , gboolean  , GtkCallback  , gpointer  ) ;
   void (*set_focus_child)(GtkContainer * , GtkWidget * ) ;
   GType (*child_type)(GtkContainer * ) ;
   gchar *(*composite_name)(GtkContainer * , GtkWidget * ) ;
   void (*set_child_property)(GtkContainer * , GtkWidget * , guint  , GValue * , GParamSpec * ) ;
   void (*get_child_property)(GtkContainer * , GtkWidget * , guint  , GValue * , GParamSpec * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkbin.h"
struct _GtkBin ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkbin.h"
typedef struct _GtkBin GtkBin;
#line 49
struct _GtkBinClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkbin.h"
typedef struct _GtkBinClass GtkBinClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkbin.h"
struct _GtkBin {
   GtkContainer container ;
   GtkWidget *child ;
};
#line 58 "/usr/include/gtk-2.0/gtk/gtkbin.h"
struct _GtkBinClass {
   GtkContainerClass parent_class ;
};
#line 49 "/usr/include/gtk-2.0/gtk/gtkwindow.h"
struct _GtkWindowClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkwindow.h"
typedef struct _GtkWindowClass GtkWindowClass;
#line 50
struct _GtkWindowGeometryInfo ;
#line 50 "/usr/include/gtk-2.0/gtk/gtkwindow.h"
typedef struct _GtkWindowGeometryInfo GtkWindowGeometryInfo;
#line 51
struct _GtkWindowGroup ;
#line 51 "/usr/include/gtk-2.0/gtk/gtkwindow.h"
typedef struct _GtkWindowGroup GtkWindowGroup;
#line 52
struct _GtkWindowGroupClass ;
#line 52 "/usr/include/gtk-2.0/gtk/gtkwindow.h"
typedef struct _GtkWindowGroupClass GtkWindowGroupClass;
#line 54 "/usr/include/gtk-2.0/gtk/gtkwindow.h"
struct _GtkWindow {
   GtkBin bin ;
   gchar *title ;
   gchar *wmclass_name ;
   gchar *wmclass_class ;
   gchar *wm_role ;
   GtkWidget *focus_widget ;
   GtkWidget *default_widget ;
   GtkWindow *transient_parent ;
   GtkWindowGeometryInfo *geometry_info ;
   GdkWindow *frame ;
   GtkWindowGroup *group ;
   guint16 configure_request_count ;
   guint allow_shrink ;
   guint allow_grow ;
   guint configure_notify_received ;
   guint need_default_position ;
   guint need_default_size ;
   guint position ;
   guint type ;
   guint has_user_ref_count ;
   guint has_focus ;
   guint modal ;
   guint destroy_with_parent ;
   guint has_frame ;
   guint iconify_initially ;
   guint stick_initially ;
   guint maximize_initially ;
   guint decorated ;
   guint type_hint ;
   guint gravity ;
   guint is_active ;
   guint has_toplevel_focus ;
   guint frame_left ;
   guint frame_top ;
   guint frame_right ;
   guint frame_bottom ;
   guint keys_changed_handler ;
   GdkModifierType mnemonic_modifier ;
   GdkScreen *screen ;
};
#line 117 "/usr/include/gtk-2.0/gtk/gtkwindow.h"
struct _GtkWindowClass {
   GtkBinClass parent_class ;
   void (*set_focus)(GtkWindow * , GtkWidget * ) ;
   gboolean (*frame_event)(GtkWindow * , GdkEvent * ) ;
   void (*activate_focus)(GtkWindow * ) ;
   void (*activate_default)(GtkWindow * ) ;
   void (*move_focus)(GtkWindow * , GtkDirectionType  ) ;
   void (*keys_changed)(GtkWindow * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 154 "/usr/include/gtk-2.0/gtk/gtkwindow.h"
struct _GtkWindowGroup {
   GObject parent_instance ;
   GSList *grabs ;
};
#line 161 "/usr/include/gtk-2.0/gtk/gtkwindow.h"
struct _GtkWindowGroupClass {
   GObjectClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 435 "/usr/include/gtk-2.0/gtk/gtkwindow.h"
typedef void (*GtkWindowKeysForeachFunc)(GtkWindow * , guint  , GdkModifierType  ,
                                         gboolean  , gpointer  );
#line 41 "/usr/include/gtk-2.0/gtk/gtkdialog.h"
enum __anonenum__569 {
    GTK_DIALOG_MODAL = 1,
    GTK_DIALOG_DESTROY_WITH_PARENT = 2,
    GTK_DIALOG_NO_SEPARATOR = 4
} ;
#line 46 "/usr/include/gtk-2.0/gtk/gtkdialog.h"
typedef enum __anonenum__569 GtkDialogFlags;
#line 56
enum __anonenum__570 {
    GTK_RESPONSE_NONE = -1,
    GTK_RESPONSE_REJECT = -2,
    GTK_RESPONSE_ACCEPT = -3,
    GTK_RESPONSE_DELETE_EVENT = -4,
    GTK_RESPONSE_OK = -5,
    GTK_RESPONSE_CANCEL = -6,
    GTK_RESPONSE_CLOSE = -7,
    GTK_RESPONSE_YES = -8,
    GTK_RESPONSE_NO = -9,
    GTK_RESPONSE_APPLY = -10,
    GTK_RESPONSE_HELP = -11
} ;
#line 83 "/usr/include/gtk-2.0/gtk/gtkdialog.h"
typedef enum __anonenum__570 GtkResponseType;
#line 94
struct _GtkDialog ;
#line 94 "/usr/include/gtk-2.0/gtk/gtkdialog.h"
typedef struct _GtkDialog GtkDialog;
#line 95
struct _GtkDialogClass ;
#line 95 "/usr/include/gtk-2.0/gtk/gtkdialog.h"
typedef struct _GtkDialogClass GtkDialogClass;
#line 97 "/usr/include/gtk-2.0/gtk/gtkdialog.h"
struct _GtkDialog {
   GtkWindow window ;
   GtkWidget *vbox ;
   GtkWidget *action_area ;
   GtkWidget *separator ;
};
#line 109 "/usr/include/gtk-2.0/gtk/gtkdialog.h"
struct _GtkDialogClass {
   GtkWindowClass parent_class ;
   void (*response)(GtkDialog * , gint  ) ;
   void (*close)(GtkDialog * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 43 "/usr/include/gtk-2.0/gtk/gtkaboutdialog.h"
struct _GtkAboutDialog ;
#line 43 "/usr/include/gtk-2.0/gtk/gtkaboutdialog.h"
typedef struct _GtkAboutDialog GtkAboutDialog;
#line 44
struct _GtkAboutDialogClass ;
#line 44 "/usr/include/gtk-2.0/gtk/gtkaboutdialog.h"
typedef struct _GtkAboutDialogClass GtkAboutDialogClass;
#line 52 "/usr/include/gtk-2.0/gtk/gtkaboutdialog.h"
struct _GtkAboutDialog {
   GtkDialog parent_instance ;
   gpointer private_data ;
};
#line 60 "/usr/include/gtk-2.0/gtk/gtkaboutdialog.h"
struct _GtkAboutDialogClass {
   GtkDialogClass parent_class ;
   gboolean (*activate_link)(GtkAboutDialog * , gchar * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
};
#line 140 "/usr/include/gtk-2.0/gtk/gtkaboutdialog.h"
typedef void (*GtkAboutDialogActivateLinkFunc)(GtkAboutDialog * , gchar * , gpointer  );
#line 48 "/usr/include/gtk-2.0/gtk/gtkmisc.h"
struct _GtkMisc ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkmisc.h"
typedef struct _GtkMisc GtkMisc;
#line 49
struct _GtkMiscClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkmisc.h"
typedef struct _GtkMiscClass GtkMiscClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkmisc.h"
struct _GtkMisc {
   GtkWidget widget ;
   gfloat xalign ;
   gfloat yalign ;
   guint16 xpad ;
   guint16 ypad ;
};
#line 62 "/usr/include/gtk-2.0/gtk/gtkmisc.h"
struct _GtkMiscClass {
   GtkWidgetClass parent_class ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkmenushell.h"
struct _GtkMenuShell ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkmenushell.h"
typedef struct _GtkMenuShell GtkMenuShell;
#line 49
struct _GtkMenuShellClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkmenushell.h"
typedef struct _GtkMenuShellClass GtkMenuShellClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkmenushell.h"
struct _GtkMenuShell {
   GtkContainer container ;
   GList *children ;
   GtkWidget *active_menu_item ;
   GtkWidget *parent_menu_shell ;
   guint button ;
   guint32 activate_time ;
   guint active ;
   guint have_grab ;
   guint have_xgrab ;
   guint ignore_leave ;
   guint menu_flag ;
   guint ignore_enter ;
   guint keyboard_mode ;
};
#line 71 "/usr/include/gtk-2.0/gtk/gtkmenushell.h"
struct _GtkMenuShellClass {
   GtkContainerClass parent_class ;
   guint submenu_placement ;
   void (*deactivate)(GtkMenuShell * ) ;
   void (*selection_done)(GtkMenuShell * ) ;
   void (*move_current)(GtkMenuShell * , GtkMenuDirectionType  ) ;
   void (*activate_current)(GtkMenuShell * , gboolean  ) ;
   void (*cancel)(GtkMenuShell * ) ;
   void (*select_item)(GtkMenuShell * , GtkWidget * ) ;
   void (*insert)(GtkMenuShell * , GtkWidget * , gint  ) ;
   gint (*get_popup_delay)(GtkMenuShell * ) ;
   gboolean (*move_selected)(GtkMenuShell * , gint  ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
};
#line 49 "/usr/include/gtk-2.0/gtk/gtkmenu.h"
struct _GtkMenu ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkmenu.h"
typedef struct _GtkMenu GtkMenu;
#line 50
struct _GtkMenuClass ;
#line 50 "/usr/include/gtk-2.0/gtk/gtkmenu.h"
typedef struct _GtkMenuClass GtkMenuClass;
#line 52 "/usr/include/gtk-2.0/gtk/gtkmenu.h"
typedef void (*GtkMenuPositionFunc)(GtkMenu * , gint * , gint * , gboolean * , gpointer  );
#line 57 "/usr/include/gtk-2.0/gtk/gtkmenu.h"
typedef void (*GtkMenuDetachFunc)(GtkWidget * , GtkMenu * );
#line 60 "/usr/include/gtk-2.0/gtk/gtkmenu.h"
struct _GtkMenu {
   GtkMenuShell menu_shell ;
   GtkWidget *parent_menu_item ;
   GtkWidget *old_active_menu_item ;
   GtkAccelGroup *accel_group ;
   gchar *accel_path ;
   GtkMenuPositionFunc position_func ;
   gpointer position_func_data ;
   guint toggle_size ;
   GtkWidget *toplevel ;
   GtkWidget *tearoff_window ;
   GtkWidget *tearoff_hbox ;
   GtkWidget *tearoff_scrollbar ;
   GtkAdjustment *tearoff_adjustment ;
   GdkWindow *view_window ;
   GdkWindow *bin_window ;
   gint scroll_offset ;
   gint saved_scroll_offset ;
   gint scroll_step ;
   guint timeout_id ;
   GdkRegion *navigation_region ;
   guint navigation_timeout ;
   guint needs_destruction_ref_count ;
   guint torn_off ;
   guint tearoff_active ;
   guint scroll_fast ;
   guint upper_arrow_visible ;
   guint lower_arrow_visible ;
   guint upper_arrow_prelight ;
   guint lower_arrow_prelight ;
};
#line 113 "/usr/include/gtk-2.0/gtk/gtkmenu.h"
struct _GtkMenuClass {
   GtkMenuShellClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 49 "/usr/include/gtk-2.0/gtk/gtklabel.h"
struct _GtkLabel ;
#line 49 "/usr/include/gtk-2.0/gtk/gtklabel.h"
typedef struct _GtkLabel GtkLabel;
#line 50
struct _GtkLabelClass ;
#line 50 "/usr/include/gtk-2.0/gtk/gtklabel.h"
typedef struct _GtkLabelClass GtkLabelClass;
#line 52
struct _GtkLabelSelectionInfo ;
#line 52 "/usr/include/gtk-2.0/gtk/gtklabel.h"
typedef struct _GtkLabelSelectionInfo GtkLabelSelectionInfo;
#line 54 "/usr/include/gtk-2.0/gtk/gtklabel.h"
struct _GtkLabel {
   GtkMisc misc ;
   gchar *label ;
   guint jtype ;
   guint wrap ;
   guint use_underline ;
   guint use_markup ;
   guint ellipsize ;
   guint single_line_mode ;
   guint have_transform ;
   guint in_click ;
   guint wrap_mode ;
   guint pattern_set ;
   guint track_links ;
   guint mnemonic_keyval ;
   gchar *text ;
   PangoAttrList *attrs ;
   PangoAttrList *effective_attrs ;
   PangoLayout *layout ;
   GtkWidget *mnemonic_widget ;
   GtkWindow *mnemonic_window ;
   GtkLabelSelectionInfo *select_info ;
};
#line 86 "/usr/include/gtk-2.0/gtk/gtklabel.h"
struct _GtkLabelClass {
   GtkMiscClass parent_class ;
   void (*move_cursor)(GtkLabel * , GtkMovementStep  , gint  , gboolean  ) ;
   void (*copy_clipboard)(GtkLabel * ) ;
   void (*populate_popup)(GtkLabel * , GtkMenu * ) ;
   gboolean (*activate_link)(GtkLabel * , gchar * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
};
#line 51 "/usr/include/gtk-2.0/gtk/gtkaccellabel.h"
struct _GtkAccelLabel ;
#line 51 "/usr/include/gtk-2.0/gtk/gtkaccellabel.h"
typedef struct _GtkAccelLabel GtkAccelLabel;
#line 52
struct _GtkAccelLabelClass ;
#line 52 "/usr/include/gtk-2.0/gtk/gtkaccellabel.h"
typedef struct _GtkAccelLabelClass GtkAccelLabelClass;
#line 60 "/usr/include/gtk-2.0/gtk/gtkaccellabel.h"
struct _GtkAccelLabel {
   GtkLabel label ;
   guint gtk_reserved ;
   guint accel_padding ;
   GtkWidget *accel_widget ;
   GClosure *accel_closure ;
   GtkAccelGroup *accel_group ;
   gchar *accel_string ;
   guint16 accel_string_width ;
};
#line 73 "/usr/include/gtk-2.0/gtk/gtkaccellabel.h"
struct _GtkAccelLabelClass {
   GtkLabelClass parent_class ;
   gchar *signal_quote1 ;
   gchar *signal_quote2 ;
   gchar *mod_name_shift ;
   gchar *mod_name_control ;
   gchar *mod_name_alt ;
   gchar *mod_separator ;
   gchar *accel_seperator ;
   guint latin1_to_char ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 40 "/usr/include/gtk-2.0/gtk/gtkaccelmap.h"
struct _GtkAccelMap ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkaccelmap.h"
typedef struct _GtkAccelMap GtkAccelMap;
#line 41
struct _GtkAccelMapClass ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkaccelmap.h"
typedef struct _GtkAccelMapClass GtkAccelMapClass;
#line 44 "/usr/include/gtk-2.0/gtk/gtkaccelmap.h"
typedef void (*GtkAccelMapForeach)(gpointer  , gchar * , guint  , GdkModifierType  ,
                                   gboolean  );
#line 39 "/usr/include/gtk-2.0/gtk/gtkaccessible.h"
struct _GtkAccessible ;
#line 39 "/usr/include/gtk-2.0/gtk/gtkaccessible.h"
typedef struct _GtkAccessible GtkAccessible;
#line 40
struct _GtkAccessibleClass ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkaccessible.h"
typedef struct _GtkAccessibleClass GtkAccessibleClass;
#line 45 "/usr/include/gtk-2.0/gtk/gtkaccessible.h"
struct _GtkAccessible {
   AtkObject parent ;
   GtkWidget *widget ;
};
#line 56 "/usr/include/gtk-2.0/gtk/gtkaccessible.h"
struct _GtkAccessibleClass {
   AtkObjectClass parent_class ;
   void (*connect_widget_destroyed)(GtkAccessible * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 49 "/usr/include/gtk-2.0/gtk/gtkaction.h"
struct _GtkAction ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkaction.h"
typedef struct _GtkAction GtkAction;
#line 50
struct _GtkActionClass ;
#line 50 "/usr/include/gtk-2.0/gtk/gtkaction.h"
typedef struct _GtkActionClass GtkActionClass;
#line 51
struct _GtkActionPrivate ;
#line 51 "/usr/include/gtk-2.0/gtk/gtkaction.h"
typedef struct _GtkActionPrivate GtkActionPrivate;
#line 53 "/usr/include/gtk-2.0/gtk/gtkaction.h"
struct _GtkAction {
   GObject object ;
   GtkActionPrivate *private_data ;
};
#line 62 "/usr/include/gtk-2.0/gtk/gtkaction.h"
struct _GtkActionClass {
   GObjectClass parent_class ;
   void (*activate)(GtkAction * ) ;
   GType menu_item_type ;
   GType toolbar_item_type ;
   GtkWidget *(*create_menu_item)(GtkAction * ) ;
   GtkWidget *(*create_tool_item)(GtkAction * ) ;
   void (*connect_proxy)(GtkAction * , GtkWidget * ) ;
   void (*disconnect_proxy)(GtkAction * , GtkWidget * ) ;
   GtkWidget *(*create_menu)(GtkAction * ) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 50 "/usr/include/gtk-2.0/gtk/gtkactiongroup.h"
struct _GtkActionGroup ;
#line 50 "/usr/include/gtk-2.0/gtk/gtkactiongroup.h"
typedef struct _GtkActionGroup GtkActionGroup;
#line 51
struct _GtkActionGroupPrivate ;
#line 51 "/usr/include/gtk-2.0/gtk/gtkactiongroup.h"
typedef struct _GtkActionGroupPrivate GtkActionGroupPrivate;
#line 52
struct _GtkActionGroupClass ;
#line 52 "/usr/include/gtk-2.0/gtk/gtkactiongroup.h"
typedef struct _GtkActionGroupClass GtkActionGroupClass;
#line 53
struct _GtkActionEntry ;
#line 53 "/usr/include/gtk-2.0/gtk/gtkactiongroup.h"
typedef struct _GtkActionEntry GtkActionEntry;
#line 54
struct _GtkToggleActionEntry ;
#line 54 "/usr/include/gtk-2.0/gtk/gtkactiongroup.h"
typedef struct _GtkToggleActionEntry GtkToggleActionEntry;
#line 55
struct _GtkRadioActionEntry ;
#line 55 "/usr/include/gtk-2.0/gtk/gtkactiongroup.h"
typedef struct _GtkRadioActionEntry GtkRadioActionEntry;
#line 57 "/usr/include/gtk-2.0/gtk/gtkactiongroup.h"
struct _GtkActionGroup {
   GObject parent ;
   GtkActionGroupPrivate *private_data ;
};
#line 66 "/usr/include/gtk-2.0/gtk/gtkactiongroup.h"
struct _GtkActionGroupClass {
   GObjectClass parent_class ;
   GtkAction *(*get_action)(GtkActionGroup * , gchar * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 80 "/usr/include/gtk-2.0/gtk/gtkactiongroup.h"
struct _GtkActionEntry {
   gchar *name ;
   gchar *stock_id ;
   gchar *label ;
   gchar *accelerator ;
   gchar *tooltip ;
   GCallback callback ;
};
#line 90 "/usr/include/gtk-2.0/gtk/gtkactiongroup.h"
struct _GtkToggleActionEntry {
   gchar *name ;
   gchar *stock_id ;
   gchar *label ;
   gchar *accelerator ;
   gchar *tooltip ;
   GCallback callback ;
   gboolean is_active ;
};
#line 101 "/usr/include/gtk-2.0/gtk/gtkactiongroup.h"
struct _GtkRadioActionEntry {
   gchar *name ;
   gchar *stock_id ;
   gchar *label ;
   gchar *accelerator ;
   gchar *tooltip ;
   gint value ;
};
#line 39 "/usr/include/gtk-2.0/gtk/gtkactivatable.h"
struct _GtkActivatable ;
#line 39 "/usr/include/gtk-2.0/gtk/gtkactivatable.h"
typedef struct _GtkActivatable GtkActivatable;
#line 40
struct _GtkActivatableIface ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkactivatable.h"
typedef struct _GtkActivatableIface GtkActivatableIface;
#line 56 "/usr/include/gtk-2.0/gtk/gtkactivatable.h"
struct _GtkActivatableIface {
   GTypeInterface g_iface ;
   void (*update)(GtkActivatable * , GtkAction * , gchar * ) ;
   void (*sync_action_properties)(GtkActivatable * , GtkAction * ) ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkalignment.h"
struct _GtkAlignment ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkalignment.h"
typedef struct _GtkAlignment GtkAlignment;
#line 49
struct _GtkAlignmentClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkalignment.h"
typedef struct _GtkAlignmentClass GtkAlignmentClass;
#line 50
struct _GtkAlignmentPrivate ;
#line 50 "/usr/include/gtk-2.0/gtk/gtkalignment.h"
typedef struct _GtkAlignmentPrivate GtkAlignmentPrivate;
#line 52 "/usr/include/gtk-2.0/gtk/gtkalignment.h"
struct _GtkAlignment {
   GtkBin bin ;
   gfloat xalign ;
   gfloat yalign ;
   gfloat xscale ;
   gfloat yscale ;
};
#line 62 "/usr/include/gtk-2.0/gtk/gtkalignment.h"
struct _GtkAlignmentClass {
   GtkBinClass parent_class ;
};
#line 49 "/usr/include/gtk-2.0/gtk/gtkarrow.h"
struct _GtkArrow ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkarrow.h"
typedef struct _GtkArrow GtkArrow;
#line 50
struct _GtkArrowClass ;
#line 50 "/usr/include/gtk-2.0/gtk/gtkarrow.h"
typedef struct _GtkArrowClass GtkArrowClass;
#line 52 "/usr/include/gtk-2.0/gtk/gtkarrow.h"
struct _GtkArrow {
   GtkMisc misc ;
   gint16 arrow_type ;
   gint16 shadow_type ;
};
#line 60 "/usr/include/gtk-2.0/gtk/gtkarrow.h"
struct _GtkArrowClass {
   GtkMiscClass parent_class ;
};
#line 49 "/usr/include/gtk-2.0/gtk/gtkframe.h"
struct _GtkFrame ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkframe.h"
typedef struct _GtkFrame GtkFrame;
#line 50
struct _GtkFrameClass ;
#line 50 "/usr/include/gtk-2.0/gtk/gtkframe.h"
typedef struct _GtkFrameClass GtkFrameClass;
#line 52 "/usr/include/gtk-2.0/gtk/gtkframe.h"
struct _GtkFrame {
   GtkBin bin ;
   GtkWidget *label_widget ;
   gint16 shadow_type ;
   gfloat label_xalign ;
   gfloat label_yalign ;
   GtkAllocation child_allocation ;
};
#line 64 "/usr/include/gtk-2.0/gtk/gtkframe.h"
struct _GtkFrameClass {
   GtkBinClass parent_class ;
   void (*compute_child_allocation)(GtkFrame * , GtkAllocation * ) ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkaspectframe.h"
struct _GtkAspectFrame ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkaspectframe.h"
typedef struct _GtkAspectFrame GtkAspectFrame;
#line 49
struct _GtkAspectFrameClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkaspectframe.h"
typedef struct _GtkAspectFrameClass GtkAspectFrameClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkaspectframe.h"
struct _GtkAspectFrame {
   GtkFrame frame ;
   gfloat xalign ;
   gfloat yalign ;
   gfloat ratio ;
   gboolean obey_child ;
   GtkAllocation center_allocation ;
};
#line 63 "/usr/include/gtk-2.0/gtk/gtkaspectframe.h"
struct _GtkAspectFrameClass {
   GtkFrameClass parent_class ;
};
#line 63 "/usr/include/gtk-2.0/gtk/gtkassistant.h"
enum __anonenum__571 {
    GTK_ASSISTANT_PAGE_CONTENT = 0,
    GTK_ASSISTANT_PAGE_INTRO = 1,
    GTK_ASSISTANT_PAGE_CONFIRM = 2,
    GTK_ASSISTANT_PAGE_SUMMARY = 3,
    GTK_ASSISTANT_PAGE_PROGRESS = 4
} ;
#line 70 "/usr/include/gtk-2.0/gtk/gtkassistant.h"
typedef enum __anonenum__571 GtkAssistantPageType;
#line 72
struct _GtkAssistant ;
#line 72 "/usr/include/gtk-2.0/gtk/gtkassistant.h"
typedef struct _GtkAssistant GtkAssistant;
#line 73
struct _GtkAssistantPrivate ;
#line 73 "/usr/include/gtk-2.0/gtk/gtkassistant.h"
typedef struct _GtkAssistantPrivate GtkAssistantPrivate;
#line 74
struct _GtkAssistantClass ;
#line 74 "/usr/include/gtk-2.0/gtk/gtkassistant.h"
typedef struct _GtkAssistantClass GtkAssistantClass;
#line 76 "/usr/include/gtk-2.0/gtk/gtkassistant.h"
struct _GtkAssistant {
   GtkWindow parent ;
   GtkWidget *cancel ;
   GtkWidget *forward ;
   GtkWidget *back ;
   GtkWidget *apply ;
   GtkWidget *close ;
   GtkWidget *last ;
   GtkAssistantPrivate *priv ;
};
#line 91 "/usr/include/gtk-2.0/gtk/gtkassistant.h"
struct _GtkAssistantClass {
   GtkWindowClass parent_class ;
   void (*prepare)(GtkAssistant * , GtkWidget * ) ;
   void (*apply)(GtkAssistant * ) ;
   void (*close)(GtkAssistant * ) ;
   void (*cancel)(GtkAssistant * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
   void (*_gtk_reserved5)(void) ;
};
#line 120 "/usr/include/gtk-2.0/gtk/gtkassistant.h"
typedef gint (*GtkAssistantPageFunc)(gint  , gpointer  );
#line 49 "/usr/include/gtk-2.0/gtk/gtkbox.h"
struct _GtkBox ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkbox.h"
typedef struct _GtkBox GtkBox;
#line 50
struct _GtkBoxClass ;
#line 50 "/usr/include/gtk-2.0/gtk/gtkbox.h"
typedef struct _GtkBoxClass GtkBoxClass;
#line 52 "/usr/include/gtk-2.0/gtk/gtkbox.h"
struct _GtkBox {
   GtkContainer container ;
   GList *children ;
   gint16 spacing ;
   guint homogeneous ;
};
#line 62 "/usr/include/gtk-2.0/gtk/gtkbox.h"
struct _GtkBoxClass {
   GtkContainerClass parent_class ;
};
#line 92
struct _GtkBoxChild ;
#line 92 "/usr/include/gtk-2.0/gtk/gtkbox.h"
typedef struct _GtkBoxChild GtkBoxChild;
#line 93 "/usr/include/gtk-2.0/gtk/gtkbox.h"
struct _GtkBoxChild {
   GtkWidget *widget ;
   guint16 padding ;
   guint expand ;
   guint fill ;
   guint pack ;
   guint is_secondary ;
};
#line 49 "/usr/include/gtk-2.0/gtk/gtkbbox.h"
struct _GtkButtonBox ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkbbox.h"
typedef struct _GtkButtonBox GtkButtonBox;
#line 50
struct _GtkButtonBoxClass ;
#line 50 "/usr/include/gtk-2.0/gtk/gtkbbox.h"
typedef struct _GtkButtonBoxClass GtkButtonBoxClass;
#line 52 "/usr/include/gtk-2.0/gtk/gtkbbox.h"
struct _GtkButtonBox {
   GtkBox box ;
   gint child_min_width ;
   gint child_min_height ;
   gint child_ipad_x ;
   gint child_ipad_y ;
   GtkButtonBoxStyle layout_style ;
};
#line 62 "/usr/include/gtk-2.0/gtk/gtkbbox.h"
struct _GtkButtonBoxClass {
   GtkBoxClass parent_class ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkbindings.h"
struct _GtkBindingSet ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkbindings.h"
typedef struct _GtkBindingSet GtkBindingSet;
#line 49
struct _GtkBindingEntry ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkbindings.h"
typedef struct _GtkBindingEntry GtkBindingEntry;
#line 50
struct _GtkBindingSignal ;
#line 50 "/usr/include/gtk-2.0/gtk/gtkbindings.h"
typedef struct _GtkBindingSignal GtkBindingSignal;
#line 51
struct _GtkBindingArg ;
#line 51 "/usr/include/gtk-2.0/gtk/gtkbindings.h"
typedef struct _GtkBindingArg GtkBindingArg;
#line 53 "/usr/include/gtk-2.0/gtk/gtkbindings.h"
struct _GtkBindingSet {
   gchar *set_name ;
   gint priority ;
   GSList *widget_path_pspecs ;
   GSList *widget_class_pspecs ;
   GSList *class_branch_pspecs ;
   GtkBindingEntry *entries ;
   GtkBindingEntry *current ;
   guint parsed ;
};
#line 65 "/usr/include/gtk-2.0/gtk/gtkbindings.h"
struct _GtkBindingEntry {
   guint keyval ;
   GdkModifierType modifiers ;
   GtkBindingSet *binding_set ;
   guint destroyed ;
   guint in_emission ;
   guint marks_unbound ;
   GtkBindingEntry *set_next ;
   GtkBindingEntry *hash_next ;
   GtkBindingSignal *signals ;
};
#line 84 "/usr/include/gtk-2.0/gtk/gtkbindings.h"
union __anonunion_572 {
   glong long_data ;
   gdouble double_data ;
   gchar *string_data ;
};
#line 81 "/usr/include/gtk-2.0/gtk/gtkbindings.h"
struct _GtkBindingArg {
   GType arg_type ;
   union __anonunion_572 d ;
};
#line 91 "/usr/include/gtk-2.0/gtk/gtkbindings.h"
struct _GtkBindingSignal {
   GtkBindingSignal *next ;
   gchar *signal_name ;
   guint n_args ;
   GtkBindingArg *args ;
};
#line 42 "/usr/include/gtk-2.0/gtk/gtkbuilder.h"
struct _GtkBuilder ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkbuilder.h"
typedef struct _GtkBuilder GtkBuilder;
#line 43
struct _GtkBuilderClass ;
#line 43 "/usr/include/gtk-2.0/gtk/gtkbuilder.h"
typedef struct _GtkBuilderClass GtkBuilderClass;
#line 44
struct _GtkBuilderPrivate ;
#line 44 "/usr/include/gtk-2.0/gtk/gtkbuilder.h"
typedef struct _GtkBuilderPrivate GtkBuilderPrivate;
#line 46
enum __anonenum__573 {
    GTK_BUILDER_ERROR_INVALID_TYPE_FUNCTION = 0,
    GTK_BUILDER_ERROR_UNHANDLED_TAG = 1,
    GTK_BUILDER_ERROR_MISSING_ATTRIBUTE = 2,
    GTK_BUILDER_ERROR_INVALID_ATTRIBUTE = 3,
    GTK_BUILDER_ERROR_INVALID_TAG = 4,
    GTK_BUILDER_ERROR_MISSING_PROPERTY_VALUE = 5,
    GTK_BUILDER_ERROR_INVALID_VALUE = 6,
    GTK_BUILDER_ERROR_VERSION_MISMATCH = 7,
    GTK_BUILDER_ERROR_DUPLICATE_ID = 8
} ;
#line 57 "/usr/include/gtk-2.0/gtk/gtkbuilder.h"
typedef enum __anonenum__573 GtkBuilderError;
#line 61 "/usr/include/gtk-2.0/gtk/gtkbuilder.h"
struct _GtkBuilder {
   GObject parent_instance ;
   GtkBuilderPrivate *priv ;
};
#line 68 "/usr/include/gtk-2.0/gtk/gtkbuilder.h"
struct _GtkBuilderClass {
   GObjectClass parent_class ;
   GType (*get_type_from_name)(GtkBuilder * , char const   * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
   void (*_gtk_reserved5)(void) ;
   void (*_gtk_reserved6)(void) ;
   void (*_gtk_reserved7)(void) ;
   void (*_gtk_reserved8)(void) ;
};
#line 86 "/usr/include/gtk-2.0/gtk/gtkbuilder.h"
typedef void (*GtkBuilderConnectFunc)(GtkBuilder * , GObject * , gchar * , gchar * ,
                                      GObject * , GConnectFlags  , gpointer  );
#line 40 "/usr/include/gtk-2.0/gtk/gtkbuildable.h"
struct _GtkBuildable ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkbuildable.h"
typedef struct _GtkBuildable GtkBuildable;
#line 41
struct _GtkBuildableIface ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkbuildable.h"
typedef struct _GtkBuildableIface GtkBuildableIface;
#line 92 "/usr/include/gtk-2.0/gtk/gtkbuildable.h"
struct _GtkBuildableIface {
   GTypeInterface g_iface ;
   void (*set_name)(GtkBuildable * , gchar * ) ;
   gchar *(*get_name)(GtkBuildable * ) ;
   void (*add_child)(GtkBuildable * , GtkBuilder * , GObject * , gchar * ) ;
   void (*set_buildable_property)(GtkBuildable * , GtkBuilder * , gchar * , GValue * ) ;
   GObject *(*construct_child)(GtkBuildable * , GtkBuilder * , gchar * ) ;
   gboolean (*custom_tag_start)(GtkBuildable * , GtkBuilder * , GObject * , gchar * ,
                                GMarkupParser * , gpointer * ) ;
   void (*custom_tag_end)(GtkBuildable * , GtkBuilder * , GObject * , gchar * , gpointer * ) ;
   void (*custom_finished)(GtkBuildable * , GtkBuilder * , GObject * , gchar * , gpointer  ) ;
   void (*parser_finished)(GtkBuildable * , GtkBuilder * ) ;
   GObject *(*get_internal_child)(GtkBuildable * , GtkBuilder * , gchar * ) ;
};
#line 49 "/usr/include/gtk-2.0/gtk/gtkimage.h"
struct _GtkImage ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkimage.h"
typedef struct _GtkImage GtkImage;
#line 50
struct _GtkImageClass ;
#line 50 "/usr/include/gtk-2.0/gtk/gtkimage.h"
typedef struct _GtkImageClass GtkImageClass;
#line 52
struct _GtkImagePixmapData ;
#line 52 "/usr/include/gtk-2.0/gtk/gtkimage.h"
typedef struct _GtkImagePixmapData GtkImagePixmapData;
#line 53
struct _GtkImageImageData ;
#line 53 "/usr/include/gtk-2.0/gtk/gtkimage.h"
typedef struct _GtkImageImageData GtkImageImageData;
#line 54
struct _GtkImagePixbufData ;
#line 54 "/usr/include/gtk-2.0/gtk/gtkimage.h"
typedef struct _GtkImagePixbufData GtkImagePixbufData;
#line 55
struct _GtkImageStockData ;
#line 55 "/usr/include/gtk-2.0/gtk/gtkimage.h"
typedef struct _GtkImageStockData GtkImageStockData;
#line 56
struct _GtkImageIconSetData ;
#line 56 "/usr/include/gtk-2.0/gtk/gtkimage.h"
typedef struct _GtkImageIconSetData GtkImageIconSetData;
#line 57
struct _GtkImageAnimationData ;
#line 57 "/usr/include/gtk-2.0/gtk/gtkimage.h"
typedef struct _GtkImageAnimationData GtkImageAnimationData;
#line 58
struct _GtkImageIconNameData ;
#line 58 "/usr/include/gtk-2.0/gtk/gtkimage.h"
typedef struct _GtkImageIconNameData GtkImageIconNameData;
#line 59
struct _GtkImageGIconData ;
#line 59 "/usr/include/gtk-2.0/gtk/gtkimage.h"
typedef struct _GtkImageGIconData GtkImageGIconData;
#line 61 "/usr/include/gtk-2.0/gtk/gtkimage.h"
struct _GtkImagePixmapData {
   GdkPixmap *pixmap ;
};
#line 66 "/usr/include/gtk-2.0/gtk/gtkimage.h"
struct _GtkImageImageData {
   GdkImage *image ;
};
#line 71 "/usr/include/gtk-2.0/gtk/gtkimage.h"
struct _GtkImagePixbufData {
   GdkPixbuf *pixbuf ;
};
#line 76 "/usr/include/gtk-2.0/gtk/gtkimage.h"
struct _GtkImageStockData {
   gchar *stock_id ;
};
#line 81 "/usr/include/gtk-2.0/gtk/gtkimage.h"
struct _GtkImageIconSetData {
   GtkIconSet *icon_set ;
};
#line 86 "/usr/include/gtk-2.0/gtk/gtkimage.h"
struct _GtkImageAnimationData {
   GdkPixbufAnimation *anim ;
   GdkPixbufAnimationIter *iter ;
   guint frame_timeout ;
};
#line 93 "/usr/include/gtk-2.0/gtk/gtkimage.h"
struct _GtkImageIconNameData {
   gchar *icon_name ;
   GdkPixbuf *pixbuf ;
   guint theme_change_id ;
};
#line 100 "/usr/include/gtk-2.0/gtk/gtkimage.h"
struct _GtkImageGIconData {
   GIcon *icon ;
   GdkPixbuf *pixbuf ;
   guint theme_change_id ;
};
#line 129
enum __anonenum__574 {
    GTK_IMAGE_EMPTY = 0,
    GTK_IMAGE_PIXMAP = 1,
    GTK_IMAGE_IMAGE = 2,
    GTK_IMAGE_PIXBUF = 3,
    GTK_IMAGE_STOCK = 4,
    GTK_IMAGE_ICON_SET = 5,
    GTK_IMAGE_ANIMATION = 6,
    GTK_IMAGE_ICON_NAME = 7,
    GTK_IMAGE_GICON = 8
} ;
#line 140 "/usr/include/gtk-2.0/gtk/gtkimage.h"
typedef enum __anonenum__574 GtkImageType;
#line 154 "/usr/include/gtk-2.0/gtk/gtkimage.h"
union __anonunion_575 {
   GtkImagePixmapData pixmap ;
   GtkImageImageData image ;
   GtkImagePixbufData pixbuf ;
   GtkImageStockData stock ;
   GtkImageIconSetData icon_set ;
   GtkImageAnimationData anim ;
   GtkImageIconNameData name ;
   GtkImageGIconData gicon ;
};
#line 148 "/usr/include/gtk-2.0/gtk/gtkimage.h"
struct _GtkImage {
   GtkMisc misc ;
   GtkImageType storage_type ;
   union __anonunion_575 data ;
   GdkBitmap *mask ;
   GtkIconSize icon_size ;
};
#line 173 "/usr/include/gtk-2.0/gtk/gtkimage.h"
struct _GtkImageClass {
   GtkMiscClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkbutton.h"
struct _GtkButton ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkbutton.h"
typedef struct _GtkButton GtkButton;
#line 49
struct _GtkButtonClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkbutton.h"
typedef struct _GtkButtonClass GtkButtonClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkbutton.h"
struct _GtkButton {
   GtkBin bin ;
   GdkWindow *event_window ;
   gchar *label_text ;
   guint activate_timeout ;
   guint constructed ;
   guint in_button ;
   guint button_down ;
   guint relief ;
   guint use_underline ;
   guint use_stock ;
   guint depressed ;
   guint depress_on_activate ;
   guint focus_on_click ;
};
#line 72 "/usr/include/gtk-2.0/gtk/gtkbutton.h"
struct _GtkButtonClass {
   GtkBinClass parent_class ;
   void (*pressed)(GtkButton * ) ;
   void (*released)(GtkButton * ) ;
   void (*clicked)(GtkButton * ) ;
   void (*enter)(GtkButton * ) ;
   void (*leave)(GtkButton * ) ;
   void (*activate)(GtkButton * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 53 "/usr/include/gtk-2.0/gtk/gtkcalendar.h"
struct _GtkCalendar ;
#line 53 "/usr/include/gtk-2.0/gtk/gtkcalendar.h"
typedef struct _GtkCalendar GtkCalendar;
#line 54
struct _GtkCalendarClass ;
#line 54 "/usr/include/gtk-2.0/gtk/gtkcalendar.h"
typedef struct _GtkCalendarClass GtkCalendarClass;
#line 56
struct _GtkCalendarPrivate ;
#line 56 "/usr/include/gtk-2.0/gtk/gtkcalendar.h"
typedef struct _GtkCalendarPrivate GtkCalendarPrivate;
#line 72
enum __anonenum__576 {
    GTK_CALENDAR_SHOW_HEADING = 1,
    GTK_CALENDAR_SHOW_DAY_NAMES = 2,
    GTK_CALENDAR_NO_MONTH_CHANGE = 4,
    GTK_CALENDAR_SHOW_WEEK_NUMBERS = 8,
    GTK_CALENDAR_WEEK_START_MONDAY = 16,
    GTK_CALENDAR_SHOW_DETAILS = 32
} ;
#line 80 "/usr/include/gtk-2.0/gtk/gtkcalendar.h"
typedef enum __anonenum__576 GtkCalendarDisplayOptions;
#line 99 "/usr/include/gtk-2.0/gtk/gtkcalendar.h"
typedef gchar *(*GtkCalendarDetailFunc)(GtkCalendar * , guint  , guint  , guint  ,
                                        gpointer  );
#line 105 "/usr/include/gtk-2.0/gtk/gtkcalendar.h"
struct _GtkCalendar {
   GtkWidget widget ;
   GtkStyle *header_style ;
   GtkStyle *label_style ;
   gint month ;
   gint year ;
   gint selected_day ;
   gint day_month[6][7] ;
   gint day[6][7] ;
   gint num_marked_dates ;
   gint marked_date[31] ;
   GtkCalendarDisplayOptions display_flags ;
   GdkColor marked_date_color[31] ;
   GdkGC *gc ;
   GdkGC *xor_gc ;
   gint focus_row ;
   gint focus_col ;
   gint highlight_row ;
   gint highlight_col ;
   GtkCalendarPrivate *priv ;
   gchar grow_space[32] ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 143 "/usr/include/gtk-2.0/gtk/gtkcalendar.h"
struct _GtkCalendarClass {
   GtkWidgetClass parent_class ;
   void (*month_changed)(GtkCalendar * ) ;
   void (*day_selected)(GtkCalendar * ) ;
   void (*day_selected_double_click)(GtkCalendar * ) ;
   void (*prev_month)(GtkCalendar * ) ;
   void (*next_month)(GtkCalendar * ) ;
   void (*prev_year)(GtkCalendar * ) ;
   void (*next_year)(GtkCalendar * ) ;
};
#line 37 "/usr/include/gtk-2.0/gtk/gtkcelleditable.h"
struct _GtkCellEditable ;
#line 37 "/usr/include/gtk-2.0/gtk/gtkcelleditable.h"
typedef struct _GtkCellEditable GtkCellEditable;
#line 38
struct _GtkCellEditableIface ;
#line 38 "/usr/include/gtk-2.0/gtk/gtkcelleditable.h"
typedef struct _GtkCellEditableIface GtkCellEditableIface;
#line 40 "/usr/include/gtk-2.0/gtk/gtkcelleditable.h"
struct _GtkCellEditableIface {
   GTypeInterface g_iface ;
   void (*editing_done)(GtkCellEditable * ) ;
   void (*remove_widget)(GtkCellEditable * ) ;
   void (*start_editing)(GtkCellEditable * , GdkEvent * ) ;
};
#line 31 "/usr/include/gtk-2.0/gtk/gtkcellrenderer.h"
enum __anonenum__577 {
    GTK_CELL_RENDERER_SELECTED = 1,
    GTK_CELL_RENDERER_PRELIT = 2,
    GTK_CELL_RENDERER_INSENSITIVE = 4,
    GTK_CELL_RENDERER_SORTED = 8,
    GTK_CELL_RENDERER_FOCUSED = 16
} ;
#line 39 "/usr/include/gtk-2.0/gtk/gtkcellrenderer.h"
typedef enum __anonenum__577 GtkCellRendererState;
#line 41
enum __anonenum__578 {
    GTK_CELL_RENDERER_MODE_INERT = 0,
    GTK_CELL_RENDERER_MODE_ACTIVATABLE = 1,
    GTK_CELL_RENDERER_MODE_EDITABLE = 2
} ;
#line 46 "/usr/include/gtk-2.0/gtk/gtkcellrenderer.h"
typedef enum __anonenum__578 GtkCellRendererMode;
#line 55
struct _GtkCellRenderer ;
#line 55 "/usr/include/gtk-2.0/gtk/gtkcellrenderer.h"
typedef struct _GtkCellRenderer GtkCellRenderer;
#line 56
struct _GtkCellRendererClass ;
#line 56 "/usr/include/gtk-2.0/gtk/gtkcellrenderer.h"
typedef struct _GtkCellRendererClass GtkCellRendererClass;
#line 58 "/usr/include/gtk-2.0/gtk/gtkcellrenderer.h"
struct _GtkCellRenderer {
   GtkObject parent ;
   gfloat xalign ;
   gfloat yalign ;
   gint width ;
   gint height ;
   guint16 xpad ;
   guint16 ypad ;
   guint mode ;
   guint visible ;
   guint is_expander ;
   guint is_expanded ;
   guint cell_background_set ;
   guint sensitive ;
   guint editing ;
};
#line 80 "/usr/include/gtk-2.0/gtk/gtkcellrenderer.h"
struct _GtkCellRendererClass {
   GtkObjectClass parent_class ;
   void (*get_size)(GtkCellRenderer * , GtkWidget * , GdkRectangle * , gint * , gint * ,
                    gint * , gint * ) ;
   void (*render)(GtkCellRenderer * , GdkDrawable * , GtkWidget * , GdkRectangle * ,
                  GdkRectangle * , GdkRectangle * , GtkCellRendererState  ) ;
   gboolean (*activate)(GtkCellRenderer * , GdkEvent * , GtkWidget * , gchar * , GdkRectangle * ,
                        GdkRectangle * , GtkCellRendererState  ) ;
   GtkCellEditable *(*start_editing)(GtkCellRenderer * , GdkEvent * , GtkWidget * ,
                                     gchar * , GdkRectangle * , GdkRectangle * , GtkCellRendererState  ) ;
   void (*editing_canceled)(GtkCellRenderer * ) ;
   void (*editing_started)(GtkCellRenderer * , GtkCellEditable * , gchar * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
};
#line 43 "/usr/include/gtk-2.0/gtk/gtktreemodel.h"
struct _GtkTreeIter ;
#line 43 "/usr/include/gtk-2.0/gtk/gtktreemodel.h"
typedef struct _GtkTreeIter GtkTreeIter;
#line 44
struct _GtkTreePath ;
#line 44 "/usr/include/gtk-2.0/gtk/gtktreemodel.h"
typedef struct _GtkTreePath GtkTreePath;
#line 45
struct _GtkTreeRowReference ;
#line 45 "/usr/include/gtk-2.0/gtk/gtktreemodel.h"
typedef struct _GtkTreeRowReference GtkTreeRowReference;
#line 46
struct _GtkTreeModel ;
#line 46 "/usr/include/gtk-2.0/gtk/gtktreemodel.h"
typedef struct _GtkTreeModel GtkTreeModel;
#line 47
struct _GtkTreeModelIface ;
#line 47 "/usr/include/gtk-2.0/gtk/gtktreemodel.h"
typedef struct _GtkTreeModelIface GtkTreeModelIface;
#line 48 "/usr/include/gtk-2.0/gtk/gtktreemodel.h"
typedef gboolean (*GtkTreeModelForeachFunc)(GtkTreeModel * , GtkTreePath * , GtkTreeIter * ,
                                            gpointer  );
#line 51
enum __anonenum__579 {
    GTK_TREE_MODEL_ITERS_PERSIST = 1,
    GTK_TREE_MODEL_LIST_ONLY = 2
} ;
#line 55 "/usr/include/gtk-2.0/gtk/gtktreemodel.h"
typedef enum __anonenum__579 GtkTreeModelFlags;
#line 57 "/usr/include/gtk-2.0/gtk/gtktreemodel.h"
struct _GtkTreeIter {
   gint stamp ;
   gpointer user_data ;
   gpointer user_data2 ;
   gpointer user_data3 ;
};
#line 65 "/usr/include/gtk-2.0/gtk/gtktreemodel.h"
struct _GtkTreeModelIface {
   GTypeInterface g_iface ;
   void (*row_changed)(GtkTreeModel * , GtkTreePath * , GtkTreeIter * ) ;
   void (*row_inserted)(GtkTreeModel * , GtkTreePath * , GtkTreeIter * ) ;
   void (*row_has_child_toggled)(GtkTreeModel * , GtkTreePath * , GtkTreeIter * ) ;
   void (*row_deleted)(GtkTreeModel * , GtkTreePath * ) ;
   void (*rows_reordered)(GtkTreeModel * , GtkTreePath * , GtkTreeIter * , gint * ) ;
   GtkTreeModelFlags (*get_flags)(GtkTreeModel * ) ;
   gint (*get_n_columns)(GtkTreeModel * ) ;
   GType (*get_column_type)(GtkTreeModel * , gint  ) ;
   gboolean (*get_iter)(GtkTreeModel * , GtkTreeIter * , GtkTreePath * ) ;
   GtkTreePath *(*get_path)(GtkTreeModel * , GtkTreeIter * ) ;
   void (*get_value)(GtkTreeModel * , GtkTreeIter * , gint  , GValue * ) ;
   gboolean (*iter_next)(GtkTreeModel * , GtkTreeIter * ) ;
   gboolean (*iter_children)(GtkTreeModel * , GtkTreeIter * , GtkTreeIter * ) ;
   gboolean (*iter_has_child)(GtkTreeModel * , GtkTreeIter * ) ;
   gint (*iter_n_children)(GtkTreeModel * , GtkTreeIter * ) ;
   gboolean (*iter_nth_child)(GtkTreeModel * , GtkTreeIter * , GtkTreeIter * , gint  ) ;
   gboolean (*iter_parent)(GtkTreeModel * , GtkTreeIter * , GtkTreeIter * ) ;
   void (*ref_node)(GtkTreeModel * , GtkTreeIter * ) ;
   void (*unref_node)(GtkTreeModel * , GtkTreeIter * ) ;
};
#line 40 "/usr/include/gtk-2.0/gtk/gtktreesortable.h"
enum __anonenum__580 {
    GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID = -1,
    GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID = -2
} ;
#line 45
struct _GtkTreeSortable ;
#line 45 "/usr/include/gtk-2.0/gtk/gtktreesortable.h"
typedef struct _GtkTreeSortable GtkTreeSortable;
#line 46
struct _GtkTreeSortableIface ;
#line 46 "/usr/include/gtk-2.0/gtk/gtktreesortable.h"
typedef struct _GtkTreeSortableIface GtkTreeSortableIface;
#line 48 "/usr/include/gtk-2.0/gtk/gtktreesortable.h"
typedef gint (*GtkTreeIterCompareFunc)(GtkTreeModel * , GtkTreeIter * , GtkTreeIter * ,
                                       gpointer  );
#line 54 "/usr/include/gtk-2.0/gtk/gtktreesortable.h"
struct _GtkTreeSortableIface {
   GTypeInterface g_iface ;
   void (*sort_column_changed)(GtkTreeSortable * ) ;
   gboolean (*get_sort_column_id)(GtkTreeSortable * , gint * , GtkSortType * ) ;
   void (*set_sort_column_id)(GtkTreeSortable * , gint  , GtkSortType  ) ;
   void (*set_sort_func)(GtkTreeSortable * , gint  , GtkTreeIterCompareFunc  , gpointer  ,
                         GDestroyNotify  ) ;
   void (*set_default_sort_func)(GtkTreeSortable * , GtkTreeIterCompareFunc  , gpointer  ,
                                 GDestroyNotify  ) ;
   gboolean (*has_default_sort_func)(GtkTreeSortable * ) ;
};
#line 45 "/usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h"
enum __anonenum__581 {
    GTK_TREE_VIEW_COLUMN_GROW_ONLY = 0,
    GTK_TREE_VIEW_COLUMN_AUTOSIZE = 1,
    GTK_TREE_VIEW_COLUMN_FIXED = 2
} ;
#line 50 "/usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h"
typedef enum __anonenum__581 GtkTreeViewColumnSizing;
#line 52
struct _GtkTreeViewColumn ;
#line 52 "/usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h"
typedef struct _GtkTreeViewColumn GtkTreeViewColumn;
#line 53
struct _GtkTreeViewColumnClass ;
#line 53 "/usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h"
typedef struct _GtkTreeViewColumnClass GtkTreeViewColumnClass;
#line 55 "/usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h"
typedef void (*GtkTreeCellDataFunc)(GtkTreeViewColumn * , GtkCellRenderer * , GtkTreeModel * ,
                                    GtkTreeIter * , gpointer  );
#line 62 "/usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h"
struct _GtkTreeViewColumn {
   GtkObject parent ;
   GtkWidget *tree_view ;
   GtkWidget *button ;
   GtkWidget *child ;
   GtkWidget *arrow ;
   GtkWidget *alignment ;
   GdkWindow *window ;
   GtkCellEditable *editable_widget ;
   gfloat xalign ;
   guint property_changed_signal ;
   gint spacing ;
   GtkTreeViewColumnSizing column_type ;
   gint requested_width ;
   gint button_request ;
   gint resized_width ;
   gint width ;
   gint fixed_width ;
   gint min_width ;
   gint max_width ;
   gint drag_x ;
   gint drag_y ;
   gchar *title ;
   GList *cell_list ;
   guint sort_clicked_signal ;
   guint sort_column_changed_signal ;
   gint sort_column_id ;
   GtkSortType sort_order ;
   guint visible ;
   guint resizable ;
   guint clickable ;
   guint dirty ;
   guint show_sort_indicator ;
   guint maybe_reordered ;
   guint reorderable ;
   guint use_resized_width ;
   guint expand ;
};
#line 113 "/usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h"
struct _GtkTreeViewColumnClass {
   GtkObjectClass parent_class ;
   void (*clicked)(GtkTreeViewColumn * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 39 "/usr/include/gtk-2.0/gtk/gtkcelllayout.h"
struct _GtkCellLayout ;
#line 39 "/usr/include/gtk-2.0/gtk/gtkcelllayout.h"
typedef struct _GtkCellLayout GtkCellLayout;
#line 40
struct _GtkCellLayoutIface ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkcelllayout.h"
typedef struct _GtkCellLayoutIface GtkCellLayoutIface;
#line 43 "/usr/include/gtk-2.0/gtk/gtkcelllayout.h"
typedef void (*GtkCellLayoutDataFunc)(GtkCellLayout * , GtkCellRenderer * , GtkTreeModel * ,
                                      GtkTreeIter * , gpointer  );
#line 49 "/usr/include/gtk-2.0/gtk/gtkcelllayout.h"
struct _GtkCellLayoutIface {
   GTypeInterface g_iface ;
   void (*pack_start)(GtkCellLayout * , GtkCellRenderer * , gboolean  ) ;
   void (*pack_end)(GtkCellLayout * , GtkCellRenderer * , gboolean  ) ;
   void (*clear)(GtkCellLayout * ) ;
   void (*add_attribute)(GtkCellLayout * , GtkCellRenderer * , gchar * , gint  ) ;
   void (*set_cell_data_func)(GtkCellLayout * , GtkCellRenderer * , GtkCellLayoutDataFunc  ,
                              gpointer  , GDestroyNotify  ) ;
   void (*clear_attributes)(GtkCellLayout * , GtkCellRenderer * ) ;
   void (*reorder)(GtkCellLayout * , GtkCellRenderer * , gint  ) ;
   GList *(*get_cells)(GtkCellLayout * ) ;
};
#line 41 "/usr/include/gtk-2.0/gtk/gtkcellrenderertext.h"
struct _GtkCellRendererText ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkcellrenderertext.h"
typedef struct _GtkCellRendererText GtkCellRendererText;
#line 42
struct _GtkCellRendererTextClass ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkcellrenderertext.h"
typedef struct _GtkCellRendererTextClass GtkCellRendererTextClass;
#line 44 "/usr/include/gtk-2.0/gtk/gtkcellrenderertext.h"
struct _GtkCellRendererText {
   GtkCellRenderer parent ;
   gchar *text ;
   PangoFontDescription *font ;
   gdouble font_scale ;
   PangoColor foreground ;
   PangoColor background ;
   PangoAttrList *extra_attrs ;
   PangoUnderline underline_style ;
   gint rise ;
   gint fixed_height_rows ;
   guint strikethrough ;
   guint editable ;
   guint scale_set ;
   guint foreground_set ;
   guint background_set ;
   guint underline_set ;
   guint rise_set ;
   guint strikethrough_set ;
   guint editable_set ;
   guint calc_fixed_height ;
};
#line 81 "/usr/include/gtk-2.0/gtk/gtkcellrenderertext.h"
struct _GtkCellRendererTextClass {
   GtkCellRendererClass parent_class ;
   void (*edited)(GtkCellRendererText * , gchar * , gchar * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 38 "/usr/include/gtk-2.0/gtk/gtkcellrendereraccel.h"
struct _GtkCellRendererAccel ;
#line 38 "/usr/include/gtk-2.0/gtk/gtkcellrendereraccel.h"
typedef struct _GtkCellRendererAccel GtkCellRendererAccel;
#line 39
struct _GtkCellRendererAccelClass ;
#line 39 "/usr/include/gtk-2.0/gtk/gtkcellrendereraccel.h"
typedef struct _GtkCellRendererAccelClass GtkCellRendererAccelClass;
#line 42
enum __anonenum__582 {
    GTK_CELL_RENDERER_ACCEL_MODE_GTK = 0,
    GTK_CELL_RENDERER_ACCEL_MODE_OTHER = 1
} ;
#line 46 "/usr/include/gtk-2.0/gtk/gtkcellrendereraccel.h"
typedef enum __anonenum__582 GtkCellRendererAccelMode;
#line 49 "/usr/include/gtk-2.0/gtk/gtkcellrendereraccel.h"
struct _GtkCellRendererAccel {
   GtkCellRendererText parent ;
   guint accel_key ;
   GdkModifierType accel_mods ;
   guint keycode ;
   GtkCellRendererAccelMode accel_mode ;
   GtkWidget *edit_widget ;
   GtkWidget *grab_widget ;
   GtkWidget *sizing_label ;
};
#line 64 "/usr/include/gtk-2.0/gtk/gtkcellrendereraccel.h"
struct _GtkCellRendererAccelClass {
   GtkCellRendererTextClass parent_class ;
   void (*accel_edited)(GtkCellRendererAccel * , gchar * , guint  , GdkModifierType  ,
                        guint  ) ;
   void (*accel_cleared)(GtkCellRendererAccel * , gchar * ) ;
   void (*_gtk_reserved0)(void) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 39 "/usr/include/gtk-2.0/gtk/gtkcellrenderercombo.h"
struct _GtkCellRendererCombo ;
#line 39 "/usr/include/gtk-2.0/gtk/gtkcellrenderercombo.h"
typedef struct _GtkCellRendererCombo GtkCellRendererCombo;
#line 40
struct _GtkCellRendererComboClass ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkcellrenderercombo.h"
typedef struct _GtkCellRendererComboClass GtkCellRendererComboClass;
#line 42 "/usr/include/gtk-2.0/gtk/gtkcellrenderercombo.h"
struct _GtkCellRendererCombo {
   GtkCellRendererText parent ;
   GtkTreeModel *model ;
   gint text_column ;
   gboolean has_entry ;
   guint focus_out_id ;
};
#line 54 "/usr/include/gtk-2.0/gtk/gtkcellrenderercombo.h"
struct _GtkCellRendererComboClass {
   GtkCellRendererTextClass parent ;
};
#line 40 "/usr/include/gtk-2.0/gtk/gtkcellrendererpixbuf.h"
struct _GtkCellRendererPixbuf ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkcellrendererpixbuf.h"
typedef struct _GtkCellRendererPixbuf GtkCellRendererPixbuf;
#line 41
struct _GtkCellRendererPixbufClass ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkcellrendererpixbuf.h"
typedef struct _GtkCellRendererPixbufClass GtkCellRendererPixbufClass;
#line 43 "/usr/include/gtk-2.0/gtk/gtkcellrendererpixbuf.h"
struct _GtkCellRendererPixbuf {
   GtkCellRenderer parent ;
   GdkPixbuf *pixbuf ;
   GdkPixbuf *pixbuf_expander_open ;
   GdkPixbuf *pixbuf_expander_closed ;
};
#line 53 "/usr/include/gtk-2.0/gtk/gtkcellrendererpixbuf.h"
struct _GtkCellRendererPixbufClass {
   GtkCellRendererClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 46 "/usr/include/gtk-2.0/gtk/gtkcellrendererprogress.h"
struct _GtkCellRendererProgress ;
#line 46 "/usr/include/gtk-2.0/gtk/gtkcellrendererprogress.h"
typedef struct _GtkCellRendererProgress GtkCellRendererProgress;
#line 47
struct _GtkCellRendererProgressClass ;
#line 47 "/usr/include/gtk-2.0/gtk/gtkcellrendererprogress.h"
typedef struct _GtkCellRendererProgressClass GtkCellRendererProgressClass;
#line 48
struct _GtkCellRendererProgressPrivate ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkcellrendererprogress.h"
typedef struct _GtkCellRendererProgressPrivate GtkCellRendererProgressPrivate;
#line 50 "/usr/include/gtk-2.0/gtk/gtkcellrendererprogress.h"
struct _GtkCellRendererProgress {
   GtkCellRenderer parent_instance ;
   GtkCellRendererProgressPrivate *priv ;
};
#line 58 "/usr/include/gtk-2.0/gtk/gtkcellrendererprogress.h"
struct _GtkCellRendererProgressClass {
   GtkCellRendererClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 38 "/usr/include/gtk-2.0/gtk/gtkcellrendererspin.h"
struct _GtkCellRendererSpin ;
#line 38 "/usr/include/gtk-2.0/gtk/gtkcellrendererspin.h"
typedef struct _GtkCellRendererSpin GtkCellRendererSpin;
#line 39
struct _GtkCellRendererSpinClass ;
#line 39 "/usr/include/gtk-2.0/gtk/gtkcellrendererspin.h"
typedef struct _GtkCellRendererSpinClass GtkCellRendererSpinClass;
#line 40
struct _GtkCellRendererSpinPrivate ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkcellrendererspin.h"
typedef struct _GtkCellRendererSpinPrivate GtkCellRendererSpinPrivate;
#line 42 "/usr/include/gtk-2.0/gtk/gtkcellrendererspin.h"
struct _GtkCellRendererSpin {
   GtkCellRendererText parent ;
};
#line 47 "/usr/include/gtk-2.0/gtk/gtkcellrendererspin.h"
struct _GtkCellRendererSpinClass {
   GtkCellRendererTextClass parent ;
};
#line 41 "/usr/include/gtk-2.0/gtk/gtkcellrendererspinner.h"
struct _GtkCellRendererSpinner ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkcellrendererspinner.h"
typedef struct _GtkCellRendererSpinner GtkCellRendererSpinner;
#line 42
struct _GtkCellRendererSpinnerClass ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkcellrendererspinner.h"
typedef struct _GtkCellRendererSpinnerClass GtkCellRendererSpinnerClass;
#line 43
struct _GtkCellRendererSpinnerPrivate ;
#line 43 "/usr/include/gtk-2.0/gtk/gtkcellrendererspinner.h"
typedef struct _GtkCellRendererSpinnerPrivate GtkCellRendererSpinnerPrivate;
#line 45 "/usr/include/gtk-2.0/gtk/gtkcellrendererspinner.h"
struct _GtkCellRendererSpinner {
   GtkCellRenderer parent ;
   GtkCellRendererSpinnerPrivate *priv ;
};
#line 51 "/usr/include/gtk-2.0/gtk/gtkcellrendererspinner.h"
struct _GtkCellRendererSpinnerClass {
   GtkCellRendererClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 40 "/usr/include/gtk-2.0/gtk/gtkcellrenderertoggle.h"
struct _GtkCellRendererToggle ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkcellrenderertoggle.h"
typedef struct _GtkCellRendererToggle GtkCellRendererToggle;
#line 41
struct _GtkCellRendererToggleClass ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkcellrenderertoggle.h"
typedef struct _GtkCellRendererToggleClass GtkCellRendererToggleClass;
#line 43 "/usr/include/gtk-2.0/gtk/gtkcellrenderertoggle.h"
struct _GtkCellRendererToggle {
   GtkCellRenderer parent ;
   guint active ;
   guint activatable ;
   guint radio ;
};
#line 53 "/usr/include/gtk-2.0/gtk/gtkcellrenderertoggle.h"
struct _GtkCellRendererToggleClass {
   GtkCellRendererClass parent_class ;
   void (*toggled)(GtkCellRendererToggle * , gchar * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 40 "/usr/include/gtk-2.0/gtk/gtkcellview.h"
struct _GtkCellView ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkcellview.h"
typedef struct _GtkCellView GtkCellView;
#line 41
struct _GtkCellViewClass ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkcellview.h"
typedef struct _GtkCellViewClass GtkCellViewClass;
#line 42
struct _GtkCellViewPrivate ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkcellview.h"
typedef struct _GtkCellViewPrivate GtkCellViewPrivate;
#line 44 "/usr/include/gtk-2.0/gtk/gtkcellview.h"
struct _GtkCellView {
   GtkWidget parent_instance ;
   GtkCellViewPrivate *priv ;
};
#line 52 "/usr/include/gtk-2.0/gtk/gtkcellview.h"
struct _GtkCellViewClass {
   GtkWidgetClass parent_class ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtktogglebutton.h"
struct _GtkToggleButton ;
#line 48 "/usr/include/gtk-2.0/gtk/gtktogglebutton.h"
typedef struct _GtkToggleButton GtkToggleButton;
#line 49
struct _GtkToggleButtonClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtktogglebutton.h"
typedef struct _GtkToggleButtonClass GtkToggleButtonClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtktogglebutton.h"
struct _GtkToggleButton {
   GtkButton button ;
   guint active ;
   guint draw_indicator ;
   guint inconsistent ;
};
#line 60 "/usr/include/gtk-2.0/gtk/gtktogglebutton.h"
struct _GtkToggleButtonClass {
   GtkButtonClass parent_class ;
   void (*toggled)(GtkToggleButton * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkcheckbutton.h"
struct _GtkCheckButton ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkcheckbutton.h"
typedef struct _GtkCheckButton GtkCheckButton;
#line 49
struct _GtkCheckButtonClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkcheckbutton.h"
typedef struct _GtkCheckButtonClass GtkCheckButtonClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkcheckbutton.h"
struct _GtkCheckButton {
   GtkToggleButton toggle_button ;
};
#line 56 "/usr/include/gtk-2.0/gtk/gtkcheckbutton.h"
struct _GtkCheckButtonClass {
   GtkToggleButtonClass parent_class ;
   void (*draw_indicator)(GtkCheckButton * , GdkRectangle * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkitem.h"
struct _GtkItem ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkitem.h"
typedef struct _GtkItem GtkItem;
#line 49
struct _GtkItemClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkitem.h"
typedef struct _GtkItemClass GtkItemClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkitem.h"
struct _GtkItem {
   GtkBin bin ;
};
#line 56 "/usr/include/gtk-2.0/gtk/gtkitem.h"
struct _GtkItemClass {
   GtkBinClass parent_class ;
   void (*select)(GtkItem * ) ;
   void (*deselect)(GtkItem * ) ;
   void (*toggle)(GtkItem * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkmenuitem.h"
struct _GtkMenuItem ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkmenuitem.h"
typedef struct _GtkMenuItem GtkMenuItem;
#line 49
struct _GtkMenuItemClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkmenuitem.h"
typedef struct _GtkMenuItemClass GtkMenuItemClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkmenuitem.h"
struct _GtkMenuItem {
   GtkItem item ;
   GtkWidget *submenu ;
   GdkWindow *event_window ;
   guint16 toggle_size ;
   guint16 accelerator_width ;
   gchar *accel_path ;
   guint show_submenu_indicator ;
   guint submenu_placement ;
   guint submenu_direction ;
   guint right_justify ;
   guint timer_from_keypress ;
   guint from_menubar ;
   guint timer ;
};
#line 71 "/usr/include/gtk-2.0/gtk/gtkmenuitem.h"
struct _GtkMenuItemClass {
   GtkItemClass parent_class ;
   guint hide_on_activate ;
   void (*activate)(GtkMenuItem * ) ;
   void (*activate_item)(GtkMenuItem * ) ;
   void (*toggle_size_request)(GtkMenuItem * , gint * ) ;
   void (*toggle_size_allocate)(GtkMenuItem * , gint  ) ;
   void (*set_label)(GtkMenuItem * , gchar * ) ;
   gchar *(*get_label)(GtkMenuItem * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h"
struct _GtkCheckMenuItem ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h"
typedef struct _GtkCheckMenuItem GtkCheckMenuItem;
#line 49
struct _GtkCheckMenuItemClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h"
typedef struct _GtkCheckMenuItemClass GtkCheckMenuItemClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h"
struct _GtkCheckMenuItem {
   GtkMenuItem menu_item ;
   guint active ;
   guint always_show_toggle ;
   guint inconsistent ;
   guint draw_as_radio ;
};
#line 61 "/usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h"
struct _GtkCheckMenuItemClass {
   GtkMenuItemClass parent_class ;
   void (*toggled)(GtkCheckMenuItem * ) ;
   void (*draw_indicator)(GtkCheckMenuItem * , GdkRectangle * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 67 "/usr/include/gtk-2.0/gtk/gtktexttag.h"
struct _GtkTextIter ;
#line 67 "/usr/include/gtk-2.0/gtk/gtktexttag.h"
typedef struct _GtkTextIter GtkTextIter;
#line 68
struct _GtkTextTagTable ;
#line 68 "/usr/include/gtk-2.0/gtk/gtktexttag.h"
typedef struct _GtkTextTagTable GtkTextTagTable;
#line 70
struct _GtkTextAttributes ;
#line 70 "/usr/include/gtk-2.0/gtk/gtktexttag.h"
typedef struct _GtkTextAttributes GtkTextAttributes;
#line 81
struct _GtkTextTag ;
#line 81 "/usr/include/gtk-2.0/gtk/gtktexttag.h"
typedef struct _GtkTextTag GtkTextTag;
#line 82
struct _GtkTextTagClass ;
#line 82 "/usr/include/gtk-2.0/gtk/gtktexttag.h"
typedef struct _GtkTextTagClass GtkTextTagClass;
#line 84 "/usr/include/gtk-2.0/gtk/gtktexttag.h"
struct _GtkTextTag {
   GObject parent_instance ;
   GtkTextTagTable *table ;
   char *name ;
   int priority ;
   GtkTextAttributes *values ;
   guint bg_color_set ;
   guint bg_stipple_set ;
   guint fg_color_set ;
   guint scale_set ;
   guint fg_stipple_set ;
   guint justification_set ;
   guint left_margin_set ;
   guint indent_set ;
   guint rise_set ;
   guint strikethrough_set ;
   guint right_margin_set ;
   guint pixels_above_lines_set ;
   guint pixels_below_lines_set ;
   guint pixels_inside_wrap_set ;
   guint tabs_set ;
   guint underline_set ;
   guint wrap_mode_set ;
   guint bg_full_height_set ;
   guint invisible_set ;
   guint editable_set ;
   guint language_set ;
   guint pg_bg_color_set ;
   guint accumulative_margin ;
   guint pad1 ;
};
#line 140 "/usr/include/gtk-2.0/gtk/gtktexttag.h"
struct _GtkTextTagClass {
   GObjectClass parent_class ;
   gboolean (*event)(GtkTextTag * , GObject * , GdkEvent * , GtkTextIter * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 170
struct _GtkTextAppearance ;
#line 170 "/usr/include/gtk-2.0/gtk/gtktexttag.h"
typedef struct _GtkTextAppearance GtkTextAppearance;
#line 172 "/usr/include/gtk-2.0/gtk/gtktexttag.h"
struct _GtkTextAppearance {
   GdkColor bg_color ;
   GdkColor fg_color ;
   GdkBitmap *bg_stipple ;
   GdkBitmap *fg_stipple ;
   gint rise ;
   gpointer padding1 ;
   guint underline ;
   guint strikethrough ;
   guint draw_bg ;
   guint inside_selection ;
   guint is_text ;
   guint pad1 ;
   guint pad2 ;
   guint pad3 ;
   guint pad4 ;
};
#line 214 "/usr/include/gtk-2.0/gtk/gtktexttag.h"
struct _GtkTextAttributes {
   guint refcount ;
   GtkTextAppearance appearance ;
   GtkJustification justification ;
   GtkTextDirection direction ;
   PangoFontDescription *font ;
   gdouble font_scale ;
   gint left_margin ;
   gint indent ;
   gint right_margin ;
   gint pixels_above_lines ;
   gint pixels_below_lines ;
   gint pixels_inside_wrap ;
   PangoTabArray *tabs ;
   GtkWrapMode wrap_mode ;
   PangoLanguage *language ;
   GdkColor *pg_bg_color ;
   guint invisible ;
   guint bg_full_height ;
   guint editable ;
   guint realized ;
   guint pad1 ;
   guint pad2 ;
   guint pad3 ;
   guint pad4 ;
};
#line 45 "/usr/include/gtk-2.0/gtk/gtktextchild.h"
struct _GtkTextChildAnchor ;
#line 45 "/usr/include/gtk-2.0/gtk/gtktextchild.h"
typedef struct _GtkTextChildAnchor GtkTextChildAnchor;
#line 46
struct _GtkTextChildAnchorClass ;
#line 46 "/usr/include/gtk-2.0/gtk/gtktextchild.h"
typedef struct _GtkTextChildAnchorClass GtkTextChildAnchorClass;
#line 55 "/usr/include/gtk-2.0/gtk/gtktextchild.h"
struct _GtkTextChildAnchor {
   GObject parent_instance ;
   gpointer segment ;
};
#line 62 "/usr/include/gtk-2.0/gtk/gtktextchild.h"
struct _GtkTextChildAnchorClass {
   GObjectClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 39 "/usr/include/gtk-2.0/gtk/gtktextiter.h"
enum __anonenum__583 {
    GTK_TEXT_SEARCH_VISIBLE_ONLY = 1,
    GTK_TEXT_SEARCH_TEXT_ONLY = 2
} ;
#line 43 "/usr/include/gtk-2.0/gtk/gtktextiter.h"
typedef enum __anonenum__583 GtkTextSearchFlags;
#line 51
struct _GtkTextBuffer ;
#line 51 "/usr/include/gtk-2.0/gtk/gtktextiter.h"
typedef struct _GtkTextBuffer GtkTextBuffer;
#line 55 "/usr/include/gtk-2.0/gtk/gtktextiter.h"
struct _GtkTextIter {
   gpointer dummy1 ;
   gpointer dummy2 ;
   gint dummy3 ;
   gint dummy4 ;
   gint dummy5 ;
   gint dummy6 ;
   gint dummy7 ;
   gint dummy8 ;
   gpointer dummy9 ;
   gpointer dummy10 ;
   gint dummy11 ;
   gint dummy12 ;
   gint dummy13 ;
   gpointer dummy14 ;
};
#line 262 "/usr/include/gtk-2.0/gtk/gtktextiter.h"
typedef gboolean (*GtkTextCharPredicate)(gunichar  , gpointer  );
#line 41 "/usr/include/gtk-2.0/gtk/gtkselection.h"
struct _GtkTargetList ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkselection.h"
typedef struct _GtkTargetList GtkTargetList;
#line 42
struct _GtkTargetEntry ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkselection.h"
typedef struct _GtkTargetEntry GtkTargetEntry;
#line 58 "/usr/include/gtk-2.0/gtk/gtkselection.h"
struct _GtkSelectionData {
   GdkAtom selection ;
   GdkAtom target ;
   GdkAtom type ;
   gint format ;
   guchar *data ;
   gint length ;
   GdkDisplay *display ;
};
#line 69 "/usr/include/gtk-2.0/gtk/gtkselection.h"
struct _GtkTargetEntry {
   gchar *target ;
   guint flags ;
   guint info ;
};
#line 79
struct _GtkTargetPair ;
#line 79 "/usr/include/gtk-2.0/gtk/gtkselection.h"
typedef struct _GtkTargetPair GtkTargetPair;
#line 82 "/usr/include/gtk-2.0/gtk/gtkselection.h"
struct _GtkTargetList {
   GList *list ;
   guint ref_count ;
};
#line 87 "/usr/include/gtk-2.0/gtk/gtkselection.h"
struct _GtkTargetPair {
   GdkAtom target ;
   guint flags ;
   guint info ;
};
#line 37 "/usr/include/gtk-2.0/gtk/gtkclipboard.h"
typedef void (*GtkClipboardReceivedFunc)(GtkClipboard * , GtkSelectionData * , gpointer  );
#line 40 "/usr/include/gtk-2.0/gtk/gtkclipboard.h"
typedef void (*GtkClipboardTextReceivedFunc)(GtkClipboard * , gchar * , gpointer  );
#line 43 "/usr/include/gtk-2.0/gtk/gtkclipboard.h"
typedef void (*GtkClipboardRichTextReceivedFunc)(GtkClipboard * , GdkAtom  , guint8 * ,
                                                 gsize  , gpointer  );
#line 48 "/usr/include/gtk-2.0/gtk/gtkclipboard.h"
typedef void (*GtkClipboardImageReceivedFunc)(GtkClipboard * , GdkPixbuf * , gpointer  );
#line 51 "/usr/include/gtk-2.0/gtk/gtkclipboard.h"
typedef void (*GtkClipboardURIReceivedFunc)(GtkClipboard * , gchar ** , gpointer  );
#line 54 "/usr/include/gtk-2.0/gtk/gtkclipboard.h"
typedef void (*GtkClipboardTargetsReceivedFunc)(GtkClipboard * , GdkAtom * , gint  ,
                                                gpointer  );
#line 63 "/usr/include/gtk-2.0/gtk/gtkclipboard.h"
typedef void (*GtkClipboardGetFunc)(GtkClipboard * , GtkSelectionData * , guint  ,
                                    gpointer  );
#line 67 "/usr/include/gtk-2.0/gtk/gtkclipboard.h"
typedef void (*GtkClipboardClearFunc)(GtkClipboard * , gpointer  );
#line 58 "/usr/include/gtk-2.0/gtk/gtkcolorbutton.h"
struct _GtkColorButton ;
#line 58 "/usr/include/gtk-2.0/gtk/gtkcolorbutton.h"
typedef struct _GtkColorButton GtkColorButton;
#line 59
struct _GtkColorButtonClass ;
#line 59 "/usr/include/gtk-2.0/gtk/gtkcolorbutton.h"
typedef struct _GtkColorButtonClass GtkColorButtonClass;
#line 60
struct _GtkColorButtonPrivate ;
#line 60 "/usr/include/gtk-2.0/gtk/gtkcolorbutton.h"
typedef struct _GtkColorButtonPrivate GtkColorButtonPrivate;
#line 62 "/usr/include/gtk-2.0/gtk/gtkcolorbutton.h"
struct _GtkColorButton {
   GtkButton button ;
   GtkColorButtonPrivate *priv ;
};
#line 70 "/usr/include/gtk-2.0/gtk/gtkcolorbutton.h"
struct _GtkColorButtonClass {
   GtkButtonClass parent_class ;
   void (*color_set)(GtkColorButton * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkvbox.h"
struct _GtkVBox ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkvbox.h"
typedef struct _GtkVBox GtkVBox;
#line 49
struct _GtkVBoxClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkvbox.h"
typedef struct _GtkVBoxClass GtkVBoxClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkvbox.h"
struct _GtkVBox {
   GtkBox box ;
};
#line 56 "/usr/include/gtk-2.0/gtk/gtkvbox.h"
struct _GtkVBoxClass {
   GtkBoxClass parent_class ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkcolorsel.h"
struct _GtkColorSelection ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkcolorsel.h"
typedef struct _GtkColorSelection GtkColorSelection;
#line 49
struct _GtkColorSelectionClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkcolorsel.h"
typedef struct _GtkColorSelectionClass GtkColorSelectionClass;
#line 52 "/usr/include/gtk-2.0/gtk/gtkcolorsel.h"
typedef void (*GtkColorSelectionChangePaletteFunc)(GdkColor * , gint  );
#line 54 "/usr/include/gtk-2.0/gtk/gtkcolorsel.h"
typedef void (*GtkColorSelectionChangePaletteWithScreenFunc)(GdkScreen * , GdkColor * ,
                                                             gint  );
#line 58 "/usr/include/gtk-2.0/gtk/gtkcolorsel.h"
struct _GtkColorSelection {
   GtkVBox parent_instance ;
   gpointer private_data ;
};
#line 66 "/usr/include/gtk-2.0/gtk/gtkcolorsel.h"
struct _GtkColorSelectionClass {
   GtkVBoxClass parent_class ;
   void (*color_changed)(GtkColorSelection * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkcolorseldialog.h"
struct _GtkColorSelectionDialog ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkcolorseldialog.h"
typedef struct _GtkColorSelectionDialog GtkColorSelectionDialog;
#line 49
struct _GtkColorSelectionDialogClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkcolorseldialog.h"
typedef struct _GtkColorSelectionDialogClass GtkColorSelectionDialogClass;
#line 52 "/usr/include/gtk-2.0/gtk/gtkcolorseldialog.h"
struct _GtkColorSelectionDialog {
   GtkDialog parent_instance ;
   GtkWidget *colorsel ;
   GtkWidget *ok_button ;
   GtkWidget *cancel_button ;
   GtkWidget *help_button ;
};
#line 62 "/usr/include/gtk-2.0/gtk/gtkcolorseldialog.h"
struct _GtkColorSelectionDialogClass {
   GtkDialogClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 42 "/usr/include/gtk-2.0/gtk/gtkdnd.h"
enum __anonenum__584 {
    GTK_DEST_DEFAULT_MOTION = 1,
    GTK_DEST_DEFAULT_HIGHLIGHT = 2,
    GTK_DEST_DEFAULT_DROP = 4,
    GTK_DEST_DEFAULT_ALL = 7
} ;
#line 47 "/usr/include/gtk-2.0/gtk/gtkdnd.h"
typedef enum __anonenum__584 GtkDestDefaults;
#line 51
enum __anonenum__585 {
    GTK_TARGET_SAME_APP = 1,
    GTK_TARGET_SAME_WIDGET = 2,
    GTK_TARGET_OTHER_APP = 4,
    GTK_TARGET_OTHER_WIDGET = 8
} ;
#line 56 "/usr/include/gtk-2.0/gtk/gtkdnd.h"
typedef enum __anonenum__585 GtkTargetFlags;
#line 47 "/usr/include/gtk-2.0/gtk/gtkeditable.h"
struct _GtkEditable ;
#line 47 "/usr/include/gtk-2.0/gtk/gtkeditable.h"
typedef struct _GtkEditable GtkEditable;
#line 48
struct _GtkEditableClass ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkeditable.h"
typedef struct _GtkEditableClass GtkEditableClass;
#line 50 "/usr/include/gtk-2.0/gtk/gtkeditable.h"
struct _GtkEditableClass {
   GTypeInterface base_iface ;
   void (*insert_text)(GtkEditable * , gchar * , gint  , gint * ) ;
   void (*delete_text)(GtkEditable * , gint  , gint  ) ;
   void (*changed)(GtkEditable * ) ;
   void (*do_insert_text)(GtkEditable * , gchar * , gint  , gint * ) ;
   void (*do_delete_text)(GtkEditable * , gint  , gint  ) ;
   gchar *(*get_chars)(GtkEditable * , gint  , gint  ) ;
   void (*set_selection_bounds)(GtkEditable * , gint  , gint  ) ;
   gboolean (*get_selection_bounds)(GtkEditable * , gint * , gint * ) ;
   void (*set_position)(GtkEditable * , gint  ) ;
   gint (*get_position)(GtkEditable * ) ;
};
#line 42 "/usr/include/gtk-2.0/gtk/gtkimcontext.h"
struct _GtkIMContext ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkimcontext.h"
typedef struct _GtkIMContext GtkIMContext;
#line 43
struct _GtkIMContextClass ;
#line 43 "/usr/include/gtk-2.0/gtk/gtkimcontext.h"
typedef struct _GtkIMContextClass GtkIMContextClass;
#line 45 "/usr/include/gtk-2.0/gtk/gtkimcontext.h"
struct _GtkIMContext {
   GObject parent_instance ;
};
#line 50 "/usr/include/gtk-2.0/gtk/gtkimcontext.h"
struct _GtkIMContextClass {
   GtkObjectClass parent_class ;
   void (*preedit_start)(GtkIMContext * ) ;
   void (*preedit_end)(GtkIMContext * ) ;
   void (*preedit_changed)(GtkIMContext * ) ;
   void (*commit)(GtkIMContext * , gchar * ) ;
   gboolean (*retrieve_surrounding)(GtkIMContext * ) ;
   gboolean (*delete_surrounding)(GtkIMContext * , gint  , gint  ) ;
   void (*set_client_window)(GtkIMContext * , GdkWindow * ) ;
   void (*get_preedit_string)(GtkIMContext * , gchar ** , PangoAttrList ** , gint * ) ;
   gboolean (*filter_keypress)(GtkIMContext * , GdkEventKey * ) ;
   void (*focus_in)(GtkIMContext * ) ;
   void (*focus_out)(GtkIMContext * ) ;
   void (*reset)(GtkIMContext * ) ;
   void (*set_cursor_location)(GtkIMContext * , GdkRectangle * ) ;
   void (*set_use_preedit)(GtkIMContext * , gboolean  ) ;
   void (*set_surrounding)(GtkIMContext * , gchar * , gint  , gint  ) ;
   gboolean (*get_surrounding)(GtkIMContext * , gchar ** , gint * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
   void (*_gtk_reserved5)(void) ;
   void (*_gtk_reserved6)(void) ;
};
#line 41 "/usr/include/gtk-2.0/gtk/gtkentrybuffer.h"
struct _GtkEntryBuffer ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkentrybuffer.h"
typedef struct _GtkEntryBuffer GtkEntryBuffer;
#line 42
struct _GtkEntryBufferClass ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkentrybuffer.h"
typedef struct _GtkEntryBufferClass GtkEntryBufferClass;
#line 43
struct _GtkEntryBufferPrivate ;
#line 43 "/usr/include/gtk-2.0/gtk/gtkentrybuffer.h"
typedef struct _GtkEntryBufferPrivate GtkEntryBufferPrivate;
#line 45 "/usr/include/gtk-2.0/gtk/gtkentrybuffer.h"
struct _GtkEntryBuffer {
   GObject parent_instance ;
   GtkEntryBufferPrivate *priv ;
};
#line 53 "/usr/include/gtk-2.0/gtk/gtkentrybuffer.h"
struct _GtkEntryBufferClass {
   GObjectClass parent_class ;
   void (*inserted_text)(GtkEntryBuffer * , guint  , gchar * , guint  ) ;
   void (*deleted_text)(GtkEntryBuffer * , guint  , guint  ) ;
   gchar *(*get_text)(GtkEntryBuffer * , gsize * ) ;
   guint (*get_length)(GtkEntryBuffer * ) ;
   guint (*insert_text)(GtkEntryBuffer * , guint  , gchar * , guint  ) ;
   guint (*delete_text)(GtkEntryBuffer * , guint  , guint  ) ;
   void (*_gtk_reserved0)(void) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
   void (*_gtk_reserved5)(void) ;
};
#line 42 "/usr/include/gtk-2.0/gtk/gtkliststore.h"
struct _GtkListStore ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkliststore.h"
typedef struct _GtkListStore GtkListStore;
#line 43
struct _GtkListStoreClass ;
#line 43 "/usr/include/gtk-2.0/gtk/gtkliststore.h"
typedef struct _GtkListStoreClass GtkListStoreClass;
#line 45 "/usr/include/gtk-2.0/gtk/gtkliststore.h"
struct _GtkListStore {
   GObject parent ;
   gint stamp ;
   gpointer seq ;
   gpointer _gtk_reserved1 ;
   GList *sort_list ;
   gint n_columns ;
   gint sort_column_id ;
   GtkSortType order ;
   GType *column_headers ;
   gint length ;
   GtkTreeIterCompareFunc default_sort_func ;
   gpointer default_sort_data ;
   GDestroyNotify default_sort_destroy ;
   guint columns_dirty ;
};
#line 65 "/usr/include/gtk-2.0/gtk/gtkliststore.h"
struct _GtkListStoreClass {
   GObjectClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 40 "/usr/include/gtk-2.0/gtk/gtktreemodelfilter.h"
typedef gboolean (*GtkTreeModelFilterVisibleFunc)(GtkTreeModel * , GtkTreeIter * ,
                                                  gpointer  );
#line 43 "/usr/include/gtk-2.0/gtk/gtktreemodelfilter.h"
typedef void (*GtkTreeModelFilterModifyFunc)(GtkTreeModel * , GtkTreeIter * , GValue * ,
                                             gint  , gpointer  );
#line 49
struct _GtkTreeModelFilter ;
#line 49 "/usr/include/gtk-2.0/gtk/gtktreemodelfilter.h"
typedef struct _GtkTreeModelFilter GtkTreeModelFilter;
#line 50
struct _GtkTreeModelFilterClass ;
#line 50 "/usr/include/gtk-2.0/gtk/gtktreemodelfilter.h"
typedef struct _GtkTreeModelFilterClass GtkTreeModelFilterClass;
#line 51
struct _GtkTreeModelFilterPrivate ;
#line 51 "/usr/include/gtk-2.0/gtk/gtktreemodelfilter.h"
typedef struct _GtkTreeModelFilterPrivate GtkTreeModelFilterPrivate;
#line 53 "/usr/include/gtk-2.0/gtk/gtktreemodelfilter.h"
struct _GtkTreeModelFilter {
   GObject parent ;
   GtkTreeModelFilterPrivate *priv ;
};
#line 61 "/usr/include/gtk-2.0/gtk/gtktreemodelfilter.h"
struct _GtkTreeModelFilterClass {
   GObjectClass parent_class ;
   void (*_gtk_reserved0)(void) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
};
#line 41 "/usr/include/gtk-2.0/gtk/gtkentrycompletion.h"
struct _GtkEntryCompletion ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkentrycompletion.h"
typedef struct _GtkEntryCompletion GtkEntryCompletion;
#line 42
struct _GtkEntryCompletionClass ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkentrycompletion.h"
typedef struct _GtkEntryCompletionClass GtkEntryCompletionClass;
#line 43
struct _GtkEntryCompletionPrivate ;
#line 43 "/usr/include/gtk-2.0/gtk/gtkentrycompletion.h"
typedef struct _GtkEntryCompletionPrivate GtkEntryCompletionPrivate;
#line 45 "/usr/include/gtk-2.0/gtk/gtkentrycompletion.h"
typedef gboolean (*GtkEntryCompletionMatchFunc)(GtkEntryCompletion * , gchar * , GtkTreeIter * ,
                                                gpointer  );
#line 51 "/usr/include/gtk-2.0/gtk/gtkentrycompletion.h"
struct _GtkEntryCompletion {
   GObject parent_instance ;
   GtkEntryCompletionPrivate *priv ;
};
#line 59 "/usr/include/gtk-2.0/gtk/gtkentrycompletion.h"
struct _GtkEntryCompletionClass {
   GObjectClass parent_class ;
   gboolean (*match_selected)(GtkEntryCompletion * , GtkTreeModel * , GtkTreeIter * ) ;
   void (*action_activated)(GtkEntryCompletion * , gint  ) ;
   gboolean (*insert_prefix)(GtkEntryCompletion * , gchar * ) ;
   gboolean (*cursor_on_match)(GtkEntryCompletion * , GtkTreeModel * , GtkTreeIter * ) ;
   void (*_gtk_reserved0)(void) ;
   void (*_gtk_reserved1)(void) ;
};
#line 57 "/usr/include/gtk-2.0/gtk/gtkentry.h"
enum __anonenum__586 {
    GTK_ENTRY_ICON_PRIMARY = 0,
    GTK_ENTRY_ICON_SECONDARY = 1
} ;
#line 61 "/usr/include/gtk-2.0/gtk/gtkentry.h"
typedef enum __anonenum__586 GtkEntryIconPosition;
#line 63
struct _GtkEntry ;
#line 63 "/usr/include/gtk-2.0/gtk/gtkentry.h"
typedef struct _GtkEntry GtkEntry;
#line 64
struct _GtkEntryClass ;
#line 64 "/usr/include/gtk-2.0/gtk/gtkentry.h"
typedef struct _GtkEntryClass GtkEntryClass;
#line 66 "/usr/include/gtk-2.0/gtk/gtkentry.h"
struct _GtkEntry {
   GtkWidget widget ;
   gchar *text ;
   guint editable ;
   guint visible ;
   guint overwrite_mode ;
   guint in_drag ;
   guint16 text_length ;
   guint16 text_max_length ;
   GdkWindow *text_area ;
   GtkIMContext *im_context ;
   GtkWidget *popup_menu ;
   gint current_pos ;
   gint selection_bound ;
   PangoLayout *cached_layout ;
   guint cache_includes_preedit ;
   guint need_im_reset ;
   guint has_frame ;
   guint activates_default ;
   guint cursor_visible ;
   guint in_click ;
   guint is_cell_renderer ;
   guint editing_canceled ;
   guint mouse_cursor_obscured ;
   guint select_words ;
   guint select_lines ;
   guint resolved_dir ;
   guint truncate_multiline ;
   guint button ;
   guint blink_timeout ;
   guint recompute_idle ;
   gint scroll_offset ;
   gint ascent ;
   gint descent ;
   guint16 x_text_size ;
   guint16 x_n_bytes ;
   guint16 preedit_length ;
   guint16 preedit_cursor ;
   gint dnd_position ;
   gint drag_start_x ;
   gint drag_start_y ;
   gunichar invisible_char ;
   gint width_chars ;
};
#line 128 "/usr/include/gtk-2.0/gtk/gtkentry.h"
struct _GtkEntryClass {
   GtkWidgetClass parent_class ;
   void (*populate_popup)(GtkEntry * , GtkMenu * ) ;
   void (*activate)(GtkEntry * ) ;
   void (*move_cursor)(GtkEntry * , GtkMovementStep  , gint  , gboolean  ) ;
   void (*insert_at_cursor)(GtkEntry * , gchar * ) ;
   void (*delete_from_cursor)(GtkEntry * , GtkDeleteType  , gint  ) ;
   void (*backspace)(GtkEntry * ) ;
   void (*cut_clipboard)(GtkEntry * ) ;
   void (*copy_clipboard)(GtkEntry * ) ;
   void (*paste_clipboard)(GtkEntry * ) ;
   void (*toggle_overwrite)(GtkEntry * ) ;
   void (*get_text_area_size)(GtkEntry * , gint * , gint * , gint * , gint * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
};
#line 36 "/usr/include/gtk-2.0/gtk/gtktreeview.h"
enum __anonenum__587 {
    GTK_TREE_VIEW_DROP_BEFORE = 0,
    GTK_TREE_VIEW_DROP_AFTER = 1,
    GTK_TREE_VIEW_DROP_INTO_OR_BEFORE = 2,
    GTK_TREE_VIEW_DROP_INTO_OR_AFTER = 3
} ;
#line 46 "/usr/include/gtk-2.0/gtk/gtktreeview.h"
typedef enum __anonenum__587 GtkTreeViewDropPosition;
#line 55
struct _GtkTreeView ;
#line 55 "/usr/include/gtk-2.0/gtk/gtktreeview.h"
typedef struct _GtkTreeView GtkTreeView;
#line 56
struct _GtkTreeViewClass ;
#line 56 "/usr/include/gtk-2.0/gtk/gtktreeview.h"
typedef struct _GtkTreeViewClass GtkTreeViewClass;
#line 57
struct _GtkTreeViewPrivate ;
#line 57 "/usr/include/gtk-2.0/gtk/gtktreeview.h"
typedef struct _GtkTreeViewPrivate GtkTreeViewPrivate;
#line 58
struct _GtkTreeSelection ;
#line 58 "/usr/include/gtk-2.0/gtk/gtktreeview.h"
typedef struct _GtkTreeSelection GtkTreeSelection;
#line 59
struct _GtkTreeSelectionClass ;
#line 59 "/usr/include/gtk-2.0/gtk/gtktreeview.h"
typedef struct _GtkTreeSelectionClass GtkTreeSelectionClass;
#line 61 "/usr/include/gtk-2.0/gtk/gtktreeview.h"
struct _GtkTreeView {
   GtkContainer parent ;
   GtkTreeViewPrivate *priv ;
};
#line 68 "/usr/include/gtk-2.0/gtk/gtktreeview.h"
struct _GtkTreeViewClass {
   GtkContainerClass parent_class ;
   void (*set_scroll_adjustments)(GtkTreeView * , GtkAdjustment * , GtkAdjustment * ) ;
   void (*row_activated)(GtkTreeView * , GtkTreePath * , GtkTreeViewColumn * ) ;
   gboolean (*test_expand_row)(GtkTreeView * , GtkTreeIter * , GtkTreePath * ) ;
   gboolean (*test_collapse_row)(GtkTreeView * , GtkTreeIter * , GtkTreePath * ) ;
   void (*row_expanded)(GtkTreeView * , GtkTreeIter * , GtkTreePath * ) ;
   void (*row_collapsed)(GtkTreeView * , GtkTreeIter * , GtkTreePath * ) ;
   void (*columns_changed)(GtkTreeView * ) ;
   void (*cursor_changed)(GtkTreeView * ) ;
   gboolean (*move_cursor)(GtkTreeView * , GtkMovementStep  , gint  ) ;
   gboolean (*select_all)(GtkTreeView * ) ;
   gboolean (*unselect_all)(GtkTreeView * ) ;
   gboolean (*select_cursor_row)(GtkTreeView * , gboolean  ) ;
   gboolean (*toggle_cursor_row)(GtkTreeView * ) ;
   gboolean (*expand_collapse_cursor_row)(GtkTreeView * , gboolean  , gboolean  ,
                                          gboolean  ) ;
   gboolean (*select_cursor_parent)(GtkTreeView * ) ;
   gboolean (*start_interactive_search)(GtkTreeView * ) ;
   void (*_gtk_reserved0)(void) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 118 "/usr/include/gtk-2.0/gtk/gtktreeview.h"
typedef gboolean (*GtkTreeViewColumnDropFunc)(GtkTreeView * , GtkTreeViewColumn * ,
                                              GtkTreeViewColumn * , GtkTreeViewColumn * ,
                                              gpointer  );
#line 123 "/usr/include/gtk-2.0/gtk/gtktreeview.h"
typedef void (*GtkTreeViewMappingFunc)(GtkTreeView * , GtkTreePath * , gpointer  );
#line 126 "/usr/include/gtk-2.0/gtk/gtktreeview.h"
typedef gboolean (*GtkTreeViewSearchEqualFunc)(GtkTreeModel * , gint  , gchar * ,
                                               GtkTreeIter * , gpointer  );
#line 131 "/usr/include/gtk-2.0/gtk/gtktreeview.h"
typedef gboolean (*GtkTreeViewRowSeparatorFunc)(GtkTreeModel * , GtkTreeIter * , gpointer  );
#line 134 "/usr/include/gtk-2.0/gtk/gtktreeview.h"
typedef void (*GtkTreeViewSearchPositionFunc)(GtkTreeView * , GtkWidget * , gpointer  );
#line 365 "/usr/include/gtk-2.0/gtk/gtktreeview.h"
typedef void (*GtkTreeDestroyCountFunc)(GtkTreeView * , GtkTreePath * , gint  , gpointer  );
#line 40 "/usr/include/gtk-2.0/gtk/gtkcombobox.h"
struct _GtkComboBox ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkcombobox.h"
typedef struct _GtkComboBox GtkComboBox;
#line 41
struct _GtkComboBoxClass ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkcombobox.h"
typedef struct _GtkComboBoxClass GtkComboBoxClass;
#line 42
struct _GtkComboBoxPrivate ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkcombobox.h"
typedef struct _GtkComboBoxPrivate GtkComboBoxPrivate;
#line 44 "/usr/include/gtk-2.0/gtk/gtkcombobox.h"
struct _GtkComboBox {
   GtkBin parent_instance ;
   GtkComboBoxPrivate *priv ;
};
#line 52 "/usr/include/gtk-2.0/gtk/gtkcombobox.h"
struct _GtkComboBoxClass {
   GtkBinClass parent_class ;
   void (*changed)(GtkComboBox * ) ;
   gchar *(*get_active_text)(GtkComboBox * ) ;
   void (*_gtk_reserved0)(void) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
};
#line 41 "/usr/include/gtk-2.0/gtk/gtkcomboboxentry.h"
struct _GtkComboBoxEntry ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkcomboboxentry.h"
typedef struct _GtkComboBoxEntry GtkComboBoxEntry;
#line 42
struct _GtkComboBoxEntryClass ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkcomboboxentry.h"
typedef struct _GtkComboBoxEntryClass GtkComboBoxEntryClass;
#line 43
struct _GtkComboBoxEntryPrivate ;
#line 43 "/usr/include/gtk-2.0/gtk/gtkcomboboxentry.h"
typedef struct _GtkComboBoxEntryPrivate GtkComboBoxEntryPrivate;
#line 45 "/usr/include/gtk-2.0/gtk/gtkcomboboxentry.h"
struct _GtkComboBoxEntry {
   GtkComboBox parent_instance ;
   GtkComboBoxEntryPrivate *priv ;
};
#line 53 "/usr/include/gtk-2.0/gtk/gtkcomboboxentry.h"
struct _GtkComboBoxEntryClass {
   GtkComboBoxClass parent_class ;
   void (*_gtk_reserved0)(void) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
};
#line 37 "/usr/include/gtk-2.0/gtk/gtkcomboboxtext.h"
struct _GtkComboBoxText ;
#line 37 "/usr/include/gtk-2.0/gtk/gtkcomboboxtext.h"
typedef struct _GtkComboBoxText GtkComboBoxText;
#line 38
struct _GtkComboBoxTextPrivate ;
#line 38 "/usr/include/gtk-2.0/gtk/gtkcomboboxtext.h"
typedef struct _GtkComboBoxTextPrivate GtkComboBoxTextPrivate;
#line 39
struct _GtkComboBoxTextClass ;
#line 39 "/usr/include/gtk-2.0/gtk/gtkcomboboxtext.h"
typedef struct _GtkComboBoxTextClass GtkComboBoxTextClass;
#line 41 "/usr/include/gtk-2.0/gtk/gtkcomboboxtext.h"
struct _GtkComboBoxText {
   GtkComboBox parent_instance ;
   GtkComboBoxTextPrivate *priv ;
};
#line 49 "/usr/include/gtk-2.0/gtk/gtkcomboboxtext.h"
struct _GtkComboBoxTextClass {
   GtkComboBoxClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkdrawingarea.h"
struct _GtkDrawingArea ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkdrawingarea.h"
typedef struct _GtkDrawingArea GtkDrawingArea;
#line 49
struct _GtkDrawingAreaClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkdrawingarea.h"
typedef struct _GtkDrawingAreaClass GtkDrawingAreaClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkdrawingarea.h"
struct _GtkDrawingArea {
   GtkWidget widget ;
   gpointer draw_data ;
};
#line 58 "/usr/include/gtk-2.0/gtk/gtkdrawingarea.h"
struct _GtkDrawingAreaClass {
   GtkWidgetClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 47 "/usr/include/gtk-2.0/gtk/gtkeventbox.h"
struct _GtkEventBox ;
#line 47 "/usr/include/gtk-2.0/gtk/gtkeventbox.h"
typedef struct _GtkEventBox GtkEventBox;
#line 48
struct _GtkEventBoxClass ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkeventbox.h"
typedef struct _GtkEventBoxClass GtkEventBoxClass;
#line 50 "/usr/include/gtk-2.0/gtk/gtkeventbox.h"
struct _GtkEventBox {
   GtkBin bin ;
};
#line 55 "/usr/include/gtk-2.0/gtk/gtkeventbox.h"
struct _GtkEventBoxClass {
   GtkBinClass parent_class ;
};
#line 42 "/usr/include/gtk-2.0/gtk/gtkexpander.h"
struct _GtkExpander ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkexpander.h"
typedef struct _GtkExpander GtkExpander;
#line 43
struct _GtkExpanderClass ;
#line 43 "/usr/include/gtk-2.0/gtk/gtkexpander.h"
typedef struct _GtkExpanderClass GtkExpanderClass;
#line 44
struct _GtkExpanderPrivate ;
#line 44 "/usr/include/gtk-2.0/gtk/gtkexpander.h"
typedef struct _GtkExpanderPrivate GtkExpanderPrivate;
#line 46 "/usr/include/gtk-2.0/gtk/gtkexpander.h"
struct _GtkExpander {
   GtkBin bin ;
   GtkExpanderPrivate *priv ;
};
#line 53 "/usr/include/gtk-2.0/gtk/gtkexpander.h"
struct _GtkExpanderClass {
   GtkBinClass parent_class ;
   void (*activate)(GtkExpander * ) ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkfixed.h"
struct _GtkFixed ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkfixed.h"
typedef struct _GtkFixed GtkFixed;
#line 49
struct _GtkFixedClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkfixed.h"
typedef struct _GtkFixedClass GtkFixedClass;
#line 50
struct _GtkFixedChild ;
#line 50 "/usr/include/gtk-2.0/gtk/gtkfixed.h"
typedef struct _GtkFixedChild GtkFixedChild;
#line 52 "/usr/include/gtk-2.0/gtk/gtkfixed.h"
struct _GtkFixed {
   GtkContainer container ;
   GList *children ;
};
#line 59 "/usr/include/gtk-2.0/gtk/gtkfixed.h"
struct _GtkFixedClass {
   GtkContainerClass parent_class ;
};
#line 64 "/usr/include/gtk-2.0/gtk/gtkfixed.h"
struct _GtkFixedChild {
   GtkWidget *widget ;
   gint x ;
   gint y ;
};
#line 36 "/usr/include/gtk-2.0/gtk/gtkfilefilter.h"
struct _GtkFileFilter ;
#line 36 "/usr/include/gtk-2.0/gtk/gtkfilefilter.h"
typedef struct _GtkFileFilter GtkFileFilter;
#line 37
struct _GtkFileFilterInfo ;
#line 37 "/usr/include/gtk-2.0/gtk/gtkfilefilter.h"
typedef struct _GtkFileFilterInfo GtkFileFilterInfo;
#line 39
enum __anonenum__588 {
    GTK_FILE_FILTER_FILENAME = 1,
    GTK_FILE_FILTER_URI = 2,
    GTK_FILE_FILTER_DISPLAY_NAME = 4,
    GTK_FILE_FILTER_MIME_TYPE = 8
} ;
#line 44 "/usr/include/gtk-2.0/gtk/gtkfilefilter.h"
typedef enum __anonenum__588 GtkFileFilterFlags;
#line 46 "/usr/include/gtk-2.0/gtk/gtkfilefilter.h"
typedef gboolean (*GtkFileFilterFunc)(GtkFileFilterInfo * , gpointer  );
#line 49 "/usr/include/gtk-2.0/gtk/gtkfilefilter.h"
struct _GtkFileFilterInfo {
   GtkFileFilterFlags contains ;
   gchar *filename ;
   gchar *uri ;
   gchar *display_name ;
   gchar *mime_type ;
};
#line 37 "/usr/include/gtk-2.0/gtk/gtkfilechooser.h"
struct _GtkFileChooser ;
#line 37 "/usr/include/gtk-2.0/gtk/gtkfilechooser.h"
typedef struct _GtkFileChooser GtkFileChooser;
#line 56
enum __anonenum__589 {
    GTK_FILE_CHOOSER_ACTION_OPEN = 0,
    GTK_FILE_CHOOSER_ACTION_SAVE = 1,
    GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER = 2,
    GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER = 3
} ;
#line 62 "/usr/include/gtk-2.0/gtk/gtkfilechooser.h"
typedef enum __anonenum__589 GtkFileChooserAction;
#line 81
enum __anonenum__590 {
    GTK_FILE_CHOOSER_CONFIRMATION_CONFIRM = 0,
    GTK_FILE_CHOOSER_CONFIRMATION_ACCEPT_FILENAME = 1,
    GTK_FILE_CHOOSER_CONFIRMATION_SELECT_AGAIN = 2
} ;
#line 86 "/usr/include/gtk-2.0/gtk/gtkfilechooser.h"
typedef enum __anonenum__590 GtkFileChooserConfirmation;
#line 109
enum __anonenum__591 {
    GTK_FILE_CHOOSER_ERROR_NONEXISTENT = 0,
    GTK_FILE_CHOOSER_ERROR_BAD_FILENAME = 1,
    GTK_FILE_CHOOSER_ERROR_ALREADY_EXISTS = 2,
    GTK_FILE_CHOOSER_ERROR_INCOMPLETE_HOSTNAME = 3
} ;
#line 114 "/usr/include/gtk-2.0/gtk/gtkfilechooser.h"
typedef enum __anonenum__591 GtkFileChooserError;
#line 48 "/usr/include/gtk-2.0/gtk/gtkhbox.h"
struct _GtkHBox ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkhbox.h"
typedef struct _GtkHBox GtkHBox;
#line 49
struct _GtkHBoxClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkhbox.h"
typedef struct _GtkHBoxClass GtkHBoxClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkhbox.h"
struct _GtkHBox {
   GtkBox box ;
};
#line 56 "/usr/include/gtk-2.0/gtk/gtkhbox.h"
struct _GtkHBoxClass {
   GtkBoxClass parent_class ;
};
#line 40 "/usr/include/gtk-2.0/gtk/gtkfilechooserbutton.h"
struct _GtkFileChooserButton ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkfilechooserbutton.h"
typedef struct _GtkFileChooserButton GtkFileChooserButton;
#line 41
struct _GtkFileChooserButtonPrivate ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkfilechooserbutton.h"
typedef struct _GtkFileChooserButtonPrivate GtkFileChooserButtonPrivate;
#line 42
struct _GtkFileChooserButtonClass ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkfilechooserbutton.h"
typedef struct _GtkFileChooserButtonClass GtkFileChooserButtonClass;
#line 44 "/usr/include/gtk-2.0/gtk/gtkfilechooserbutton.h"
struct _GtkFileChooserButton {
   GtkHBox parent ;
   GtkFileChooserButtonPrivate *priv ;
};
#line 52 "/usr/include/gtk-2.0/gtk/gtkfilechooserbutton.h"
struct _GtkFileChooserButtonClass {
   GtkHBoxClass parent_class ;
   void (*file_set)(GtkFileChooserButton * ) ;
   void *__gtk_reserved1 ;
   void *__gtk_reserved2 ;
   void *__gtk_reserved3 ;
   void *__gtk_reserved4 ;
   void *__gtk_reserved5 ;
   void *__gtk_reserved6 ;
   void *__gtk_reserved7 ;
};
#line 40 "/usr/include/gtk-2.0/gtk/gtkfilechooserdialog.h"
struct _GtkFileChooserDialog ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkfilechooserdialog.h"
typedef struct _GtkFileChooserDialog GtkFileChooserDialog;
#line 41
struct _GtkFileChooserDialogPrivate ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkfilechooserdialog.h"
typedef struct _GtkFileChooserDialogPrivate GtkFileChooserDialogPrivate;
#line 42
struct _GtkFileChooserDialogClass ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkfilechooserdialog.h"
typedef struct _GtkFileChooserDialogClass GtkFileChooserDialogClass;
#line 44 "/usr/include/gtk-2.0/gtk/gtkfilechooserdialog.h"
struct _GtkFileChooserDialog {
   GtkDialog parent_instance ;
   GtkFileChooserDialogPrivate *priv ;
};
#line 51 "/usr/include/gtk-2.0/gtk/gtkfilechooserdialog.h"
struct _GtkFileChooserDialogClass {
   GtkDialogClass parent_class ;
};
#line 40 "/usr/include/gtk-2.0/gtk/gtkfilechooserwidget.h"
struct _GtkFileChooserWidget ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkfilechooserwidget.h"
typedef struct _GtkFileChooserWidget GtkFileChooserWidget;
#line 41
struct _GtkFileChooserWidgetPrivate ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkfilechooserwidget.h"
typedef struct _GtkFileChooserWidgetPrivate GtkFileChooserWidgetPrivate;
#line 42
struct _GtkFileChooserWidgetClass ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkfilechooserwidget.h"
typedef struct _GtkFileChooserWidgetClass GtkFileChooserWidgetClass;
#line 44 "/usr/include/gtk-2.0/gtk/gtkfilechooserwidget.h"
struct _GtkFileChooserWidget {
   GtkVBox parent_instance ;
   GtkFileChooserWidgetPrivate *priv ;
};
#line 51 "/usr/include/gtk-2.0/gtk/gtkfilechooserwidget.h"
struct _GtkFileChooserWidgetClass {
   GtkVBoxClass parent_class ;
};
#line 49 "/usr/include/gtk-2.0/gtk/gtkfontbutton.h"
struct _GtkFontButton ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkfontbutton.h"
typedef struct _GtkFontButton GtkFontButton;
#line 50
struct _GtkFontButtonClass ;
#line 50 "/usr/include/gtk-2.0/gtk/gtkfontbutton.h"
typedef struct _GtkFontButtonClass GtkFontButtonClass;
#line 51
struct _GtkFontButtonPrivate ;
#line 51 "/usr/include/gtk-2.0/gtk/gtkfontbutton.h"
typedef struct _GtkFontButtonPrivate GtkFontButtonPrivate;
#line 53 "/usr/include/gtk-2.0/gtk/gtkfontbutton.h"
struct _GtkFontButton {
   GtkButton button ;
   GtkFontButtonPrivate *priv ;
};
#line 60 "/usr/include/gtk-2.0/gtk/gtkfontbutton.h"
struct _GtkFontButtonClass {
   GtkButtonClass parent_class ;
   void (*font_set)(GtkFontButton * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 61 "/usr/include/gtk-2.0/gtk/gtkfontsel.h"
struct _GtkFontSelection ;
#line 61 "/usr/include/gtk-2.0/gtk/gtkfontsel.h"
typedef struct _GtkFontSelection GtkFontSelection;
#line 62
struct _GtkFontSelectionClass ;
#line 62 "/usr/include/gtk-2.0/gtk/gtkfontsel.h"
typedef struct _GtkFontSelectionClass GtkFontSelectionClass;
#line 64
struct _GtkFontSelectionDialog ;
#line 64 "/usr/include/gtk-2.0/gtk/gtkfontsel.h"
typedef struct _GtkFontSelectionDialog GtkFontSelectionDialog;
#line 65
struct _GtkFontSelectionDialogClass ;
#line 65 "/usr/include/gtk-2.0/gtk/gtkfontsel.h"
typedef struct _GtkFontSelectionDialogClass GtkFontSelectionDialogClass;
#line 67 "/usr/include/gtk-2.0/gtk/gtkfontsel.h"
struct _GtkFontSelection {
   GtkVBox parent_instance ;
   GtkWidget *font_entry ;
   GtkWidget *family_list ;
   GtkWidget *font_style_entry ;
   GtkWidget *face_list ;
   GtkWidget *size_entry ;
   GtkWidget *size_list ;
   GtkWidget *pixels_button ;
   GtkWidget *points_button ;
   GtkWidget *filter_button ;
   GtkWidget *preview_entry ;
   PangoFontFamily *family ;
   PangoFontFace *face ;
   gint size ;
   GdkFont *font ;
};
#line 92 "/usr/include/gtk-2.0/gtk/gtkfontsel.h"
struct _GtkFontSelectionClass {
   GtkVBoxClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 103 "/usr/include/gtk-2.0/gtk/gtkfontsel.h"
struct _GtkFontSelectionDialog {
   GtkDialog parent_instance ;
   GtkWidget *fontsel ;
   GtkWidget *main_vbox ;
   GtkWidget *action_area ;
   GtkWidget *ok_button ;
   GtkWidget *apply_button ;
   GtkWidget *cancel_button ;
   gint dialog_width ;
   gboolean auto_resize ;
};
#line 127 "/usr/include/gtk-2.0/gtk/gtkfontsel.h"
struct _GtkFontSelectionDialogClass {
   GtkDialogClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 53 "/usr/include/gtk-2.0/gtk/gtkhandlebox.h"
struct _GtkHandleBox ;
#line 53 "/usr/include/gtk-2.0/gtk/gtkhandlebox.h"
typedef struct _GtkHandleBox GtkHandleBox;
#line 54
struct _GtkHandleBoxClass ;
#line 54 "/usr/include/gtk-2.0/gtk/gtkhandlebox.h"
typedef struct _GtkHandleBoxClass GtkHandleBoxClass;
#line 56 "/usr/include/gtk-2.0/gtk/gtkhandlebox.h"
struct _GtkHandleBox {
   GtkBin bin ;
   GdkWindow *bin_window ;
   GdkWindow *float_window ;
   GtkShadowType shadow_type ;
   guint handle_position ;
   guint float_window_mapped ;
   guint child_detached ;
   guint in_drag ;
   guint shrink_on_detach ;
   int snap_edge ;
   gint deskoff_x ;
   gint deskoff_y ;
   GtkAllocation attach_allocation ;
   GtkAllocation float_allocation ;
};
#line 80 "/usr/include/gtk-2.0/gtk/gtkhandlebox.h"
struct _GtkHandleBoxClass {
   GtkBinClass parent_class ;
   void (*child_attached)(GtkHandleBox * , GtkWidget * ) ;
   void (*child_detached)(GtkHandleBox * , GtkWidget * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkhbbox.h"
struct _GtkHButtonBox ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkhbbox.h"
typedef struct _GtkHButtonBox GtkHButtonBox;
#line 49
struct _GtkHButtonBoxClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkhbbox.h"
typedef struct _GtkHButtonBoxClass GtkHButtonBoxClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkhbbox.h"
struct _GtkHButtonBox {
   GtkButtonBox button_box ;
};
#line 56 "/usr/include/gtk-2.0/gtk/gtkhbbox.h"
struct _GtkHButtonBoxClass {
   GtkButtonBoxClass parent_class ;
};
#line 46 "/usr/include/gtk-2.0/gtk/gtkpaned.h"
struct _GtkPaned ;
#line 46 "/usr/include/gtk-2.0/gtk/gtkpaned.h"
typedef struct _GtkPaned GtkPaned;
#line 47
struct _GtkPanedClass ;
#line 47 "/usr/include/gtk-2.0/gtk/gtkpaned.h"
typedef struct _GtkPanedClass GtkPanedClass;
#line 48
struct _GtkPanedPrivate ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkpaned.h"
typedef struct _GtkPanedPrivate GtkPanedPrivate;
#line 50 "/usr/include/gtk-2.0/gtk/gtkpaned.h"
struct _GtkPaned {
   GtkContainer container ;
   GtkWidget *child1 ;
   GtkWidget *child2 ;
   GdkWindow *handle ;
   GdkGC *xor_gc ;
   GdkCursorType cursor_type ;
   GdkRectangle handle_pos ;
   gint child1_size ;
   gint last_allocation ;
   gint min_position ;
   gint max_position ;
   guint position_set ;
   guint in_drag ;
   guint child1_shrink ;
   guint child1_resize ;
   guint child2_shrink ;
   guint child2_resize ;
   guint orientation ;
   guint in_recursion ;
   guint handle_prelit ;
   GtkWidget *last_child1_focus ;
   GtkWidget *last_child2_focus ;
   GtkPanedPrivate *priv ;
   gint drag_pos ;
   gint original_position ;
};
#line 87 "/usr/include/gtk-2.0/gtk/gtkpaned.h"
struct _GtkPanedClass {
   GtkContainerClass parent_class ;
   gboolean (*cycle_child_focus)(GtkPaned * , gboolean  ) ;
   gboolean (*toggle_handle_focus)(GtkPaned * ) ;
   gboolean (*move_handle)(GtkPaned * , GtkScrollType  ) ;
   gboolean (*cycle_handle_focus)(GtkPaned * , gboolean  ) ;
   gboolean (*accept_position)(GtkPaned * ) ;
   gboolean (*cancel_position)(GtkPaned * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 46 "/usr/include/gtk-2.0/gtk/gtkhpaned.h"
struct _GtkHPaned ;
#line 46 "/usr/include/gtk-2.0/gtk/gtkhpaned.h"
typedef struct _GtkHPaned GtkHPaned;
#line 47
struct _GtkHPanedClass ;
#line 47 "/usr/include/gtk-2.0/gtk/gtkhpaned.h"
typedef struct _GtkHPanedClass GtkHPanedClass;
#line 49 "/usr/include/gtk-2.0/gtk/gtkhpaned.h"
struct _GtkHPaned {
   GtkPaned paned ;
};
#line 54 "/usr/include/gtk-2.0/gtk/gtkhpaned.h"
struct _GtkHPanedClass {
   GtkPanedClass parent_class ;
};
#line 60 "/usr/include/gtk-2.0/gtk/gtkruler.h"
struct _GtkRuler ;
#line 60 "/usr/include/gtk-2.0/gtk/gtkruler.h"
typedef struct _GtkRuler GtkRuler;
#line 61
struct _GtkRulerClass ;
#line 61 "/usr/include/gtk-2.0/gtk/gtkruler.h"
typedef struct _GtkRulerClass GtkRulerClass;
#line 62
struct _GtkRulerMetric ;
#line 62 "/usr/include/gtk-2.0/gtk/gtkruler.h"
typedef struct _GtkRulerMetric GtkRulerMetric;
#line 67 "/usr/include/gtk-2.0/gtk/gtkruler.h"
struct _GtkRuler {
   GtkWidget widget ;
   GdkPixmap *backing_store ;
   GdkGC *non_gr_exp_gc ;
   GtkRulerMetric *metric ;
   gint xsrc ;
   gint ysrc ;
   gint slider_size ;
   gdouble lower ;
   gdouble upper ;
   gdouble position ;
   gdouble max_size ;
};
#line 88 "/usr/include/gtk-2.0/gtk/gtkruler.h"
struct _GtkRulerClass {
   GtkWidgetClass parent_class ;
   void (*draw_ticks)(GtkRuler * ) ;
   void (*draw_pos)(GtkRuler * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 102 "/usr/include/gtk-2.0/gtk/gtkruler.h"
struct _GtkRulerMetric {
   gchar *metric_name ;
   gchar *abbrev ;
   gdouble pixels_per_unit ;
   gdouble ruler_scale[10] ;
   gint subdivide[5] ;
};
#line 61 "/usr/include/gtk-2.0/gtk/gtkhruler.h"
struct _GtkHRuler ;
#line 61 "/usr/include/gtk-2.0/gtk/gtkhruler.h"
typedef struct _GtkHRuler GtkHRuler;
#line 62
struct _GtkHRulerClass ;
#line 62 "/usr/include/gtk-2.0/gtk/gtkhruler.h"
typedef struct _GtkHRulerClass GtkHRulerClass;
#line 64 "/usr/include/gtk-2.0/gtk/gtkhruler.h"
struct _GtkHRuler {
   GtkRuler ruler ;
};
#line 69 "/usr/include/gtk-2.0/gtk/gtkhruler.h"
struct _GtkHRulerClass {
   GtkRulerClass parent_class ;
};
#line 50 "/usr/include/gtk-2.0/gtk/gtkrange.h"
struct _GtkRangeLayout ;
#line 50 "/usr/include/gtk-2.0/gtk/gtkrange.h"
typedef struct _GtkRangeLayout GtkRangeLayout;
#line 51
struct _GtkRangeStepTimer ;
#line 51 "/usr/include/gtk-2.0/gtk/gtkrange.h"
typedef struct _GtkRangeStepTimer GtkRangeStepTimer;
#line 53
struct _GtkRange ;
#line 53 "/usr/include/gtk-2.0/gtk/gtkrange.h"
typedef struct _GtkRange GtkRange;
#line 54
struct _GtkRangeClass ;
#line 54 "/usr/include/gtk-2.0/gtk/gtkrange.h"
typedef struct _GtkRangeClass GtkRangeClass;
#line 56 "/usr/include/gtk-2.0/gtk/gtkrange.h"
struct _GtkRange {
   GtkWidget widget ;
   GtkAdjustment *adjustment ;
   GtkUpdateType update_policy ;
   guint inverted ;
   guint flippable ;
   guint has_stepper_a ;
   guint has_stepper_b ;
   guint has_stepper_c ;
   guint has_stepper_d ;
   guint need_recalc ;
   guint slider_size_fixed ;
   gint min_slider_size ;
   GtkOrientation orientation ;
   GdkRectangle range_rect ;
   gint slider_start ;
   gint slider_end ;
   gint round_digits ;
   guint trough_click_forward ;
   guint update_pending ;
   GtkRangeLayout *layout ;
   GtkRangeStepTimer *timer ;
   gint slide_initial_slider_position ;
   gint slide_initial_coordinate ;
   guint update_timeout_id ;
   GdkWindow *event_window ;
};
#line 105 "/usr/include/gtk-2.0/gtk/gtkrange.h"
struct _GtkRangeClass {
   GtkWidgetClass parent_class ;
   gchar *slider_detail ;
   gchar *stepper_detail ;
   void (*value_changed)(GtkRange * ) ;
   void (*adjust_bounds)(GtkRange * , gdouble  ) ;
   void (*move_slider)(GtkRange * , GtkScrollType  ) ;
   void (*get_range_border)(GtkRange * , GtkBorder * ) ;
   gboolean (*change_value)(GtkRange * , GtkScrollType  , gdouble  ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkscale.h"
struct _GtkScale ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkscale.h"
typedef struct _GtkScale GtkScale;
#line 49
struct _GtkScaleClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkscale.h"
typedef struct _GtkScaleClass GtkScaleClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkscale.h"
struct _GtkScale {
   GtkRange range ;
   gint digits ;
   guint draw_value ;
   guint value_pos ;
};
#line 60 "/usr/include/gtk-2.0/gtk/gtkscale.h"
struct _GtkScaleClass {
   GtkRangeClass parent_class ;
   gchar *(*format_value)(GtkScale * , gdouble  ) ;
   void (*draw_value)(GtkScale * ) ;
   void (*get_layout_offsets)(GtkScale * , gint * , gint * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkhscale.h"
struct _GtkHScale ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkhscale.h"
typedef struct _GtkHScale GtkHScale;
#line 49
struct _GtkHScaleClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkhscale.h"
typedef struct _GtkHScaleClass GtkHScaleClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkhscale.h"
struct _GtkHScale {
   GtkScale scale ;
};
#line 56 "/usr/include/gtk-2.0/gtk/gtkhscale.h"
struct _GtkHScaleClass {
   GtkScaleClass parent_class ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkscrollbar.h"
struct _GtkScrollbar ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkscrollbar.h"
typedef struct _GtkScrollbar GtkScrollbar;
#line 49
struct _GtkScrollbarClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkscrollbar.h"
typedef struct _GtkScrollbarClass GtkScrollbarClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkscrollbar.h"
struct _GtkScrollbar {
   GtkRange range ;
};
#line 56 "/usr/include/gtk-2.0/gtk/gtkscrollbar.h"
struct _GtkScrollbarClass {
   GtkRangeClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 49 "/usr/include/gtk-2.0/gtk/gtkhscrollbar.h"
struct _GtkHScrollbar ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkhscrollbar.h"
typedef struct _GtkHScrollbar GtkHScrollbar;
#line 50
struct _GtkHScrollbarClass ;
#line 50 "/usr/include/gtk-2.0/gtk/gtkhscrollbar.h"
typedef struct _GtkHScrollbarClass GtkHScrollbarClass;
#line 52 "/usr/include/gtk-2.0/gtk/gtkhscrollbar.h"
struct _GtkHScrollbar {
   GtkScrollbar scrollbar ;
};
#line 57 "/usr/include/gtk-2.0/gtk/gtkhscrollbar.h"
struct _GtkHScrollbarClass {
   GtkScrollbarClass parent_class ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkseparator.h"
struct _GtkSeparator ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkseparator.h"
typedef struct _GtkSeparator GtkSeparator;
#line 49
struct _GtkSeparatorClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkseparator.h"
typedef struct _GtkSeparatorClass GtkSeparatorClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkseparator.h"
struct _GtkSeparator {
   GtkWidget widget ;
};
#line 56 "/usr/include/gtk-2.0/gtk/gtkseparator.h"
struct _GtkSeparatorClass {
   GtkWidgetClass parent_class ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkhseparator.h"
struct _GtkHSeparator ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkhseparator.h"
typedef struct _GtkHSeparator GtkHSeparator;
#line 49
struct _GtkHSeparatorClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkhseparator.h"
typedef struct _GtkHSeparatorClass GtkHSeparatorClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkhseparator.h"
struct _GtkHSeparator {
   GtkSeparator separator ;
};
#line 56 "/usr/include/gtk-2.0/gtk/gtkhseparator.h"
struct _GtkHSeparatorClass {
   GtkSeparatorClass parent_class ;
};
#line 51 "/usr/include/gtk-2.0/gtk/gtkhsv.h"
struct _GtkHSV ;
#line 51 "/usr/include/gtk-2.0/gtk/gtkhsv.h"
typedef struct _GtkHSV GtkHSV;
#line 52
struct _GtkHSVClass ;
#line 52 "/usr/include/gtk-2.0/gtk/gtkhsv.h"
typedef struct _GtkHSVClass GtkHSVClass;
#line 54 "/usr/include/gtk-2.0/gtk/gtkhsv.h"
struct _GtkHSV {
   GtkWidget parent_instance ;
   gpointer priv ;
};
#line 62 "/usr/include/gtk-2.0/gtk/gtkhsv.h"
struct _GtkHSVClass {
   GtkWidgetClass parent_class ;
   void (*changed)(GtkHSV * ) ;
   void (*move)(GtkHSV * , GtkDirectionType  ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 39 "/usr/include/gtk-2.0/gtk/gtkiconfactory.h"
struct _GtkIconFactoryClass ;
#line 39 "/usr/include/gtk-2.0/gtk/gtkiconfactory.h"
typedef struct _GtkIconFactoryClass GtkIconFactoryClass;
#line 50 "/usr/include/gtk-2.0/gtk/gtkiconfactory.h"
struct _GtkIconFactory {
   GObject parent_instance ;
   GHashTable *icons ;
};
#line 57 "/usr/include/gtk-2.0/gtk/gtkiconfactory.h"
struct _GtkIconFactoryClass {
   GObjectClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 41 "/usr/include/gtk-2.0/gtk/gtkicontheme.h"
struct _GtkIconInfo ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkicontheme.h"
typedef struct _GtkIconInfo GtkIconInfo;
#line 42
struct _GtkIconTheme ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkicontheme.h"
typedef struct _GtkIconTheme GtkIconTheme;
#line 43
struct _GtkIconThemeClass ;
#line 43 "/usr/include/gtk-2.0/gtk/gtkicontheme.h"
typedef struct _GtkIconThemeClass GtkIconThemeClass;
#line 44
struct _GtkIconThemePrivate ;
#line 44 "/usr/include/gtk-2.0/gtk/gtkicontheme.h"
typedef struct _GtkIconThemePrivate GtkIconThemePrivate;
#line 46 "/usr/include/gtk-2.0/gtk/gtkicontheme.h"
struct _GtkIconTheme {
   GObject parent_instance ;
   GtkIconThemePrivate *priv ;
};
#line 54 "/usr/include/gtk-2.0/gtk/gtkicontheme.h"
struct _GtkIconThemeClass {
   GObjectClass parent_class ;
   void (*changed)(GtkIconTheme * ) ;
};
#line 80
enum __anonenum__592 {
    GTK_ICON_LOOKUP_NO_SVG = 1,
    GTK_ICON_LOOKUP_FORCE_SVG = 2,
    GTK_ICON_LOOKUP_USE_BUILTIN = 4,
    GTK_ICON_LOOKUP_GENERIC_FALLBACK = 8,
    GTK_ICON_LOOKUP_FORCE_SIZE = 16
} ;
#line 87 "/usr/include/gtk-2.0/gtk/gtkicontheme.h"
typedef enum __anonenum__592 GtkIconLookupFlags;
#line 98
enum __anonenum__593 {
    GTK_ICON_THEME_NOT_FOUND = 0,
    GTK_ICON_THEME_FAILED = 1
} ;
#line 101 "/usr/include/gtk-2.0/gtk/gtkicontheme.h"
typedef enum __anonenum__593 GtkIconThemeError;
#line 42 "/usr/include/gtk-2.0/gtk/gtkiconview.h"
struct _GtkIconView ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkiconview.h"
typedef struct _GtkIconView GtkIconView;
#line 43
struct _GtkIconViewClass ;
#line 43 "/usr/include/gtk-2.0/gtk/gtkiconview.h"
typedef struct _GtkIconViewClass GtkIconViewClass;
#line 44
struct _GtkIconViewPrivate ;
#line 44 "/usr/include/gtk-2.0/gtk/gtkiconview.h"
typedef struct _GtkIconViewPrivate GtkIconViewPrivate;
#line 46 "/usr/include/gtk-2.0/gtk/gtkiconview.h"
typedef void (*GtkIconViewForeachFunc)(GtkIconView * , GtkTreePath * , gpointer  );
#line 50
enum __anonenum__594 {
    GTK_ICON_VIEW_NO_DROP = 0,
    GTK_ICON_VIEW_DROP_INTO = 1,
    GTK_ICON_VIEW_DROP_LEFT = 2,
    GTK_ICON_VIEW_DROP_RIGHT = 3,
    GTK_ICON_VIEW_DROP_ABOVE = 4,
    GTK_ICON_VIEW_DROP_BELOW = 5
} ;
#line 58 "/usr/include/gtk-2.0/gtk/gtkiconview.h"
typedef enum __anonenum__594 GtkIconViewDropPosition;
#line 60 "/usr/include/gtk-2.0/gtk/gtkiconview.h"
struct _GtkIconView {
   GtkContainer parent ;
   GtkIconViewPrivate *priv ;
};
#line 67 "/usr/include/gtk-2.0/gtk/gtkiconview.h"
struct _GtkIconViewClass {
   GtkContainerClass parent_class ;
   void (*set_scroll_adjustments)(GtkIconView * , GtkAdjustment * , GtkAdjustment * ) ;
   void (*item_activated)(GtkIconView * , GtkTreePath * ) ;
   void (*selection_changed)(GtkIconView * ) ;
   void (*select_all)(GtkIconView * ) ;
   void (*unselect_all)(GtkIconView * ) ;
   void (*select_cursor_item)(GtkIconView * ) ;
   void (*toggle_cursor_item)(GtkIconView * ) ;
   gboolean (*move_cursor)(GtkIconView * , GtkMovementStep  , gint  ) ;
   gboolean (*activate_cursor_item)(GtkIconView * ) ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkimagemenuitem.h"
struct _GtkImageMenuItem ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkimagemenuitem.h"
typedef struct _GtkImageMenuItem GtkImageMenuItem;
#line 49
struct _GtkImageMenuItemClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkimagemenuitem.h"
typedef struct _GtkImageMenuItemClass GtkImageMenuItemClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkimagemenuitem.h"
struct _GtkImageMenuItem {
   GtkMenuItem menu_item ;
   GtkWidget *image ;
};
#line 60 "/usr/include/gtk-2.0/gtk/gtkimagemenuitem.h"
struct _GtkImageMenuItemClass {
   GtkMenuItemClass parent_class ;
};
#line 41 "/usr/include/gtk-2.0/gtk/gtkimcontextsimple.h"
struct _GtkIMContextSimple ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkimcontextsimple.h"
typedef struct _GtkIMContextSimple GtkIMContextSimple;
#line 42
struct _GtkIMContextSimpleClass ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkimcontextsimple.h"
typedef struct _GtkIMContextSimpleClass GtkIMContextSimpleClass;
#line 46 "/usr/include/gtk-2.0/gtk/gtkimcontextsimple.h"
struct _GtkIMContextSimple {
   GtkIMContext object ;
   GSList *tables ;
   guint compose_buffer[8] ;
   gunichar tentative_match ;
   gint tentative_match_len ;
   guint in_hex_sequence ;
   guint modifiers_dropped ;
};
#line 60 "/usr/include/gtk-2.0/gtk/gtkimcontextsimple.h"
struct _GtkIMContextSimpleClass {
   GtkIMContextClass parent_class ;
};
#line 40 "/usr/include/gtk-2.0/gtk/gtkimmulticontext.h"
struct _GtkIMMulticontext ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkimmulticontext.h"
typedef struct _GtkIMMulticontext GtkIMMulticontext;
#line 41
struct _GtkIMMulticontextClass ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkimmulticontext.h"
typedef struct _GtkIMMulticontextClass GtkIMMulticontextClass;
#line 42
struct _GtkIMMulticontextPrivate ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkimmulticontext.h"
typedef struct _GtkIMMulticontextPrivate GtkIMMulticontextPrivate;
#line 44 "/usr/include/gtk-2.0/gtk/gtkimmulticontext.h"
struct _GtkIMMulticontext {
   GtkIMContext object ;
   GtkIMContext *slave ;
   GtkIMMulticontextPrivate *priv ;
   gchar *context_id ;
};
#line 55 "/usr/include/gtk-2.0/gtk/gtkimmulticontext.h"
struct _GtkIMMulticontextClass {
   GtkIMContextClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 54 "/usr/include/gtk-2.0/gtk/gtkinfobar.h"
struct _GtkInfoBarPrivate ;
#line 54 "/usr/include/gtk-2.0/gtk/gtkinfobar.h"
typedef struct _GtkInfoBarPrivate GtkInfoBarPrivate;
#line 55
struct _GtkInfoBarClass ;
#line 55 "/usr/include/gtk-2.0/gtk/gtkinfobar.h"
typedef struct _GtkInfoBarClass GtkInfoBarClass;
#line 56
struct _GtkInfoBar ;
#line 56 "/usr/include/gtk-2.0/gtk/gtkinfobar.h"
typedef struct _GtkInfoBar GtkInfoBar;
#line 59 "/usr/include/gtk-2.0/gtk/gtkinfobar.h"
struct _GtkInfoBar {
   GtkHBox parent ;
   GtkInfoBarPrivate *priv ;
};
#line 68 "/usr/include/gtk-2.0/gtk/gtkinfobar.h"
struct _GtkInfoBarClass {
   GtkHBoxClass parent_class ;
   void (*response)(GtkInfoBar * , gint  ) ;
   void (*close)(GtkInfoBar * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
   void (*_gtk_reserved5)(void) ;
   void (*_gtk_reserved6)(void) ;
};
#line 46 "/usr/include/gtk-2.0/gtk/gtkinvisible.h"
struct _GtkInvisible ;
#line 46 "/usr/include/gtk-2.0/gtk/gtkinvisible.h"
typedef struct _GtkInvisible GtkInvisible;
#line 47
struct _GtkInvisibleClass ;
#line 47 "/usr/include/gtk-2.0/gtk/gtkinvisible.h"
typedef struct _GtkInvisibleClass GtkInvisibleClass;
#line 49 "/usr/include/gtk-2.0/gtk/gtkinvisible.h"
struct _GtkInvisible {
   GtkWidget widget ;
   gboolean has_user_ref_count ;
   GdkScreen *screen ;
};
#line 57 "/usr/include/gtk-2.0/gtk/gtkinvisible.h"
struct _GtkInvisibleClass {
   GtkWidgetClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 53 "/usr/include/gtk-2.0/gtk/gtklayout.h"
struct _GtkLayout ;
#line 53 "/usr/include/gtk-2.0/gtk/gtklayout.h"
typedef struct _GtkLayout GtkLayout;
#line 54
struct _GtkLayoutClass ;
#line 54 "/usr/include/gtk-2.0/gtk/gtklayout.h"
typedef struct _GtkLayoutClass GtkLayoutClass;
#line 56 "/usr/include/gtk-2.0/gtk/gtklayout.h"
struct _GtkLayout {
   GtkContainer container ;
   GList *children ;
   guint width ;
   guint height ;
   GtkAdjustment *hadjustment ;
   GtkAdjustment *vadjustment ;
   GdkWindow *bin_window ;
   GdkVisibilityState visibility ;
   gint scroll_x ;
   gint scroll_y ;
   guint freeze_count ;
};
#line 79 "/usr/include/gtk-2.0/gtk/gtklayout.h"
struct _GtkLayoutClass {
   GtkContainerClass parent_class ;
   void (*set_scroll_adjustments)(GtkLayout * , GtkAdjustment * , GtkAdjustment * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 43 "/usr/include/gtk-2.0/gtk/gtklinkbutton.h"
struct _GtkLinkButton ;
#line 43 "/usr/include/gtk-2.0/gtk/gtklinkbutton.h"
typedef struct _GtkLinkButton GtkLinkButton;
#line 44
struct _GtkLinkButtonClass ;
#line 44 "/usr/include/gtk-2.0/gtk/gtklinkbutton.h"
typedef struct _GtkLinkButtonClass GtkLinkButtonClass;
#line 45
struct _GtkLinkButtonPrivate ;
#line 45 "/usr/include/gtk-2.0/gtk/gtklinkbutton.h"
typedef struct _GtkLinkButtonPrivate GtkLinkButtonPrivate;
#line 47 "/usr/include/gtk-2.0/gtk/gtklinkbutton.h"
typedef void (*GtkLinkButtonUriFunc)(GtkLinkButton * , gchar * , gpointer  );
#line 51 "/usr/include/gtk-2.0/gtk/gtklinkbutton.h"
struct _GtkLinkButton {
   GtkButton parent_instance ;
   GtkLinkButtonPrivate *priv ;
};
#line 58 "/usr/include/gtk-2.0/gtk/gtklinkbutton.h"
struct _GtkLinkButtonClass {
   GtkButtonClass parent_class ;
   void (*_gtk_padding1)(void) ;
   void (*_gtk_padding2)(void) ;
   void (*_gtk_padding3)(void) ;
   void (*_gtk_padding4)(void) ;
};
#line 62 "/usr/include/gtk-2.0/gtk/gtkmain.h"
typedef gint (*GtkKeySnoopFunc)(GtkWidget * , GdkEventKey * , gpointer  );
#line 48 "/usr/include/gtk-2.0/gtk/gtkmenubar.h"
struct _GtkMenuBar ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkmenubar.h"
typedef struct _GtkMenuBar GtkMenuBar;
#line 49
struct _GtkMenuBarClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkmenubar.h"
typedef struct _GtkMenuBarClass GtkMenuBarClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkmenubar.h"
struct _GtkMenuBar {
   GtkMenuShell menu_shell ;
};
#line 56 "/usr/include/gtk-2.0/gtk/gtkmenubar.h"
struct _GtkMenuBarClass {
   GtkMenuShellClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 46 "/usr/include/gtk-2.0/gtk/gtktooltips.h"
struct _GtkTooltips ;
#line 46 "/usr/include/gtk-2.0/gtk/gtktooltips.h"
typedef struct _GtkTooltips GtkTooltips;
#line 47
struct _GtkTooltipsClass ;
#line 47 "/usr/include/gtk-2.0/gtk/gtktooltips.h"
typedef struct _GtkTooltipsClass GtkTooltipsClass;
#line 48
struct _GtkTooltipsData ;
#line 48 "/usr/include/gtk-2.0/gtk/gtktooltips.h"
typedef struct _GtkTooltipsData GtkTooltipsData;
#line 50 "/usr/include/gtk-2.0/gtk/gtktooltips.h"
struct _GtkTooltipsData {
   GtkTooltips *tooltips ;
   GtkWidget *widget ;
   gchar *tip_text ;
   gchar *tip_private ;
};
#line 58 "/usr/include/gtk-2.0/gtk/gtktooltips.h"
struct _GtkTooltips {
   GtkObject parent_instance ;
   GtkWidget *tip_window ;
   GtkWidget *tip_label ;
   GtkTooltipsData *active_tips_data ;
   GList *tips_data_list ;
   guint delay ;
   guint enabled ;
   guint have_grab ;
   guint use_sticky_delay ;
   gint timer_tag ;
   GTimeVal last_popdown ;
};
#line 76 "/usr/include/gtk-2.0/gtk/gtktooltips.h"
struct _GtkTooltipsClass {
   GtkObjectClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 40 "/usr/include/gtk-2.0/gtk/gtksizegroup.h"
struct _GtkSizeGroup ;
#line 40 "/usr/include/gtk-2.0/gtk/gtksizegroup.h"
typedef struct _GtkSizeGroup GtkSizeGroup;
#line 41
struct _GtkSizeGroupClass ;
#line 41 "/usr/include/gtk-2.0/gtk/gtksizegroup.h"
typedef struct _GtkSizeGroupClass GtkSizeGroupClass;
#line 43 "/usr/include/gtk-2.0/gtk/gtksizegroup.h"
struct _GtkSizeGroup {
   GObject parent_instance ;
   GSList *widgets ;
   guint8 mode ;
   guint have_width ;
   guint have_height ;
   guint ignore_hidden ;
   GtkRequisition requisition ;
};
#line 59 "/usr/include/gtk-2.0/gtk/gtksizegroup.h"
struct _GtkSizeGroupClass {
   GObjectClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 80
enum __anonenum__595 {
    GTK_SIZE_GROUP_NONE = 0,
    GTK_SIZE_GROUP_HORIZONTAL = 1,
    GTK_SIZE_GROUP_VERTICAL = 2,
    GTK_SIZE_GROUP_BOTH = 3
} ;
#line 85 "/usr/include/gtk-2.0/gtk/gtksizegroup.h"
typedef enum __anonenum__595 GtkSizeGroupMode;
#line 44 "/usr/include/gtk-2.0/gtk/gtktoolitem.h"
struct _GtkToolItem ;
#line 44 "/usr/include/gtk-2.0/gtk/gtktoolitem.h"
typedef struct _GtkToolItem GtkToolItem;
#line 45
struct _GtkToolItemClass ;
#line 45 "/usr/include/gtk-2.0/gtk/gtktoolitem.h"
typedef struct _GtkToolItemClass GtkToolItemClass;
#line 46
struct _GtkToolItemPrivate ;
#line 46 "/usr/include/gtk-2.0/gtk/gtktoolitem.h"
typedef struct _GtkToolItemPrivate GtkToolItemPrivate;
#line 48 "/usr/include/gtk-2.0/gtk/gtktoolitem.h"
struct _GtkToolItem {
   GtkBin parent ;
   GtkToolItemPrivate *priv ;
};
#line 56 "/usr/include/gtk-2.0/gtk/gtktoolitem.h"
struct _GtkToolItemClass {
   GtkBinClass parent_class ;
   gboolean (*create_menu_proxy)(GtkToolItem * ) ;
   void (*toolbar_reconfigured)(GtkToolItem * ) ;
   gboolean (*set_tooltip)(GtkToolItem * , GtkTooltips * , gchar * , gchar * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 41 "/usr/include/gtk-2.0/gtk/gtktoolbutton.h"
struct _GtkToolButton ;
#line 41 "/usr/include/gtk-2.0/gtk/gtktoolbutton.h"
typedef struct _GtkToolButton GtkToolButton;
#line 42
struct _GtkToolButtonClass ;
#line 42 "/usr/include/gtk-2.0/gtk/gtktoolbutton.h"
typedef struct _GtkToolButtonClass GtkToolButtonClass;
#line 43
struct _GtkToolButtonPrivate ;
#line 43 "/usr/include/gtk-2.0/gtk/gtktoolbutton.h"
typedef struct _GtkToolButtonPrivate GtkToolButtonPrivate;
#line 45 "/usr/include/gtk-2.0/gtk/gtktoolbutton.h"
struct _GtkToolButton {
   GtkToolItem parent ;
   GtkToolButtonPrivate *priv ;
};
#line 53 "/usr/include/gtk-2.0/gtk/gtktoolbutton.h"
struct _GtkToolButtonClass {
   GtkToolItemClass parent_class ;
   GType button_type ;
   void (*clicked)(GtkToolButton * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 41 "/usr/include/gtk-2.0/gtk/gtkmenutoolbutton.h"
struct _GtkMenuToolButtonClass ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkmenutoolbutton.h"
typedef struct _GtkMenuToolButtonClass GtkMenuToolButtonClass;
#line 42
struct _GtkMenuToolButton ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkmenutoolbutton.h"
typedef struct _GtkMenuToolButton GtkMenuToolButton;
#line 43
struct _GtkMenuToolButtonPrivate ;
#line 43 "/usr/include/gtk-2.0/gtk/gtkmenutoolbutton.h"
typedef struct _GtkMenuToolButtonPrivate GtkMenuToolButtonPrivate;
#line 45 "/usr/include/gtk-2.0/gtk/gtkmenutoolbutton.h"
struct _GtkMenuToolButton {
   GtkToolButton parent ;
   GtkMenuToolButtonPrivate *priv ;
};
#line 53 "/usr/include/gtk-2.0/gtk/gtkmenutoolbutton.h"
struct _GtkMenuToolButtonClass {
   GtkToolButtonClass parent_class ;
   void (*show_menu)(GtkMenuToolButton * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 47 "/usr/include/gtk-2.0/gtk/gtkmessagedialog.h"
struct _GtkMessageDialog ;
#line 47 "/usr/include/gtk-2.0/gtk/gtkmessagedialog.h"
typedef struct _GtkMessageDialog GtkMessageDialog;
#line 48
struct _GtkMessageDialogClass ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkmessagedialog.h"
typedef struct _GtkMessageDialogClass GtkMessageDialogClass;
#line 50 "/usr/include/gtk-2.0/gtk/gtkmessagedialog.h"
struct _GtkMessageDialog {
   GtkDialog parent_instance ;
   GtkWidget *image ;
   GtkWidget *label ;
};
#line 60 "/usr/include/gtk-2.0/gtk/gtkmessagedialog.h"
struct _GtkMessageDialogClass {
   GtkDialogClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 89
enum __anonenum__596 {
    GTK_BUTTONS_NONE = 0,
    GTK_BUTTONS_OK = 1,
    GTK_BUTTONS_CLOSE = 2,
    GTK_BUTTONS_CANCEL = 3,
    GTK_BUTTONS_YES_NO = 4,
    GTK_BUTTONS_OK_CANCEL = 5
} ;
#line 97 "/usr/include/gtk-2.0/gtk/gtkmessagedialog.h"
typedef enum __anonenum__596 GtkButtonsType;
#line 46 "/usr/include/gtk-2.0/gtk/gtkmodules.h"
typedef void (*GtkModuleInitFunc)(gint * , gchar *** );
#line 48 "/usr/include/gtk-2.0/gtk/gtkmodules.h"
typedef void (*GtkModuleDisplayInitFunc)(GdkDisplay * );
#line 43 "/usr/include/gtk-2.0/gtk/gtkmountoperation.h"
struct _GtkMountOperation ;
#line 43 "/usr/include/gtk-2.0/gtk/gtkmountoperation.h"
typedef struct _GtkMountOperation GtkMountOperation;
#line 44
struct _GtkMountOperationClass ;
#line 44 "/usr/include/gtk-2.0/gtk/gtkmountoperation.h"
typedef struct _GtkMountOperationClass GtkMountOperationClass;
#line 45
struct _GtkMountOperationPrivate ;
#line 45 "/usr/include/gtk-2.0/gtk/gtkmountoperation.h"
typedef struct _GtkMountOperationPrivate GtkMountOperationPrivate;
#line 52 "/usr/include/gtk-2.0/gtk/gtkmountoperation.h"
struct _GtkMountOperation {
   GMountOperation parent_instance ;
   GtkMountOperationPrivate *priv ;
};
#line 59 "/usr/include/gtk-2.0/gtk/gtkmountoperation.h"
struct _GtkMountOperationClass {
   GMountOperationClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 49 "/usr/include/gtk-2.0/gtk/gtknotebook.h"
enum __anonenum__597 {
    GTK_NOTEBOOK_TAB_FIRST = 0,
    GTK_NOTEBOOK_TAB_LAST = 1
} ;
#line 53 "/usr/include/gtk-2.0/gtk/gtknotebook.h"
typedef enum __anonenum__597 GtkNotebookTab;
#line 55
struct _GtkNotebook ;
#line 55 "/usr/include/gtk-2.0/gtk/gtknotebook.h"
typedef struct _GtkNotebook GtkNotebook;
#line 56
struct _GtkNotebookClass ;
#line 56 "/usr/include/gtk-2.0/gtk/gtknotebook.h"
typedef struct _GtkNotebookClass GtkNotebookClass;
#line 58
struct _GtkNotebookPage ;
#line 58 "/usr/include/gtk-2.0/gtk/gtknotebook.h"
typedef struct _GtkNotebookPage GtkNotebookPage;
#line 61 "/usr/include/gtk-2.0/gtk/gtknotebook.h"
struct _GtkNotebook {
   GtkContainer container ;
   GtkNotebookPage *cur_page ;
   GList *children ;
   GList *first_tab ;
   GList *focus_tab ;
   GtkWidget *menu ;
   GdkWindow *event_window ;
   guint32 timer ;
   guint16 tab_hborder ;
   guint16 tab_vborder ;
   guint show_tabs ;
   guint homogeneous ;
   guint show_border ;
   guint tab_pos ;
   guint scrollable ;
   guint in_child ;
   guint click_child ;
   guint button ;
   guint need_timer ;
   guint child_has_focus ;
   guint have_visible_child ;
   guint focus_out ;
   guint has_before_previous ;
   guint has_before_next ;
   guint has_after_previous ;
   guint has_after_next ;
};
#line 101 "/usr/include/gtk-2.0/gtk/gtknotebook.h"
struct _GtkNotebookClass {
   GtkContainerClass parent_class ;
   void (*switch_page)(GtkNotebook * , GtkNotebookPage * , guint  ) ;
   gboolean (*select_page)(GtkNotebook * , gboolean  ) ;
   gboolean (*focus_tab)(GtkNotebook * , GtkNotebookTab  ) ;
   gboolean (*change_current_page)(GtkNotebook * , gint  ) ;
   void (*move_focus_out)(GtkNotebook * , GtkDirectionType  ) ;
   gboolean (*reorder_tab)(GtkNotebook * , GtkDirectionType  , gboolean  ) ;
   gint (*insert_page)(GtkNotebook * , GtkWidget * , GtkWidget * , GtkWidget * , gint  ) ;
   GtkNotebook *(*create_window)(GtkNotebook * , GtkWidget * , gint  , gint  ) ;
   void (*_gtk_reserved1)(void) ;
};
#line 141 "/usr/include/gtk-2.0/gtk/gtknotebook.h"
typedef GtkNotebook *(*GtkNotebookWindowCreationFunc)(GtkNotebook * , GtkWidget * ,
                                                      gint  , gint  , gpointer  );
#line 39 "/usr/include/gtk-2.0/gtk/gtkoffscreenwindow.h"
struct _GtkOffscreenWindow ;
#line 39 "/usr/include/gtk-2.0/gtk/gtkoffscreenwindow.h"
typedef struct _GtkOffscreenWindow GtkOffscreenWindow;
#line 40
struct _GtkOffscreenWindowClass ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkoffscreenwindow.h"
typedef struct _GtkOffscreenWindowClass GtkOffscreenWindowClass;
#line 42 "/usr/include/gtk-2.0/gtk/gtkoffscreenwindow.h"
struct _GtkOffscreenWindow {
   GtkWindow parent_object ;
};
#line 47 "/usr/include/gtk-2.0/gtk/gtkoffscreenwindow.h"
struct _GtkOffscreenWindowClass {
   GtkWindowClass parent_class ;
};
#line 43 "/usr/include/gtk-2.0/gtk/gtkorientable.h"
struct _GtkOrientable ;
#line 43 "/usr/include/gtk-2.0/gtk/gtkorientable.h"
typedef struct _GtkOrientable GtkOrientable;
#line 44
struct _GtkOrientableIface ;
#line 44 "/usr/include/gtk-2.0/gtk/gtkorientable.h"
typedef struct _GtkOrientableIface GtkOrientableIface;
#line 46 "/usr/include/gtk-2.0/gtk/gtkorientable.h"
struct _GtkOrientableIface {
   GTypeInterface base_iface ;
};
#line 34 "/usr/include/gtk-2.0/gtk/gtkpapersize.h"
struct _GtkPaperSize ;
#line 34 "/usr/include/gtk-2.0/gtk/gtkpapersize.h"
typedef struct _GtkPaperSize GtkPaperSize;
#line 34 "/usr/include/gtk-2.0/gtk/gtkpagesetup.h"
struct _GtkPageSetup ;
#line 34 "/usr/include/gtk-2.0/gtk/gtkpagesetup.h"
typedef struct _GtkPageSetup GtkPageSetup;
#line 45 "/usr/include/gtk-2.0/gtk/gtksocket.h"
struct _GtkSocket ;
#line 45 "/usr/include/gtk-2.0/gtk/gtksocket.h"
typedef struct _GtkSocket GtkSocket;
#line 46
struct _GtkSocketClass ;
#line 46 "/usr/include/gtk-2.0/gtk/gtksocket.h"
typedef struct _GtkSocketClass GtkSocketClass;
#line 48 "/usr/include/gtk-2.0/gtk/gtksocket.h"
struct _GtkSocket {
   GtkContainer container ;
   guint16 request_width ;
   guint16 request_height ;
   guint16 current_width ;
   guint16 current_height ;
   GdkWindow *plug_window ;
   GtkWidget *plug_widget ;
   gshort xembed_version ;
   guint same_app ;
   guint focus_in ;
   guint have_size ;
   guint need_map ;
   guint is_mapped ;
   guint active ;
   GtkAccelGroup *accel_group ;
   GtkWidget *toplevel ;
};
#line 72 "/usr/include/gtk-2.0/gtk/gtksocket.h"
struct _GtkSocketClass {
   GtkContainerClass parent_class ;
   void (*plug_added)(GtkSocket * ) ;
   gboolean (*plug_removed)(GtkSocket * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkplug.h"
struct _GtkPlug ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkplug.h"
typedef struct _GtkPlug GtkPlug;
#line 49
struct _GtkPlugClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkplug.h"
typedef struct _GtkPlugClass GtkPlugClass;
#line 52 "/usr/include/gtk-2.0/gtk/gtkplug.h"
struct _GtkPlug {
   GtkWindow window ;
   GdkWindow *socket_window ;
   GtkWidget *modality_window ;
   GtkWindowGroup *modality_group ;
   GHashTable *grabbed_keys ;
   guint same_app ;
};
#line 64 "/usr/include/gtk-2.0/gtk/gtkplug.h"
struct _GtkPlugClass {
   GtkWindowClass parent_class ;
   void (*embedded)(GtkPlug * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 35 "/usr/include/gtk-2.0/gtk/gtkprintcontext.h"
struct _GtkPrintContext ;
#line 35 "/usr/include/gtk-2.0/gtk/gtkprintcontext.h"
typedef struct _GtkPrintContext GtkPrintContext;
#line 32 "/usr/include/gtk-2.0/gtk/gtkprintsettings.h"
struct _GtkPrintSettings ;
#line 32 "/usr/include/gtk-2.0/gtk/gtkprintsettings.h"
typedef struct _GtkPrintSettings GtkPrintSettings;
#line 38 "/usr/include/gtk-2.0/gtk/gtkprintsettings.h"
typedef void (*GtkPrintSettingsFunc)(gchar * , gchar * , gpointer  );
#line 42
struct _GtkPageRange ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkprintsettings.h"
typedef struct _GtkPageRange GtkPageRange;
#line 43 "/usr/include/gtk-2.0/gtk/gtkprintsettings.h"
struct _GtkPageRange {
   gint start ;
   gint end ;
};
#line 38 "/usr/include/gtk-2.0/gtk/gtkprintoperationpreview.h"
struct _GtkPrintOperationPreview ;
#line 38 "/usr/include/gtk-2.0/gtk/gtkprintoperationpreview.h"
typedef struct _GtkPrintOperationPreview GtkPrintOperationPreview;
#line 39
struct _GtkPrintOperationPreviewIface ;
#line 39 "/usr/include/gtk-2.0/gtk/gtkprintoperationpreview.h"
typedef struct _GtkPrintOperationPreviewIface GtkPrintOperationPreviewIface;
#line 42 "/usr/include/gtk-2.0/gtk/gtkprintoperationpreview.h"
struct _GtkPrintOperationPreviewIface {
   GTypeInterface g_iface ;
   void (*ready)(GtkPrintOperationPreview * , GtkPrintContext * ) ;
   void (*got_page_size)(GtkPrintOperationPreview * , GtkPrintContext * , GtkPageSetup * ) ;
   void (*render_page)(GtkPrintOperationPreview * , gint  ) ;
   gboolean (*is_selected)(GtkPrintOperationPreview * , gint  ) ;
   void (*end_preview)(GtkPrintOperationPreview * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
   void (*_gtk_reserved5)(void) ;
   void (*_gtk_reserved6)(void) ;
   void (*_gtk_reserved7)(void) ;
};
#line 47 "/usr/include/gtk-2.0/gtk/gtkprintoperation.h"
struct _GtkPrintOperationClass ;
#line 47 "/usr/include/gtk-2.0/gtk/gtkprintoperation.h"
typedef struct _GtkPrintOperationClass GtkPrintOperationClass;
#line 48
struct _GtkPrintOperationPrivate ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkprintoperation.h"
typedef struct _GtkPrintOperationPrivate GtkPrintOperationPrivate;
#line 49
struct _GtkPrintOperation ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkprintoperation.h"
typedef struct _GtkPrintOperation GtkPrintOperation;
#line 51
enum __anonenum__598 {
    GTK_PRINT_STATUS_INITIAL = 0,
    GTK_PRINT_STATUS_PREPARING = 1,
    GTK_PRINT_STATUS_GENERATING_DATA = 2,
    GTK_PRINT_STATUS_SENDING_DATA = 3,
    GTK_PRINT_STATUS_PENDING = 4,
    GTK_PRINT_STATUS_PENDING_ISSUE = 5,
    GTK_PRINT_STATUS_PRINTING = 6,
    GTK_PRINT_STATUS_FINISHED = 7,
    GTK_PRINT_STATUS_FINISHED_ABORTED = 8
} ;
#line 61 "/usr/include/gtk-2.0/gtk/gtkprintoperation.h"
typedef enum __anonenum__598 GtkPrintStatus;
#line 63
enum __anonenum__599 {
    GTK_PRINT_OPERATION_RESULT_ERROR = 0,
    GTK_PRINT_OPERATION_RESULT_APPLY = 1,
    GTK_PRINT_OPERATION_RESULT_CANCEL = 2,
    GTK_PRINT_OPERATION_RESULT_IN_PROGRESS = 3
} ;
#line 68 "/usr/include/gtk-2.0/gtk/gtkprintoperation.h"
typedef enum __anonenum__599 GtkPrintOperationResult;
#line 70
enum __anonenum__600 {
    GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG = 0,
    GTK_PRINT_OPERATION_ACTION_PRINT = 1,
    GTK_PRINT_OPERATION_ACTION_PREVIEW = 2,
    GTK_PRINT_OPERATION_ACTION_EXPORT = 3
} ;
#line 75 "/usr/include/gtk-2.0/gtk/gtkprintoperation.h"
typedef enum __anonenum__600 GtkPrintOperationAction;
#line 78 "/usr/include/gtk-2.0/gtk/gtkprintoperation.h"
struct _GtkPrintOperation {
   GObject parent_instance ;
   GtkPrintOperationPrivate *priv ;
};
#line 85 "/usr/include/gtk-2.0/gtk/gtkprintoperation.h"
struct _GtkPrintOperationClass {
   GObjectClass parent_class ;
   void (*done)(GtkPrintOperation * , GtkPrintOperationResult  ) ;
   void (*begin_print)(GtkPrintOperation * , GtkPrintContext * ) ;
   gboolean (*paginate)(GtkPrintOperation * , GtkPrintContext * ) ;
   void (*request_page_setup)(GtkPrintOperation * , GtkPrintContext * , gint  , GtkPageSetup * ) ;
   void (*draw_page)(GtkPrintOperation * , GtkPrintContext * , gint  ) ;
   void (*end_print)(GtkPrintOperation * , GtkPrintContext * ) ;
   void (*status_changed)(GtkPrintOperation * ) ;
   GtkWidget *(*create_custom_widget)(GtkPrintOperation * ) ;
   void (*custom_widget_apply)(GtkPrintOperation * , GtkWidget * ) ;
   gboolean (*preview)(GtkPrintOperation * , GtkPrintOperationPreview * , GtkPrintContext * ,
                       GtkWindow * ) ;
   void (*update_custom_widget)(GtkPrintOperation * , GtkWidget * , GtkPageSetup * ,
                                GtkPrintSettings * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
   void (*_gtk_reserved5)(void) ;
   void (*_gtk_reserved6)(void) ;
};
#line 131
enum __anonenum__601 {
    GTK_PRINT_ERROR_GENERAL = 0,
    GTK_PRINT_ERROR_INTERNAL_ERROR = 1,
    GTK_PRINT_ERROR_NOMEM = 2,
    GTK_PRINT_ERROR_INVALID_FILE = 3
} ;
#line 137 "/usr/include/gtk-2.0/gtk/gtkprintoperation.h"
typedef enum __anonenum__601 GtkPrintError;
#line 196 "/usr/include/gtk-2.0/gtk/gtkprintoperation.h"
typedef void (*GtkPageSetupDoneFunc)(GtkPageSetup * , gpointer  );
#line 48 "/usr/include/gtk-2.0/gtk/gtkprogress.h"
struct _GtkProgress ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkprogress.h"
typedef struct _GtkProgress GtkProgress;
#line 49
struct _GtkProgressClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkprogress.h"
typedef struct _GtkProgressClass GtkProgressClass;
#line 52 "/usr/include/gtk-2.0/gtk/gtkprogress.h"
struct _GtkProgress {
   GtkWidget widget ;
   GtkAdjustment *adjustment ;
   GdkPixmap *offscreen_pixmap ;
   gchar *format ;
   gfloat x_align ;
   gfloat y_align ;
   guint show_text ;
   guint activity_mode ;
   guint use_text_format ;
};
#line 67 "/usr/include/gtk-2.0/gtk/gtkprogress.h"
struct _GtkProgressClass {
   GtkWidgetClass parent_class ;
   void (*paint)(GtkProgress * ) ;
   void (*update)(GtkProgress * ) ;
   void (*act_mode_enter)(GtkProgress * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkprogressbar.h"
struct _GtkProgressBar ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkprogressbar.h"
typedef struct _GtkProgressBar GtkProgressBar;
#line 49
struct _GtkProgressBarClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkprogressbar.h"
typedef struct _GtkProgressBarClass GtkProgressBarClass;
#line 51
enum __anonenum__602 {
    GTK_PROGRESS_CONTINUOUS = 0,
    GTK_PROGRESS_DISCRETE = 1
} ;
#line 55 "/usr/include/gtk-2.0/gtk/gtkprogressbar.h"
typedef enum __anonenum__602 GtkProgressBarStyle;
#line 57
enum __anonenum__603 {
    GTK_PROGRESS_LEFT_TO_RIGHT = 0,
    GTK_PROGRESS_RIGHT_TO_LEFT = 1,
    GTK_PROGRESS_BOTTOM_TO_TOP = 2,
    GTK_PROGRESS_TOP_TO_BOTTOM = 3
} ;
#line 63 "/usr/include/gtk-2.0/gtk/gtkprogressbar.h"
typedef enum __anonenum__603 GtkProgressBarOrientation;
#line 65 "/usr/include/gtk-2.0/gtk/gtkprogressbar.h"
struct _GtkProgressBar {
   GtkProgress progress ;
   GtkProgressBarStyle bar_style ;
   GtkProgressBarOrientation orientation ;
   guint blocks ;
   gint in_block ;
   gint activity_pos ;
   guint activity_step ;
   guint activity_blocks ;
   gdouble pulse_fraction ;
   guint activity_dir ;
   guint ellipsize ;
   guint dirty ;
};
#line 86 "/usr/include/gtk-2.0/gtk/gtkprogressbar.h"
struct _GtkProgressBarClass {
   GtkProgressClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 49 "/usr/include/gtk-2.0/gtk/gtktoggleaction.h"
struct _GtkToggleAction ;
#line 49 "/usr/include/gtk-2.0/gtk/gtktoggleaction.h"
typedef struct _GtkToggleAction GtkToggleAction;
#line 50
struct _GtkToggleActionPrivate ;
#line 50 "/usr/include/gtk-2.0/gtk/gtktoggleaction.h"
typedef struct _GtkToggleActionPrivate GtkToggleActionPrivate;
#line 51
struct _GtkToggleActionClass ;
#line 51 "/usr/include/gtk-2.0/gtk/gtktoggleaction.h"
typedef struct _GtkToggleActionClass GtkToggleActionClass;
#line 53 "/usr/include/gtk-2.0/gtk/gtktoggleaction.h"
struct _GtkToggleAction {
   GtkAction parent ;
   GtkToggleActionPrivate *private_data ;
};
#line 62 "/usr/include/gtk-2.0/gtk/gtktoggleaction.h"
struct _GtkToggleActionClass {
   GtkActionClass parent_class ;
   void (*toggled)(GtkToggleAction * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 49 "/usr/include/gtk-2.0/gtk/gtkradioaction.h"
struct _GtkRadioAction ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkradioaction.h"
typedef struct _GtkRadioAction GtkRadioAction;
#line 50
struct _GtkRadioActionPrivate ;
#line 50 "/usr/include/gtk-2.0/gtk/gtkradioaction.h"
typedef struct _GtkRadioActionPrivate GtkRadioActionPrivate;
#line 51
struct _GtkRadioActionClass ;
#line 51 "/usr/include/gtk-2.0/gtk/gtkradioaction.h"
typedef struct _GtkRadioActionClass GtkRadioActionClass;
#line 53 "/usr/include/gtk-2.0/gtk/gtkradioaction.h"
struct _GtkRadioAction {
   GtkToggleAction parent ;
   GtkRadioActionPrivate *private_data ;
};
#line 62 "/usr/include/gtk-2.0/gtk/gtkradioaction.h"
struct _GtkRadioActionClass {
   GtkToggleActionClass parent_class ;
   void (*changed)(GtkRadioAction * , GtkRadioAction * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkradiobutton.h"
struct _GtkRadioButton ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkradiobutton.h"
typedef struct _GtkRadioButton GtkRadioButton;
#line 49
struct _GtkRadioButtonClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkradiobutton.h"
typedef struct _GtkRadioButtonClass GtkRadioButtonClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkradiobutton.h"
struct _GtkRadioButton {
   GtkCheckButton check_button ;
   GSList *group ;
};
#line 58 "/usr/include/gtk-2.0/gtk/gtkradiobutton.h"
struct _GtkRadioButtonClass {
   GtkCheckButtonClass parent_class ;
   void (*group_changed)(GtkRadioButton * ) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkradiomenuitem.h"
struct _GtkRadioMenuItem ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkradiomenuitem.h"
typedef struct _GtkRadioMenuItem GtkRadioMenuItem;
#line 49
struct _GtkRadioMenuItemClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkradiomenuitem.h"
typedef struct _GtkRadioMenuItemClass GtkRadioMenuItemClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkradiomenuitem.h"
struct _GtkRadioMenuItem {
   GtkCheckMenuItem check_menu_item ;
   GSList *group ;
};
#line 58 "/usr/include/gtk-2.0/gtk/gtkradiomenuitem.h"
struct _GtkRadioMenuItemClass {
   GtkCheckMenuItemClass parent_class ;
   void (*group_changed)(GtkRadioMenuItem * ) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 41 "/usr/include/gtk-2.0/gtk/gtktoggletoolbutton.h"
struct _GtkToggleToolButton ;
#line 41 "/usr/include/gtk-2.0/gtk/gtktoggletoolbutton.h"
typedef struct _GtkToggleToolButton GtkToggleToolButton;
#line 42
struct _GtkToggleToolButtonClass ;
#line 42 "/usr/include/gtk-2.0/gtk/gtktoggletoolbutton.h"
typedef struct _GtkToggleToolButtonClass GtkToggleToolButtonClass;
#line 43
struct _GtkToggleToolButtonPrivate ;
#line 43 "/usr/include/gtk-2.0/gtk/gtktoggletoolbutton.h"
typedef struct _GtkToggleToolButtonPrivate GtkToggleToolButtonPrivate;
#line 45 "/usr/include/gtk-2.0/gtk/gtktoggletoolbutton.h"
struct _GtkToggleToolButton {
   GtkToolButton parent ;
   GtkToggleToolButtonPrivate *priv ;
};
#line 53 "/usr/include/gtk-2.0/gtk/gtktoggletoolbutton.h"
struct _GtkToggleToolButtonClass {
   GtkToolButtonClass parent_class ;
   void (*toggled)(GtkToggleToolButton * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 41 "/usr/include/gtk-2.0/gtk/gtkradiotoolbutton.h"
struct _GtkRadioToolButton ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkradiotoolbutton.h"
typedef struct _GtkRadioToolButton GtkRadioToolButton;
#line 42
struct _GtkRadioToolButtonClass ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkradiotoolbutton.h"
typedef struct _GtkRadioToolButtonClass GtkRadioToolButtonClass;
#line 44 "/usr/include/gtk-2.0/gtk/gtkradiotoolbutton.h"
struct _GtkRadioToolButton {
   GtkToggleToolButton parent ;
};
#line 49 "/usr/include/gtk-2.0/gtk/gtkradiotoolbutton.h"
struct _GtkRadioToolButtonClass {
   GtkToggleToolButtonClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 43 "/usr/include/gtk-2.0/gtk/gtkrecentmanager.h"
struct _GtkRecentInfo ;
#line 43 "/usr/include/gtk-2.0/gtk/gtkrecentmanager.h"
typedef struct _GtkRecentInfo GtkRecentInfo;
#line 44
struct _GtkRecentData ;
#line 44 "/usr/include/gtk-2.0/gtk/gtkrecentmanager.h"
typedef struct _GtkRecentData GtkRecentData;
#line 45
struct _GtkRecentManager ;
#line 45 "/usr/include/gtk-2.0/gtk/gtkrecentmanager.h"
typedef struct _GtkRecentManager GtkRecentManager;
#line 46
struct _GtkRecentManagerClass ;
#line 46 "/usr/include/gtk-2.0/gtk/gtkrecentmanager.h"
typedef struct _GtkRecentManagerClass GtkRecentManagerClass;
#line 47
struct _GtkRecentManagerPrivate ;
#line 47 "/usr/include/gtk-2.0/gtk/gtkrecentmanager.h"
typedef struct _GtkRecentManagerPrivate GtkRecentManagerPrivate;
#line 69 "/usr/include/gtk-2.0/gtk/gtkrecentmanager.h"
struct _GtkRecentData {
   gchar *display_name ;
   gchar *description ;
   gchar *mime_type ;
   gchar *app_name ;
   gchar *app_exec ;
   gchar **groups ;
   gboolean is_private ;
};
#line 84 "/usr/include/gtk-2.0/gtk/gtkrecentmanager.h"
struct _GtkRecentManager {
   GObject parent_instance ;
   GtkRecentManagerPrivate *priv ;
};
#line 92 "/usr/include/gtk-2.0/gtk/gtkrecentmanager.h"
struct _GtkRecentManagerClass {
   GObjectClass parent_class ;
   void (*changed)(GtkRecentManager * ) ;
   void (*_gtk_recent1)(void) ;
   void (*_gtk_recent2)(void) ;
   void (*_gtk_recent3)(void) ;
   void (*_gtk_recent4)(void) ;
};
#line 123
enum __anonenum__604 {
    GTK_RECENT_MANAGER_ERROR_NOT_FOUND = 0,
    GTK_RECENT_MANAGER_ERROR_INVALID_URI = 1,
    GTK_RECENT_MANAGER_ERROR_INVALID_ENCODING = 2,
    GTK_RECENT_MANAGER_ERROR_NOT_REGISTERED = 3,
    GTK_RECENT_MANAGER_ERROR_READ = 4,
    GTK_RECENT_MANAGER_ERROR_WRITE = 5,
    GTK_RECENT_MANAGER_ERROR_UNKNOWN = 6
} ;
#line 132 "/usr/include/gtk-2.0/gtk/gtkrecentmanager.h"
typedef enum __anonenum__604 GtkRecentManagerError;
#line 41 "/usr/include/gtk-2.0/gtk/gtkrecentaction.h"
struct _GtkRecentAction ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkrecentaction.h"
typedef struct _GtkRecentAction GtkRecentAction;
#line 42
struct _GtkRecentActionPrivate ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkrecentaction.h"
typedef struct _GtkRecentActionPrivate GtkRecentActionPrivate;
#line 43
struct _GtkRecentActionClass ;
#line 43 "/usr/include/gtk-2.0/gtk/gtkrecentaction.h"
typedef struct _GtkRecentActionClass GtkRecentActionClass;
#line 45 "/usr/include/gtk-2.0/gtk/gtkrecentaction.h"
struct _GtkRecentAction {
   GtkAction parent_instance ;
   GtkRecentActionPrivate *priv ;
};
#line 53 "/usr/include/gtk-2.0/gtk/gtkrecentaction.h"
struct _GtkRecentActionClass {
   GtkActionClass parent_class ;
};
#line 36 "/usr/include/gtk-2.0/gtk/gtkrecentfilter.h"
struct _GtkRecentFilter ;
#line 36 "/usr/include/gtk-2.0/gtk/gtkrecentfilter.h"
typedef struct _GtkRecentFilter GtkRecentFilter;
#line 37
struct _GtkRecentFilterInfo ;
#line 37 "/usr/include/gtk-2.0/gtk/gtkrecentfilter.h"
typedef struct _GtkRecentFilterInfo GtkRecentFilterInfo;
#line 39
enum __anonenum__605 {
    GTK_RECENT_FILTER_URI = 1,
    GTK_RECENT_FILTER_DISPLAY_NAME = 2,
    GTK_RECENT_FILTER_MIME_TYPE = 4,
    GTK_RECENT_FILTER_APPLICATION = 8,
    GTK_RECENT_FILTER_GROUP = 16,
    GTK_RECENT_FILTER_AGE = 32
} ;
#line 46 "/usr/include/gtk-2.0/gtk/gtkrecentfilter.h"
typedef enum __anonenum__605 GtkRecentFilterFlags;
#line 48 "/usr/include/gtk-2.0/gtk/gtkrecentfilter.h"
typedef gboolean (*GtkRecentFilterFunc)(GtkRecentFilterInfo * , gpointer  );
#line 51 "/usr/include/gtk-2.0/gtk/gtkrecentfilter.h"
struct _GtkRecentFilterInfo {
   GtkRecentFilterFlags contains ;
   gchar *uri ;
   gchar *display_name ;
   gchar *mime_type ;
   gchar **applications ;
   gchar **groups ;
   gint age ;
};
#line 54 "/usr/include/gtk-2.0/gtk/gtkrecentchooser.h"
enum __anonenum__606 {
    GTK_RECENT_SORT_NONE = 0,
    GTK_RECENT_SORT_MRU = 1,
    GTK_RECENT_SORT_LRU = 2,
    GTK_RECENT_SORT_CUSTOM = 3
} ;
#line 60 "/usr/include/gtk-2.0/gtk/gtkrecentchooser.h"
typedef enum __anonenum__606 GtkRecentSortType;
#line 62 "/usr/include/gtk-2.0/gtk/gtkrecentchooser.h"
typedef gint (*GtkRecentSortFunc)(GtkRecentInfo * , GtkRecentInfo * , gpointer  );
#line 67
struct _GtkRecentChooser ;
#line 67 "/usr/include/gtk-2.0/gtk/gtkrecentchooser.h"
typedef struct _GtkRecentChooser GtkRecentChooser;
#line 68
struct _GtkRecentChooserIface ;
#line 68 "/usr/include/gtk-2.0/gtk/gtkrecentchooser.h"
typedef struct _GtkRecentChooserIface GtkRecentChooserIface;
#line 72
enum __anonenum__607 {
    GTK_RECENT_CHOOSER_ERROR_NOT_FOUND = 0,
    GTK_RECENT_CHOOSER_ERROR_INVALID_URI = 1
} ;
#line 76 "/usr/include/gtk-2.0/gtk/gtkrecentchooser.h"
typedef enum __anonenum__607 GtkRecentChooserError;
#line 81 "/usr/include/gtk-2.0/gtk/gtkrecentchooser.h"
struct _GtkRecentChooserIface {
   GTypeInterface base_iface ;
   gboolean (*set_current_uri)(GtkRecentChooser * , gchar * , GError ** ) ;
   gchar *(*get_current_uri)(GtkRecentChooser * ) ;
   gboolean (*select_uri)(GtkRecentChooser * , gchar * , GError ** ) ;
   void (*unselect_uri)(GtkRecentChooser * , gchar * ) ;
   void (*select_all)(GtkRecentChooser * ) ;
   void (*unselect_all)(GtkRecentChooser * ) ;
   GList *(*get_items)(GtkRecentChooser * ) ;
   GtkRecentManager *(*get_recent_manager)(GtkRecentChooser * ) ;
   void (*add_filter)(GtkRecentChooser * , GtkRecentFilter * ) ;
   void (*remove_filter)(GtkRecentChooser * , GtkRecentFilter * ) ;
   GSList *(*list_filters)(GtkRecentChooser * ) ;
   void (*set_sort_func)(GtkRecentChooser * , GtkRecentSortFunc  , gpointer  , GDestroyNotify  ) ;
   void (*item_activated)(GtkRecentChooser * ) ;
   void (*selection_changed)(GtkRecentChooser * ) ;
};
#line 40 "/usr/include/gtk-2.0/gtk/gtkrecentchooserdialog.h"
struct _GtkRecentChooserDialog ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkrecentchooserdialog.h"
typedef struct _GtkRecentChooserDialog GtkRecentChooserDialog;
#line 41
struct _GtkRecentChooserDialogClass ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkrecentchooserdialog.h"
typedef struct _GtkRecentChooserDialogClass GtkRecentChooserDialogClass;
#line 43
struct _GtkRecentChooserDialogPrivate ;
#line 43 "/usr/include/gtk-2.0/gtk/gtkrecentchooserdialog.h"
typedef struct _GtkRecentChooserDialogPrivate GtkRecentChooserDialogPrivate;
#line 46 "/usr/include/gtk-2.0/gtk/gtkrecentchooserdialog.h"
struct _GtkRecentChooserDialog {
   GtkDialog parent_instance ;
   GtkRecentChooserDialogPrivate *priv ;
};
#line 54 "/usr/include/gtk-2.0/gtk/gtkrecentchooserdialog.h"
struct _GtkRecentChooserDialogClass {
   GtkDialogClass parent_class ;
};
#line 40 "/usr/include/gtk-2.0/gtk/gtkrecentchoosermenu.h"
struct _GtkRecentChooserMenu ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkrecentchoosermenu.h"
typedef struct _GtkRecentChooserMenu GtkRecentChooserMenu;
#line 41
struct _GtkRecentChooserMenuClass ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkrecentchoosermenu.h"
typedef struct _GtkRecentChooserMenuClass GtkRecentChooserMenuClass;
#line 42
struct _GtkRecentChooserMenuPrivate ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkrecentchoosermenu.h"
typedef struct _GtkRecentChooserMenuPrivate GtkRecentChooserMenuPrivate;
#line 44 "/usr/include/gtk-2.0/gtk/gtkrecentchoosermenu.h"
struct _GtkRecentChooserMenu {
   GtkMenu parent_instance ;
   GtkRecentChooserMenuPrivate *priv ;
};
#line 52 "/usr/include/gtk-2.0/gtk/gtkrecentchoosermenu.h"
struct _GtkRecentChooserMenuClass {
   GtkMenuClass parent_class ;
   void (*gtk_recent1)(void) ;
   void (*gtk_recent2)(void) ;
   void (*gtk_recent3)(void) ;
   void (*gtk_recent4)(void) ;
};
#line 40 "/usr/include/gtk-2.0/gtk/gtkrecentchooserwidget.h"
struct _GtkRecentChooserWidget ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkrecentchooserwidget.h"
typedef struct _GtkRecentChooserWidget GtkRecentChooserWidget;
#line 41
struct _GtkRecentChooserWidgetClass ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkrecentchooserwidget.h"
typedef struct _GtkRecentChooserWidgetClass GtkRecentChooserWidgetClass;
#line 43
struct _GtkRecentChooserWidgetPrivate ;
#line 43 "/usr/include/gtk-2.0/gtk/gtkrecentchooserwidget.h"
typedef struct _GtkRecentChooserWidgetPrivate GtkRecentChooserWidgetPrivate;
#line 45 "/usr/include/gtk-2.0/gtk/gtkrecentchooserwidget.h"
struct _GtkRecentChooserWidget {
   GtkVBox parent_instance ;
   GtkRecentChooserWidgetPrivate *priv ;
};
#line 53 "/usr/include/gtk-2.0/gtk/gtkrecentchooserwidget.h"
struct _GtkRecentChooserWidgetClass {
   GtkVBoxClass parent_class ;
};
#line 54 "/usr/include/gtk-2.0/gtk/gtkscalebutton.h"
struct _GtkScaleButton ;
#line 54 "/usr/include/gtk-2.0/gtk/gtkscalebutton.h"
typedef struct _GtkScaleButton GtkScaleButton;
#line 55
struct _GtkScaleButtonClass ;
#line 55 "/usr/include/gtk-2.0/gtk/gtkscalebutton.h"
typedef struct _GtkScaleButtonClass GtkScaleButtonClass;
#line 56
struct _GtkScaleButtonPrivate ;
#line 56 "/usr/include/gtk-2.0/gtk/gtkscalebutton.h"
typedef struct _GtkScaleButtonPrivate GtkScaleButtonPrivate;
#line 58 "/usr/include/gtk-2.0/gtk/gtkscalebutton.h"
struct _GtkScaleButton {
   GtkButton parent ;
   GtkWidget *plus_button ;
   GtkWidget *minus_button ;
   GtkScaleButtonPrivate *priv ;
};
#line 69 "/usr/include/gtk-2.0/gtk/gtkscalebutton.h"
struct _GtkScaleButtonClass {
   GtkButtonClass parent_class ;
   void (*value_changed)(GtkScaleButton * , gdouble  ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 49 "/usr/include/gtk-2.0/gtk/gtkvscrollbar.h"
struct _GtkVScrollbar ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkvscrollbar.h"
typedef struct _GtkVScrollbar GtkVScrollbar;
#line 50
struct _GtkVScrollbarClass ;
#line 50 "/usr/include/gtk-2.0/gtk/gtkvscrollbar.h"
typedef struct _GtkVScrollbarClass GtkVScrollbarClass;
#line 58 "/usr/include/gtk-2.0/gtk/gtkvscrollbar.h"
struct _GtkVScrollbar {
   GtkScrollbar scrollbar ;
};
#line 63 "/usr/include/gtk-2.0/gtk/gtkvscrollbar.h"
struct _GtkVScrollbarClass {
   GtkScrollbarClass parent_class ;
};
#line 50 "/usr/include/gtk-2.0/gtk/gtkviewport.h"
struct _GtkViewport ;
#line 50 "/usr/include/gtk-2.0/gtk/gtkviewport.h"
typedef struct _GtkViewport GtkViewport;
#line 51
struct _GtkViewportClass ;
#line 51 "/usr/include/gtk-2.0/gtk/gtkviewport.h"
typedef struct _GtkViewportClass GtkViewportClass;
#line 53 "/usr/include/gtk-2.0/gtk/gtkviewport.h"
struct _GtkViewport {
   GtkBin bin ;
   GtkShadowType shadow_type ;
   GdkWindow *view_window ;
   GdkWindow *bin_window ;
   GtkAdjustment *hadjustment ;
   GtkAdjustment *vadjustment ;
};
#line 64 "/usr/include/gtk-2.0/gtk/gtkviewport.h"
struct _GtkViewportClass {
   GtkBinClass parent_class ;
   void (*set_scroll_adjustments)(GtkViewport * , GtkAdjustment * , GtkAdjustment * ) ;
};
#line 52 "/usr/include/gtk-2.0/gtk/gtkscrolledwindow.h"
struct _GtkScrolledWindow ;
#line 52 "/usr/include/gtk-2.0/gtk/gtkscrolledwindow.h"
typedef struct _GtkScrolledWindow GtkScrolledWindow;
#line 53
struct _GtkScrolledWindowClass ;
#line 53 "/usr/include/gtk-2.0/gtk/gtkscrolledwindow.h"
typedef struct _GtkScrolledWindowClass GtkScrolledWindowClass;
#line 55 "/usr/include/gtk-2.0/gtk/gtkscrolledwindow.h"
struct _GtkScrolledWindow {
   GtkBin container ;
   GtkWidget *hscrollbar ;
   GtkWidget *vscrollbar ;
   guint hscrollbar_policy ;
   guint vscrollbar_policy ;
   guint hscrollbar_visible ;
   guint vscrollbar_visible ;
   guint window_placement ;
   guint focus_out ;
   guint16 shadow_type ;
};
#line 74 "/usr/include/gtk-2.0/gtk/gtkscrolledwindow.h"
struct _GtkScrolledWindowClass {
   GtkBinClass parent_class ;
   gint scrollbar_spacing ;
   gboolean (*scroll_child)(GtkScrolledWindow * , GtkScrollType  , gboolean  ) ;
   void (*move_focus_out)(GtkScrolledWindow * , GtkDirectionType  ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkseparatormenuitem.h"
struct _GtkSeparatorMenuItem ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkseparatormenuitem.h"
typedef struct _GtkSeparatorMenuItem GtkSeparatorMenuItem;
#line 49
struct _GtkSeparatorMenuItemClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkseparatormenuitem.h"
typedef struct _GtkSeparatorMenuItemClass GtkSeparatorMenuItemClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkseparatormenuitem.h"
struct _GtkSeparatorMenuItem {
   GtkMenuItem menu_item ;
};
#line 56 "/usr/include/gtk-2.0/gtk/gtkseparatormenuitem.h"
struct _GtkSeparatorMenuItemClass {
   GtkMenuItemClass parent_class ;
};
#line 40 "/usr/include/gtk-2.0/gtk/gtkseparatortoolitem.h"
struct _GtkSeparatorToolItem ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkseparatortoolitem.h"
typedef struct _GtkSeparatorToolItem GtkSeparatorToolItem;
#line 41
struct _GtkSeparatorToolItemClass ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkseparatortoolitem.h"
typedef struct _GtkSeparatorToolItemClass GtkSeparatorToolItemClass;
#line 42
struct _GtkSeparatorToolItemPrivate ;
#line 42 "/usr/include/gtk-2.0/gtk/gtkseparatortoolitem.h"
typedef struct _GtkSeparatorToolItemPrivate GtkSeparatorToolItemPrivate;
#line 44 "/usr/include/gtk-2.0/gtk/gtkseparatortoolitem.h"
struct _GtkSeparatorToolItem {
   GtkToolItem parent ;
   GtkSeparatorToolItemPrivate *priv ;
};
#line 52 "/usr/include/gtk-2.0/gtk/gtkseparatortoolitem.h"
struct _GtkSeparatorToolItemClass {
   GtkToolItemClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 53 "/usr/include/gtk-2.0/gtk/gtkspinbutton.h"
enum __anonenum__608 {
    GTK_UPDATE_ALWAYS = 0,
    GTK_UPDATE_IF_VALID = 1
} ;
#line 57 "/usr/include/gtk-2.0/gtk/gtkspinbutton.h"
typedef enum __anonenum__608 GtkSpinButtonUpdatePolicy;
#line 59
enum __anonenum__609 {
    GTK_SPIN_STEP_FORWARD = 0,
    GTK_SPIN_STEP_BACKWARD = 1,
    GTK_SPIN_PAGE_FORWARD = 2,
    GTK_SPIN_PAGE_BACKWARD = 3,
    GTK_SPIN_HOME = 4,
    GTK_SPIN_END = 5,
    GTK_SPIN_USER_DEFINED = 6
} ;
#line 68 "/usr/include/gtk-2.0/gtk/gtkspinbutton.h"
typedef enum __anonenum__609 GtkSpinType;
#line 71
struct _GtkSpinButton ;
#line 71 "/usr/include/gtk-2.0/gtk/gtkspinbutton.h"
typedef struct _GtkSpinButton GtkSpinButton;
#line 72
struct _GtkSpinButtonClass ;
#line 72 "/usr/include/gtk-2.0/gtk/gtkspinbutton.h"
typedef struct _GtkSpinButtonClass GtkSpinButtonClass;
#line 75 "/usr/include/gtk-2.0/gtk/gtkspinbutton.h"
struct _GtkSpinButton {
   GtkEntry entry ;
   GtkAdjustment *adjustment ;
   GdkWindow *panel ;
   guint32 timer ;
   gdouble climb_rate ;
   gdouble timer_step ;
   GtkSpinButtonUpdatePolicy update_policy ;
   guint in_child ;
   guint click_child ;
   guint button ;
   guint need_timer ;
   guint timer_calls ;
   guint digits ;
   guint numeric ;
   guint wrap ;
   guint snap_to_ticks ;
};
#line 101 "/usr/include/gtk-2.0/gtk/gtkspinbutton.h"
struct _GtkSpinButtonClass {
   GtkEntryClass parent_class ;
   gint (*input)(GtkSpinButton * , gdouble * ) ;
   gint (*output)(GtkSpinButton * ) ;
   void (*value_changed)(GtkSpinButton * ) ;
   void (*change_value)(GtkSpinButton * , GtkScrollType  ) ;
   void (*wrapped)(GtkSpinButton * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
};
#line 43 "/usr/include/gtk-2.0/gtk/gtkspinner.h"
struct _GtkSpinner ;
#line 43 "/usr/include/gtk-2.0/gtk/gtkspinner.h"
typedef struct _GtkSpinner GtkSpinner;
#line 44
struct _GtkSpinnerClass ;
#line 44 "/usr/include/gtk-2.0/gtk/gtkspinner.h"
typedef struct _GtkSpinnerClass GtkSpinnerClass;
#line 45
struct _GtkSpinnerPrivate ;
#line 45 "/usr/include/gtk-2.0/gtk/gtkspinner.h"
typedef struct _GtkSpinnerPrivate GtkSpinnerPrivate;
#line 47 "/usr/include/gtk-2.0/gtk/gtkspinner.h"
struct _GtkSpinner {
   GtkDrawingArea parent ;
   GtkSpinnerPrivate *priv ;
};
#line 53 "/usr/include/gtk-2.0/gtk/gtkspinner.h"
struct _GtkSpinnerClass {
   GtkDrawingAreaClass parent_class ;
};
#line 47 "/usr/include/gtk-2.0/gtk/gtkstatusbar.h"
struct _GtkStatusbar ;
#line 47 "/usr/include/gtk-2.0/gtk/gtkstatusbar.h"
typedef struct _GtkStatusbar GtkStatusbar;
#line 48
struct _GtkStatusbarClass ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkstatusbar.h"
typedef struct _GtkStatusbarClass GtkStatusbarClass;
#line 50 "/usr/include/gtk-2.0/gtk/gtkstatusbar.h"
struct _GtkStatusbar {
   GtkHBox parent_widget ;
   GtkWidget *frame ;
   GtkWidget *label ;
   GSList *messages ;
   GSList *keys ;
   guint seq_context_id ;
   guint seq_message_id ;
   GdkWindow *grip_window ;
   guint has_resize_grip ;
};
#line 68 "/usr/include/gtk-2.0/gtk/gtkstatusbar.h"
struct _GtkStatusbarClass {
   GtkHBoxClass parent_class ;
   gpointer reserved ;
   void (*text_pushed)(GtkStatusbar * , guint  , gchar * ) ;
   void (*text_popped)(GtkStatusbar * , guint  , gchar * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 43 "/usr/include/gtk-2.0/gtk/gtkstatusicon.h"
struct _GtkStatusIcon ;
#line 43 "/usr/include/gtk-2.0/gtk/gtkstatusicon.h"
typedef struct _GtkStatusIcon GtkStatusIcon;
#line 44
struct _GtkStatusIconClass ;
#line 44 "/usr/include/gtk-2.0/gtk/gtkstatusicon.h"
typedef struct _GtkStatusIconClass GtkStatusIconClass;
#line 45
struct _GtkStatusIconPrivate ;
#line 45 "/usr/include/gtk-2.0/gtk/gtkstatusicon.h"
typedef struct _GtkStatusIconPrivate GtkStatusIconPrivate;
#line 47 "/usr/include/gtk-2.0/gtk/gtkstatusicon.h"
struct _GtkStatusIcon {
   GObject parent_instance ;
   GtkStatusIconPrivate *priv ;
};
#line 54 "/usr/include/gtk-2.0/gtk/gtkstatusicon.h"
struct _GtkStatusIconClass {
   GObjectClass parent_class ;
   void (*activate)(GtkStatusIcon * ) ;
   void (*popup_menu)(GtkStatusIcon * , guint  , guint32  ) ;
   gboolean (*size_changed)(GtkStatusIcon * , gint  ) ;
   gboolean (*button_press_event)(GtkStatusIcon * , GdkEventButton * ) ;
   gboolean (*button_release_event)(GtkStatusIcon * , GdkEventButton * ) ;
   gboolean (*scroll_event)(GtkStatusIcon * , GdkEventScroll * ) ;
   gboolean (*query_tooltip)(GtkStatusIcon * , gint  , gint  , gboolean  , GtkTooltip * ) ;
   void *__gtk_reserved1 ;
   void *__gtk_reserved2 ;
};
#line 40 "/usr/include/gtk-2.0/gtk/gtkstock.h"
struct _GtkStockItem ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkstock.h"
typedef struct _GtkStockItem GtkStockItem;
#line 42 "/usr/include/gtk-2.0/gtk/gtkstock.h"
struct _GtkStockItem {
   gchar *stock_id ;
   gchar *label ;
   GdkModifierType modifier ;
   guint keyval ;
   gchar *translation_domain ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtktable.h"
struct _GtkTable ;
#line 48 "/usr/include/gtk-2.0/gtk/gtktable.h"
typedef struct _GtkTable GtkTable;
#line 49
struct _GtkTableClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtktable.h"
typedef struct _GtkTableClass GtkTableClass;
#line 50
struct _GtkTableChild ;
#line 50 "/usr/include/gtk-2.0/gtk/gtktable.h"
typedef struct _GtkTableChild GtkTableChild;
#line 51
struct _GtkTableRowCol ;
#line 51 "/usr/include/gtk-2.0/gtk/gtktable.h"
typedef struct _GtkTableRowCol GtkTableRowCol;
#line 53 "/usr/include/gtk-2.0/gtk/gtktable.h"
struct _GtkTable {
   GtkContainer container ;
   GList *children ;
   GtkTableRowCol *rows ;
   GtkTableRowCol *cols ;
   guint16 nrows ;
   guint16 ncols ;
   guint16 column_spacing ;
   guint16 row_spacing ;
   guint homogeneous ;
};
#line 67 "/usr/include/gtk-2.0/gtk/gtktable.h"
struct _GtkTableClass {
   GtkContainerClass parent_class ;
};
#line 72 "/usr/include/gtk-2.0/gtk/gtktable.h"
struct _GtkTableChild {
   GtkWidget *widget ;
   guint16 left_attach ;
   guint16 right_attach ;
   guint16 top_attach ;
   guint16 bottom_attach ;
   guint16 xpadding ;
   guint16 ypadding ;
   guint xexpand ;
   guint yexpand ;
   guint xshrink ;
   guint yshrink ;
   guint xfill ;
   guint yfill ;
};
#line 89 "/usr/include/gtk-2.0/gtk/gtktable.h"
struct _GtkTableRowCol {
   guint16 requisition ;
   guint16 allocation ;
   guint16 spacing ;
   guint need_expand ;
   guint need_shrink ;
   guint expand ;
   guint shrink ;
   guint empty ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtktearoffmenuitem.h"
struct _GtkTearoffMenuItem ;
#line 48 "/usr/include/gtk-2.0/gtk/gtktearoffmenuitem.h"
typedef struct _GtkTearoffMenuItem GtkTearoffMenuItem;
#line 49
struct _GtkTearoffMenuItemClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtktearoffmenuitem.h"
typedef struct _GtkTearoffMenuItemClass GtkTearoffMenuItemClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtktearoffmenuitem.h"
struct _GtkTearoffMenuItem {
   GtkMenuItem menu_item ;
   guint torn_off ;
};
#line 58 "/usr/include/gtk-2.0/gtk/gtktearoffmenuitem.h"
struct _GtkTearoffMenuItemClass {
   GtkMenuItemClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 38 "/usr/include/gtk-2.0/gtk/gtktexttagtable.h"
typedef void (*GtkTextTagTableForeach)(GtkTextTag * , gpointer  );
#line 47
struct _GtkTextTagTableClass ;
#line 47 "/usr/include/gtk-2.0/gtk/gtktexttagtable.h"
typedef struct _GtkTextTagTableClass GtkTextTagTableClass;
#line 49 "/usr/include/gtk-2.0/gtk/gtktexttagtable.h"
struct _GtkTextTagTable {
   GObject parent_instance ;
   GHashTable *hash ;
   GSList *anonymous ;
   gint anon_count ;
   GSList *buffers ;
};
#line 60 "/usr/include/gtk-2.0/gtk/gtktexttagtable.h"
struct _GtkTextTagTableClass {
   GObjectClass parent_class ;
   void (*tag_changed)(GtkTextTagTable * , GtkTextTag * , gboolean  ) ;
   void (*tag_added)(GtkTextTagTable * , GtkTextTag * ) ;
   void (*tag_removed)(GtkTextTagTable * , GtkTextTag * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 61 "/usr/include/gtk-2.0/gtk/gtktextmark.h"
struct _GtkTextMark ;
#line 61 "/usr/include/gtk-2.0/gtk/gtktextmark.h"
typedef struct _GtkTextMark GtkTextMark;
#line 62
struct _GtkTextMarkClass ;
#line 62 "/usr/include/gtk-2.0/gtk/gtktextmark.h"
typedef struct _GtkTextMarkClass GtkTextMarkClass;
#line 71 "/usr/include/gtk-2.0/gtk/gtktextmark.h"
struct _GtkTextMark {
   GObject parent_instance ;
   gpointer segment ;
};
#line 78 "/usr/include/gtk-2.0/gtk/gtktextmark.h"
struct _GtkTextMarkClass {
   GObjectClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 54 "/usr/include/gtk-2.0/gtk/gtktextbuffer.h"
enum __anonenum__610 {
    GTK_TEXT_BUFFER_TARGET_INFO_BUFFER_CONTENTS = -1,
    GTK_TEXT_BUFFER_TARGET_INFO_RICH_TEXT = -2,
    GTK_TEXT_BUFFER_TARGET_INFO_TEXT = -3
} ;
#line 59 "/usr/include/gtk-2.0/gtk/gtktextbuffer.h"
typedef enum __anonenum__610 GtkTextBufferTargetInfo;
#line 61
struct _GtkTextBTree ;
#line 61 "/usr/include/gtk-2.0/gtk/gtktextbuffer.h"
typedef struct _GtkTextBTree GtkTextBTree;
#line 63
struct _GtkTextLogAttrCache ;
#line 63 "/usr/include/gtk-2.0/gtk/gtktextbuffer.h"
typedef struct _GtkTextLogAttrCache GtkTextLogAttrCache;
#line 72
struct _GtkTextBufferClass ;
#line 72 "/usr/include/gtk-2.0/gtk/gtktextbuffer.h"
typedef struct _GtkTextBufferClass GtkTextBufferClass;
#line 74 "/usr/include/gtk-2.0/gtk/gtktextbuffer.h"
struct _GtkTextBuffer {
   GObject parent_instance ;
   GtkTextTagTable *tag_table ;
   GtkTextBTree *btree ;
   GSList *clipboard_contents_buffers ;
   GSList *selection_clipboards ;
   GtkTextLogAttrCache *log_attr_cache ;
   guint user_action_count ;
   guint modified ;
   guint has_selection ;
};
#line 94 "/usr/include/gtk-2.0/gtk/gtktextbuffer.h"
struct _GtkTextBufferClass {
   GObjectClass parent_class ;
   void (*insert_text)(GtkTextBuffer * , GtkTextIter * , gchar * , gint  ) ;
   void (*insert_pixbuf)(GtkTextBuffer * , GtkTextIter * , GdkPixbuf * ) ;
   void (*insert_child_anchor)(GtkTextBuffer * , GtkTextIter * , GtkTextChildAnchor * ) ;
   void (*delete_range)(GtkTextBuffer * , GtkTextIter * , GtkTextIter * ) ;
   void (*changed)(GtkTextBuffer * ) ;
   void (*modified_changed)(GtkTextBuffer * ) ;
   void (*mark_set)(GtkTextBuffer * , GtkTextIter * , GtkTextMark * ) ;
   void (*mark_deleted)(GtkTextBuffer * , GtkTextMark * ) ;
   void (*apply_tag)(GtkTextBuffer * , GtkTextTag * , GtkTextIter * , GtkTextIter * ) ;
   void (*remove_tag)(GtkTextBuffer * , GtkTextTag * , GtkTextIter * , GtkTextIter * ) ;
   void (*begin_user_action)(GtkTextBuffer * ) ;
   void (*end_user_action)(GtkTextBuffer * ) ;
   void (*paste_done)(GtkTextBuffer * , GtkClipboard * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
   void (*_gtk_reserved5)(void) ;
};
#line 33 "/usr/include/gtk-2.0/gtk/gtktextbufferrichtext.h"
typedef guint8 *(*GtkTextBufferSerializeFunc)(GtkTextBuffer * , GtkTextBuffer * ,
                                              GtkTextIter * , GtkTextIter * , gsize * ,
                                              gpointer  );
#line 39 "/usr/include/gtk-2.0/gtk/gtktextbufferrichtext.h"
typedef gboolean (*GtkTextBufferDeserializeFunc)(GtkTextBuffer * , GtkTextBuffer * ,
                                                 GtkTextIter * , guint8 * , gsize  ,
                                                 gboolean  , gpointer  , GError ** );
#line 48 "/usr/include/gtk-2.0/gtk/gtktextview.h"
enum __anonenum__611 {
    GTK_TEXT_WINDOW_PRIVATE = 0,
    GTK_TEXT_WINDOW_WIDGET = 1,
    GTK_TEXT_WINDOW_TEXT = 2,
    GTK_TEXT_WINDOW_LEFT = 3,
    GTK_TEXT_WINDOW_RIGHT = 4,
    GTK_TEXT_WINDOW_TOP = 5,
    GTK_TEXT_WINDOW_BOTTOM = 6
} ;
#line 57 "/usr/include/gtk-2.0/gtk/gtktextview.h"
typedef enum __anonenum__611 GtkTextWindowType;
#line 61
struct _GtkTextView ;
#line 61 "/usr/include/gtk-2.0/gtk/gtktextview.h"
typedef struct _GtkTextView GtkTextView;
#line 62
struct _GtkTextViewClass ;
#line 62 "/usr/include/gtk-2.0/gtk/gtktextview.h"
typedef struct _GtkTextViewClass GtkTextViewClass;
#line 65
struct _GtkTextWindow ;
#line 65 "/usr/include/gtk-2.0/gtk/gtktextview.h"
typedef struct _GtkTextWindow GtkTextWindow;
#line 66
struct _GtkTextPendingScroll ;
#line 66 "/usr/include/gtk-2.0/gtk/gtktextview.h"
typedef struct _GtkTextPendingScroll GtkTextPendingScroll;
#line 72
struct _GtkTextLayout ;
#line 68 "/usr/include/gtk-2.0/gtk/gtktextview.h"
struct _GtkTextView {
   GtkContainer parent_instance ;
   struct _GtkTextLayout *layout ;
   GtkTextBuffer *buffer ;
   guint selection_drag_handler ;
   guint scroll_timeout ;
   gint pixels_above_lines ;
   gint pixels_below_lines ;
   gint pixels_inside_wrap ;
   GtkWrapMode wrap_mode ;
   GtkJustification justify ;
   gint left_margin ;
   gint right_margin ;
   gint indent ;
   PangoTabArray *tabs ;
   guint editable ;
   guint overwrite_mode ;
   guint cursor_visible ;
   guint need_im_reset ;
   guint accepts_tab ;
   guint width_changed ;
   guint onscreen_validated ;
   guint mouse_cursor_obscured ;
   GtkTextWindow *text_window ;
   GtkTextWindow *left_window ;
   GtkTextWindow *right_window ;
   GtkTextWindow *top_window ;
   GtkTextWindow *bottom_window ;
   GtkAdjustment *hadjustment ;
   GtkAdjustment *vadjustment ;
   gint xoffset ;
   gint yoffset ;
   gint width ;
   gint height ;
   gint virtual_cursor_x ;
   gint virtual_cursor_y ;
   GtkTextMark *first_para_mark ;
   gint first_para_pixels ;
   GtkTextMark *dnd_mark ;
   guint blink_timeout ;
   guint first_validate_idle ;
   guint incremental_validate_idle ;
   GtkIMContext *im_context ;
   GtkWidget *popup_menu ;
   gint drag_start_x ;
   gint drag_start_y ;
   GSList *children ;
   GtkTextPendingScroll *pending_scroll ;
   gint pending_place_cursor_button ;
};
#line 155 "/usr/include/gtk-2.0/gtk/gtktextview.h"
struct _GtkTextViewClass {
   GtkContainerClass parent_class ;
   void (*set_scroll_adjustments)(GtkTextView * , GtkAdjustment * , GtkAdjustment * ) ;
   void (*populate_popup)(GtkTextView * , GtkMenu * ) ;
   void (*move_cursor)(GtkTextView * , GtkMovementStep  , gint  , gboolean  ) ;
   void (*page_horizontally)(GtkTextView * , gint  , gboolean  ) ;
   void (*set_anchor)(GtkTextView * ) ;
   void (*insert_at_cursor)(GtkTextView * , gchar * ) ;
   void (*delete_from_cursor)(GtkTextView * , GtkDeleteType  , gint  ) ;
   void (*backspace)(GtkTextView * ) ;
   void (*cut_clipboard)(GtkTextView * ) ;
   void (*copy_clipboard)(GtkTextView * ) ;
   void (*paste_clipboard)(GtkTextView * ) ;
   void (*toggle_overwrite)(GtkTextView * ) ;
   void (*move_focus)(GtkTextView * , GtkDirectionType  ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
   void (*_gtk_reserved5)(void) ;
   void (*_gtk_reserved6)(void) ;
   void (*_gtk_reserved7)(void) ;
};
#line 45 "/usr/include/gtk-2.0/gtk/gtkpixmap.h"
struct _GtkPixmap ;
#line 45 "/usr/include/gtk-2.0/gtk/gtkpixmap.h"
typedef struct _GtkPixmap GtkPixmap;
#line 46
struct _GtkPixmapClass ;
#line 46 "/usr/include/gtk-2.0/gtk/gtkpixmap.h"
typedef struct _GtkPixmapClass GtkPixmapClass;
#line 48 "/usr/include/gtk-2.0/gtk/gtkpixmap.h"
struct _GtkPixmap {
   GtkMisc misc ;
   GdkPixmap *pixmap ;
   GdkBitmap *mask ;
   GdkPixmap *pixmap_insensitive ;
   guint build_insensitive ;
};
#line 59 "/usr/include/gtk-2.0/gtk/gtkpixmap.h"
struct _GtkPixmapClass {
   GtkMiscClass parent_class ;
};
#line 62 "/usr/include/gtk-2.0/gtk/gtktoolbar.h"
enum __anonenum__612 {
    GTK_TOOLBAR_CHILD_SPACE = 0,
    GTK_TOOLBAR_CHILD_BUTTON = 1,
    GTK_TOOLBAR_CHILD_TOGGLEBUTTON = 2,
    GTK_TOOLBAR_CHILD_RADIOBUTTON = 3,
    GTK_TOOLBAR_CHILD_WIDGET = 4
} ;
#line 69 "/usr/include/gtk-2.0/gtk/gtktoolbar.h"
typedef enum __anonenum__612 GtkToolbarChildType;
#line 71
struct _GtkToolbarChild ;
#line 71 "/usr/include/gtk-2.0/gtk/gtktoolbar.h"
typedef struct _GtkToolbarChild GtkToolbarChild;
#line 73 "/usr/include/gtk-2.0/gtk/gtktoolbar.h"
struct _GtkToolbarChild {
   GtkToolbarChildType type ;
   GtkWidget *widget ;
   GtkWidget *icon ;
   GtkWidget *label ;
};
#line 83
enum __anonenum__613 {
    GTK_TOOLBAR_SPACE_EMPTY = 0,
    GTK_TOOLBAR_SPACE_LINE = 1
} ;
#line 87 "/usr/include/gtk-2.0/gtk/gtktoolbar.h"
typedef enum __anonenum__613 GtkToolbarSpaceStyle;
#line 89
struct _GtkToolbar ;
#line 89 "/usr/include/gtk-2.0/gtk/gtktoolbar.h"
typedef struct _GtkToolbar GtkToolbar;
#line 90
struct _GtkToolbarClass ;
#line 90 "/usr/include/gtk-2.0/gtk/gtktoolbar.h"
typedef struct _GtkToolbarClass GtkToolbarClass;
#line 91
struct _GtkToolbarPrivate ;
#line 91 "/usr/include/gtk-2.0/gtk/gtktoolbar.h"
typedef struct _GtkToolbarPrivate GtkToolbarPrivate;
#line 93 "/usr/include/gtk-2.0/gtk/gtktoolbar.h"
struct _GtkToolbar {
   GtkContainer container ;
   gint num_children ;
   GList *children ;
   GtkOrientation orientation ;
   GtkToolbarStyle style ;
   GtkIconSize icon_size ;
   GtkTooltips *tooltips ;
   gint button_maxw ;
   gint button_maxh ;
   guint _gtk_reserved1 ;
   guint _gtk_reserved2 ;
   guint style_set ;
   guint icon_size_set ;
};
#line 121 "/usr/include/gtk-2.0/gtk/gtktoolbar.h"
struct _GtkToolbarClass {
   GtkContainerClass parent_class ;
   void (*orientation_changed)(GtkToolbar * , GtkOrientation  ) ;
   void (*style_changed)(GtkToolbar * , GtkToolbarStyle  ) ;
   gboolean (*popup_context_menu)(GtkToolbar * , gint  , gint  , gint  ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
};
#line 41 "/usr/include/gtk-2.0/gtk/gtktoolitemgroup.h"
struct _GtkToolItemGroup ;
#line 41 "/usr/include/gtk-2.0/gtk/gtktoolitemgroup.h"
typedef struct _GtkToolItemGroup GtkToolItemGroup;
#line 42
struct _GtkToolItemGroupClass ;
#line 42 "/usr/include/gtk-2.0/gtk/gtktoolitemgroup.h"
typedef struct _GtkToolItemGroupClass GtkToolItemGroupClass;
#line 43
struct _GtkToolItemGroupPrivate ;
#line 43 "/usr/include/gtk-2.0/gtk/gtktoolitemgroup.h"
typedef struct _GtkToolItemGroupPrivate GtkToolItemGroupPrivate;
#line 50 "/usr/include/gtk-2.0/gtk/gtktoolitemgroup.h"
struct _GtkToolItemGroup {
   GtkContainer parent_instance ;
   GtkToolItemGroupPrivate *priv ;
};
#line 56 "/usr/include/gtk-2.0/gtk/gtktoolitemgroup.h"
struct _GtkToolItemGroupClass {
   GtkContainerClass parent_class ;
};
#line 42 "/usr/include/gtk-2.0/gtk/gtktoolpalette.h"
struct _GtkToolPalette ;
#line 42 "/usr/include/gtk-2.0/gtk/gtktoolpalette.h"
typedef struct _GtkToolPalette GtkToolPalette;
#line 43
struct _GtkToolPaletteClass ;
#line 43 "/usr/include/gtk-2.0/gtk/gtktoolpalette.h"
typedef struct _GtkToolPaletteClass GtkToolPaletteClass;
#line 44
struct _GtkToolPalettePrivate ;
#line 44 "/usr/include/gtk-2.0/gtk/gtktoolpalette.h"
typedef struct _GtkToolPalettePrivate GtkToolPalettePrivate;
#line 53
enum __anonenum__614 {
    GTK_TOOL_PALETTE_DRAG_ITEMS = 1,
    GTK_TOOL_PALETTE_DRAG_GROUPS = 2
} ;
#line 58 "/usr/include/gtk-2.0/gtk/gtktoolpalette.h"
typedef enum __anonenum__614 GtkToolPaletteDragTargets;
#line 65 "/usr/include/gtk-2.0/gtk/gtktoolpalette.h"
struct _GtkToolPalette {
   GtkContainer parent_instance ;
   GtkToolPalettePrivate *priv ;
};
#line 71 "/usr/include/gtk-2.0/gtk/gtktoolpalette.h"
struct _GtkToolPaletteClass {
   GtkContainerClass parent_class ;
   void (*set_scroll_adjustments)(GtkWidget * , GtkAdjustment * , GtkAdjustment * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
   void (*_gtk_reserved5)(void) ;
   void (*_gtk_reserved6)(void) ;
};
#line 43 "/usr/include/gtk-2.0/gtk/gtktoolshell.h"
struct _GtkToolShell ;
#line 43 "/usr/include/gtk-2.0/gtk/gtktoolshell.h"
typedef struct _GtkToolShell GtkToolShell;
#line 44
struct _GtkToolShellIface ;
#line 44 "/usr/include/gtk-2.0/gtk/gtktoolshell.h"
typedef struct _GtkToolShellIface GtkToolShellIface;
#line 60 "/usr/include/gtk-2.0/gtk/gtktoolshell.h"
struct _GtkToolShellIface {
   GTypeInterface g_iface ;
   GtkIconSize (*get_icon_size)(GtkToolShell * ) ;
   GtkOrientation (*get_orientation)(GtkToolShell * ) ;
   GtkToolbarStyle (*get_style)(GtkToolShell * ) ;
   GtkReliefStyle (*get_relief_style)(GtkToolShell * ) ;
   void (*rebuild_menu)(GtkToolShell * ) ;
   GtkOrientation (*get_text_orientation)(GtkToolShell * ) ;
   gfloat (*get_text_alignment)(GtkToolShell * ) ;
   PangoEllipsizeMode (*get_ellipsize_mode)(GtkToolShell * ) ;
   GtkSizeGroup *(*get_text_size_group)(GtkToolShell * ) ;
};
#line 37 "/usr/include/gtk-2.0/gtk/gtktreednd.h"
struct _GtkTreeDragSource ;
#line 37 "/usr/include/gtk-2.0/gtk/gtktreednd.h"
typedef struct _GtkTreeDragSource GtkTreeDragSource;
#line 38
struct _GtkTreeDragSourceIface ;
#line 38 "/usr/include/gtk-2.0/gtk/gtktreednd.h"
typedef struct _GtkTreeDragSourceIface GtkTreeDragSourceIface;
#line 40 "/usr/include/gtk-2.0/gtk/gtktreednd.h"
struct _GtkTreeDragSourceIface {
   GTypeInterface g_iface ;
   gboolean (*row_draggable)(GtkTreeDragSource * , GtkTreePath * ) ;
   gboolean (*drag_data_get)(GtkTreeDragSource * , GtkTreePath * , GtkSelectionData * ) ;
   gboolean (*drag_data_delete)(GtkTreeDragSource * , GtkTreePath * ) ;
};
#line 79
struct _GtkTreeDragDest ;
#line 79 "/usr/include/gtk-2.0/gtk/gtktreednd.h"
typedef struct _GtkTreeDragDest GtkTreeDragDest;
#line 80
struct _GtkTreeDragDestIface ;
#line 80 "/usr/include/gtk-2.0/gtk/gtktreednd.h"
typedef struct _GtkTreeDragDestIface GtkTreeDragDestIface;
#line 82 "/usr/include/gtk-2.0/gtk/gtktreednd.h"
struct _GtkTreeDragDestIface {
   GTypeInterface g_iface ;
   gboolean (*drag_data_received)(GtkTreeDragDest * , GtkTreePath * , GtkSelectionData * ) ;
   gboolean (*row_drop_possible)(GtkTreeDragDest * , GtkTreePath * , GtkSelectionData * ) ;
};
#line 40 "/usr/include/gtk-2.0/gtk/gtktreemodelsort.h"
struct _GtkTreeModelSort ;
#line 40 "/usr/include/gtk-2.0/gtk/gtktreemodelsort.h"
typedef struct _GtkTreeModelSort GtkTreeModelSort;
#line 41
struct _GtkTreeModelSortClass ;
#line 41 "/usr/include/gtk-2.0/gtk/gtktreemodelsort.h"
typedef struct _GtkTreeModelSortClass GtkTreeModelSortClass;
#line 43 "/usr/include/gtk-2.0/gtk/gtktreemodelsort.h"
struct _GtkTreeModelSort {
   GObject parent ;
   gpointer root ;
   gint stamp ;
   guint child_flags ;
   GtkTreeModel *child_model ;
   gint zero_ref_count ;
   GList *sort_list ;
   gint sort_column_id ;
   GtkSortType order ;
   GtkTreeIterCompareFunc default_sort_func ;
   gpointer default_sort_data ;
   GDestroyNotify default_sort_destroy ;
   guint changed_id ;
   guint inserted_id ;
   guint has_child_toggled_id ;
   guint deleted_id ;
   guint reordered_id ;
};
#line 72 "/usr/include/gtk-2.0/gtk/gtktreemodelsort.h"
struct _GtkTreeModelSortClass {
   GObjectClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 39 "/usr/include/gtk-2.0/gtk/gtktreeselection.h"
typedef gboolean (*GtkTreeSelectionFunc)(GtkTreeSelection * , GtkTreeModel * , GtkTreePath * ,
                                         gboolean  , gpointer  );
#line 44 "/usr/include/gtk-2.0/gtk/gtktreeselection.h"
typedef void (*GtkTreeSelectionForeachFunc)(GtkTreeModel * , GtkTreePath * , GtkTreeIter * ,
                                            gpointer  );
#line 49 "/usr/include/gtk-2.0/gtk/gtktreeselection.h"
struct _GtkTreeSelection {
   GObject parent ;
   GtkTreeView *tree_view ;
   GtkSelectionMode type ;
   GtkTreeSelectionFunc user_func ;
   gpointer user_data ;
   GDestroyNotify destroy ;
};
#line 62 "/usr/include/gtk-2.0/gtk/gtktreeselection.h"
struct _GtkTreeSelectionClass {
   GObjectClass parent_class ;
   void (*changed)(GtkTreeSelection * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 43 "/usr/include/gtk-2.0/gtk/gtktreestore.h"
struct _GtkTreeStore ;
#line 43 "/usr/include/gtk-2.0/gtk/gtktreestore.h"
typedef struct _GtkTreeStore GtkTreeStore;
#line 44
struct _GtkTreeStoreClass ;
#line 44 "/usr/include/gtk-2.0/gtk/gtktreestore.h"
typedef struct _GtkTreeStoreClass GtkTreeStoreClass;
#line 46 "/usr/include/gtk-2.0/gtk/gtktreestore.h"
struct _GtkTreeStore {
   GObject parent ;
   gint stamp ;
   gpointer root ;
   gpointer last ;
   gint n_columns ;
   gint sort_column_id ;
   GList *sort_list ;
   GtkSortType order ;
   GType *column_headers ;
   GtkTreeIterCompareFunc default_sort_func ;
   gpointer default_sort_data ;
   GDestroyNotify default_sort_destroy ;
   guint columns_dirty ;
};
#line 64 "/usr/include/gtk-2.0/gtk/gtktreestore.h"
struct _GtkTreeStoreClass {
   GObjectClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 52 "/usr/include/gtk-2.0/gtk/gtkuimanager.h"
struct _GtkUIManager ;
#line 52 "/usr/include/gtk-2.0/gtk/gtkuimanager.h"
typedef struct _GtkUIManager GtkUIManager;
#line 53
struct _GtkUIManagerClass ;
#line 53 "/usr/include/gtk-2.0/gtk/gtkuimanager.h"
typedef struct _GtkUIManagerClass GtkUIManagerClass;
#line 54
struct _GtkUIManagerPrivate ;
#line 54 "/usr/include/gtk-2.0/gtk/gtkuimanager.h"
typedef struct _GtkUIManagerPrivate GtkUIManagerPrivate;
#line 57 "/usr/include/gtk-2.0/gtk/gtkuimanager.h"
struct _GtkUIManager {
   GObject parent ;
   GtkUIManagerPrivate *private_data ;
};
#line 65 "/usr/include/gtk-2.0/gtk/gtkuimanager.h"
struct _GtkUIManagerClass {
   GObjectClass parent_class ;
   void (*add_widget)(GtkUIManager * , GtkWidget * ) ;
   void (*actions_changed)(GtkUIManager * ) ;
   void (*connect_proxy)(GtkUIManager * , GtkAction * , GtkWidget * ) ;
   void (*disconnect_proxy)(GtkUIManager * , GtkAction * , GtkWidget * ) ;
   void (*pre_activate)(GtkUIManager * , GtkAction * ) ;
   void (*post_activate)(GtkUIManager * , GtkAction * ) ;
   GtkWidget *(*get_widget)(GtkUIManager * , gchar * ) ;
   GtkAction *(*get_action)(GtkUIManager * , gchar * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
};
#line 94
enum __anonenum__615 {
    GTK_UI_MANAGER_AUTO = 0,
    GTK_UI_MANAGER_MENUBAR = 1,
    GTK_UI_MANAGER_MENU = 2,
    GTK_UI_MANAGER_TOOLBAR = 4,
    GTK_UI_MANAGER_PLACEHOLDER = 8,
    GTK_UI_MANAGER_POPUP = 16,
    GTK_UI_MANAGER_MENUITEM = 32,
    GTK_UI_MANAGER_TOOLITEM = 64,
    GTK_UI_MANAGER_SEPARATOR = 128,
    GTK_UI_MANAGER_ACCELERATOR = 256,
    GTK_UI_MANAGER_POPUP_WITH_ACCELS = 512
} ;
#line 106 "/usr/include/gtk-2.0/gtk/gtkuimanager.h"
typedef enum __anonenum__615 GtkUIManagerItemType;
#line 49 "/usr/include/gtk-2.0/gtk/gtkvbbox.h"
struct _GtkVButtonBox ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkvbbox.h"
typedef struct _GtkVButtonBox GtkVButtonBox;
#line 50
struct _GtkVButtonBoxClass ;
#line 50 "/usr/include/gtk-2.0/gtk/gtkvbbox.h"
typedef struct _GtkVButtonBoxClass GtkVButtonBoxClass;
#line 52 "/usr/include/gtk-2.0/gtk/gtkvbbox.h"
struct _GtkVButtonBox {
   GtkButtonBox button_box ;
};
#line 57 "/usr/include/gtk-2.0/gtk/gtkvbbox.h"
struct _GtkVButtonBoxClass {
   GtkButtonBoxClass parent_class ;
};
#line 48 "/usr/include/gtk-2.0/gtk/gtkvolumebutton.h"
struct _GtkVolumeButton ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkvolumebutton.h"
typedef struct _GtkVolumeButton GtkVolumeButton;
#line 49
struct _GtkVolumeButtonClass ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkvolumebutton.h"
typedef struct _GtkVolumeButtonClass GtkVolumeButtonClass;
#line 51 "/usr/include/gtk-2.0/gtk/gtkvolumebutton.h"
struct _GtkVolumeButton {
   GtkScaleButton parent ;
};
#line 56 "/usr/include/gtk-2.0/gtk/gtkvolumebutton.h"
struct _GtkVolumeButtonClass {
   GtkScaleButtonClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 46 "/usr/include/gtk-2.0/gtk/gtkvpaned.h"
struct _GtkVPaned ;
#line 46 "/usr/include/gtk-2.0/gtk/gtkvpaned.h"
typedef struct _GtkVPaned GtkVPaned;
#line 47
struct _GtkVPanedClass ;
#line 47 "/usr/include/gtk-2.0/gtk/gtkvpaned.h"
typedef struct _GtkVPanedClass GtkVPanedClass;
#line 49 "/usr/include/gtk-2.0/gtk/gtkvpaned.h"
struct _GtkVPaned {
   GtkPaned paned ;
};
#line 54 "/usr/include/gtk-2.0/gtk/gtkvpaned.h"
struct _GtkVPanedClass {
   GtkPanedClass parent_class ;
};
#line 61 "/usr/include/gtk-2.0/gtk/gtkvruler.h"
struct _GtkVRuler ;
#line 61 "/usr/include/gtk-2.0/gtk/gtkvruler.h"
typedef struct _GtkVRuler GtkVRuler;
#line 62
struct _GtkVRulerClass ;
#line 62 "/usr/include/gtk-2.0/gtk/gtkvruler.h"
typedef struct _GtkVRulerClass GtkVRulerClass;
#line 64 "/usr/include/gtk-2.0/gtk/gtkvruler.h"
struct _GtkVRuler {
   GtkRuler ruler ;
};
#line 69 "/usr/include/gtk-2.0/gtk/gtkvruler.h"
struct _GtkVRulerClass {
   GtkRulerClass parent_class ;
};
#line 49 "/usr/include/gtk-2.0/gtk/gtkvscale.h"
struct _GtkVScale ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkvscale.h"
typedef struct _GtkVScale GtkVScale;
#line 50
struct _GtkVScaleClass ;
#line 50 "/usr/include/gtk-2.0/gtk/gtkvscale.h"
typedef struct _GtkVScaleClass GtkVScaleClass;
#line 58 "/usr/include/gtk-2.0/gtk/gtkvscale.h"
struct _GtkVScale {
   GtkScale scale ;
};
#line 63 "/usr/include/gtk-2.0/gtk/gtkvscale.h"
struct _GtkVScaleClass {
   GtkScaleClass parent_class ;
};
#line 49 "/usr/include/gtk-2.0/gtk/gtkvseparator.h"
struct _GtkVSeparator ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkvseparator.h"
typedef struct _GtkVSeparator GtkVSeparator;
#line 50
struct _GtkVSeparatorClass ;
#line 50 "/usr/include/gtk-2.0/gtk/gtkvseparator.h"
typedef struct _GtkVSeparatorClass GtkVSeparatorClass;
#line 58 "/usr/include/gtk-2.0/gtk/gtkvseparator.h"
struct _GtkVSeparator {
   GtkSeparator separator ;
};
#line 63 "/usr/include/gtk-2.0/gtk/gtkvseparator.h"
struct _GtkVSeparatorClass {
   GtkSeparatorClass parent_class ;
};
#line 46 "/usr/include/gtk-2.0/gtk/gtkclist.h"
enum __anonenum__616 {
    GTK_CLIST_IN_DRAG = 1,
    GTK_CLIST_ROW_HEIGHT_SET = 2,
    GTK_CLIST_SHOW_TITLES = 4,
    GTK_CLIST_ADD_MODE = 16,
    GTK_CLIST_AUTO_SORT = 32,
    GTK_CLIST_AUTO_RESIZE_BLOCKED = 64,
    GTK_CLIST_REORDERABLE = 128,
    GTK_CLIST_USE_DRAG_ICONS = 256,
    GTK_CLIST_DRAW_DRAG_LINE = 512,
    GTK_CLIST_DRAW_DRAG_RECT = 1024
} ;
#line 61
enum __anonenum__617 {
    GTK_CELL_EMPTY = 0,
    GTK_CELL_TEXT = 1,
    GTK_CELL_PIXMAP = 2,
    GTK_CELL_PIXTEXT = 3,
    GTK_CELL_WIDGET = 4
} ;
#line 68 "/usr/include/gtk-2.0/gtk/gtkclist.h"
typedef enum __anonenum__617 GtkCellType;
#line 70
enum __anonenum__618 {
    GTK_CLIST_DRAG_NONE = 0,
    GTK_CLIST_DRAG_BEFORE = 1,
    GTK_CLIST_DRAG_INTO = 2,
    GTK_CLIST_DRAG_AFTER = 3
} ;
#line 76 "/usr/include/gtk-2.0/gtk/gtkclist.h"
typedef enum __anonenum__618 GtkCListDragPos;
#line 78
enum __anonenum__619 {
    GTK_BUTTON_IGNORED = 0,
    GTK_BUTTON_SELECTS = 1,
    GTK_BUTTON_DRAGS = 2,
    GTK_BUTTON_EXPANDS = 4
} ;
#line 84 "/usr/include/gtk-2.0/gtk/gtkclist.h"
typedef enum __anonenum__619 GtkButtonAction;
#line 117
struct _GtkCList ;
#line 117 "/usr/include/gtk-2.0/gtk/gtkclist.h"
typedef struct _GtkCList GtkCList;
#line 118
struct _GtkCListClass ;
#line 118 "/usr/include/gtk-2.0/gtk/gtkclist.h"
typedef struct _GtkCListClass GtkCListClass;
#line 119
struct _GtkCListColumn ;
#line 119 "/usr/include/gtk-2.0/gtk/gtkclist.h"
typedef struct _GtkCListColumn GtkCListColumn;
#line 120
struct _GtkCListRow ;
#line 120 "/usr/include/gtk-2.0/gtk/gtkclist.h"
typedef struct _GtkCListRow GtkCListRow;
#line 122
struct _GtkCell ;
#line 122 "/usr/include/gtk-2.0/gtk/gtkclist.h"
typedef struct _GtkCell GtkCell;
#line 123
struct _GtkCellText ;
#line 123 "/usr/include/gtk-2.0/gtk/gtkclist.h"
typedef struct _GtkCellText GtkCellText;
#line 124
struct _GtkCellPixmap ;
#line 124 "/usr/include/gtk-2.0/gtk/gtkclist.h"
typedef struct _GtkCellPixmap GtkCellPixmap;
#line 125
struct _GtkCellPixText ;
#line 125 "/usr/include/gtk-2.0/gtk/gtkclist.h"
typedef struct _GtkCellPixText GtkCellPixText;
#line 126
struct _GtkCellWidget ;
#line 126 "/usr/include/gtk-2.0/gtk/gtkclist.h"
typedef struct _GtkCellWidget GtkCellWidget;
#line 128 "/usr/include/gtk-2.0/gtk/gtkclist.h"
typedef gint (*GtkCListCompareFunc)(GtkCList * , gconstpointer  , gconstpointer  );
#line 132
struct _GtkCListCellInfo ;
#line 132 "/usr/include/gtk-2.0/gtk/gtkclist.h"
typedef struct _GtkCListCellInfo GtkCListCellInfo;
#line 133
struct _GtkCListDestInfo ;
#line 133 "/usr/include/gtk-2.0/gtk/gtkclist.h"
typedef struct _GtkCListDestInfo GtkCListDestInfo;
#line 135 "/usr/include/gtk-2.0/gtk/gtkclist.h"
struct _GtkCListCellInfo {
   gint row ;
   gint column ;
};
#line 141 "/usr/include/gtk-2.0/gtk/gtkclist.h"
struct _GtkCListDestInfo {
   GtkCListCellInfo cell ;
   GtkCListDragPos insert_pos ;
};
#line 147 "/usr/include/gtk-2.0/gtk/gtkclist.h"
struct _GtkCList {
   GtkContainer container ;
   guint16 flags ;
   gpointer reserved1 ;
   gpointer reserved2 ;
   guint freeze_count ;
   GdkRectangle internal_allocation ;
   gint rows ;
   gint row_height ;
   GList *row_list ;
   GList *row_list_end ;
   gint columns ;
   GdkRectangle column_title_area ;
   GdkWindow *title_window ;
   GtkCListColumn *column ;
   GdkWindow *clist_window ;
   gint clist_window_width ;
   gint clist_window_height ;
   gint hoffset ;
   gint voffset ;
   GtkShadowType shadow_type ;
   GtkSelectionMode selection_mode ;
   GList *selection ;
   GList *selection_end ;
   GList *undo_selection ;
   GList *undo_unselection ;
   gint undo_anchor ;
   guint8 button_actions[5] ;
   guint8 drag_button ;
   GtkCListCellInfo click_cell ;
   GtkAdjustment *hadjustment ;
   GtkAdjustment *vadjustment ;
   GdkGC *xor_gc ;
   GdkGC *fg_gc ;
   GdkGC *bg_gc ;
   GdkCursor *cursor_drag ;
   gint x_drag ;
   gint focus_row ;
   gint focus_header_column ;
   gint anchor ;
   GtkStateType anchor_state ;
   gint drag_pos ;
   gint htimer ;
   gint vtimer ;
   GtkSortType sort_type ;
   GtkCListCompareFunc compare ;
   gint sort_column ;
   gint drag_highlight_row ;
   GtkCListDragPos drag_highlight_pos ;
};
#line 245 "/usr/include/gtk-2.0/gtk/gtkclist.h"
struct _GtkCListClass {
   GtkContainerClass parent_class ;
   void (*set_scroll_adjustments)(GtkCList * , GtkAdjustment * , GtkAdjustment * ) ;
   void (*refresh)(GtkCList * ) ;
   void (*select_row)(GtkCList * , gint  , gint  , GdkEvent * ) ;
   void (*unselect_row)(GtkCList * , gint  , gint  , GdkEvent * ) ;
   void (*row_move)(GtkCList * , gint  , gint  ) ;
   void (*click_column)(GtkCList * , gint  ) ;
   void (*resize_column)(GtkCList * , gint  , gint  ) ;
   void (*toggle_focus_row)(GtkCList * ) ;
   void (*select_all)(GtkCList * ) ;
   void (*unselect_all)(GtkCList * ) ;
   void (*undo_selection)(GtkCList * ) ;
   void (*start_selection)(GtkCList * ) ;
   void (*end_selection)(GtkCList * ) ;
   void (*extend_selection)(GtkCList * , GtkScrollType  , gfloat  , gboolean  ) ;
   void (*scroll_horizontal)(GtkCList * , GtkScrollType  , gfloat  ) ;
   void (*scroll_vertical)(GtkCList * , GtkScrollType  , gfloat  ) ;
   void (*toggle_add_mode)(GtkCList * ) ;
   void (*abort_column_resize)(GtkCList * ) ;
   void (*resync_selection)(GtkCList * , GdkEvent * ) ;
   GList *(*selection_find)(GtkCList * , gint  , GList * ) ;
   void (*draw_row)(GtkCList * , GdkRectangle * , gint  , GtkCListRow * ) ;
   void (*draw_drag_highlight)(GtkCList * , GtkCListRow * , gint  , GtkCListDragPos  ) ;
   void (*clear)(GtkCList * ) ;
   void (*fake_unselect_all)(GtkCList * , gint  ) ;
   void (*sort_list)(GtkCList * ) ;
   gint (*insert_row)(GtkCList * , gint  , gchar *[] ) ;
   void (*remove_row)(GtkCList * , gint  ) ;
   void (*set_cell_contents)(GtkCList * , GtkCListRow * , gint  , GtkCellType  , gchar * ,
                             guint8  , GdkPixmap * , GdkBitmap * ) ;
   void (*cell_size_request)(GtkCList * , GtkCListRow * , gint  , GtkRequisition * ) ;
};
#line 324 "/usr/include/gtk-2.0/gtk/gtkclist.h"
struct _GtkCListColumn {
   gchar *title ;
   GdkRectangle area ;
   GtkWidget *button ;
   GdkWindow *window ;
   gint width ;
   gint min_width ;
   gint max_width ;
   GtkJustification justification ;
   guint visible ;
   guint width_set ;
   guint resizeable ;
   guint auto_resize ;
   guint button_passive ;
};
#line 344 "/usr/include/gtk-2.0/gtk/gtkclist.h"
struct _GtkCListRow {
   GtkCell *cell ;
   GtkStateType state ;
   GdkColor foreground ;
   GdkColor background ;
   GtkStyle *style ;
   gpointer data ;
   GDestroyNotify destroy ;
   guint fg_set ;
   guint bg_set ;
   guint selectable ;
};
#line 363 "/usr/include/gtk-2.0/gtk/gtkclist.h"
struct _GtkCellText {
   GtkCellType type ;
   gint16 vertical ;
   gint16 horizontal ;
   GtkStyle *style ;
   gchar *text ;
};
#line 375 "/usr/include/gtk-2.0/gtk/gtkclist.h"
struct _GtkCellPixmap {
   GtkCellType type ;
   gint16 vertical ;
   gint16 horizontal ;
   GtkStyle *style ;
   GdkPixmap *pixmap ;
   GdkBitmap *mask ;
};
#line 388 "/usr/include/gtk-2.0/gtk/gtkclist.h"
struct _GtkCellPixText {
   GtkCellType type ;
   gint16 vertical ;
   gint16 horizontal ;
   GtkStyle *style ;
   gchar *text ;
   guint8 spacing ;
   GdkPixmap *pixmap ;
   GdkBitmap *mask ;
};
#line 403 "/usr/include/gtk-2.0/gtk/gtkclist.h"
struct _GtkCellWidget {
   GtkCellType type ;
   gint16 vertical ;
   gint16 horizontal ;
   GtkStyle *style ;
   GtkWidget *widget ;
};
#line 427 "/usr/include/gtk-2.0/gtk/gtkclist.h"
struct __anonstruct_621 {
   GdkPixmap *pixmap ;
   GdkBitmap *mask ;
};
#line 432 "/usr/include/gtk-2.0/gtk/gtkclist.h"
struct __anonstruct_622 {
   gchar *text ;
   guint8 spacing ;
   GdkPixmap *pixmap ;
   GdkBitmap *mask ;
};
#line 424 "/usr/include/gtk-2.0/gtk/gtkclist.h"
union __anonunion_620 {
   gchar *text ;
   struct __anonstruct_621 pm ;
   struct __anonstruct_622 pt ;
   GtkWidget *widget ;
};
#line 415 "/usr/include/gtk-2.0/gtk/gtkclist.h"
struct _GtkCell {
   GtkCellType type ;
   gint16 vertical ;
   gint16 horizontal ;
   GtkStyle *style ;
   union __anonunion_620 u ;
};
#line 45 "/usr/include/gtk-2.0/gtk/gtkcombo.h"
struct _GtkCombo ;
#line 45 "/usr/include/gtk-2.0/gtk/gtkcombo.h"
typedef struct _GtkCombo GtkCombo;
#line 46
struct _GtkComboClass ;
#line 46 "/usr/include/gtk-2.0/gtk/gtkcombo.h"
typedef struct _GtkComboClass GtkComboClass;
#line 49 "/usr/include/gtk-2.0/gtk/gtkcombo.h"
struct _GtkCombo {
   GtkHBox hbox ;
   GtkWidget *entry ;
   GtkWidget *button ;
   GtkWidget *popup ;
   GtkWidget *popwin ;
   GtkWidget *list ;
   guint entry_change_id ;
   guint list_change_id ;
   guint value_in_list ;
   guint ok_if_empty ;
   guint case_sensitive ;
   guint use_arrows ;
   guint use_arrows_always ;
   guint16 current_button ;
   guint activate_id ;
};
#line 77 "/usr/include/gtk-2.0/gtk/gtkcombo.h"
struct _GtkComboClass {
   GtkHBoxClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 55 "/usr/include/gtk-2.0/gtk/gtkctree.h"
enum __anonenum__623 {
    GTK_CTREE_POS_BEFORE = 0,
    GTK_CTREE_POS_AS_CHILD = 1,
    GTK_CTREE_POS_AFTER = 2
} ;
#line 60 "/usr/include/gtk-2.0/gtk/gtkctree.h"
typedef enum __anonenum__623 GtkCTreePos;
#line 62
enum __anonenum__624 {
    GTK_CTREE_LINES_NONE = 0,
    GTK_CTREE_LINES_SOLID = 1,
    GTK_CTREE_LINES_DOTTED = 2,
    GTK_CTREE_LINES_TABBED = 3
} ;
#line 68 "/usr/include/gtk-2.0/gtk/gtkctree.h"
typedef enum __anonenum__624 GtkCTreeLineStyle;
#line 70
enum __anonenum__625 {
    GTK_CTREE_EXPANDER_NONE = 0,
    GTK_CTREE_EXPANDER_SQUARE = 1,
    GTK_CTREE_EXPANDER_TRIANGLE = 2,
    GTK_CTREE_EXPANDER_CIRCULAR = 3
} ;
#line 76 "/usr/include/gtk-2.0/gtk/gtkctree.h"
typedef enum __anonenum__625 GtkCTreeExpanderStyle;
#line 78
enum __anonenum__626 {
    GTK_CTREE_EXPANSION_EXPAND = 0,
    GTK_CTREE_EXPANSION_EXPAND_RECURSIVE = 1,
    GTK_CTREE_EXPANSION_COLLAPSE = 2,
    GTK_CTREE_EXPANSION_COLLAPSE_RECURSIVE = 3,
    GTK_CTREE_EXPANSION_TOGGLE = 4,
    GTK_CTREE_EXPANSION_TOGGLE_RECURSIVE = 5
} ;
#line 86 "/usr/include/gtk-2.0/gtk/gtkctree.h"
typedef enum __anonenum__626 GtkCTreeExpansionType;
#line 88
struct _GtkCTree ;
#line 88 "/usr/include/gtk-2.0/gtk/gtkctree.h"
typedef struct _GtkCTree GtkCTree;
#line 89
struct _GtkCTreeClass ;
#line 89 "/usr/include/gtk-2.0/gtk/gtkctree.h"
typedef struct _GtkCTreeClass GtkCTreeClass;
#line 90
struct _GtkCTreeRow ;
#line 90 "/usr/include/gtk-2.0/gtk/gtkctree.h"
typedef struct _GtkCTreeRow GtkCTreeRow;
#line 91
struct _GtkCTreeNode ;
#line 91 "/usr/include/gtk-2.0/gtk/gtkctree.h"
typedef struct _GtkCTreeNode GtkCTreeNode;
#line 93 "/usr/include/gtk-2.0/gtk/gtkctree.h"
typedef void (*GtkCTreeFunc)(GtkCTree * , GtkCTreeNode * , gpointer  );
#line 97 "/usr/include/gtk-2.0/gtk/gtkctree.h"
typedef gboolean (*GtkCTreeGNodeFunc)(GtkCTree * , guint  , GNode * , GtkCTreeNode * ,
                                      gpointer  );
#line 103 "/usr/include/gtk-2.0/gtk/gtkctree.h"
typedef gboolean (*GtkCTreeCompareDragFunc)(GtkCTree * , GtkCTreeNode * , GtkCTreeNode * ,
                                            GtkCTreeNode * );
#line 108 "/usr/include/gtk-2.0/gtk/gtkctree.h"
struct _GtkCTree {
   GtkCList clist ;
   GdkGC *lines_gc ;
   gint tree_indent ;
   gint tree_spacing ;
   gint tree_column ;
   guint line_style ;
   guint expander_style ;
   guint show_stub ;
   GtkCTreeCompareDragFunc drag_compare ;
};
#line 125 "/usr/include/gtk-2.0/gtk/gtkctree.h"
struct _GtkCTreeClass {
   GtkCListClass parent_class ;
   void (*tree_select_row)(GtkCTree * , GtkCTreeNode * , gint  ) ;
   void (*tree_unselect_row)(GtkCTree * , GtkCTreeNode * , gint  ) ;
   void (*tree_expand)(GtkCTree * , GtkCTreeNode * ) ;
   void (*tree_collapse)(GtkCTree * , GtkCTreeNode * ) ;
   void (*tree_move)(GtkCTree * , GtkCTreeNode * , GtkCTreeNode * , GtkCTreeNode * ) ;
   void (*change_focus_row_expansion)(GtkCTree * , GtkCTreeExpansionType  ) ;
};
#line 147 "/usr/include/gtk-2.0/gtk/gtkctree.h"
struct _GtkCTreeRow {
   GtkCListRow row ;
   GtkCTreeNode *parent ;
   GtkCTreeNode *sibling ;
   GtkCTreeNode *children ;
   GdkPixmap *pixmap_closed ;
   GdkBitmap *mask_closed ;
   GdkPixmap *pixmap_opened ;
   GdkBitmap *mask_opened ;
   guint16 level ;
   guint is_leaf ;
   guint expanded ;
};
#line 166 "/usr/include/gtk-2.0/gtk/gtkctree.h"
struct _GtkCTreeNode {
   GList list ;
};
#line 46 "/usr/include/gtk-2.0/gtk/gtkcurve.h"
struct _GtkCurve ;
#line 46 "/usr/include/gtk-2.0/gtk/gtkcurve.h"
typedef struct _GtkCurve GtkCurve;
#line 47
struct _GtkCurveClass ;
#line 47 "/usr/include/gtk-2.0/gtk/gtkcurve.h"
typedef struct _GtkCurveClass GtkCurveClass;
#line 50 "/usr/include/gtk-2.0/gtk/gtkcurve.h"
struct _GtkCurve {
   GtkDrawingArea graph ;
   gint cursor_type ;
   gfloat min_x ;
   gfloat max_x ;
   gfloat min_y ;
   gfloat max_y ;
   GdkPixmap *pixmap ;
   GtkCurveType curve_type ;
   gint height ;
   gint grab_point ;
   gint last ;
   gint num_points ;
   GdkPoint *point ;
   gint num_ctlpoints ;
   gfloat (*ctlpoint)[2] ;
};
#line 74 "/usr/include/gtk-2.0/gtk/gtkcurve.h"
struct _GtkCurveClass {
   GtkDrawingAreaClass parent_class ;
   void (*curve_type_changed)(GtkCurve * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 46 "/usr/include/gtk-2.0/gtk/gtkfilesel.h"
struct _GtkFileSelection ;
#line 46 "/usr/include/gtk-2.0/gtk/gtkfilesel.h"
typedef struct _GtkFileSelection GtkFileSelection;
#line 47
struct _GtkFileSelectionClass ;
#line 47 "/usr/include/gtk-2.0/gtk/gtkfilesel.h"
typedef struct _GtkFileSelectionClass GtkFileSelectionClass;
#line 49 "/usr/include/gtk-2.0/gtk/gtkfilesel.h"
struct _GtkFileSelection {
   GtkDialog parent_instance ;
   GtkWidget *dir_list ;
   GtkWidget *file_list ;
   GtkWidget *selection_entry ;
   GtkWidget *selection_text ;
   GtkWidget *main_vbox ;
   GtkWidget *ok_button ;
   GtkWidget *cancel_button ;
   GtkWidget *help_button ;
   GtkWidget *history_pulldown ;
   GtkWidget *history_menu ;
   GList *history_list ;
   GtkWidget *fileop_dialog ;
   GtkWidget *fileop_entry ;
   gchar *fileop_file ;
   gpointer cmpl_state ;
   GtkWidget *fileop_c_dir ;
   GtkWidget *fileop_del_file ;
   GtkWidget *fileop_ren_file ;
   GtkWidget *button_area ;
   GtkWidget *action_area ;
   GPtrArray *selected_names ;
   gchar *last_selected ;
};
#line 83 "/usr/include/gtk-2.0/gtk/gtkfilesel.h"
struct _GtkFileSelectionClass {
   GtkDialogClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 45 "/usr/include/gtk-2.0/gtk/gtkgamma.h"
struct _GtkGammaCurve ;
#line 45 "/usr/include/gtk-2.0/gtk/gtkgamma.h"
typedef struct _GtkGammaCurve GtkGammaCurve;
#line 46
struct _GtkGammaCurveClass ;
#line 46 "/usr/include/gtk-2.0/gtk/gtkgamma.h"
typedef struct _GtkGammaCurveClass GtkGammaCurveClass;
#line 49 "/usr/include/gtk-2.0/gtk/gtkgamma.h"
struct _GtkGammaCurve {
   GtkVBox vbox ;
   GtkWidget *table ;
   GtkWidget *curve ;
   GtkWidget *button[5] ;
   gfloat gamma ;
   GtkWidget *gamma_dialog ;
   GtkWidget *gamma_text ;
};
#line 62 "/usr/include/gtk-2.0/gtk/gtkgamma.h"
struct _GtkGammaCurveClass {
   GtkVBoxClass parent_class ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 56 "/usr/include/gtk-2.0/gtk/gtkinputdialog.h"
struct _GtkInputDialog ;
#line 56 "/usr/include/gtk-2.0/gtk/gtkinputdialog.h"
typedef struct _GtkInputDialog GtkInputDialog;
#line 57
struct _GtkInputDialogClass ;
#line 57 "/usr/include/gtk-2.0/gtk/gtkinputdialog.h"
typedef struct _GtkInputDialogClass GtkInputDialogClass;
#line 59 "/usr/include/gtk-2.0/gtk/gtkinputdialog.h"
struct _GtkInputDialog {
   GtkDialog dialog ;
   GtkWidget *axis_list ;
   GtkWidget *axis_listbox ;
   GtkWidget *mode_optionmenu ;
   GtkWidget *close_button ;
   GtkWidget *save_button ;
   GtkWidget *axis_items[7] ;
   GdkDevice *current_device ;
   GtkWidget *keys_list ;
   GtkWidget *keys_listbox ;
};
#line 77 "/usr/include/gtk-2.0/gtk/gtkinputdialog.h"
struct _GtkInputDialogClass {
   GtkDialogClass parent_class ;
   void (*enable_device)(GtkInputDialog * , GdkDevice * ) ;
   void (*disable_device)(GtkInputDialog * , GdkDevice * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 40 "/usr/include/gtk-2.0/gtk/gtkitemfactory.h"
typedef void (*GtkPrintFunc)(gpointer  , gchar * );
#line 47 "/usr/include/gtk-2.0/gtk/gtkitemfactory.h"
typedef void (*GtkItemFactoryCallback)();
#line 48 "/usr/include/gtk-2.0/gtk/gtkitemfactory.h"
typedef void (*GtkItemFactoryCallback1)(gpointer  , guint  , GtkWidget * );
#line 60
struct _GtkItemFactory ;
#line 60 "/usr/include/gtk-2.0/gtk/gtkitemfactory.h"
typedef struct _GtkItemFactory GtkItemFactory;
#line 61
struct _GtkItemFactoryClass ;
#line 61 "/usr/include/gtk-2.0/gtk/gtkitemfactory.h"
typedef struct _GtkItemFactoryClass GtkItemFactoryClass;
#line 62
struct _GtkItemFactoryEntry ;
#line 62 "/usr/include/gtk-2.0/gtk/gtkitemfactory.h"
typedef struct _GtkItemFactoryEntry GtkItemFactoryEntry;
#line 63
struct _GtkItemFactoryItem ;
#line 63 "/usr/include/gtk-2.0/gtk/gtkitemfactory.h"
typedef struct _GtkItemFactoryItem GtkItemFactoryItem;
#line 65 "/usr/include/gtk-2.0/gtk/gtkitemfactory.h"
struct _GtkItemFactory {
   GtkObject object ;
   gchar *path ;
   GtkAccelGroup *accel_group ;
   GtkWidget *widget ;
   GSList *items ;
   GtkTranslateFunc translate_func ;
   gpointer translate_data ;
   GDestroyNotify translate_notify ;
};
#line 79 "/usr/include/gtk-2.0/gtk/gtkitemfactory.h"
struct _GtkItemFactoryClass {
   GtkObjectClass object_class ;
   GHashTable *item_ht ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 92 "/usr/include/gtk-2.0/gtk/gtkitemfactory.h"
struct _GtkItemFactoryEntry {
   gchar *path ;
   gchar *accelerator ;
   GtkItemFactoryCallback callback ;
   guint callback_action ;
   gchar *item_type ;
   gconstpointer extra_data ;
};
#line 125 "/usr/include/gtk-2.0/gtk/gtkitemfactory.h"
struct _GtkItemFactoryItem {
   gchar *path ;
   GSList *widgets ;
};
#line 203 "/usr/include/gtk-2.0/gtk/gtkitemfactory.h"
typedef void (*GtkMenuCallback)(GtkWidget * , gpointer  );
#line 205 "/usr/include/gtk-2.0/gtk/gtkitemfactory.h"
struct __anonstruct_627 {
   gchar *path ;
   gchar *accelerator ;
   GtkMenuCallback callback ;
   gpointer callback_data ;
   GtkWidget *widget ;
};
#line 211 "/usr/include/gtk-2.0/gtk/gtkitemfactory.h"
typedef struct __anonstruct_627 GtkMenuEntry;
#line 214 "/usr/include/gtk-2.0/gtk/gtkitemfactory.h"
typedef void (*GtkItemFactoryCallback2)(GtkWidget * , gpointer  , guint  );
#line 44 "/usr/include/gtk-2.0/gtk/gtklist.h"
struct _GtkList ;
#line 44 "/usr/include/gtk-2.0/gtk/gtklist.h"
typedef struct _GtkList GtkList;
#line 45
struct _GtkListClass ;
#line 45 "/usr/include/gtk-2.0/gtk/gtklist.h"
typedef struct _GtkListClass GtkListClass;
#line 47 "/usr/include/gtk-2.0/gtk/gtklist.h"
struct _GtkList {
   GtkContainer container ;
   GList *children ;
   GList *selection ;
   GList *undo_selection ;
   GList *undo_unselection ;
   GtkWidget *last_focus_child ;
   GtkWidget *undo_focus_child ;
   guint htimer ;
   guint vtimer ;
   gint anchor ;
   gint drag_pos ;
   GtkStateType anchor_state ;
   guint selection_mode ;
   guint drag_selection ;
   guint add_mode ;
};
#line 72 "/usr/include/gtk-2.0/gtk/gtklist.h"
struct _GtkListClass {
   GtkContainerClass parent_class ;
   void (*selection_changed)(GtkList * ) ;
   void (*select_child)(GtkList * , GtkWidget * ) ;
   void (*unselect_child)(GtkList * , GtkWidget * ) ;
};
#line 46 "/usr/include/gtk-2.0/gtk/gtklistitem.h"
struct _GtkListItem ;
#line 46 "/usr/include/gtk-2.0/gtk/gtklistitem.h"
typedef struct _GtkListItem GtkListItem;
#line 47
struct _GtkListItemClass ;
#line 47 "/usr/include/gtk-2.0/gtk/gtklistitem.h"
typedef struct _GtkListItemClass GtkListItemClass;
#line 49 "/usr/include/gtk-2.0/gtk/gtklistitem.h"
struct _GtkListItem {
   GtkItem item ;
};
#line 54 "/usr/include/gtk-2.0/gtk/gtklistitem.h"
struct _GtkListItemClass {
   GtkItemClass parent_class ;
   void (*toggle_focus_row)(GtkListItem * ) ;
   void (*select_all)(GtkListItem * ) ;
   void (*unselect_all)(GtkListItem * ) ;
   void (*undo_selection)(GtkListItem * ) ;
   void (*start_selection)(GtkListItem * ) ;
   void (*end_selection)(GtkListItem * ) ;
   void (*extend_selection)(GtkListItem * , GtkScrollType  , gfloat  , gboolean  ) ;
   void (*scroll_horizontal)(GtkListItem * , GtkScrollType  , gfloat  ) ;
   void (*scroll_vertical)(GtkListItem * , GtkScrollType  , gfloat  ) ;
   void (*toggle_add_mode)(GtkListItem * ) ;
};
#line 45 "/usr/include/gtk-2.0/gtk/gtkoldeditable.h"
struct _GtkOldEditable ;
#line 45 "/usr/include/gtk-2.0/gtk/gtkoldeditable.h"
typedef struct _GtkOldEditable GtkOldEditable;
#line 46
struct _GtkOldEditableClass ;
#line 46 "/usr/include/gtk-2.0/gtk/gtkoldeditable.h"
typedef struct _GtkOldEditableClass GtkOldEditableClass;
#line 48 "/usr/include/gtk-2.0/gtk/gtkoldeditable.h"
typedef void (*GtkTextFunction)(GtkOldEditable * , guint32  );
#line 50 "/usr/include/gtk-2.0/gtk/gtkoldeditable.h"
struct _GtkOldEditable {
   GtkWidget widget ;
   guint current_pos ;
   guint selection_start_pos ;
   guint selection_end_pos ;
   guint has_selection ;
   guint editable ;
   guint visible ;
   gchar *clipboard_text ;
};
#line 68 "/usr/include/gtk-2.0/gtk/gtkoldeditable.h"
struct _GtkOldEditableClass {
   GtkWidgetClass parent_class ;
   void (*activate)(GtkOldEditable * ) ;
   void (*set_editable)(GtkOldEditable * , gboolean  ) ;
   void (*move_cursor)(GtkOldEditable * , gint  , gint  ) ;
   void (*move_word)(GtkOldEditable * , gint  ) ;
   void (*move_page)(GtkOldEditable * , gint  , gint  ) ;
   void (*move_to_row)(GtkOldEditable * , gint  ) ;
   void (*move_to_column)(GtkOldEditable * , gint  ) ;
   void (*kill_char)(GtkOldEditable * , gint  ) ;
   void (*kill_word)(GtkOldEditable * , gint  ) ;
   void (*kill_line)(GtkOldEditable * , gint  ) ;
   void (*cut_clipboard)(GtkOldEditable * ) ;
   void (*copy_clipboard)(GtkOldEditable * ) ;
   void (*paste_clipboard)(GtkOldEditable * ) ;
   void (*update_text)(GtkOldEditable * , gint  , gint  ) ;
   gchar *(*get_chars)(GtkOldEditable * , gint  , gint  ) ;
   void (*set_selection)(GtkOldEditable * , gint  , gint  ) ;
   void (*set_position)(GtkOldEditable * , gint  ) ;
};
#line 45 "/usr/include/gtk-2.0/gtk/gtkoptionmenu.h"
struct _GtkOptionMenu ;
#line 45 "/usr/include/gtk-2.0/gtk/gtkoptionmenu.h"
typedef struct _GtkOptionMenu GtkOptionMenu;
#line 46
struct _GtkOptionMenuClass ;
#line 46 "/usr/include/gtk-2.0/gtk/gtkoptionmenu.h"
typedef struct _GtkOptionMenuClass GtkOptionMenuClass;
#line 48 "/usr/include/gtk-2.0/gtk/gtkoptionmenu.h"
struct _GtkOptionMenu {
   GtkButton button ;
   GtkWidget *menu ;
   GtkWidget *menu_item ;
   guint16 width ;
   guint16 height ;
};
#line 59 "/usr/include/gtk-2.0/gtk/gtkoptionmenu.h"
struct _GtkOptionMenuClass {
   GtkButtonClass parent_class ;
   void (*changed)(GtkOptionMenu * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 45 "/usr/include/gtk-2.0/gtk/gtkpreview.h"
struct _GtkPreview ;
#line 45 "/usr/include/gtk-2.0/gtk/gtkpreview.h"
typedef struct _GtkPreview GtkPreview;
#line 46
struct _GtkPreviewInfo ;
#line 46 "/usr/include/gtk-2.0/gtk/gtkpreview.h"
typedef struct _GtkPreviewInfo GtkPreviewInfo;
#line 47
union _GtkDitherInfo ;
#line 47 "/usr/include/gtk-2.0/gtk/gtkpreview.h"
typedef union _GtkDitherInfo GtkDitherInfo;
#line 48
struct _GtkPreviewClass ;
#line 48 "/usr/include/gtk-2.0/gtk/gtkpreview.h"
typedef struct _GtkPreviewClass GtkPreviewClass;
#line 50 "/usr/include/gtk-2.0/gtk/gtkpreview.h"
struct _GtkPreview {
   GtkWidget widget ;
   guchar *buffer ;
   guint16 buffer_width ;
   guint16 buffer_height ;
   guint16 bpp ;
   guint16 rowstride ;
   GdkRgbDither dither ;
   guint type ;
   guint expand ;
};
#line 67 "/usr/include/gtk-2.0/gtk/gtkpreview.h"
struct _GtkPreviewInfo {
   guchar *lookup ;
   gdouble gamma ;
};
#line 74 "/usr/include/gtk-2.0/gtk/gtkpreview.h"
union _GtkDitherInfo {
   gushort s[2] ;
   guchar c[4] ;
};
#line 80 "/usr/include/gtk-2.0/gtk/gtkpreview.h"
struct _GtkPreviewClass {
   GtkWidgetClass parent_class ;
   GtkPreviewInfo info ;
};
#line 51 "/usr/include/gtk-2.0/gtk/gtktipsquery.h"
struct _GtkTipsQuery ;
#line 51 "/usr/include/gtk-2.0/gtk/gtktipsquery.h"
typedef struct _GtkTipsQuery GtkTipsQuery;
#line 52
struct _GtkTipsQueryClass ;
#line 52 "/usr/include/gtk-2.0/gtk/gtktipsquery.h"
typedef struct _GtkTipsQueryClass GtkTipsQueryClass;
#line 56 "/usr/include/gtk-2.0/gtk/gtktipsquery.h"
struct _GtkTipsQuery {
   GtkLabel label ;
   guint emit_always ;
   guint in_query ;
   gchar *label_inactive ;
   gchar *label_no_tip ;
   GtkWidget *caller ;
   GtkWidget *last_crossed ;
   GdkCursor *query_cursor ;
};
#line 71 "/usr/include/gtk-2.0/gtk/gtktipsquery.h"
struct _GtkTipsQueryClass {
   GtkLabelClass parent_class ;
   void (*start_query)(GtkTipsQuery * ) ;
   void (*stop_query)(GtkTipsQuery * ) ;
   void (*widget_entered)(GtkTipsQuery * , GtkWidget * , gchar * , gchar * ) ;
   gint (*widget_selected)(GtkTipsQuery * , GtkWidget * , gchar * , gchar * , GdkEventButton * ) ;
   void (*_gtk_reserved1)(void) ;
   void (*_gtk_reserved2)(void) ;
   void (*_gtk_reserved3)(void) ;
   void (*_gtk_reserved4)(void) ;
};
#line 11 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.h"
struct GSGDialog ;
#line 13 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.h"
typedef void (*GSGCallback)(struct GSGDialog * , void * );
#line 15
enum __anonenum__639 {
    GSG_TL_X = 0,
    GSG_TL_Y = 1,
    GSG_BR_X = 2,
    GSG_BR_Y = 3
} ;
#line 22 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.h"
typedef enum __anonenum__639 GSGCornerCoordinates;
#line 24 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.h"
struct __anonstruct_640 {
   int preview ;
   int dpi ;
   int coord[4] ;
};
#line 32 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.h"
typedef struct __anonstruct_640 GSGWellKnownOptions;
#line 37
struct GSGDialogElement ;
#line 34 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.h"
struct __anonstruct_641 {
   gchar *label ;
   struct GSGDialogElement *elem ;
   gint index ;
};
#line 40 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.h"
typedef struct __anonstruct_641 GSGMenuItem;
#line 42 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.h"
struct GSGDialogElement {
   struct GSGDialog *dialog ;
   GtkWidget *automatic ;
   GtkWidget *widget ;
   GtkObject *data ;
   int menu_size ;
   GSGMenuItem *menu ;
};
#line 51 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.h"
typedef struct GSGDialogElement GSGDialogElement;
#line 53 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.h"
struct GSGDialog {
   GtkWidget *window ;
   GtkWidget *main_hbox ;
   GtkWidget *advanced_vbox ;
   int twocolumn ;
   GtkTooltips *tooltips ;
   GdkColor tooltips_fg ;
   GdkColor tooltips_bg ;
   SANE_Handle *dev ;
   char const   *dev_name ;
   GSGWellKnownOptions well_known ;
   int num_elements ;
   GSGDialogElement *element ;
   gint idle_id ;
   u_int rebuild ;
   u_int advanced ;
   GSGCallback option_reload_callback ;
   void *option_reload_arg ;
   GSGCallback param_change_callback ;
   void *param_change_arg ;
};
#line 79 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.h"
typedef struct GSGDialog GSGDialog;
#line 6 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preferences.h"
struct __anonstruct_642 {
   char const   *device ;
   char const   *filename ;
   int advanced ;
   int tooltips_enabled ;
   int twocolumn_enabled ;
   double length_unit ;
   int preserve_preview ;
   int preview_own_cmap ;
   double preview_gamma ;
};
#line 18 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preferences.h"
typedef struct __anonstruct_642 Preferences;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__72___0 {
    _PC_LINK_MAX___3 = 0,
    _PC_MAX_CANON___3 = 1,
    _PC_MAX_INPUT___3 = 2,
    _PC_NAME_MAX___3 = 3,
    _PC_PATH_MAX___3 = 4,
    _PC_PIPE_BUF___3 = 5,
    _PC_CHOWN_RESTRICTED___3 = 6,
    _PC_NO_TRUNC___3 = 7,
    _PC_VDISABLE___3 = 8,
    _PC_SYNC_IO___3 = 9,
    _PC_ASYNC_IO___3 = 10,
    _PC_PRIO_IO___3 = 11,
    _PC_SOCK_MAXBUF___3 = 12,
    _PC_FILESIZEBITS___3 = 13,
    _PC_REC_INCR_XFER_SIZE___3 = 14,
    _PC_REC_MAX_XFER_SIZE___3 = 15,
    _PC_REC_MIN_XFER_SIZE___3 = 16,
    _PC_REC_XFER_ALIGN___3 = 17,
    _PC_ALLOC_SIZE_MIN___3 = 18,
    _PC_SYMLINK_MAX___3 = 19,
    _PC_2_SYMLINKS___3 = 20
} ;
#line 71
enum __anonenum__73___0 {
    _SC_ARG_MAX___3 = 0,
    _SC_CHILD_MAX___3 = 1,
    _SC_CLK_TCK___3 = 2,
    _SC_NGROUPS_MAX___3 = 3,
    _SC_OPEN_MAX___3 = 4,
    _SC_STREAM_MAX___3 = 5,
    _SC_TZNAME_MAX___3 = 6,
    _SC_JOB_CONTROL___3 = 7,
    _SC_SAVED_IDS___3 = 8,
    _SC_REALTIME_SIGNALS___3 = 9,
    _SC_PRIORITY_SCHEDULING___3 = 10,
    _SC_TIMERS___3 = 11,
    _SC_ASYNCHRONOUS_IO___3 = 12,
    _SC_PRIORITIZED_IO___3 = 13,
    _SC_SYNCHRONIZED_IO___3 = 14,
    _SC_FSYNC___3 = 15,
    _SC_MAPPED_FILES___3 = 16,
    _SC_MEMLOCK___3 = 17,
    _SC_MEMLOCK_RANGE___3 = 18,
    _SC_MEMORY_PROTECTION___3 = 19,
    _SC_MESSAGE_PASSING___3 = 20,
    _SC_SEMAPHORES___3 = 21,
    _SC_SHARED_MEMORY_OBJECTS___3 = 22,
    _SC_AIO_LISTIO_MAX___3 = 23,
    _SC_AIO_MAX___3 = 24,
    _SC_AIO_PRIO_DELTA_MAX___3 = 25,
    _SC_DELAYTIMER_MAX___3 = 26,
    _SC_MQ_OPEN_MAX___3 = 27,
    _SC_MQ_PRIO_MAX___3 = 28,
    _SC_VERSION___3 = 29,
    _SC_PAGESIZE___3 = 30,
    _SC_RTSIG_MAX___3 = 31,
    _SC_SEM_NSEMS_MAX___3 = 32,
    _SC_SEM_VALUE_MAX___3 = 33,
    _SC_SIGQUEUE_MAX___3 = 34,
    _SC_TIMER_MAX___3 = 35,
    _SC_BC_BASE_MAX___3 = 36,
    _SC_BC_DIM_MAX___3 = 37,
    _SC_BC_SCALE_MAX___3 = 38,
    _SC_BC_STRING_MAX___3 = 39,
    _SC_COLL_WEIGHTS_MAX___3 = 40,
    _SC_EQUIV_CLASS_MAX___3 = 41,
    _SC_EXPR_NEST_MAX___3 = 42,
    _SC_LINE_MAX___3 = 43,
    _SC_RE_DUP_MAX___3 = 44,
    _SC_CHARCLASS_NAME_MAX___3 = 45,
    _SC_2_VERSION___3 = 46,
    _SC_2_C_BIND___3 = 47,
    _SC_2_C_DEV___3 = 48,
    _SC_2_FORT_DEV___3 = 49,
    _SC_2_FORT_RUN___3 = 50,
    _SC_2_SW_DEV___3 = 51,
    _SC_2_LOCALEDEF___3 = 52,
    _SC_PII___3 = 53,
    _SC_PII_XTI___3 = 54,
    _SC_PII_SOCKET___3 = 55,
    _SC_PII_INTERNET___3 = 56,
    _SC_PII_OSI___3 = 57,
    _SC_POLL___3 = 58,
    _SC_SELECT___3 = 59,
    _SC_UIO_MAXIOV___3 = 60,
    _SC_IOV_MAX___3 = 60,
    _SC_PII_INTERNET_STREAM___3 = 61,
    _SC_PII_INTERNET_DGRAM___3 = 62,
    _SC_PII_OSI_COTS___3 = 63,
    _SC_PII_OSI_CLTS___3 = 64,
    _SC_PII_OSI_M___3 = 65,
    _SC_T_IOV_MAX___3 = 66,
    _SC_THREADS___3 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___3 = 68,
    _SC_GETGR_R_SIZE_MAX___3 = 69,
    _SC_GETPW_R_SIZE_MAX___3 = 70,
    _SC_LOGIN_NAME_MAX___3 = 71,
    _SC_TTY_NAME_MAX___3 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___3 = 73,
    _SC_THREAD_KEYS_MAX___3 = 74,
    _SC_THREAD_STACK_MIN___3 = 75,
    _SC_THREAD_THREADS_MAX___3 = 76,
    _SC_THREAD_ATTR_STACKADDR___3 = 77,
    _SC_THREAD_ATTR_STACKSIZE___3 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___3 = 79,
    _SC_THREAD_PRIO_INHERIT___3 = 80,
    _SC_THREAD_PRIO_PROTECT___3 = 81,
    _SC_THREAD_PROCESS_SHARED___3 = 82,
    _SC_NPROCESSORS_CONF___3 = 83,
    _SC_NPROCESSORS_ONLN___3 = 84,
    _SC_PHYS_PAGES___3 = 85,
    _SC_AVPHYS_PAGES___3 = 86,
    _SC_ATEXIT_MAX___3 = 87,
    _SC_PASS_MAX___3 = 88,
    _SC_XOPEN_VERSION___3 = 89,
    _SC_XOPEN_XCU_VERSION___3 = 90,
    _SC_XOPEN_UNIX___3 = 91,
    _SC_XOPEN_CRYPT___3 = 92,
    _SC_XOPEN_ENH_I18N___3 = 93,
    _SC_XOPEN_SHM___3 = 94,
    _SC_2_CHAR_TERM___3 = 95,
    _SC_2_C_VERSION___3 = 96,
    _SC_2_UPE___3 = 97,
    _SC_XOPEN_XPG2___3 = 98,
    _SC_XOPEN_XPG3___3 = 99,
    _SC_XOPEN_XPG4___3 = 100,
    _SC_CHAR_BIT___3 = 101,
    _SC_CHAR_MAX___3 = 102,
    _SC_CHAR_MIN___3 = 103,
    _SC_INT_MAX___3 = 104,
    _SC_INT_MIN___3 = 105,
    _SC_LONG_BIT___3 = 106,
    _SC_WORD_BIT___3 = 107,
    _SC_MB_LEN_MAX___3 = 108,
    _SC_NZERO___3 = 109,
    _SC_SSIZE_MAX___3 = 110,
    _SC_SCHAR_MAX___3 = 111,
    _SC_SCHAR_MIN___3 = 112,
    _SC_SHRT_MAX___3 = 113,
    _SC_SHRT_MIN___3 = 114,
    _SC_UCHAR_MAX___3 = 115,
    _SC_UINT_MAX___3 = 116,
    _SC_ULONG_MAX___3 = 117,
    _SC_USHRT_MAX___3 = 118,
    _SC_NL_ARGMAX___3 = 119,
    _SC_NL_LANGMAX___3 = 120,
    _SC_NL_MSGMAX___3 = 121,
    _SC_NL_NMAX___3 = 122,
    _SC_NL_SETMAX___3 = 123,
    _SC_NL_TEXTMAX___3 = 124,
    _SC_XBS5_ILP32_OFF32___3 = 125,
    _SC_XBS5_ILP32_OFFBIG___3 = 126,
    _SC_XBS5_LP64_OFF64___3 = 127,
    _SC_XBS5_LPBIG_OFFBIG___3 = 128,
    _SC_XOPEN_LEGACY___3 = 129,
    _SC_XOPEN_REALTIME___3 = 130,
    _SC_XOPEN_REALTIME_THREADS___3 = 131,
    _SC_ADVISORY_INFO___3 = 132,
    _SC_BARRIERS___3 = 133,
    _SC_BASE___3 = 134,
    _SC_C_LANG_SUPPORT___3 = 135,
    _SC_C_LANG_SUPPORT_R___3 = 136,
    _SC_CLOCK_SELECTION___3 = 137,
    _SC_CPUTIME___3 = 138,
    _SC_THREAD_CPUTIME___3 = 139,
    _SC_DEVICE_IO___3 = 140,
    _SC_DEVICE_SPECIFIC___3 = 141,
    _SC_DEVICE_SPECIFIC_R___3 = 142,
    _SC_FD_MGMT___3 = 143,
    _SC_FIFO___3 = 144,
    _SC_PIPE___3 = 145,
    _SC_FILE_ATTRIBUTES___3 = 146,
    _SC_FILE_LOCKING___3 = 147,
    _SC_FILE_SYSTEM___3 = 148,
    _SC_MONOTONIC_CLOCK___3 = 149,
    _SC_MULTI_PROCESS___3 = 150,
    _SC_SINGLE_PROCESS___3 = 151,
    _SC_NETWORKING___3 = 152,
    _SC_READER_WRITER_LOCKS___3 = 153,
    _SC_SPIN_LOCKS___3 = 154,
    _SC_REGEXP___3 = 155,
    _SC_REGEX_VERSION___3 = 156,
    _SC_SHELL___3 = 157,
    _SC_SIGNALS___3 = 158,
    _SC_SPAWN___3 = 159,
    _SC_SPORADIC_SERVER___3 = 160,
    _SC_THREAD_SPORADIC_SERVER___3 = 161,
    _SC_SYSTEM_DATABASE___3 = 162,
    _SC_SYSTEM_DATABASE_R___3 = 163,
    _SC_TIMEOUTS___3 = 164,
    _SC_TYPED_MEMORY_OBJECTS___3 = 165,
    _SC_USER_GROUPS___3 = 166,
    _SC_USER_GROUPS_R___3 = 167,
    _SC_2_PBS___3 = 168,
    _SC_2_PBS_ACCOUNTING___3 = 169,
    _SC_2_PBS_LOCATE___3 = 170,
    _SC_2_PBS_MESSAGE___3 = 171,
    _SC_2_PBS_TRACK___3 = 172,
    _SC_SYMLOOP_MAX___3 = 173,
    _SC_STREAMS___3 = 174,
    _SC_2_PBS_CHECKPOINT___3 = 175,
    _SC_V6_ILP32_OFF32___3 = 176,
    _SC_V6_ILP32_OFFBIG___3 = 177,
    _SC_V6_LP64_OFF64___3 = 178,
    _SC_V6_LPBIG_OFFBIG___3 = 179,
    _SC_HOST_NAME_MAX___3 = 180,
    _SC_TRACE___3 = 181,
    _SC_TRACE_EVENT_FILTER___3 = 182,
    _SC_TRACE_INHERIT___3 = 183,
    _SC_TRACE_LOG___3 = 184,
    _SC_LEVEL1_ICACHE_SIZE___3 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___3 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___3 = 187,
    _SC_LEVEL1_DCACHE_SIZE___3 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___3 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___3 = 190,
    _SC_LEVEL2_CACHE_SIZE___3 = 191,
    _SC_LEVEL2_CACHE_ASSOC___3 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___3 = 193,
    _SC_LEVEL3_CACHE_SIZE___3 = 194,
    _SC_LEVEL3_CACHE_ASSOC___3 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___3 = 196,
    _SC_LEVEL4_CACHE_SIZE___3 = 197,
    _SC_LEVEL4_CACHE_ASSOC___3 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___3 = 199,
    _SC_IPV6___3 = 235,
    _SC_RAW_SOCKETS___3 = 236,
    _SC_V7_ILP32_OFF32___3 = 237,
    _SC_V7_ILP32_OFFBIG___3 = 238,
    _SC_V7_LP64_OFF64___3 = 239,
    _SC_V7_LPBIG_OFFBIG___3 = 240,
    _SC_SS_REPL_MAX___3 = 241,
    _SC_TRACE_EVENT_NAME_MAX___3 = 242,
    _SC_TRACE_NAME_MAX___3 = 243,
    _SC_TRACE_SYS_MAX___3 = 244,
    _SC_TRACE_USER_EVENT_MAX___3 = 245,
    _SC_XOPEN_STREAMS___3 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___3 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___3 = 248,
    _SC_MINSIGSTKSZ___3 = 249,
    _SC_SIGSTKSZ___3 = 250
} ;
#line 539
enum __anonenum__74___0 {
    _CS_PATH___3 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___3 = 1,
    _CS_GNU_LIBC_VERSION___3 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___3 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___3 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___3 = 5,
    _CS_LFS_CFLAGS___3 = 1000,
    _CS_LFS_LDFLAGS___3 = 1001,
    _CS_LFS_LIBS___3 = 1002,
    _CS_LFS_LINTFLAGS___3 = 1003,
    _CS_LFS64_CFLAGS___3 = 1004,
    _CS_LFS64_LDFLAGS___3 = 1005,
    _CS_LFS64_LIBS___3 = 1006,
    _CS_LFS64_LINTFLAGS___3 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___3 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___3 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___3 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___3 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___3 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___3 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___3 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___3 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___3 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___3 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___3 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___3 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___3 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___3 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___3 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___3 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___3 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___3 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___3 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___3 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___3 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___3 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___3 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___3 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___3 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___3 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___3 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___3 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___3 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___3 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___3 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___3 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___3 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___3 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___3 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___3 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___3 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___3 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___3 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___3 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___3 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___3 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___3 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___3 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___3 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___3 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___3 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___3 = 1147,
    _CS_V6_ENV___3 = 1148,
    _CS_V7_ENV___3 = 1149
} ;
#line 52 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preferences.c"
struct __anonstruct_647 {
   SANE_String name ;
   void (*codec)(Wire * , Preferences * , long  ) ;
   long offset ;
};
#line 163 "/usr/include/math.h"
typedef float float_t;
#line 164 "/usr/include/math.h"
typedef double double_t;
#line 251
enum __anonenum__649 {
    FP_INT_UPWARD = 0,
    FP_INT_DOWNWARD = 1,
    FP_INT_TOWARDZERO = 2,
    FP_INT_TONEARESTFROMZERO = 3,
    FP_INT_TONEAREST = 4
} ;
#line 934
enum __anonenum__650 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__680 {
    SI_ASYNCNL___0 = -60,
    SI_DETHREAD___0 = -7,
    SI_TKILL___0 = -6,
    SI_SIGIO___0 = -5,
    SI_ASYNCIO___0 = -4,
    SI_MESGQ___0 = -3,
    SI_TIMER___0 = -2,
    SI_QUEUE___0 = -1,
    SI_USER___0 = 0,
    SI_KERNEL___0 = 128
} ;
#line 71
enum __anonenum__681 {
    ILL_ILLOPC___0 = 1,
    ILL_ILLOPN___0 = 2,
    ILL_ILLADR___0 = 3,
    ILL_ILLTRP___0 = 4,
    ILL_PRVOPC___0 = 5,
    ILL_PRVREG___0 = 6,
    ILL_COPROC___0 = 7,
    ILL_BADSTK___0 = 8,
    ILL_BADIADDR___0 = 9
} ;
#line 94
enum __anonenum__682 {
    FPE_INTDIV___0 = 1,
    FPE_INTOVF___0 = 2,
    FPE_FLTDIV___0 = 3,
    FPE_FLTOVF___0 = 4,
    FPE_FLTUND___0 = 5,
    FPE_FLTRES___0 = 6,
    FPE_FLTINV___0 = 7,
    FPE_FLTSUB___0 = 8,
    FPE_FLTUNK___0 = 14,
    FPE_CONDTRAP___0 = 15
} ;
#line 119
enum __anonenum__683 {
    SEGV_MAPERR___0 = 1,
    SEGV_ACCERR___0 = 2,
    SEGV_BNDERR___0 = 3,
    SEGV_PKUERR___0 = 4,
    SEGV_ACCADI___0 = 5,
    SEGV_ADIDERR___0 = 6,
    SEGV_ADIPERR___0 = 7,
    SEGV_MTEAERR___0 = 8,
    SEGV_MTESERR___0 = 9
} ;
#line 142
enum __anonenum__684 {
    BUS_ADRALN___0 = 1,
    BUS_ADRERR___0 = 2,
    BUS_OBJERR___0 = 3,
    BUS_MCEERR_AR___0 = 4,
    BUS_MCEERR_AO___0 = 5
} ;
#line 159
enum __anonenum__685 {
    TRAP_BRKPT___0 = 1,
    TRAP_TRACE___0 = 2,
    TRAP_BRANCH___0 = 3,
    TRAP_HWBKPT___0 = 4,
    TRAP_UNK___0 = 5
} ;
#line 176
enum __anonenum__686 {
    CLD_EXITED___0 = 1,
    CLD_KILLED___0 = 2,
    CLD_DUMPED___0 = 3,
    CLD_TRAPPED___0 = 4,
    CLD_STOPPED___0 = 5,
    CLD_CONTINUED___0 = 6
} ;
#line 193
enum __anonenum__687 {
    POLL_IN___0 = 1,
    POLL_OUT___0 = 2,
    POLL_MSG___0 = 3,
    POLL_ERR___0 = 4,
    POLL_PRI___0 = 5,
    POLL_HUP___0 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__690 {
    SIGEV_SIGNAL___0 = 0,
    SIGEV_NONE___0 = 1,
    SIGEV_THREAD___0 = 2,
    SIGEV_THREAD_ID___0 = 4
} ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
enum __anonenum__694 {
    REG_R8___0 = 0,
    REG_R9___0 = 1,
    REG_R10___0 = 2,
    REG_R11___0 = 3,
    REG_R12___0 = 4,
    REG_R13___0 = 5,
    REG_R14___0 = 6,
    REG_R15___0 = 7,
    REG_RDI___0 = 8,
    REG_RSI___0 = 9,
    REG_RBP___0 = 10,
    REG_RBX___0 = 11,
    REG_RDX___0 = 12,
    REG_RAX___0 = 13,
    REG_RCX___0 = 14,
    REG_RSP___0 = 15,
    REG_RIP___0 = 16,
    REG_EFL___0 = 17,
    REG_CSGSFS___0 = 18,
    REG_ERR___0 = 19,
    REG_TRAPNO___0 = 20,
    REG_OLDMASK___0 = 21,
    REG_CR2___0 = 22
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__696 {
    _PC_LINK_MAX___4 = 0,
    _PC_MAX_CANON___4 = 1,
    _PC_MAX_INPUT___4 = 2,
    _PC_NAME_MAX___4 = 3,
    _PC_PATH_MAX___4 = 4,
    _PC_PIPE_BUF___4 = 5,
    _PC_CHOWN_RESTRICTED___4 = 6,
    _PC_NO_TRUNC___4 = 7,
    _PC_VDISABLE___4 = 8,
    _PC_SYNC_IO___4 = 9,
    _PC_ASYNC_IO___4 = 10,
    _PC_PRIO_IO___4 = 11,
    _PC_SOCK_MAXBUF___4 = 12,
    _PC_FILESIZEBITS___4 = 13,
    _PC_REC_INCR_XFER_SIZE___4 = 14,
    _PC_REC_MAX_XFER_SIZE___4 = 15,
    _PC_REC_MIN_XFER_SIZE___4 = 16,
    _PC_REC_XFER_ALIGN___4 = 17,
    _PC_ALLOC_SIZE_MIN___4 = 18,
    _PC_SYMLINK_MAX___4 = 19,
    _PC_2_SYMLINKS___4 = 20
} ;
#line 71
enum __anonenum__697 {
    _SC_ARG_MAX___4 = 0,
    _SC_CHILD_MAX___4 = 1,
    _SC_CLK_TCK___4 = 2,
    _SC_NGROUPS_MAX___4 = 3,
    _SC_OPEN_MAX___4 = 4,
    _SC_STREAM_MAX___4 = 5,
    _SC_TZNAME_MAX___4 = 6,
    _SC_JOB_CONTROL___4 = 7,
    _SC_SAVED_IDS___4 = 8,
    _SC_REALTIME_SIGNALS___4 = 9,
    _SC_PRIORITY_SCHEDULING___4 = 10,
    _SC_TIMERS___4 = 11,
    _SC_ASYNCHRONOUS_IO___4 = 12,
    _SC_PRIORITIZED_IO___4 = 13,
    _SC_SYNCHRONIZED_IO___4 = 14,
    _SC_FSYNC___4 = 15,
    _SC_MAPPED_FILES___4 = 16,
    _SC_MEMLOCK___4 = 17,
    _SC_MEMLOCK_RANGE___4 = 18,
    _SC_MEMORY_PROTECTION___4 = 19,
    _SC_MESSAGE_PASSING___4 = 20,
    _SC_SEMAPHORES___4 = 21,
    _SC_SHARED_MEMORY_OBJECTS___4 = 22,
    _SC_AIO_LISTIO_MAX___4 = 23,
    _SC_AIO_MAX___4 = 24,
    _SC_AIO_PRIO_DELTA_MAX___4 = 25,
    _SC_DELAYTIMER_MAX___4 = 26,
    _SC_MQ_OPEN_MAX___4 = 27,
    _SC_MQ_PRIO_MAX___4 = 28,
    _SC_VERSION___4 = 29,
    _SC_PAGESIZE___4 = 30,
    _SC_RTSIG_MAX___4 = 31,
    _SC_SEM_NSEMS_MAX___4 = 32,
    _SC_SEM_VALUE_MAX___4 = 33,
    _SC_SIGQUEUE_MAX___4 = 34,
    _SC_TIMER_MAX___4 = 35,
    _SC_BC_BASE_MAX___4 = 36,
    _SC_BC_DIM_MAX___4 = 37,
    _SC_BC_SCALE_MAX___4 = 38,
    _SC_BC_STRING_MAX___4 = 39,
    _SC_COLL_WEIGHTS_MAX___4 = 40,
    _SC_EQUIV_CLASS_MAX___4 = 41,
    _SC_EXPR_NEST_MAX___4 = 42,
    _SC_LINE_MAX___4 = 43,
    _SC_RE_DUP_MAX___4 = 44,
    _SC_CHARCLASS_NAME_MAX___4 = 45,
    _SC_2_VERSION___4 = 46,
    _SC_2_C_BIND___4 = 47,
    _SC_2_C_DEV___4 = 48,
    _SC_2_FORT_DEV___4 = 49,
    _SC_2_FORT_RUN___4 = 50,
    _SC_2_SW_DEV___4 = 51,
    _SC_2_LOCALEDEF___4 = 52,
    _SC_PII___4 = 53,
    _SC_PII_XTI___4 = 54,
    _SC_PII_SOCKET___4 = 55,
    _SC_PII_INTERNET___4 = 56,
    _SC_PII_OSI___4 = 57,
    _SC_POLL___4 = 58,
    _SC_SELECT___4 = 59,
    _SC_UIO_MAXIOV___4 = 60,
    _SC_IOV_MAX___4 = 60,
    _SC_PII_INTERNET_STREAM___4 = 61,
    _SC_PII_INTERNET_DGRAM___4 = 62,
    _SC_PII_OSI_COTS___4 = 63,
    _SC_PII_OSI_CLTS___4 = 64,
    _SC_PII_OSI_M___4 = 65,
    _SC_T_IOV_MAX___4 = 66,
    _SC_THREADS___4 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___4 = 68,
    _SC_GETGR_R_SIZE_MAX___4 = 69,
    _SC_GETPW_R_SIZE_MAX___4 = 70,
    _SC_LOGIN_NAME_MAX___4 = 71,
    _SC_TTY_NAME_MAX___4 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___4 = 73,
    _SC_THREAD_KEYS_MAX___4 = 74,
    _SC_THREAD_STACK_MIN___4 = 75,
    _SC_THREAD_THREADS_MAX___4 = 76,
    _SC_THREAD_ATTR_STACKADDR___4 = 77,
    _SC_THREAD_ATTR_STACKSIZE___4 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___4 = 79,
    _SC_THREAD_PRIO_INHERIT___4 = 80,
    _SC_THREAD_PRIO_PROTECT___4 = 81,
    _SC_THREAD_PROCESS_SHARED___4 = 82,
    _SC_NPROCESSORS_CONF___4 = 83,
    _SC_NPROCESSORS_ONLN___4 = 84,
    _SC_PHYS_PAGES___4 = 85,
    _SC_AVPHYS_PAGES___4 = 86,
    _SC_ATEXIT_MAX___4 = 87,
    _SC_PASS_MAX___4 = 88,
    _SC_XOPEN_VERSION___4 = 89,
    _SC_XOPEN_XCU_VERSION___4 = 90,
    _SC_XOPEN_UNIX___4 = 91,
    _SC_XOPEN_CRYPT___4 = 92,
    _SC_XOPEN_ENH_I18N___4 = 93,
    _SC_XOPEN_SHM___4 = 94,
    _SC_2_CHAR_TERM___4 = 95,
    _SC_2_C_VERSION___4 = 96,
    _SC_2_UPE___4 = 97,
    _SC_XOPEN_XPG2___4 = 98,
    _SC_XOPEN_XPG3___4 = 99,
    _SC_XOPEN_XPG4___4 = 100,
    _SC_CHAR_BIT___4 = 101,
    _SC_CHAR_MAX___4 = 102,
    _SC_CHAR_MIN___4 = 103,
    _SC_INT_MAX___4 = 104,
    _SC_INT_MIN___4 = 105,
    _SC_LONG_BIT___4 = 106,
    _SC_WORD_BIT___4 = 107,
    _SC_MB_LEN_MAX___4 = 108,
    _SC_NZERO___4 = 109,
    _SC_SSIZE_MAX___4 = 110,
    _SC_SCHAR_MAX___4 = 111,
    _SC_SCHAR_MIN___4 = 112,
    _SC_SHRT_MAX___4 = 113,
    _SC_SHRT_MIN___4 = 114,
    _SC_UCHAR_MAX___4 = 115,
    _SC_UINT_MAX___4 = 116,
    _SC_ULONG_MAX___4 = 117,
    _SC_USHRT_MAX___4 = 118,
    _SC_NL_ARGMAX___4 = 119,
    _SC_NL_LANGMAX___4 = 120,
    _SC_NL_MSGMAX___4 = 121,
    _SC_NL_NMAX___4 = 122,
    _SC_NL_SETMAX___4 = 123,
    _SC_NL_TEXTMAX___4 = 124,
    _SC_XBS5_ILP32_OFF32___4 = 125,
    _SC_XBS5_ILP32_OFFBIG___4 = 126,
    _SC_XBS5_LP64_OFF64___4 = 127,
    _SC_XBS5_LPBIG_OFFBIG___4 = 128,
    _SC_XOPEN_LEGACY___4 = 129,
    _SC_XOPEN_REALTIME___4 = 130,
    _SC_XOPEN_REALTIME_THREADS___4 = 131,
    _SC_ADVISORY_INFO___4 = 132,
    _SC_BARRIERS___4 = 133,
    _SC_BASE___4 = 134,
    _SC_C_LANG_SUPPORT___4 = 135,
    _SC_C_LANG_SUPPORT_R___4 = 136,
    _SC_CLOCK_SELECTION___4 = 137,
    _SC_CPUTIME___4 = 138,
    _SC_THREAD_CPUTIME___4 = 139,
    _SC_DEVICE_IO___4 = 140,
    _SC_DEVICE_SPECIFIC___4 = 141,
    _SC_DEVICE_SPECIFIC_R___4 = 142,
    _SC_FD_MGMT___4 = 143,
    _SC_FIFO___4 = 144,
    _SC_PIPE___4 = 145,
    _SC_FILE_ATTRIBUTES___4 = 146,
    _SC_FILE_LOCKING___4 = 147,
    _SC_FILE_SYSTEM___4 = 148,
    _SC_MONOTONIC_CLOCK___4 = 149,
    _SC_MULTI_PROCESS___4 = 150,
    _SC_SINGLE_PROCESS___4 = 151,
    _SC_NETWORKING___4 = 152,
    _SC_READER_WRITER_LOCKS___4 = 153,
    _SC_SPIN_LOCKS___4 = 154,
    _SC_REGEXP___4 = 155,
    _SC_REGEX_VERSION___4 = 156,
    _SC_SHELL___4 = 157,
    _SC_SIGNALS___4 = 158,
    _SC_SPAWN___4 = 159,
    _SC_SPORADIC_SERVER___4 = 160,
    _SC_THREAD_SPORADIC_SERVER___4 = 161,
    _SC_SYSTEM_DATABASE___4 = 162,
    _SC_SYSTEM_DATABASE_R___4 = 163,
    _SC_TIMEOUTS___4 = 164,
    _SC_TYPED_MEMORY_OBJECTS___4 = 165,
    _SC_USER_GROUPS___4 = 166,
    _SC_USER_GROUPS_R___4 = 167,
    _SC_2_PBS___4 = 168,
    _SC_2_PBS_ACCOUNTING___4 = 169,
    _SC_2_PBS_LOCATE___4 = 170,
    _SC_2_PBS_MESSAGE___4 = 171,
    _SC_2_PBS_TRACK___4 = 172,
    _SC_SYMLOOP_MAX___4 = 173,
    _SC_STREAMS___4 = 174,
    _SC_2_PBS_CHECKPOINT___4 = 175,
    _SC_V6_ILP32_OFF32___4 = 176,
    _SC_V6_ILP32_OFFBIG___4 = 177,
    _SC_V6_LP64_OFF64___4 = 178,
    _SC_V6_LPBIG_OFFBIG___4 = 179,
    _SC_HOST_NAME_MAX___4 = 180,
    _SC_TRACE___4 = 181,
    _SC_TRACE_EVENT_FILTER___4 = 182,
    _SC_TRACE_INHERIT___4 = 183,
    _SC_TRACE_LOG___4 = 184,
    _SC_LEVEL1_ICACHE_SIZE___4 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___4 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___4 = 187,
    _SC_LEVEL1_DCACHE_SIZE___4 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___4 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___4 = 190,
    _SC_LEVEL2_CACHE_SIZE___4 = 191,
    _SC_LEVEL2_CACHE_ASSOC___4 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___4 = 193,
    _SC_LEVEL3_CACHE_SIZE___4 = 194,
    _SC_LEVEL3_CACHE_ASSOC___4 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___4 = 196,
    _SC_LEVEL4_CACHE_SIZE___4 = 197,
    _SC_LEVEL4_CACHE_ASSOC___4 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___4 = 199,
    _SC_IPV6___4 = 235,
    _SC_RAW_SOCKETS___4 = 236,
    _SC_V7_ILP32_OFF32___4 = 237,
    _SC_V7_ILP32_OFFBIG___4 = 238,
    _SC_V7_LP64_OFF64___4 = 239,
    _SC_V7_LPBIG_OFFBIG___4 = 240,
    _SC_SS_REPL_MAX___4 = 241,
    _SC_TRACE_EVENT_NAME_MAX___4 = 242,
    _SC_TRACE_NAME_MAX___4 = 243,
    _SC_TRACE_SYS_MAX___4 = 244,
    _SC_TRACE_USER_EVENT_MAX___4 = 245,
    _SC_XOPEN_STREAMS___4 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___4 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___4 = 248,
    _SC_MINSIGSTKSZ___4 = 249,
    _SC_SIGSTKSZ___4 = 250
} ;
#line 539
enum __anonenum__698 {
    _CS_PATH___4 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___4 = 1,
    _CS_GNU_LIBC_VERSION___4 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___4 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___4 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___4 = 5,
    _CS_LFS_CFLAGS___4 = 1000,
    _CS_LFS_LDFLAGS___4 = 1001,
    _CS_LFS_LIBS___4 = 1002,
    _CS_LFS_LINTFLAGS___4 = 1003,
    _CS_LFS64_CFLAGS___4 = 1004,
    _CS_LFS64_LDFLAGS___4 = 1005,
    _CS_LFS64_LIBS___4 = 1006,
    _CS_LFS64_LINTFLAGS___4 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___4 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___4 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___4 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___4 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___4 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___4 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___4 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___4 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___4 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___4 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___4 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___4 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___4 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___4 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___4 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___4 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___4 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___4 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___4 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___4 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___4 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___4 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___4 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___4 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___4 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___4 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___4 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___4 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___4 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___4 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___4 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___4 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___4 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___4 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___4 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___4 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___4 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___4 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___4 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___4 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___4 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___4 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___4 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___4 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___4 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___4 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___4 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___4 = 1147,
    _CS_V6_ENV___4 = 1148,
    _CS_V7_ENV___4 = 1149
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__699 {
    SS_ONSTACK___0 = 1,
    SS_DISABLE___0 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__714 {
    DT_UNKNOWN___0 = 0,
    DT_FIFO___0 = 1,
    DT_CHR___0 = 2,
    DT_DIR___0 = 4,
    DT_BLK___0 = 6,
    DT_REG___0 = 8,
    DT_LNK___0 = 10,
    DT_SOCK___0 = 12,
    DT_WHT___0 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__773 {
    PTHREAD_CREATE_JOINABLE___0 = 0,
    PTHREAD_CREATE_DETACHED___0 = 1
} ;
#line 47
enum __anonenum__774 {
    PTHREAD_MUTEX_TIMED_NP___0 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___0 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___0 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___0 = 3,
    PTHREAD_MUTEX_NORMAL___0 = 0,
    PTHREAD_MUTEX_RECURSIVE___0 = 1,
    PTHREAD_MUTEX_ERRORCHECK___0 = 2,
    PTHREAD_MUTEX_DEFAULT___0 = 0,
    PTHREAD_MUTEX_FAST_NP___0 = 0
} ;
#line 69
enum __anonenum__775 {
    PTHREAD_MUTEX_STALLED___0 = 0,
    PTHREAD_MUTEX_STALLED_NP___0 = 0,
    PTHREAD_MUTEX_ROBUST___0 = 1,
    PTHREAD_MUTEX_ROBUST_NP___0 = 1
} ;
#line 81
enum __anonenum__776 {
    PTHREAD_PRIO_NONE___0 = 0,
    PTHREAD_PRIO_INHERIT___0 = 1,
    PTHREAD_PRIO_PROTECT___0 = 2
} ;
#line 104
enum __anonenum__777 {
    PTHREAD_RWLOCK_PREFER_READER_NP___0 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___0 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___0 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___0 = 0
} ;
#line 124
enum __anonenum__778 {
    PTHREAD_INHERIT_SCHED___0 = 0,
    PTHREAD_EXPLICIT_SCHED___0 = 1
} ;
#line 134
enum __anonenum__779 {
    PTHREAD_SCOPE_SYSTEM___0 = 0,
    PTHREAD_SCOPE_PROCESS___0 = 1
} ;
#line 144
enum __anonenum__780 {
    PTHREAD_PROCESS_PRIVATE___0 = 0,
    PTHREAD_PROCESS_SHARED___0 = 1
} ;
#line 168
enum __anonenum__781 {
    PTHREAD_CANCEL_ENABLE___0 = 0,
    PTHREAD_CANCEL_DISABLE___0 = 1
} ;
#line 175
enum __anonenum__782 {
    PTHREAD_CANCEL_DEFERRED___0 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___0 = 1
} ;
#line 40 "/usr/include/gtk-2.0/gtk/gtktreesortable.h"
enum __anonenum__1071 {
    GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID___0 = -1,
    GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID___0 = -2
} ;
#line 46 "/usr/include/gtk-2.0/gtk/gtkclist.h"
enum __anonenum__1107 {
    GTK_CLIST_IN_DRAG___0 = 1,
    GTK_CLIST_ROW_HEIGHT_SET___0 = 2,
    GTK_CLIST_SHOW_TITLES___0 = 4,
    GTK_CLIST_ADD_MODE___0 = 16,
    GTK_CLIST_AUTO_SORT___0 = 32,
    GTK_CLIST_AUTO_RESIZE_BLOCKED___0 = 64,
    GTK_CLIST_REORDERABLE___0 = 128,
    GTK_CLIST_USE_DRAG_ICONS___0 = 256,
    GTK_CLIST_DRAW_DRAG_LINE___0 = 512,
    GTK_CLIST_DRAW_DRAG_RECT___0 = 1024
} ;
#line 58 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.h"
struct __anonstruct_1134 {
   int active ;
   int coord[4] ;
};
#line 26 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.h"
struct __anonstruct_1133 {
   GSGDialog *dialog ;
   SANE_Value_Type surface_type ;
   SANE_Unit surface_unit ;
   float surface[4] ;
   float aspect ;
   int saved_dpi_valid ;
   SANE_Word saved_dpi ;
   int saved_coord_valid[4] ;
   SANE_Word saved_coord[4] ;
   int preview_width ;
   int preview_height ;
   u_char *preview_row ;
   int scanning ;
   time_t image_last_time_updated ;
   gint input_tag ;
   SANE_Parameters params ;
   int image_offset ;
   int image_x ;
   int image_y ;
   int image_width ;
   int image_height ;
   u_char *image_data ;
   GdkGC *gc ;
   int selection_drag ;
   struct __anonstruct_1134 selection ;
   struct __anonstruct_1134 previous_selection ;
   GtkWidget *top ;
   GtkWidget *hruler ;
   GtkWidget *vruler ;
   GtkWidget *viewport ;
   GtkWidget *window ;
   GtkWidget *cancel ;
   GtkWidget *preview ;
};
#line 73 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.h"
typedef struct __anonstruct_1133 Preview;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__1154 {
    SI_ASYNCNL___1 = -60,
    SI_DETHREAD___1 = -7,
    SI_TKILL___1 = -6,
    SI_SIGIO___1 = -5,
    SI_ASYNCIO___1 = -4,
    SI_MESGQ___1 = -3,
    SI_TIMER___1 = -2,
    SI_QUEUE___1 = -1,
    SI_USER___1 = 0,
    SI_KERNEL___1 = 128
} ;
#line 71
enum __anonenum__1155 {
    ILL_ILLOPC___1 = 1,
    ILL_ILLOPN___1 = 2,
    ILL_ILLADR___1 = 3,
    ILL_ILLTRP___1 = 4,
    ILL_PRVOPC___1 = 5,
    ILL_PRVREG___1 = 6,
    ILL_COPROC___1 = 7,
    ILL_BADSTK___1 = 8,
    ILL_BADIADDR___1 = 9
} ;
#line 94
enum __anonenum__1156 {
    FPE_INTDIV___1 = 1,
    FPE_INTOVF___1 = 2,
    FPE_FLTDIV___1 = 3,
    FPE_FLTOVF___1 = 4,
    FPE_FLTUND___1 = 5,
    FPE_FLTRES___1 = 6,
    FPE_FLTINV___1 = 7,
    FPE_FLTSUB___1 = 8,
    FPE_FLTUNK___1 = 14,
    FPE_CONDTRAP___1 = 15
} ;
#line 119
enum __anonenum__1157 {
    SEGV_MAPERR___1 = 1,
    SEGV_ACCERR___1 = 2,
    SEGV_BNDERR___1 = 3,
    SEGV_PKUERR___1 = 4,
    SEGV_ACCADI___1 = 5,
    SEGV_ADIDERR___1 = 6,
    SEGV_ADIPERR___1 = 7,
    SEGV_MTEAERR___1 = 8,
    SEGV_MTESERR___1 = 9
} ;
#line 142
enum __anonenum__1158 {
    BUS_ADRALN___1 = 1,
    BUS_ADRERR___1 = 2,
    BUS_OBJERR___1 = 3,
    BUS_MCEERR_AR___1 = 4,
    BUS_MCEERR_AO___1 = 5
} ;
#line 159
enum __anonenum__1159 {
    TRAP_BRKPT___1 = 1,
    TRAP_TRACE___1 = 2,
    TRAP_BRANCH___1 = 3,
    TRAP_HWBKPT___1 = 4,
    TRAP_UNK___1 = 5
} ;
#line 176
enum __anonenum__1160 {
    CLD_EXITED___1 = 1,
    CLD_KILLED___1 = 2,
    CLD_DUMPED___1 = 3,
    CLD_TRAPPED___1 = 4,
    CLD_STOPPED___1 = 5,
    CLD_CONTINUED___1 = 6
} ;
#line 193
enum __anonenum__1161 {
    POLL_IN___1 = 1,
    POLL_OUT___1 = 2,
    POLL_MSG___1 = 3,
    POLL_ERR___1 = 4,
    POLL_PRI___1 = 5,
    POLL_HUP___1 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__1164 {
    SIGEV_SIGNAL___1 = 0,
    SIGEV_NONE___1 = 1,
    SIGEV_THREAD___1 = 2,
    SIGEV_THREAD_ID___1 = 4
} ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
enum __anonenum__1168 {
    REG_R8___1 = 0,
    REG_R9___1 = 1,
    REG_R10___1 = 2,
    REG_R11___1 = 3,
    REG_R12___1 = 4,
    REG_R13___1 = 5,
    REG_R14___1 = 6,
    REG_R15___1 = 7,
    REG_RDI___1 = 8,
    REG_RSI___1 = 9,
    REG_RBP___1 = 10,
    REG_RBX___1 = 11,
    REG_RDX___1 = 12,
    REG_RAX___1 = 13,
    REG_RCX___1 = 14,
    REG_RSP___1 = 15,
    REG_RIP___1 = 16,
    REG_EFL___1 = 17,
    REG_CSGSFS___1 = 18,
    REG_ERR___1 = 19,
    REG_TRAPNO___1 = 20,
    REG_OLDMASK___1 = 21,
    REG_CR2___1 = 22
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__1170 {
    _PC_LINK_MAX___5 = 0,
    _PC_MAX_CANON___5 = 1,
    _PC_MAX_INPUT___5 = 2,
    _PC_NAME_MAX___5 = 3,
    _PC_PATH_MAX___5 = 4,
    _PC_PIPE_BUF___5 = 5,
    _PC_CHOWN_RESTRICTED___5 = 6,
    _PC_NO_TRUNC___5 = 7,
    _PC_VDISABLE___5 = 8,
    _PC_SYNC_IO___5 = 9,
    _PC_ASYNC_IO___5 = 10,
    _PC_PRIO_IO___5 = 11,
    _PC_SOCK_MAXBUF___5 = 12,
    _PC_FILESIZEBITS___5 = 13,
    _PC_REC_INCR_XFER_SIZE___5 = 14,
    _PC_REC_MAX_XFER_SIZE___5 = 15,
    _PC_REC_MIN_XFER_SIZE___5 = 16,
    _PC_REC_XFER_ALIGN___5 = 17,
    _PC_ALLOC_SIZE_MIN___5 = 18,
    _PC_SYMLINK_MAX___5 = 19,
    _PC_2_SYMLINKS___5 = 20
} ;
#line 71
enum __anonenum__1171 {
    _SC_ARG_MAX___5 = 0,
    _SC_CHILD_MAX___5 = 1,
    _SC_CLK_TCK___5 = 2,
    _SC_NGROUPS_MAX___5 = 3,
    _SC_OPEN_MAX___5 = 4,
    _SC_STREAM_MAX___5 = 5,
    _SC_TZNAME_MAX___5 = 6,
    _SC_JOB_CONTROL___5 = 7,
    _SC_SAVED_IDS___5 = 8,
    _SC_REALTIME_SIGNALS___5 = 9,
    _SC_PRIORITY_SCHEDULING___5 = 10,
    _SC_TIMERS___5 = 11,
    _SC_ASYNCHRONOUS_IO___5 = 12,
    _SC_PRIORITIZED_IO___5 = 13,
    _SC_SYNCHRONIZED_IO___5 = 14,
    _SC_FSYNC___5 = 15,
    _SC_MAPPED_FILES___5 = 16,
    _SC_MEMLOCK___5 = 17,
    _SC_MEMLOCK_RANGE___5 = 18,
    _SC_MEMORY_PROTECTION___5 = 19,
    _SC_MESSAGE_PASSING___5 = 20,
    _SC_SEMAPHORES___5 = 21,
    _SC_SHARED_MEMORY_OBJECTS___5 = 22,
    _SC_AIO_LISTIO_MAX___5 = 23,
    _SC_AIO_MAX___5 = 24,
    _SC_AIO_PRIO_DELTA_MAX___5 = 25,
    _SC_DELAYTIMER_MAX___5 = 26,
    _SC_MQ_OPEN_MAX___5 = 27,
    _SC_MQ_PRIO_MAX___5 = 28,
    _SC_VERSION___5 = 29,
    _SC_PAGESIZE___5 = 30,
    _SC_RTSIG_MAX___5 = 31,
    _SC_SEM_NSEMS_MAX___5 = 32,
    _SC_SEM_VALUE_MAX___5 = 33,
    _SC_SIGQUEUE_MAX___5 = 34,
    _SC_TIMER_MAX___5 = 35,
    _SC_BC_BASE_MAX___5 = 36,
    _SC_BC_DIM_MAX___5 = 37,
    _SC_BC_SCALE_MAX___5 = 38,
    _SC_BC_STRING_MAX___5 = 39,
    _SC_COLL_WEIGHTS_MAX___5 = 40,
    _SC_EQUIV_CLASS_MAX___5 = 41,
    _SC_EXPR_NEST_MAX___5 = 42,
    _SC_LINE_MAX___5 = 43,
    _SC_RE_DUP_MAX___5 = 44,
    _SC_CHARCLASS_NAME_MAX___5 = 45,
    _SC_2_VERSION___5 = 46,
    _SC_2_C_BIND___5 = 47,
    _SC_2_C_DEV___5 = 48,
    _SC_2_FORT_DEV___5 = 49,
    _SC_2_FORT_RUN___5 = 50,
    _SC_2_SW_DEV___5 = 51,
    _SC_2_LOCALEDEF___5 = 52,
    _SC_PII___5 = 53,
    _SC_PII_XTI___5 = 54,
    _SC_PII_SOCKET___5 = 55,
    _SC_PII_INTERNET___5 = 56,
    _SC_PII_OSI___5 = 57,
    _SC_POLL___5 = 58,
    _SC_SELECT___5 = 59,
    _SC_UIO_MAXIOV___5 = 60,
    _SC_IOV_MAX___5 = 60,
    _SC_PII_INTERNET_STREAM___5 = 61,
    _SC_PII_INTERNET_DGRAM___5 = 62,
    _SC_PII_OSI_COTS___5 = 63,
    _SC_PII_OSI_CLTS___5 = 64,
    _SC_PII_OSI_M___5 = 65,
    _SC_T_IOV_MAX___5 = 66,
    _SC_THREADS___5 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___5 = 68,
    _SC_GETGR_R_SIZE_MAX___5 = 69,
    _SC_GETPW_R_SIZE_MAX___5 = 70,
    _SC_LOGIN_NAME_MAX___5 = 71,
    _SC_TTY_NAME_MAX___5 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___5 = 73,
    _SC_THREAD_KEYS_MAX___5 = 74,
    _SC_THREAD_STACK_MIN___5 = 75,
    _SC_THREAD_THREADS_MAX___5 = 76,
    _SC_THREAD_ATTR_STACKADDR___5 = 77,
    _SC_THREAD_ATTR_STACKSIZE___5 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___5 = 79,
    _SC_THREAD_PRIO_INHERIT___5 = 80,
    _SC_THREAD_PRIO_PROTECT___5 = 81,
    _SC_THREAD_PROCESS_SHARED___5 = 82,
    _SC_NPROCESSORS_CONF___5 = 83,
    _SC_NPROCESSORS_ONLN___5 = 84,
    _SC_PHYS_PAGES___5 = 85,
    _SC_AVPHYS_PAGES___5 = 86,
    _SC_ATEXIT_MAX___5 = 87,
    _SC_PASS_MAX___5 = 88,
    _SC_XOPEN_VERSION___5 = 89,
    _SC_XOPEN_XCU_VERSION___5 = 90,
    _SC_XOPEN_UNIX___5 = 91,
    _SC_XOPEN_CRYPT___5 = 92,
    _SC_XOPEN_ENH_I18N___5 = 93,
    _SC_XOPEN_SHM___5 = 94,
    _SC_2_CHAR_TERM___5 = 95,
    _SC_2_C_VERSION___5 = 96,
    _SC_2_UPE___5 = 97,
    _SC_XOPEN_XPG2___5 = 98,
    _SC_XOPEN_XPG3___5 = 99,
    _SC_XOPEN_XPG4___5 = 100,
    _SC_CHAR_BIT___5 = 101,
    _SC_CHAR_MAX___5 = 102,
    _SC_CHAR_MIN___5 = 103,
    _SC_INT_MAX___5 = 104,
    _SC_INT_MIN___5 = 105,
    _SC_LONG_BIT___5 = 106,
    _SC_WORD_BIT___5 = 107,
    _SC_MB_LEN_MAX___5 = 108,
    _SC_NZERO___5 = 109,
    _SC_SSIZE_MAX___5 = 110,
    _SC_SCHAR_MAX___5 = 111,
    _SC_SCHAR_MIN___5 = 112,
    _SC_SHRT_MAX___5 = 113,
    _SC_SHRT_MIN___5 = 114,
    _SC_UCHAR_MAX___5 = 115,
    _SC_UINT_MAX___5 = 116,
    _SC_ULONG_MAX___5 = 117,
    _SC_USHRT_MAX___5 = 118,
    _SC_NL_ARGMAX___5 = 119,
    _SC_NL_LANGMAX___5 = 120,
    _SC_NL_MSGMAX___5 = 121,
    _SC_NL_NMAX___5 = 122,
    _SC_NL_SETMAX___5 = 123,
    _SC_NL_TEXTMAX___5 = 124,
    _SC_XBS5_ILP32_OFF32___5 = 125,
    _SC_XBS5_ILP32_OFFBIG___5 = 126,
    _SC_XBS5_LP64_OFF64___5 = 127,
    _SC_XBS5_LPBIG_OFFBIG___5 = 128,
    _SC_XOPEN_LEGACY___5 = 129,
    _SC_XOPEN_REALTIME___5 = 130,
    _SC_XOPEN_REALTIME_THREADS___5 = 131,
    _SC_ADVISORY_INFO___5 = 132,
    _SC_BARRIERS___5 = 133,
    _SC_BASE___5 = 134,
    _SC_C_LANG_SUPPORT___5 = 135,
    _SC_C_LANG_SUPPORT_R___5 = 136,
    _SC_CLOCK_SELECTION___5 = 137,
    _SC_CPUTIME___5 = 138,
    _SC_THREAD_CPUTIME___5 = 139,
    _SC_DEVICE_IO___5 = 140,
    _SC_DEVICE_SPECIFIC___5 = 141,
    _SC_DEVICE_SPECIFIC_R___5 = 142,
    _SC_FD_MGMT___5 = 143,
    _SC_FIFO___5 = 144,
    _SC_PIPE___5 = 145,
    _SC_FILE_ATTRIBUTES___5 = 146,
    _SC_FILE_LOCKING___5 = 147,
    _SC_FILE_SYSTEM___5 = 148,
    _SC_MONOTONIC_CLOCK___5 = 149,
    _SC_MULTI_PROCESS___5 = 150,
    _SC_SINGLE_PROCESS___5 = 151,
    _SC_NETWORKING___5 = 152,
    _SC_READER_WRITER_LOCKS___5 = 153,
    _SC_SPIN_LOCKS___5 = 154,
    _SC_REGEXP___5 = 155,
    _SC_REGEX_VERSION___5 = 156,
    _SC_SHELL___5 = 157,
    _SC_SIGNALS___5 = 158,
    _SC_SPAWN___5 = 159,
    _SC_SPORADIC_SERVER___5 = 160,
    _SC_THREAD_SPORADIC_SERVER___5 = 161,
    _SC_SYSTEM_DATABASE___5 = 162,
    _SC_SYSTEM_DATABASE_R___5 = 163,
    _SC_TIMEOUTS___5 = 164,
    _SC_TYPED_MEMORY_OBJECTS___5 = 165,
    _SC_USER_GROUPS___5 = 166,
    _SC_USER_GROUPS_R___5 = 167,
    _SC_2_PBS___5 = 168,
    _SC_2_PBS_ACCOUNTING___5 = 169,
    _SC_2_PBS_LOCATE___5 = 170,
    _SC_2_PBS_MESSAGE___5 = 171,
    _SC_2_PBS_TRACK___5 = 172,
    _SC_SYMLOOP_MAX___5 = 173,
    _SC_STREAMS___5 = 174,
    _SC_2_PBS_CHECKPOINT___5 = 175,
    _SC_V6_ILP32_OFF32___5 = 176,
    _SC_V6_ILP32_OFFBIG___5 = 177,
    _SC_V6_LP64_OFF64___5 = 178,
    _SC_V6_LPBIG_OFFBIG___5 = 179,
    _SC_HOST_NAME_MAX___5 = 180,
    _SC_TRACE___5 = 181,
    _SC_TRACE_EVENT_FILTER___5 = 182,
    _SC_TRACE_INHERIT___5 = 183,
    _SC_TRACE_LOG___5 = 184,
    _SC_LEVEL1_ICACHE_SIZE___5 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___5 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___5 = 187,
    _SC_LEVEL1_DCACHE_SIZE___5 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___5 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___5 = 190,
    _SC_LEVEL2_CACHE_SIZE___5 = 191,
    _SC_LEVEL2_CACHE_ASSOC___5 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___5 = 193,
    _SC_LEVEL3_CACHE_SIZE___5 = 194,
    _SC_LEVEL3_CACHE_ASSOC___5 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___5 = 196,
    _SC_LEVEL4_CACHE_SIZE___5 = 197,
    _SC_LEVEL4_CACHE_ASSOC___5 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___5 = 199,
    _SC_IPV6___5 = 235,
    _SC_RAW_SOCKETS___5 = 236,
    _SC_V7_ILP32_OFF32___5 = 237,
    _SC_V7_ILP32_OFFBIG___5 = 238,
    _SC_V7_LP64_OFF64___5 = 239,
    _SC_V7_LPBIG_OFFBIG___5 = 240,
    _SC_SS_REPL_MAX___5 = 241,
    _SC_TRACE_EVENT_NAME_MAX___5 = 242,
    _SC_TRACE_NAME_MAX___5 = 243,
    _SC_TRACE_SYS_MAX___5 = 244,
    _SC_TRACE_USER_EVENT_MAX___5 = 245,
    _SC_XOPEN_STREAMS___5 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___5 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___5 = 248,
    _SC_MINSIGSTKSZ___5 = 249,
    _SC_SIGSTKSZ___5 = 250
} ;
#line 539
enum __anonenum__1172 {
    _CS_PATH___5 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___5 = 1,
    _CS_GNU_LIBC_VERSION___5 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___5 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___5 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___5 = 5,
    _CS_LFS_CFLAGS___5 = 1000,
    _CS_LFS_LDFLAGS___5 = 1001,
    _CS_LFS_LIBS___5 = 1002,
    _CS_LFS_LINTFLAGS___5 = 1003,
    _CS_LFS64_CFLAGS___5 = 1004,
    _CS_LFS64_LDFLAGS___5 = 1005,
    _CS_LFS64_LIBS___5 = 1006,
    _CS_LFS64_LINTFLAGS___5 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___5 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___5 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___5 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___5 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___5 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___5 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___5 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___5 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___5 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___5 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___5 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___5 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___5 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___5 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___5 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___5 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___5 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___5 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___5 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___5 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___5 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___5 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___5 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___5 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___5 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___5 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___5 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___5 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___5 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___5 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___5 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___5 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___5 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___5 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___5 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___5 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___5 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___5 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___5 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___5 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___5 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___5 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___5 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___5 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___5 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___5 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___5 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___5 = 1147,
    _CS_V6_ENV___5 = 1148,
    _CS_V7_ENV___5 = 1149
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__1173 {
    SS_ONSTACK___1 = 1,
    SS_DISABLE___1 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__1181 {
    DT_UNKNOWN___1 = 0,
    DT_FIFO___1 = 1,
    DT_CHR___1 = 2,
    DT_DIR___1 = 4,
    DT_BLK___1 = 6,
    DT_REG___1 = 8,
    DT_LNK___1 = 10,
    DT_SOCK___1 = 12,
    DT_WHT___1 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__1240 {
    PTHREAD_CREATE_JOINABLE___1 = 0,
    PTHREAD_CREATE_DETACHED___1 = 1
} ;
#line 47
enum __anonenum__1241 {
    PTHREAD_MUTEX_TIMED_NP___1 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___1 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___1 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___1 = 3,
    PTHREAD_MUTEX_NORMAL___1 = 0,
    PTHREAD_MUTEX_RECURSIVE___1 = 1,
    PTHREAD_MUTEX_ERRORCHECK___1 = 2,
    PTHREAD_MUTEX_DEFAULT___1 = 0,
    PTHREAD_MUTEX_FAST_NP___1 = 0
} ;
#line 69
enum __anonenum__1242 {
    PTHREAD_MUTEX_STALLED___1 = 0,
    PTHREAD_MUTEX_STALLED_NP___1 = 0,
    PTHREAD_MUTEX_ROBUST___1 = 1,
    PTHREAD_MUTEX_ROBUST_NP___1 = 1
} ;
#line 81
enum __anonenum__1243 {
    PTHREAD_PRIO_NONE___1 = 0,
    PTHREAD_PRIO_INHERIT___1 = 1,
    PTHREAD_PRIO_PROTECT___1 = 2
} ;
#line 104
enum __anonenum__1244 {
    PTHREAD_RWLOCK_PREFER_READER_NP___1 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___1 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___1 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___1 = 0
} ;
#line 124
enum __anonenum__1245 {
    PTHREAD_INHERIT_SCHED___1 = 0,
    PTHREAD_EXPLICIT_SCHED___1 = 1
} ;
#line 134
enum __anonenum__1246 {
    PTHREAD_SCOPE_SYSTEM___1 = 0,
    PTHREAD_SCOPE_PROCESS___1 = 1
} ;
#line 144
enum __anonenum__1247 {
    PTHREAD_PROCESS_PRIVATE___1 = 0,
    PTHREAD_PROCESS_SHARED___1 = 1
} ;
#line 168
enum __anonenum__1248 {
    PTHREAD_CANCEL_ENABLE___1 = 0,
    PTHREAD_CANCEL_DISABLE___1 = 1
} ;
#line 175
enum __anonenum__1249 {
    PTHREAD_CANCEL_DEFERRED___1 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___1 = 1
} ;
#line 40 "/usr/include/gtk-2.0/gtk/gtktreesortable.h"
enum __anonenum__1539 {
    GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID___1 = -1,
    GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID___1 = -2
} ;
#line 46 "/usr/include/gtk-2.0/gtk/gtkclist.h"
enum __anonenum__1575 {
    GTK_CLIST_IN_DRAG___1 = 1,
    GTK_CLIST_ROW_HEIGHT_SET___1 = 2,
    GTK_CLIST_SHOW_TITLES___1 = 4,
    GTK_CLIST_ADD_MODE___1 = 16,
    GTK_CLIST_AUTO_SORT___1 = 32,
    GTK_CLIST_AUTO_RESIZE_BLOCKED___1 = 64,
    GTK_CLIST_REORDERABLE___1 = 128,
    GTK_CLIST_USE_DRAG_ICONS___1 = 256,
    GTK_CLIST_DRAW_DRAG_LINE___1 = 512,
    GTK_CLIST_DRAW_DRAG_RECT___1 = 1024
} ;
#line 21 "/root/oss-experiment/data/sane-frontends-1.0.14/src/progress.h"
struct Progress_t {
   GtkSignalFunc callback ;
   gpointer callback_data ;
   GtkWidget *shell ;
   GtkWidget *pbar ;
};
#line 28 "/root/oss-experiment/data/sane-frontends-1.0.14/src/progress.h"
typedef struct Progress_t Progress_t;
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 50 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock64 {
   short l_type ;
   short l_whence ;
   __off64_t l_start ;
   __off64_t l_len ;
   __pid_t l_pid ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 265 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h"
enum __pid_type {
    F_OWNER_TID = 0,
    F_OWNER_PID = 1,
    F_OWNER_PGRP = 2,
    F_OWNER_GID = 2
} ;
#line 274 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h"
struct f_owner_ex {
   enum __pid_type type ;
   __pid_t pid ;
};
#line 358 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h"
struct file_handle {
   unsigned int handle_bytes ;
   int handle_type ;
   unsigned char f_handle[0] ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__1622 {
    SI_ASYNCNL___2 = -60,
    SI_DETHREAD___2 = -7,
    SI_TKILL___2 = -6,
    SI_SIGIO___2 = -5,
    SI_ASYNCIO___2 = -4,
    SI_MESGQ___2 = -3,
    SI_TIMER___2 = -2,
    SI_QUEUE___2 = -1,
    SI_USER___2 = 0,
    SI_KERNEL___2 = 128
} ;
#line 71
enum __anonenum__1623 {
    ILL_ILLOPC___2 = 1,
    ILL_ILLOPN___2 = 2,
    ILL_ILLADR___2 = 3,
    ILL_ILLTRP___2 = 4,
    ILL_PRVOPC___2 = 5,
    ILL_PRVREG___2 = 6,
    ILL_COPROC___2 = 7,
    ILL_BADSTK___2 = 8,
    ILL_BADIADDR___2 = 9
} ;
#line 94
enum __anonenum__1624 {
    FPE_INTDIV___2 = 1,
    FPE_INTOVF___2 = 2,
    FPE_FLTDIV___2 = 3,
    FPE_FLTOVF___2 = 4,
    FPE_FLTUND___2 = 5,
    FPE_FLTRES___2 = 6,
    FPE_FLTINV___2 = 7,
    FPE_FLTSUB___2 = 8,
    FPE_FLTUNK___2 = 14,
    FPE_CONDTRAP___2 = 15
} ;
#line 119
enum __anonenum__1625 {
    SEGV_MAPERR___2 = 1,
    SEGV_ACCERR___2 = 2,
    SEGV_BNDERR___2 = 3,
    SEGV_PKUERR___2 = 4,
    SEGV_ACCADI___2 = 5,
    SEGV_ADIDERR___2 = 6,
    SEGV_ADIPERR___2 = 7,
    SEGV_MTEAERR___2 = 8,
    SEGV_MTESERR___2 = 9
} ;
#line 142
enum __anonenum__1626 {
    BUS_ADRALN___2 = 1,
    BUS_ADRERR___2 = 2,
    BUS_OBJERR___2 = 3,
    BUS_MCEERR_AR___2 = 4,
    BUS_MCEERR_AO___2 = 5
} ;
#line 159
enum __anonenum__1627 {
    TRAP_BRKPT___2 = 1,
    TRAP_TRACE___2 = 2,
    TRAP_BRANCH___2 = 3,
    TRAP_HWBKPT___2 = 4,
    TRAP_UNK___2 = 5
} ;
#line 176
enum __anonenum__1628 {
    CLD_EXITED___2 = 1,
    CLD_KILLED___2 = 2,
    CLD_DUMPED___2 = 3,
    CLD_TRAPPED___2 = 4,
    CLD_STOPPED___2 = 5,
    CLD_CONTINUED___2 = 6
} ;
#line 193
enum __anonenum__1629 {
    POLL_IN___2 = 1,
    POLL_OUT___2 = 2,
    POLL_MSG___2 = 3,
    POLL_ERR___2 = 4,
    POLL_PRI___2 = 5,
    POLL_HUP___2 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__1632 {
    SIGEV_SIGNAL___2 = 0,
    SIGEV_NONE___2 = 1,
    SIGEV_THREAD___2 = 2,
    SIGEV_THREAD_ID___2 = 4
} ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
enum __anonenum__1636 {
    REG_R8___2 = 0,
    REG_R9___2 = 1,
    REG_R10___2 = 2,
    REG_R11___2 = 3,
    REG_R12___2 = 4,
    REG_R13___2 = 5,
    REG_R14___2 = 6,
    REG_R15___2 = 7,
    REG_RDI___2 = 8,
    REG_RSI___2 = 9,
    REG_RBP___2 = 10,
    REG_RBX___2 = 11,
    REG_RDX___2 = 12,
    REG_RAX___2 = 13,
    REG_RCX___2 = 14,
    REG_RSP___2 = 15,
    REG_RIP___2 = 16,
    REG_EFL___2 = 17,
    REG_CSGSFS___2 = 18,
    REG_ERR___2 = 19,
    REG_TRAPNO___2 = 20,
    REG_OLDMASK___2 = 21,
    REG_CR2___2 = 22
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__1638 {
    _PC_LINK_MAX___6 = 0,
    _PC_MAX_CANON___6 = 1,
    _PC_MAX_INPUT___6 = 2,
    _PC_NAME_MAX___6 = 3,
    _PC_PATH_MAX___6 = 4,
    _PC_PIPE_BUF___6 = 5,
    _PC_CHOWN_RESTRICTED___6 = 6,
    _PC_NO_TRUNC___6 = 7,
    _PC_VDISABLE___6 = 8,
    _PC_SYNC_IO___6 = 9,
    _PC_ASYNC_IO___6 = 10,
    _PC_PRIO_IO___6 = 11,
    _PC_SOCK_MAXBUF___6 = 12,
    _PC_FILESIZEBITS___6 = 13,
    _PC_REC_INCR_XFER_SIZE___6 = 14,
    _PC_REC_MAX_XFER_SIZE___6 = 15,
    _PC_REC_MIN_XFER_SIZE___6 = 16,
    _PC_REC_XFER_ALIGN___6 = 17,
    _PC_ALLOC_SIZE_MIN___6 = 18,
    _PC_SYMLINK_MAX___6 = 19,
    _PC_2_SYMLINKS___6 = 20
} ;
#line 71
enum __anonenum__1639 {
    _SC_ARG_MAX___6 = 0,
    _SC_CHILD_MAX___6 = 1,
    _SC_CLK_TCK___6 = 2,
    _SC_NGROUPS_MAX___6 = 3,
    _SC_OPEN_MAX___6 = 4,
    _SC_STREAM_MAX___6 = 5,
    _SC_TZNAME_MAX___6 = 6,
    _SC_JOB_CONTROL___6 = 7,
    _SC_SAVED_IDS___6 = 8,
    _SC_REALTIME_SIGNALS___6 = 9,
    _SC_PRIORITY_SCHEDULING___6 = 10,
    _SC_TIMERS___6 = 11,
    _SC_ASYNCHRONOUS_IO___6 = 12,
    _SC_PRIORITIZED_IO___6 = 13,
    _SC_SYNCHRONIZED_IO___6 = 14,
    _SC_FSYNC___6 = 15,
    _SC_MAPPED_FILES___6 = 16,
    _SC_MEMLOCK___6 = 17,
    _SC_MEMLOCK_RANGE___6 = 18,
    _SC_MEMORY_PROTECTION___6 = 19,
    _SC_MESSAGE_PASSING___6 = 20,
    _SC_SEMAPHORES___6 = 21,
    _SC_SHARED_MEMORY_OBJECTS___6 = 22,
    _SC_AIO_LISTIO_MAX___6 = 23,
    _SC_AIO_MAX___6 = 24,
    _SC_AIO_PRIO_DELTA_MAX___6 = 25,
    _SC_DELAYTIMER_MAX___6 = 26,
    _SC_MQ_OPEN_MAX___6 = 27,
    _SC_MQ_PRIO_MAX___6 = 28,
    _SC_VERSION___6 = 29,
    _SC_PAGESIZE___6 = 30,
    _SC_RTSIG_MAX___6 = 31,
    _SC_SEM_NSEMS_MAX___6 = 32,
    _SC_SEM_VALUE_MAX___6 = 33,
    _SC_SIGQUEUE_MAX___6 = 34,
    _SC_TIMER_MAX___6 = 35,
    _SC_BC_BASE_MAX___6 = 36,
    _SC_BC_DIM_MAX___6 = 37,
    _SC_BC_SCALE_MAX___6 = 38,
    _SC_BC_STRING_MAX___6 = 39,
    _SC_COLL_WEIGHTS_MAX___6 = 40,
    _SC_EQUIV_CLASS_MAX___6 = 41,
    _SC_EXPR_NEST_MAX___6 = 42,
    _SC_LINE_MAX___6 = 43,
    _SC_RE_DUP_MAX___6 = 44,
    _SC_CHARCLASS_NAME_MAX___6 = 45,
    _SC_2_VERSION___6 = 46,
    _SC_2_C_BIND___6 = 47,
    _SC_2_C_DEV___6 = 48,
    _SC_2_FORT_DEV___6 = 49,
    _SC_2_FORT_RUN___6 = 50,
    _SC_2_SW_DEV___6 = 51,
    _SC_2_LOCALEDEF___6 = 52,
    _SC_PII___6 = 53,
    _SC_PII_XTI___6 = 54,
    _SC_PII_SOCKET___6 = 55,
    _SC_PII_INTERNET___6 = 56,
    _SC_PII_OSI___6 = 57,
    _SC_POLL___6 = 58,
    _SC_SELECT___6 = 59,
    _SC_UIO_MAXIOV___6 = 60,
    _SC_IOV_MAX___6 = 60,
    _SC_PII_INTERNET_STREAM___6 = 61,
    _SC_PII_INTERNET_DGRAM___6 = 62,
    _SC_PII_OSI_COTS___6 = 63,
    _SC_PII_OSI_CLTS___6 = 64,
    _SC_PII_OSI_M___6 = 65,
    _SC_T_IOV_MAX___6 = 66,
    _SC_THREADS___6 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___6 = 68,
    _SC_GETGR_R_SIZE_MAX___6 = 69,
    _SC_GETPW_R_SIZE_MAX___6 = 70,
    _SC_LOGIN_NAME_MAX___6 = 71,
    _SC_TTY_NAME_MAX___6 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___6 = 73,
    _SC_THREAD_KEYS_MAX___6 = 74,
    _SC_THREAD_STACK_MIN___6 = 75,
    _SC_THREAD_THREADS_MAX___6 = 76,
    _SC_THREAD_ATTR_STACKADDR___6 = 77,
    _SC_THREAD_ATTR_STACKSIZE___6 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___6 = 79,
    _SC_THREAD_PRIO_INHERIT___6 = 80,
    _SC_THREAD_PRIO_PROTECT___6 = 81,
    _SC_THREAD_PROCESS_SHARED___6 = 82,
    _SC_NPROCESSORS_CONF___6 = 83,
    _SC_NPROCESSORS_ONLN___6 = 84,
    _SC_PHYS_PAGES___6 = 85,
    _SC_AVPHYS_PAGES___6 = 86,
    _SC_ATEXIT_MAX___6 = 87,
    _SC_PASS_MAX___6 = 88,
    _SC_XOPEN_VERSION___6 = 89,
    _SC_XOPEN_XCU_VERSION___6 = 90,
    _SC_XOPEN_UNIX___6 = 91,
    _SC_XOPEN_CRYPT___6 = 92,
    _SC_XOPEN_ENH_I18N___6 = 93,
    _SC_XOPEN_SHM___6 = 94,
    _SC_2_CHAR_TERM___6 = 95,
    _SC_2_C_VERSION___6 = 96,
    _SC_2_UPE___6 = 97,
    _SC_XOPEN_XPG2___6 = 98,
    _SC_XOPEN_XPG3___6 = 99,
    _SC_XOPEN_XPG4___6 = 100,
    _SC_CHAR_BIT___6 = 101,
    _SC_CHAR_MAX___6 = 102,
    _SC_CHAR_MIN___6 = 103,
    _SC_INT_MAX___6 = 104,
    _SC_INT_MIN___6 = 105,
    _SC_LONG_BIT___6 = 106,
    _SC_WORD_BIT___6 = 107,
    _SC_MB_LEN_MAX___6 = 108,
    _SC_NZERO___6 = 109,
    _SC_SSIZE_MAX___6 = 110,
    _SC_SCHAR_MAX___6 = 111,
    _SC_SCHAR_MIN___6 = 112,
    _SC_SHRT_MAX___6 = 113,
    _SC_SHRT_MIN___6 = 114,
    _SC_UCHAR_MAX___6 = 115,
    _SC_UINT_MAX___6 = 116,
    _SC_ULONG_MAX___6 = 117,
    _SC_USHRT_MAX___6 = 118,
    _SC_NL_ARGMAX___6 = 119,
    _SC_NL_LANGMAX___6 = 120,
    _SC_NL_MSGMAX___6 = 121,
    _SC_NL_NMAX___6 = 122,
    _SC_NL_SETMAX___6 = 123,
    _SC_NL_TEXTMAX___6 = 124,
    _SC_XBS5_ILP32_OFF32___6 = 125,
    _SC_XBS5_ILP32_OFFBIG___6 = 126,
    _SC_XBS5_LP64_OFF64___6 = 127,
    _SC_XBS5_LPBIG_OFFBIG___6 = 128,
    _SC_XOPEN_LEGACY___6 = 129,
    _SC_XOPEN_REALTIME___6 = 130,
    _SC_XOPEN_REALTIME_THREADS___6 = 131,
    _SC_ADVISORY_INFO___6 = 132,
    _SC_BARRIERS___6 = 133,
    _SC_BASE___6 = 134,
    _SC_C_LANG_SUPPORT___6 = 135,
    _SC_C_LANG_SUPPORT_R___6 = 136,
    _SC_CLOCK_SELECTION___6 = 137,
    _SC_CPUTIME___6 = 138,
    _SC_THREAD_CPUTIME___6 = 139,
    _SC_DEVICE_IO___6 = 140,
    _SC_DEVICE_SPECIFIC___6 = 141,
    _SC_DEVICE_SPECIFIC_R___6 = 142,
    _SC_FD_MGMT___6 = 143,
    _SC_FIFO___6 = 144,
    _SC_PIPE___6 = 145,
    _SC_FILE_ATTRIBUTES___6 = 146,
    _SC_FILE_LOCKING___6 = 147,
    _SC_FILE_SYSTEM___6 = 148,
    _SC_MONOTONIC_CLOCK___6 = 149,
    _SC_MULTI_PROCESS___6 = 150,
    _SC_SINGLE_PROCESS___6 = 151,
    _SC_NETWORKING___6 = 152,
    _SC_READER_WRITER_LOCKS___6 = 153,
    _SC_SPIN_LOCKS___6 = 154,
    _SC_REGEXP___6 = 155,
    _SC_REGEX_VERSION___6 = 156,
    _SC_SHELL___6 = 157,
    _SC_SIGNALS___6 = 158,
    _SC_SPAWN___6 = 159,
    _SC_SPORADIC_SERVER___6 = 160,
    _SC_THREAD_SPORADIC_SERVER___6 = 161,
    _SC_SYSTEM_DATABASE___6 = 162,
    _SC_SYSTEM_DATABASE_R___6 = 163,
    _SC_TIMEOUTS___6 = 164,
    _SC_TYPED_MEMORY_OBJECTS___6 = 165,
    _SC_USER_GROUPS___6 = 166,
    _SC_USER_GROUPS_R___6 = 167,
    _SC_2_PBS___6 = 168,
    _SC_2_PBS_ACCOUNTING___6 = 169,
    _SC_2_PBS_LOCATE___6 = 170,
    _SC_2_PBS_MESSAGE___6 = 171,
    _SC_2_PBS_TRACK___6 = 172,
    _SC_SYMLOOP_MAX___6 = 173,
    _SC_STREAMS___6 = 174,
    _SC_2_PBS_CHECKPOINT___6 = 175,
    _SC_V6_ILP32_OFF32___6 = 176,
    _SC_V6_ILP32_OFFBIG___6 = 177,
    _SC_V6_LP64_OFF64___6 = 178,
    _SC_V6_LPBIG_OFFBIG___6 = 179,
    _SC_HOST_NAME_MAX___6 = 180,
    _SC_TRACE___6 = 181,
    _SC_TRACE_EVENT_FILTER___6 = 182,
    _SC_TRACE_INHERIT___6 = 183,
    _SC_TRACE_LOG___6 = 184,
    _SC_LEVEL1_ICACHE_SIZE___6 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___6 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___6 = 187,
    _SC_LEVEL1_DCACHE_SIZE___6 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___6 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___6 = 190,
    _SC_LEVEL2_CACHE_SIZE___6 = 191,
    _SC_LEVEL2_CACHE_ASSOC___6 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___6 = 193,
    _SC_LEVEL3_CACHE_SIZE___6 = 194,
    _SC_LEVEL3_CACHE_ASSOC___6 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___6 = 196,
    _SC_LEVEL4_CACHE_SIZE___6 = 197,
    _SC_LEVEL4_CACHE_ASSOC___6 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___6 = 199,
    _SC_IPV6___6 = 235,
    _SC_RAW_SOCKETS___6 = 236,
    _SC_V7_ILP32_OFF32___6 = 237,
    _SC_V7_ILP32_OFFBIG___6 = 238,
    _SC_V7_LP64_OFF64___6 = 239,
    _SC_V7_LPBIG_OFFBIG___6 = 240,
    _SC_SS_REPL_MAX___6 = 241,
    _SC_TRACE_EVENT_NAME_MAX___6 = 242,
    _SC_TRACE_NAME_MAX___6 = 243,
    _SC_TRACE_SYS_MAX___6 = 244,
    _SC_TRACE_USER_EVENT_MAX___6 = 245,
    _SC_XOPEN_STREAMS___6 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___6 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___6 = 248,
    _SC_MINSIGSTKSZ___6 = 249,
    _SC_SIGSTKSZ___6 = 250
} ;
#line 539
enum __anonenum__1640 {
    _CS_PATH___6 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___6 = 1,
    _CS_GNU_LIBC_VERSION___6 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___6 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___6 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___6 = 5,
    _CS_LFS_CFLAGS___6 = 1000,
    _CS_LFS_LDFLAGS___6 = 1001,
    _CS_LFS_LIBS___6 = 1002,
    _CS_LFS_LINTFLAGS___6 = 1003,
    _CS_LFS64_CFLAGS___6 = 1004,
    _CS_LFS64_LDFLAGS___6 = 1005,
    _CS_LFS64_LIBS___6 = 1006,
    _CS_LFS64_LINTFLAGS___6 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___6 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___6 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___6 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___6 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___6 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___6 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___6 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___6 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___6 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___6 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___6 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___6 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___6 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___6 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___6 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___6 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___6 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___6 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___6 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___6 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___6 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___6 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___6 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___6 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___6 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___6 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___6 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___6 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___6 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___6 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___6 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___6 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___6 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___6 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___6 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___6 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___6 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___6 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___6 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___6 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___6 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___6 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___6 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___6 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___6 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___6 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___6 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___6 = 1147,
    _CS_V6_ENV___6 = 1148,
    _CS_V7_ENV___6 = 1149
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__1641 {
    SS_ONSTACK___2 = 1,
    SS_DISABLE___2 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__1649 {
    DT_UNKNOWN___2 = 0,
    DT_FIFO___2 = 1,
    DT_CHR___2 = 2,
    DT_DIR___2 = 4,
    DT_BLK___2 = 6,
    DT_REG___2 = 8,
    DT_LNK___2 = 10,
    DT_SOCK___2 = 12,
    DT_WHT___2 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__1707 {
    PTHREAD_CREATE_JOINABLE___2 = 0,
    PTHREAD_CREATE_DETACHED___2 = 1
} ;
#line 47
enum __anonenum__1708 {
    PTHREAD_MUTEX_TIMED_NP___2 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___2 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___2 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___2 = 3,
    PTHREAD_MUTEX_NORMAL___2 = 0,
    PTHREAD_MUTEX_RECURSIVE___2 = 1,
    PTHREAD_MUTEX_ERRORCHECK___2 = 2,
    PTHREAD_MUTEX_DEFAULT___2 = 0,
    PTHREAD_MUTEX_FAST_NP___2 = 0
} ;
#line 69
enum __anonenum__1709 {
    PTHREAD_MUTEX_STALLED___2 = 0,
    PTHREAD_MUTEX_STALLED_NP___2 = 0,
    PTHREAD_MUTEX_ROBUST___2 = 1,
    PTHREAD_MUTEX_ROBUST_NP___2 = 1
} ;
#line 81
enum __anonenum__1710 {
    PTHREAD_PRIO_NONE___2 = 0,
    PTHREAD_PRIO_INHERIT___2 = 1,
    PTHREAD_PRIO_PROTECT___2 = 2
} ;
#line 104
enum __anonenum__1711 {
    PTHREAD_RWLOCK_PREFER_READER_NP___2 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___2 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___2 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___2 = 0
} ;
#line 124
enum __anonenum__1712 {
    PTHREAD_INHERIT_SCHED___2 = 0,
    PTHREAD_EXPLICIT_SCHED___2 = 1
} ;
#line 134
enum __anonenum__1713 {
    PTHREAD_SCOPE_SYSTEM___2 = 0,
    PTHREAD_SCOPE_PROCESS___2 = 1
} ;
#line 144
enum __anonenum__1714 {
    PTHREAD_PROCESS_PRIVATE___2 = 0,
    PTHREAD_PROCESS_SHARED___2 = 1
} ;
#line 168
enum __anonenum__1715 {
    PTHREAD_CANCEL_ENABLE___2 = 0,
    PTHREAD_CANCEL_DISABLE___2 = 1
} ;
#line 175
enum __anonenum__1716 {
    PTHREAD_CANCEL_DEFERRED___2 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___2 = 1
} ;
#line 40 "/usr/include/gtk-2.0/gtk/gtktreesortable.h"
enum __anonenum__2004 {
    GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID___2 = -1,
    GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID___2 = -2
} ;
#line 46 "/usr/include/gtk-2.0/gtk/gtkclist.h"
enum __anonenum__2040 {
    GTK_CLIST_IN_DRAG___2 = 1,
    GTK_CLIST_ROW_HEIGHT_SET___2 = 2,
    GTK_CLIST_SHOW_TITLES___2 = 4,
    GTK_CLIST_ADD_MODE___2 = 16,
    GTK_CLIST_AUTO_SORT___2 = 32,
    GTK_CLIST_AUTO_RESIZE_BLOCKED___2 = 64,
    GTK_CLIST_REORDERABLE___2 = 128,
    GTK_CLIST_USE_DRAG_ICONS___2 = 256,
    GTK_CLIST_DRAW_DRAG_LINE___2 = 512,
    GTK_CLIST_DRAW_DRAG_RECT___2 = 1024
} ;
#line 251 "/usr/include/math.h"
enum __anonenum__2066 {
    FP_INT_UPWARD___0 = 0,
    FP_INT_DOWNWARD___0 = 1,
    FP_INT_TOWARDZERO___0 = 2,
    FP_INT_TONEARESTFROMZERO___0 = 3,
    FP_INT_TONEAREST___0 = 4
} ;
#line 934
enum __anonenum__2067 {
    FP_NAN___0 = 0,
    FP_INFINITE___0 = 1,
    FP_ZERO___0 = 2,
    FP_SUBNORMAL___0 = 3,
    FP_NORMAL___0 = 4
} ;
#line 32 "/usr/include/babl-0.1/babl/babl-types.h"
union _Babl ;
#line 32 "/usr/include/babl-0.1/babl/babl-types.h"
typedef union _Babl Babl;
#line 38 "/usr/include/babl-0.1/babl/babl-types.h"
typedef void (*BablFuncLinear)(Babl * , char const   * , char * , long  , void * );
#line 45 "/usr/include/babl-0.1/babl/babl-types.h"
typedef void (*BablFuncPlanar)(Babl * , int  , char const   *[] , int [] , int  ,
                               char *[] , int [] , long  , void * );
#line 103 "/usr/include/babl-0.1/babl/babl.h"
enum __anonenum__2073 {
    BABL_ICC_INTENT_PERCEPTUAL = 0,
    BABL_ICC_INTENT_RELATIVE_COLORIMETRIC = 1,
    BABL_ICC_INTENT_SATURATION = 2,
    BABL_ICC_INTENT_ABSOLUTE_COLORIMETRIC = 3,
    BABL_ICC_INTENT_PERFORMANCE = 32
} ;
#line 110 "/usr/include/babl-0.1/babl/babl.h"
typedef enum __anonenum__2073 BablIccIntent;
#line 307
enum __anonenum__2074 {
    BABL_MODEL_FLAG_ALPHA = 2,
    BABL_MODEL_FLAG_ASSOCIATED = 4,
    BABL_MODEL_FLAG_INVERTED = 8,
    BABL_MODEL_FLAG_LINEAR = 1024,
    BABL_MODEL_FLAG_NONLINEAR = 2048,
    BABL_MODEL_FLAG_PERCEPTUAL = 4096,
    BABL_MODEL_FLAG_GRAY = 1048576,
    BABL_MODEL_FLAG_RGB = 2097152,
    BABL_MODEL_FLAG_CIE = 8388608,
    BABL_MODEL_FLAG_CMYK = 16777216
} ;
#line 323 "/usr/include/babl-0.1/babl/babl.h"
typedef enum __anonenum__2074 BablModelFlag;
#line 537
enum __anonenum__2075 {
    BABL_SPACE_FLAG_NONE = 0,
    BABL_SPACE_FLAG_EQUALIZE = 1
} ;
#line 540 "/usr/include/babl-0.1/babl/babl.h"
typedef enum __anonenum__2075 BablSpaceFlags;
#line 716 "/usr/include/babl-0.1/babl/babl.h"
typedef void (*BablFishProcess)(Babl * , char const   * , char * , long  , void * );
#line 39 "/usr/include/gegl-0.4/gegl-enums.h"
enum __anonenum__2076 {
    GEGL_DITHER_NONE = 0,
    GEGL_DITHER_FLOYD_STEINBERG = 1,
    GEGL_DITHER_BAYER = 2,
    GEGL_DITHER_RANDOM = 3,
    GEGL_DITHER_RANDOM_COVARIANT = 4,
    GEGL_DITHER_ARITHMETIC_ADD = 5,
    GEGL_DITHER_ARITHMETIC_ADD_COVARIANT = 6,
    GEGL_DITHER_ARITHMETIC_XOR = 7,
    GEGL_DITHER_ARITHMETIC_XOR_COVARIANT = 8,
    GEGL_DITHER_BLUE_NOISE = 9,
    GEGL_DITHER_BLUE_NOISE_COVARIANT = 10
} ;
#line 51 "/usr/include/gegl-0.4/gegl-enums.h"
typedef enum __anonenum__2076 GeglDitherMethod;
#line 57
enum __anonenum__2077 {
    GEGL_DISTANCE_METRIC_EUCLIDEAN = 0,
    GEGL_DISTANCE_METRIC_MANHATTAN = 1,
    GEGL_DISTANCE_METRIC_CHEBYSHEV = 2
} ;
#line 61 "/usr/include/gegl-0.4/gegl-enums.h"
typedef enum __anonenum__2077 GeglDistanceMetric;
#line 68
enum __anonenum__2078 {
    GEGL_ORIENTATION_HORIZONTAL = 0,
    GEGL_ORIENTATION_VERTICAL = 1
} ;
#line 71 "/usr/include/gegl-0.4/gegl-enums.h"
typedef enum __anonenum__2078 GeglOrientation;
#line 78
enum _GeglBablVariant {
    GEGL_BABL_VARIANT_FLOAT = 0,
    GEGL_BABL_VARIANT_LINEAR = 1,
    GEGL_BABL_VARIANT_NONLINEAR = 2,
    GEGL_BABL_VARIANT_PERCEPTUAL = 3,
    GEGL_BABL_VARIANT_LINEAR_PREMULTIPLIED = 4,
    GEGL_BABL_VARIANT_PERCEPTUAL_PREMULTIPLIED = 5,
    GEGL_BABL_VARIANT_LINEAR_PREMULTIPLIED_IF_ALPHA = 6,
    GEGL_BABL_VARIANT_PERCEPTUAL_PREMULTIPLIED_IF_ALPHA = 7,
    GEGL_BABL_VARIANT_ALPHA = 8
} ;
#line 99 "/usr/include/gegl-0.4/gegl-enums.h"
typedef enum _GeglBablVariant GeglBablVariant;
#line 106
enum __anonenum__2079 {
    GEGL_CACHE_POLICY_AUTO = 0,
    GEGL_CACHE_POLICY_NEVER = 1,
    GEGL_CACHE_POLICY_ALWAYS = 2
} ;
#line 110 "/usr/include/gegl-0.4/gegl-enums.h"
typedef enum __anonenum__2079 GeglCachePolicy;
#line 31 "/usr/include/gegl-0.4/gegl-types.h"
enum __anonenum__2080 {
    GEGL_PARAM_PAD_OUTPUT = 256,
    GEGL_PARAM_PAD_INPUT = 512
} ;
#line 35 "/usr/include/gegl-0.4/gegl-types.h"
typedef enum __anonenum__2080 GeglPadType;
#line 37
enum __anonenum__2081 {
    GEGL_BLIT_DEFAULT = 0,
    GEGL_BLIT_CACHE = 1,
    GEGL_BLIT_DIRTY = 2
} ;
#line 42 "/usr/include/gegl-0.4/gegl-types.h"
typedef enum __anonenum__2081 GeglBlitFlags;
#line 44
enum __anonenum__2082 {
    GEGL_SPLIT_STRATEGY_AUTO = 0,
    GEGL_SPLIT_STRATEGY_HORIZONTAL = 1,
    GEGL_SPLIT_STRATEGY_VERTICAL = 2
} ;
#line 49 "/usr/include/gegl-0.4/gegl-types.h"
typedef enum __anonenum__2082 GeglSplitStrategy;
#line 52
struct _GeglConfig ;
#line 52 "/usr/include/gegl-0.4/gegl-types.h"
typedef struct _GeglConfig GeglConfig;
#line 58
struct _GeglStats ;
#line 58 "/usr/include/gegl-0.4/gegl-types.h"
typedef struct _GeglStats GeglStats;
#line 64
struct _GeglCurve ;
#line 64 "/usr/include/gegl-0.4/gegl-types.h"
typedef struct _GeglCurve GeglCurve;
#line 65
struct _GeglPath ;
#line 65 "/usr/include/gegl-0.4/gegl-types.h"
typedef struct _GeglPath GeglPath;
#line 66
struct _GeglColor ;
#line 66 "/usr/include/gegl-0.4/gegl-types.h"
typedef struct _GeglColor GeglColor;
#line 67
struct _GeglAudioFragment ;
#line 67 "/usr/include/gegl-0.4/gegl-types.h"
typedef struct _GeglAudioFragment GeglAudioFragment;
#line 69
struct _GeglOperationContext ;
#line 69 "/usr/include/gegl-0.4/gegl-types.h"
typedef struct _GeglOperationContext GeglOperationContext;
#line 71
struct _GeglOperation ;
#line 71 "/usr/include/gegl-0.4/gegl-types.h"
typedef struct _GeglOperation GeglOperation;
#line 76 "/usr/include/gegl-0.4/gegl-types.h"
typedef GeglOperation *GeglOperation_autoptr;
#line 76 "/usr/include/gegl-0.4/gegl-types.h"
typedef GList *GeglOperation_listautoptr;
#line 76 "/usr/include/gegl-0.4/gegl-types.h"
typedef GSList *GeglOperation_slistautoptr;
#line 76 "/usr/include/gegl-0.4/gegl-types.h"
typedef GQueue *GeglOperation_queueautoptr;
#line 78
struct _GeglNode ;
#line 78 "/usr/include/gegl-0.4/gegl-types.h"
typedef struct _GeglNode GeglNode;
#line 83 "/usr/include/gegl-0.4/gegl-types.h"
typedef GeglNode *GeglNode_autoptr;
#line 83 "/usr/include/gegl-0.4/gegl-types.h"
typedef GList *GeglNode_listautoptr;
#line 83 "/usr/include/gegl-0.4/gegl-types.h"
typedef GSList *GeglNode_slistautoptr;
#line 83 "/usr/include/gegl-0.4/gegl-types.h"
typedef GQueue *GeglNode_queueautoptr;
#line 85
struct _GeglProcessor ;
#line 85 "/usr/include/gegl-0.4/gegl-types.h"
typedef struct _GeglProcessor GeglProcessor;
#line 90 "/usr/include/gegl-0.4/gegl-types.h"
typedef GeglProcessor *GeglProcessor_autoptr;
#line 90 "/usr/include/gegl-0.4/gegl-types.h"
typedef GList *GeglProcessor_listautoptr;
#line 90 "/usr/include/gegl-0.4/gegl-types.h"
typedef GSList *GeglProcessor_slistautoptr;
#line 90 "/usr/include/gegl-0.4/gegl-types.h"
typedef GQueue *GeglProcessor_queueautoptr;
#line 92
struct _GeglRandom ;
#line 92 "/usr/include/gegl-0.4/gegl-types.h"
typedef struct _GeglRandom GeglRandom;
#line 31 "/usr/include/gegl-0.4/gegl-buffer-matrix2.h"
struct __anonstruct_2083 {
   gdouble coeff[2][2] ;
};
#line 33 "/usr/include/gegl-0.4/gegl-buffer-matrix2.h"
typedef struct __anonstruct_2083 GeglBufferMatrix2;
#line 39 "/usr/include/gegl-0.4/gegl-buffer-enums.h"
enum __anonenum__2084 {
    GEGL_ABYSS_NONE = 0,
    GEGL_ABYSS_CLAMP = 1,
    GEGL_ABYSS_LOOP = 2,
    GEGL_ABYSS_BLACK = 3,
    GEGL_ABYSS_WHITE = 4,
    GEGL_BUFFER_FILTER_AUTO = 0,
    GEGL_BUFFER_FILTER_BILINEAR = 16,
    GEGL_BUFFER_FILTER_NEAREST = 32,
    GEGL_BUFFER_FILTER_BOX = 48,
    GEGL_BUFFER_FILTER_ALL = 48
} ;
#line 61 "/usr/include/gegl-0.4/gegl-buffer-enums.h"
typedef enum __anonenum__2084 GeglAbyssPolicy;
#line 68
enum __anonenum__2085 {
    GEGL_ACCESS_READ = 1,
    GEGL_ACCESS_WRITE = 2,
    GEGL_ACCESS_READWRITE = 3
} ;
#line 72 "/usr/include/gegl-0.4/gegl-buffer-enums.h"
typedef enum __anonenum__2085 GeglAccessMode;
#line 78
enum __anonenum__2086 {
    GEGL_SAMPLER_NEAREST = 0,
    GEGL_SAMPLER_LINEAR = 1,
    GEGL_SAMPLER_CUBIC = 2,
    GEGL_SAMPLER_NOHALO = 3,
    GEGL_SAMPLER_LOHALO = 4
} ;
#line 84 "/usr/include/gegl-0.4/gegl-buffer-enums.h"
typedef enum __anonenum__2086 GeglSamplerType;
#line 90
enum __anonenum__2087 {
    GEGL_RECTANGLE_ALIGNMENT_SUBSET = 0,
    GEGL_RECTANGLE_ALIGNMENT_SUPERSET = 1,
    GEGL_RECTANGLE_ALIGNMENT_NEAREST = 2
} ;
#line 94 "/usr/include/gegl-0.4/gegl-buffer-enums.h"
typedef enum __anonenum__2087 GeglRectangleAlignment;
#line 30 "/usr/include/gegl-0.4/gegl-buffer.h"
struct _GeglTileBackend ;
#line 30 "/usr/include/gegl-0.4/gegl-buffer.h"
typedef struct _GeglTileBackend GeglTileBackend;
#line 31
struct _GeglBuffer ;
#line 31 "/usr/include/gegl-0.4/gegl-buffer.h"
typedef struct _GeglBuffer GeglBuffer;
#line 32
struct _GeglSampler ;
#line 32 "/usr/include/gegl-0.4/gegl-buffer.h"
typedef struct _GeglSampler GeglSampler;
#line 34
struct _GeglRectangle ;
#line 34 "/usr/include/gegl-0.4/gegl-buffer.h"
typedef struct _GeglRectangle GeglRectangle;
#line 36 "/usr/include/gegl-0.4/gegl-buffer.h"
struct _GeglRectangle {
   gint x ;
   gint y ;
   gint width ;
   gint height ;
};
#line 503 "/usr/include/gegl-0.4/gegl-buffer.h"
typedef void (*GeglSamplerGetFun)(GeglSampler * , gdouble  , gdouble  , GeglBufferMatrix2 * ,
                                  void * , GeglAbyssPolicy  );
#line 29 "/usr/include/gegl-0.4/gegl-buffer-iterator.h"
struct _GeglBufferIteratorPriv ;
#line 29 "/usr/include/gegl-0.4/gegl-buffer-iterator.h"
typedef struct _GeglBufferIteratorPriv GeglBufferIteratorPriv;
#line 39 "/usr/include/gegl-0.4/gegl-buffer-iterator.h"
struct GeglBufferIteratorItem {
   gpointer data ;
   GeglRectangle roi ;
};
#line 43 "/usr/include/gegl-0.4/gegl-buffer-iterator.h"
typedef struct GeglBufferIteratorItem GeglBufferIteratorItem;
#line 45 "/usr/include/gegl-0.4/gegl-buffer-iterator.h"
struct GeglBufferIterator {
   gint length ;
   GeglBufferIteratorPriv *priv ;
   GeglBufferIteratorItem items[] ;
};
#line 50 "/usr/include/gegl-0.4/gegl-buffer-iterator.h"
typedef struct GeglBufferIterator GeglBufferIterator;
#line 780 "/usr/include/gegl-0.4/gegl-buffer.h"
typedef GeglBuffer *GeglBuffer_autoptr;
#line 780 "/usr/include/gegl-0.4/gegl-buffer.h"
typedef GList *GeglBuffer_listautoptr;
#line 780 "/usr/include/gegl-0.4/gegl-buffer.h"
typedef GSList *GeglBuffer_slistautoptr;
#line 780 "/usr/include/gegl-0.4/gegl-buffer.h"
typedef GQueue *GeglBuffer_queueautoptr;
#line 33 "/usr/include/gegl-0.4/gegl-color.h"
struct _GeglColorClass ;
#line 33 "/usr/include/gegl-0.4/gegl-color.h"
typedef struct _GeglColorClass GeglColorClass;
#line 34
struct _GeglColorPrivate ;
#line 34 "/usr/include/gegl-0.4/gegl-color.h"
typedef struct _GeglColorPrivate GeglColorPrivate;
#line 36 "/usr/include/gegl-0.4/gegl-color.h"
struct _GeglColor {
   GObject parent_instance ;
   GeglColorPrivate *priv ;
};
#line 42 "/usr/include/gegl-0.4/gegl-color.h"
struct _GeglColorClass {
   GObjectClass parent_class ;
};
#line 41 "/usr/include/gegl-0.4/gegl-curve.h"
struct _GeglCurveClass ;
#line 41 "/usr/include/gegl-0.4/gegl-curve.h"
typedef struct _GeglCurveClass GeglCurveClass;
#line 43 "/usr/include/gegl-0.4/gegl-curve.h"
struct _GeglCurve {
   GObject parent_instance ;
};
#line 48 "/usr/include/gegl-0.4/gegl-curve.h"
struct _GeglCurveClass {
   GObjectClass parent_class ;
};
#line 37 "/usr/include/gegl-0.4/gegl-matrix.h"
struct __anonstruct_2088 {
   gdouble coeff[3][3] ;
};
#line 39 "/usr/include/gegl-0.4/gegl-matrix.h"
typedef struct __anonstruct_2088 GeglMatrix3;
#line 43 "/usr/include/gegl-0.4/gegl-path.h"
struct _GeglPathClass ;
#line 43 "/usr/include/gegl-0.4/gegl-path.h"
typedef struct _GeglPathClass GeglPathClass;
#line 45 "/usr/include/gegl-0.4/gegl-path.h"
struct _GeglPath {
   GObject parent_instance ;
};
#line 81 "/usr/include/gegl-0.4/gegl-path.h"
struct GeglPathPoint {
   gfloat x ;
   gfloat y ;
};
#line 85 "/usr/include/gegl-0.4/gegl-path.h"
typedef struct GeglPathPoint GeglPathPoint;
#line 87 "/usr/include/gegl-0.4/gegl-path.h"
struct GeglPathItem {
   gchar type ;
   GeglPathPoint point[4] ;
};
#line 93 "/usr/include/gegl-0.4/gegl-path.h"
typedef struct GeglPathItem GeglPathItem;
#line 283 "/usr/include/gegl-0.4/gegl-path.h"
typedef void (*GeglNodeFunction)(GeglPathItem * , gpointer  );
#line 438 "/usr/include/gegl-0.4/gegl-path.h"
struct GeglPathList {
   struct GeglPathList *next ;
   GeglPathItem d ;
};
#line 442 "/usr/include/gegl-0.4/gegl-path.h"
typedef struct GeglPathList GeglPathList;
#line 468 "/usr/include/gegl-0.4/gegl-path.h"
typedef GeglPathList *(*GeglFlattenerFunc)(GeglPathList * );
#line 25 "/usr/include/gegl-0.4/gegl-utils.h"
enum GeglSerializeFlag {
    GEGL_SERIALIZE_TRIM_DEFAULTS = 1,
    GEGL_SERIALIZE_VERSION = 2,
    GEGL_SERIALIZE_INDENT = 4,
    GEGL_SERIALIZE_BAKE_ANIM = 8
} ;
#line 30 "/usr/include/gegl-0.4/gegl-utils.h"
typedef enum GeglSerializeFlag GeglSerializeFlag;
#line 160 "/usr/include/gegl-0.4/gegl-random.h"
typedef GeglRandom *GeglRandom_autoptr;
#line 160 "/usr/include/gegl-0.4/gegl-random.h"
typedef GList *GeglRandom_listautoptr;
#line 160 "/usr/include/gegl-0.4/gegl-random.h"
typedef GSList *GeglRandom_slistautoptr;
#line 160 "/usr/include/gegl-0.4/gegl-random.h"
typedef GQueue *GeglRandom_queueautoptr;
#line 38 "/usr/include/gegl-0.4/gegl-parallel.h"
typedef void (*GeglParallelDistributeFunc)(gint  , gint  , gpointer  );
#line 54 "/usr/include/gegl-0.4/gegl-parallel.h"
typedef void (*GeglParallelDistributeRangeFunc)(gsize  , gsize  , gpointer  );
#line 69 "/usr/include/gegl-0.4/gegl-parallel.h"
typedef void (*GeglParallelDistributeAreaFunc)(GeglRectangle * , gpointer  );
#line 29 "/usr/include/gimp-2.0/libgimpconfig/gimpconfigtypes.h"
struct _GimpConfig ;
#line 29 "/usr/include/gimp-2.0/libgimpconfig/gimpconfigtypes.h"
typedef struct _GimpConfig GimpConfig;
#line 30
struct _GimpConfigWriter ;
#line 30 "/usr/include/gimp-2.0/libgimpconfig/gimpconfigtypes.h"
typedef struct _GimpConfigWriter GimpConfigWriter;
#line 31 "/usr/include/gimp-2.0/libgimpconfig/gimpconfigtypes.h"
typedef gchar *GimpConfigPath;
#line 33
struct _GimpColorConfig ;
#line 33 "/usr/include/gimp-2.0/libgimpconfig/gimpconfigtypes.h"
typedef struct _GimpColorConfig GimpColorConfig;
#line 38 "/usr/include/gimp-2.0/libgimpconfig/gimpconfigenums.h"
enum __anonenum__2089 {
    GIMP_COLOR_MANAGEMENT_OFF = 0,
    GIMP_COLOR_MANAGEMENT_DISPLAY = 1,
    GIMP_COLOR_MANAGEMENT_SOFTPROOF = 2
} ;
#line 43 "/usr/include/gimp-2.0/libgimpconfig/gimpconfigenums.h"
typedef enum __anonenum__2089 GimpColorManagementMode;
#line 59
enum __anonenum__2090 {
    GIMP_COLOR_RENDERING_INTENT_PERCEPTUAL = 0,
    GIMP_COLOR_RENDERING_INTENT_RELATIVE_COLORIMETRIC = 1,
    GIMP_COLOR_RENDERING_INTENT_SATURATION = 2,
    GIMP_COLOR_RENDERING_INTENT_ABSOLUTE_COLORIMETRIC = 3
} ;
#line 65 "/usr/include/gimp-2.0/libgimpconfig/gimpconfigenums.h"
typedef enum __anonenum__2090 GimpColorRenderingIntent;
#line 32 "/usr/include/gimp-2.0/libgimpcolor/gimpcolortypes.h"
struct _GimpColorManaged ;
#line 32 "/usr/include/gimp-2.0/libgimpcolor/gimpcolortypes.h"
typedef struct _GimpColorManaged GimpColorManaged;
#line 33
struct _GimpColorProfile ;
#line 33 "/usr/include/gimp-2.0/libgimpcolor/gimpcolortypes.h"
typedef struct _GimpColorProfile GimpColorProfile;
#line 34
struct _GimpColorTransform ;
#line 34 "/usr/include/gimp-2.0/libgimpcolor/gimpcolortypes.h"
typedef struct _GimpColorTransform GimpColorTransform;
#line 41
struct _GimpRGB ;
#line 41 "/usr/include/gimp-2.0/libgimpcolor/gimpcolortypes.h"
typedef struct _GimpRGB GimpRGB;
#line 42
struct _GimpHSV ;
#line 42 "/usr/include/gimp-2.0/libgimpcolor/gimpcolortypes.h"
typedef struct _GimpHSV GimpHSV;
#line 43
struct _GimpHSL ;
#line 43 "/usr/include/gimp-2.0/libgimpcolor/gimpcolortypes.h"
typedef struct _GimpHSL GimpHSL;
#line 44
struct _GimpCMYK ;
#line 44 "/usr/include/gimp-2.0/libgimpcolor/gimpcolortypes.h"
typedef struct _GimpCMYK GimpCMYK;
#line 56 "/usr/include/gimp-2.0/libgimpcolor/gimpcolortypes.h"
struct _GimpRGB {
   gdouble r ;
   gdouble g ;
   gdouble b ;
   gdouble a ;
};
#line 71 "/usr/include/gimp-2.0/libgimpcolor/gimpcolortypes.h"
struct _GimpHSV {
   gdouble h ;
   gdouble s ;
   gdouble v ;
   gdouble a ;
};
#line 86 "/usr/include/gimp-2.0/libgimpcolor/gimpcolortypes.h"
struct _GimpHSL {
   gdouble h ;
   gdouble s ;
   gdouble l ;
   gdouble a ;
};
#line 104 "/usr/include/gimp-2.0/libgimpcolor/gimpcolortypes.h"
struct _GimpCMYK {
   gdouble c ;
   gdouble m ;
   gdouble y ;
   gdouble k ;
   gdouble a ;
};
#line 110 "/usr/include/gimp-2.0/libgimpcolor/gimpcolortypes.h"
typedef void (*GimpRenderFunc)(gdouble  , gdouble  , GimpRGB * , gpointer  );
#line 114 "/usr/include/gimp-2.0/libgimpcolor/gimpcolortypes.h"
typedef void (*GimpPutPixelFunc)(gint  , gint  , GimpRGB * , gpointer  );
#line 118 "/usr/include/gimp-2.0/libgimpcolor/gimpcolortypes.h"
typedef void (*GimpProgressFunc)(gint  , gint  , gint  , gpointer  );
#line 30 "/usr/include/gimp-2.0/libgimpmath/gimpmathtypes.h"
struct _GimpMatrix2 ;
#line 30 "/usr/include/gimp-2.0/libgimpmath/gimpmathtypes.h"
typedef struct _GimpMatrix2 GimpMatrix2;
#line 31
struct _GimpMatrix3 ;
#line 31 "/usr/include/gimp-2.0/libgimpmath/gimpmathtypes.h"
typedef struct _GimpMatrix3 GimpMatrix3;
#line 32
struct _GimpMatrix4 ;
#line 32 "/usr/include/gimp-2.0/libgimpmath/gimpmathtypes.h"
typedef struct _GimpMatrix4 GimpMatrix4;
#line 40 "/usr/include/gimp-2.0/libgimpmath/gimpmathtypes.h"
struct _GimpMatrix2 {
   gdouble coeff[2][2] ;
};
#line 51 "/usr/include/gimp-2.0/libgimpmath/gimpmathtypes.h"
struct _GimpMatrix3 {
   gdouble coeff[3][3] ;
};
#line 62 "/usr/include/gimp-2.0/libgimpmath/gimpmathtypes.h"
struct _GimpMatrix4 {
   gdouble coeff[4][4] ;
};
#line 68
struct _GimpVector2 ;
#line 68 "/usr/include/gimp-2.0/libgimpmath/gimpmathtypes.h"
typedef struct _GimpVector2 GimpVector2;
#line 69
struct _GimpVector3 ;
#line 69 "/usr/include/gimp-2.0/libgimpmath/gimpmathtypes.h"
typedef struct _GimpVector3 GimpVector3;
#line 70
struct _GimpVector4 ;
#line 70 "/usr/include/gimp-2.0/libgimpmath/gimpmathtypes.h"
typedef struct _GimpVector4 GimpVector4;
#line 79 "/usr/include/gimp-2.0/libgimpmath/gimpmathtypes.h"
struct _GimpVector2 {
   gdouble x ;
   gdouble y ;
};
#line 92 "/usr/include/gimp-2.0/libgimpmath/gimpmathtypes.h"
struct _GimpVector3 {
   gdouble x ;
   gdouble y ;
   gdouble z ;
};
#line 106 "/usr/include/gimp-2.0/libgimpmath/gimpmathtypes.h"
struct _GimpVector4 {
   gdouble x ;
   gdouble y ;
   gdouble z ;
   gdouble w ;
};
#line 61 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
enum __anonenum__2091 {
    GIMP_ADD_MASK_WHITE = 0,
    GIMP_ADD_MASK_BLACK = 1,
    GIMP_ADD_MASK_ALPHA = 2,
    GIMP_ADD_MASK_ALPHA_TRANSFER = 3,
    GIMP_ADD_MASK_SELECTION = 4,
    GIMP_ADD_MASK_COPY = 5,
    GIMP_ADD_MASK_CHANNEL = 6,
    GIMP_ADD_WHITE_MASK = 0,
    GIMP_ADD_BLACK_MASK = 1,
    GIMP_ADD_ALPHA_MASK = 2,
    GIMP_ADD_ALPHA_TRANSFER_MASK = 3,
    GIMP_ADD_SELECTION_MASK = 4,
    GIMP_ADD_COPY_MASK = 5,
    GIMP_ADD_CHANNEL_MASK = 6
} ;
#line 80 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2091 GimpAddMaskType;
#line 100
enum __anonenum__2092 {
    GIMP_BLEND_FG_BG_RGB = 0,
    GIMP_BLEND_FG_BG_HSV = 1,
    GIMP_BLEND_FG_TRANSPARENT = 2,
    GIMP_BLEND_CUSTOM = 3,
    GIMP_FG_BG_RGB_MODE = 0,
    GIMP_FG_BG_HSV_MODE = 1,
    GIMP_FG_TRANSPARENT_MODE = 2,
    GIMP_CUSTOM_MODE = 3
} ;
#line 113 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2092 GimpBlendMode;
#line 128
enum __anonenum__2093 {
    GIMP_BRUSH_GENERATED_CIRCLE = 0,
    GIMP_BRUSH_GENERATED_SQUARE = 1,
    GIMP_BRUSH_GENERATED_DIAMOND = 2
} ;
#line 133 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2093 GimpBrushGeneratedShape;
#line 151
enum __anonenum__2094 {
    GIMP_BUCKET_FILL_FG = 0,
    GIMP_BUCKET_FILL_BG = 1,
    GIMP_BUCKET_FILL_PATTERN = 2,
    GIMP_FG_BUCKET_FILL = 0,
    GIMP_BG_BUCKET_FILL = 1,
    GIMP_PATTERN_BUCKET_FILL = 2
} ;
#line 162 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2094 GimpBucketFillMode;
#line 177
enum __anonenum__2095 {
    GIMP_CAP_BUTT = 0,
    GIMP_CAP_ROUND = 1,
    GIMP_CAP_SQUARE = 2
} ;
#line 182 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2095 GimpCapStyle;
#line 198
enum __anonenum__2096 {
    GIMP_CHANNEL_OP_ADD = 0,
    GIMP_CHANNEL_OP_SUBTRACT = 1,
    GIMP_CHANNEL_OP_REPLACE = 2,
    GIMP_CHANNEL_OP_INTERSECT = 3
} ;
#line 204 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2096 GimpChannelOps;
#line 228
enum __anonenum__2097 {
    GIMP_CHANNEL_RED = 0,
    GIMP_CHANNEL_GREEN = 1,
    GIMP_CHANNEL_BLUE = 2,
    GIMP_CHANNEL_GRAY = 3,
    GIMP_CHANNEL_INDEXED = 4,
    GIMP_CHANNEL_ALPHA = 5,
    GIMP_RED_CHANNEL = 0,
    GIMP_GREEN_CHANNEL = 1,
    GIMP_BLUE_CHANNEL = 2,
    GIMP_GRAY_CHANNEL = 3,
    GIMP_INDEXED_CHANNEL = 4,
    GIMP_ALPHA_CHANNEL = 5
} ;
#line 245 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2097 GimpChannelType;
#line 260
enum __anonenum__2098 {
    GIMP_CHECK_SIZE_SMALL_CHECKS = 0,
    GIMP_CHECK_SIZE_MEDIUM_CHECKS = 1,
    GIMP_CHECK_SIZE_LARGE_CHECKS = 2
} ;
#line 265 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2098 GimpCheckSize;
#line 283
enum __anonenum__2099 {
    GIMP_CHECK_TYPE_LIGHT_CHECKS = 0,
    GIMP_CHECK_TYPE_GRAY_CHECKS = 1,
    GIMP_CHECK_TYPE_DARK_CHECKS = 2,
    GIMP_CHECK_TYPE_WHITE_ONLY = 3,
    GIMP_CHECK_TYPE_GRAY_ONLY = 4,
    GIMP_CHECK_TYPE_BLACK_ONLY = 5
} ;
#line 291 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2099 GimpCheckType;
#line 307
enum __anonenum__2100 {
    GIMP_CLONE_IMAGE = 0,
    GIMP_CLONE_PATTERN = 1,
    GIMP_IMAGE_CLONE = 0,
    GIMP_PATTERN_CLONE = 1
} ;
#line 316 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2100 GimpCloneType;
#line 339
enum __anonenum__2101 {
    GIMP_COLOR_TAG_NONE = 0,
    GIMP_COLOR_TAG_BLUE = 1,
    GIMP_COLOR_TAG_GREEN = 2,
    GIMP_COLOR_TAG_YELLOW = 3,
    GIMP_COLOR_TAG_ORANGE = 4,
    GIMP_COLOR_TAG_BROWN = 5,
    GIMP_COLOR_TAG_RED = 6,
    GIMP_COLOR_TAG_VIOLET = 7,
    GIMP_COLOR_TAG_GRAY = 8
} ;
#line 350 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2101 GimpColorTag;
#line 370
enum __anonenum__2102 {
    GIMP_COMPONENT_TYPE_U8 = 100,
    GIMP_COMPONENT_TYPE_U16 = 200,
    GIMP_COMPONENT_TYPE_U32 = 300,
    GIMP_COMPONENT_TYPE_HALF = 500,
    GIMP_COMPONENT_TYPE_FLOAT = 600,
    GIMP_COMPONENT_TYPE_DOUBLE = 700
} ;
#line 378 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2102 GimpComponentType;
#line 405
enum __anonenum__2103 {
    GIMP_CONVERT_PALETTE_GENERATE = 0,
    GIMP_CONVERT_PALETTE_REUSE = 1,
    GIMP_CONVERT_PALETTE_WEB = 2,
    GIMP_CONVERT_PALETTE_MONO = 3,
    GIMP_CONVERT_PALETTE_CUSTOM = 4,
    GIMP_MAKE_PALETTE = 0,
    GIMP_REUSE_PALETTE = 1,
    GIMP_WEB_PALETTE = 2,
    GIMP_MONO_PALETTE = 3,
    GIMP_CUSTOM_PALETTE = 4
} ;
#line 420 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2103 GimpConvertPaletteType;
#line 436
enum __anonenum__2104 {
    GIMP_CONVOLVE_BLUR = 0,
    GIMP_CONVOLVE_SHARPEN = 1,
    GIMP_BLUR_CONVOLVE = 0,
    GIMP_SHARPEN_CONVOLVE = 1
} ;
#line 445 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2104 GimpConvolveType;
#line 463
enum __anonenum__2105 {
    GIMP_DESATURATE_LIGHTNESS = 0,
    GIMP_DESATURATE_LUMA = 1,
    GIMP_DESATURATE_AVERAGE = 2,
    GIMP_DESATURATE_LUMINANCE = 3,
    GIMP_DESATURATE_VALUE = 4,
    GIMP_DESATURATE_LUMINOSITY = 1
} ;
#line 474 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2105 GimpDesaturateMode;
#line 490
enum __anonenum__2106 {
    GIMP_DODGE_BURN_TYPE_DODGE = 0,
    GIMP_DODGE_BURN_TYPE_BURN = 1,
    GIMP_DODGE = 0,
    GIMP_BURN = 1
} ;
#line 499 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2106 GimpDodgeBurnType;
#line 521
enum __anonenum__2107 {
    GIMP_FILL_FOREGROUND = 0,
    GIMP_FILL_BACKGROUND = 1,
    GIMP_FILL_WHITE = 2,
    GIMP_FILL_TRANSPARENT = 3,
    GIMP_FILL_PATTERN = 4,
    GIMP_FOREGROUND_FILL = 0,
    GIMP_BACKGROUND_FILL = 1,
    GIMP_WHITE_FILL = 2,
    GIMP_TRANSPARENT_FILL = 3,
    GIMP_PATTERN_FILL = 4
} ;
#line 536 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2107 GimpFillType;
#line 550
enum __anonenum__2108 {
    GIMP_FOREGROUND_EXTRACT_SIOX = 0,
    GIMP_FOREGROUND_EXTRACT_MATTING = 1
} ;
#line 554 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2108 GimpForegroundExtractMode;
#line 571
enum __anonenum__2109 {
    GIMP_GRADIENT_BLEND_RGB_PERCEPTUAL = 0,
    GIMP_GRADIENT_BLEND_RGB_LINEAR = 1,
    GIMP_GRADIENT_BLEND_CIE_LAB = 2
} ;
#line 576 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2109 GimpGradientBlendColorSpace;
#line 591
enum __anonenum__2110 {
    GIMP_GRADIENT_SEGMENT_RGB = 0,
    GIMP_GRADIENT_SEGMENT_HSV_CCW = 1,
    GIMP_GRADIENT_SEGMENT_HSV_CW = 2
} ;
#line 596 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2110 GimpGradientSegmentColor;
#line 614
enum __anonenum__2111 {
    GIMP_GRADIENT_SEGMENT_LINEAR = 0,
    GIMP_GRADIENT_SEGMENT_CURVED = 1,
    GIMP_GRADIENT_SEGMENT_SINE = 2,
    GIMP_GRADIENT_SEGMENT_SPHERE_INCREASING = 3,
    GIMP_GRADIENT_SEGMENT_SPHERE_DECREASING = 4,
    GIMP_GRADIENT_SEGMENT_STEP = 5
} ;
#line 622 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2111 GimpGradientSegmentType;
#line 645
enum __anonenum__2112 {
    GIMP_GRADIENT_LINEAR = 0,
    GIMP_GRADIENT_BILINEAR = 1,
    GIMP_GRADIENT_RADIAL = 2,
    GIMP_GRADIENT_SQUARE = 3,
    GIMP_GRADIENT_CONICAL_SYMMETRIC = 4,
    GIMP_GRADIENT_CONICAL_ASYMMETRIC = 5,
    GIMP_GRADIENT_SHAPEBURST_ANGULAR = 6,
    GIMP_GRADIENT_SHAPEBURST_SPHERICAL = 7,
    GIMP_GRADIENT_SHAPEBURST_DIMPLED = 8,
    GIMP_GRADIENT_SPIRAL_CLOCKWISE = 9,
    GIMP_GRADIENT_SPIRAL_ANTICLOCKWISE = 10
} ;
#line 658 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2112 GimpGradientType;
#line 675
enum __anonenum__2113 {
    GIMP_GRID_DOTS = 0,
    GIMP_GRID_INTERSECTIONS = 1,
    GIMP_GRID_ON_OFF_DASH = 2,
    GIMP_GRID_DOUBLE_DASH = 3,
    GIMP_GRID_SOLID = 4
} ;
#line 682 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2113 GimpGridStyle;
#line 708
enum __anonenum__2114 {
    GIMP_HUE_RANGE_ALL = 0,
    GIMP_HUE_RANGE_RED = 1,
    GIMP_HUE_RANGE_YELLOW = 2,
    GIMP_HUE_RANGE_GREEN = 3,
    GIMP_HUE_RANGE_CYAN = 4,
    GIMP_HUE_RANGE_BLUE = 5,
    GIMP_HUE_RANGE_MAGENTA = 6,
    GIMP_ALL_HUES = 0,
    GIMP_RED_HUES = 1,
    GIMP_YELLOW_HUES = 2,
    GIMP_GREEN_HUES = 3,
    GIMP_CYAN_HUES = 4,
    GIMP_BLUE_HUES = 5,
    GIMP_MAGENTA_HUES = 6
} ;
#line 727 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2114 GimpHueRange;
#line 745
enum __anonenum__2115 {
    GIMP_ICON_TYPE_ICON_NAME = 0,
    GIMP_ICON_TYPE_INLINE_PIXBUF = 1,
    GIMP_ICON_TYPE_IMAGE_FILE = 2,
    GIMP_ICON_TYPE_STOCK_ID = 0
} ;
#line 754 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2115 GimpIconType;
#line 769
enum __anonenum__2116 {
    GIMP_RGB = 0,
    GIMP_GRAY = 1,
    GIMP_INDEXED = 2
} ;
#line 774 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2116 GimpImageBaseType;
#line 792
enum __anonenum__2117 {
    GIMP_RGB_IMAGE = 0,
    GIMP_RGBA_IMAGE = 1,
    GIMP_GRAY_IMAGE = 2,
    GIMP_GRAYA_IMAGE = 3,
    GIMP_INDEXED_IMAGE = 4,
    GIMP_INDEXEDA_IMAGE = 5
} ;
#line 800 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2117 GimpImageType;
#line 815
enum __anonenum__2118 {
    GIMP_INK_BLOB_TYPE_CIRCLE = 0,
    GIMP_INK_BLOB_TYPE_SQUARE = 1,
    GIMP_INK_BLOB_TYPE_DIAMOND = 2
} ;
#line 820 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2118 GimpInkBlobType;
#line 838
enum __anonenum__2119 {
    GIMP_INTERPOLATION_NONE = 0,
    GIMP_INTERPOLATION_LINEAR = 1,
    GIMP_INTERPOLATION_CUBIC = 2,
    GIMP_INTERPOLATION_NOHALO = 3,
    GIMP_INTERPOLATION_LOHALO = 4,
    GIMP_INTERPOLATION_LANCZOS = 3
} ;
#line 849 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2119 GimpInterpolationType;
#line 864
enum __anonenum__2120 {
    GIMP_JOIN_MITER = 0,
    GIMP_JOIN_ROUND = 1,
    GIMP_JOIN_BEVEL = 2
} ;
#line 869 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2120 GimpJoinStyle;
#line 883
enum __anonenum__2121 {
    GIMP_MASK_APPLY = 0,
    GIMP_MASK_DISCARD = 1
} ;
#line 887 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2121 GimpMaskApplyMode;
#line 903
enum __anonenum__2122 {
    GIMP_EXPAND_AS_NECESSARY = 0,
    GIMP_CLIP_TO_IMAGE = 1,
    GIMP_CLIP_TO_BOTTOM_LAYER = 2,
    GIMP_FLATTEN_IMAGE = 3
} ;
#line 909 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2122 GimpMergeType;
#line 924
enum __anonenum__2123 {
    GIMP_MESSAGE_BOX = 0,
    GIMP_CONSOLE = 1,
    GIMP_ERROR_CONSOLE = 2
} ;
#line 929 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2123 GimpMessageHandlerType;
#line 944
enum __anonenum__2124 {
    GIMP_OFFSET_BACKGROUND = 0,
    GIMP_OFFSET_TRANSPARENT = 1,
    GIMP_OFFSET_WRAP_AROUND = 2
} ;
#line 949 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2124 GimpOffsetType;
#line 964
enum __anonenum__2125 {
    GIMP_ORIENTATION_HORIZONTAL = 0,
    GIMP_ORIENTATION_VERTICAL = 1,
    GIMP_ORIENTATION_UNKNOWN = 2
} ;
#line 969 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2125 GimpOrientationType;
#line 983
enum __anonenum__2126 {
    GIMP_PAINT_CONSTANT = 0,
    GIMP_PAINT_INCREMENTAL = 1
} ;
#line 987 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2126 GimpPaintApplicationMode;
#line 1025
enum __anonenum__2127 {
    GIMP_PDB_INT32 = 0,
    GIMP_PDB_INT16 = 1,
    GIMP_PDB_INT8 = 2,
    GIMP_PDB_FLOAT = 3,
    GIMP_PDB_STRING = 4,
    GIMP_PDB_INT32ARRAY = 5,
    GIMP_PDB_INT16ARRAY = 6,
    GIMP_PDB_INT8ARRAY = 7,
    GIMP_PDB_FLOATARRAY = 8,
    GIMP_PDB_STRINGARRAY = 9,
    GIMP_PDB_COLOR = 10,
    GIMP_PDB_ITEM = 11,
    GIMP_PDB_DISPLAY = 12,
    GIMP_PDB_IMAGE = 13,
    GIMP_PDB_LAYER = 14,
    GIMP_PDB_CHANNEL = 15,
    GIMP_PDB_DRAWABLE = 16,
    GIMP_PDB_SELECTION = 17,
    GIMP_PDB_COLORARRAY = 18,
    GIMP_PDB_VECTORS = 19,
    GIMP_PDB_PARASITE = 20,
    GIMP_PDB_STATUS = 21,
    GIMP_PDB_END = 22,
    GIMP_PDB_PATH = 19,
    GIMP_PDB_BOUNDARY = 18,
    GIMP_PDB_REGION = 11
} ;
#line 1056 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2127 GimpPDBArgType;
#line 1070
enum __anonenum__2128 {
    GIMP_PDB_ERROR_HANDLER_INTERNAL = 0,
    GIMP_PDB_ERROR_HANDLER_PLUGIN = 1
} ;
#line 1074 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2128 GimpPDBErrorHandler;
#line 1090
enum __anonenum__2129 {
    GIMP_INTERNAL = 0,
    GIMP_PLUGIN = 1,
    GIMP_EXTENSION = 2,
    GIMP_TEMPORARY = 3
} ;
#line 1096 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2129 GimpPDBProcType;
#line 1113
enum __anonenum__2130 {
    GIMP_PDB_EXECUTION_ERROR = 0,
    GIMP_PDB_CALLING_ERROR = 1,
    GIMP_PDB_PASS_THROUGH = 2,
    GIMP_PDB_SUCCESS = 3,
    GIMP_PDB_CANCEL = 4
} ;
#line 1120 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2130 GimpPDBStatusType;
#line 1146
enum __anonenum__2131 {
    GIMP_PRECISION_U8_LINEAR = 100,
    GIMP_PRECISION_U8_GAMMA = 150,
    GIMP_PRECISION_U16_LINEAR = 200,
    GIMP_PRECISION_U16_GAMMA = 250,
    GIMP_PRECISION_U32_LINEAR = 300,
    GIMP_PRECISION_U32_GAMMA = 350,
    GIMP_PRECISION_HALF_LINEAR = 500,
    GIMP_PRECISION_HALF_GAMMA = 550,
    GIMP_PRECISION_FLOAT_LINEAR = 600,
    GIMP_PRECISION_FLOAT_GAMMA = 650,
    GIMP_PRECISION_DOUBLE_LINEAR = 700,
    GIMP_PRECISION_DOUBLE_GAMMA = 750
} ;
#line 1160 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2131 GimpPrecision;
#line 1178
enum __anonenum__2132 {
    GIMP_PROGRESS_COMMAND_START = 0,
    GIMP_PROGRESS_COMMAND_END = 1,
    GIMP_PROGRESS_COMMAND_SET_TEXT = 2,
    GIMP_PROGRESS_COMMAND_SET_VALUE = 3,
    GIMP_PROGRESS_COMMAND_PULSE = 4,
    GIMP_PROGRESS_COMMAND_GET_WINDOW = 5
} ;
#line 1186 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2132 GimpProgressCommand;
#line 1202
enum __anonenum__2133 {
    GIMP_REPEAT_NONE = 0,
    GIMP_REPEAT_SAWTOOTH = 1,
    GIMP_REPEAT_TRIANGULAR = 2,
    GIMP_REPEAT_TRUNCATE = 3
} ;
#line 1208 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2133 GimpRepeatMode;
#line 1223
enum __anonenum__2134 {
    GIMP_ROTATE_90 = 0,
    GIMP_ROTATE_180 = 1,
    GIMP_ROTATE_270 = 2
} ;
#line 1228 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2134 GimpRotationType;
#line 1243
enum __anonenum__2135 {
    GIMP_RUN_INTERACTIVE = 0,
    GIMP_RUN_NONINTERACTIVE = 1,
    GIMP_RUN_WITH_LAST_VALS = 2
} ;
#line 1248 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2135 GimpRunMode;
#line 1271
enum __anonenum__2136 {
    GIMP_SELECT_CRITERION_COMPOSITE = 0,
    GIMP_SELECT_CRITERION_R = 1,
    GIMP_SELECT_CRITERION_G = 2,
    GIMP_SELECT_CRITERION_B = 3,
    GIMP_SELECT_CRITERION_H = 4,
    GIMP_SELECT_CRITERION_S = 5,
    GIMP_SELECT_CRITERION_V = 6,
    GIMP_SELECT_CRITERION_A = 7,
    GIMP_SELECT_CRITERION_LCH_L = 8,
    GIMP_SELECT_CRITERION_LCH_C = 9,
    GIMP_SELECT_CRITERION_LCH_H = 10
} ;
#line 1284 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2136 GimpSelectCriterion;
#line 1298
enum __anonenum__2137 {
    GIMP_PIXELS = 0,
    GIMP_POINTS = 1
} ;
#line 1302 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2137 GimpSizeType;
#line 1317
enum __anonenum__2138 {
    GIMP_STACK_TRACE_NEVER = 0,
    GIMP_STACK_TRACE_QUERY = 1,
    GIMP_STACK_TRACE_ALWAYS = 2
} ;
#line 1322 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2138 GimpStackTraceMode;
#line 1336
enum __anonenum__2139 {
    GIMP_STROKE_LINE = 0,
    GIMP_STROKE_PAINT_METHOD = 1
} ;
#line 1340 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2139 GimpStrokeMethod;
#line 1358
enum __anonenum__2140 {
    GIMP_TEXT_DIRECTION_LTR = 0,
    GIMP_TEXT_DIRECTION_RTL = 1,
    GIMP_TEXT_DIRECTION_TTB_RTL = 2,
    GIMP_TEXT_DIRECTION_TTB_RTL_UPRIGHT = 3,
    GIMP_TEXT_DIRECTION_TTB_LTR = 4,
    GIMP_TEXT_DIRECTION_TTB_LTR_UPRIGHT = 5
} ;
#line 1366 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2140 GimpTextDirection;
#line 1382
enum __anonenum__2141 {
    GIMP_TEXT_HINT_STYLE_NONE = 0,
    GIMP_TEXT_HINT_STYLE_SLIGHT = 1,
    GIMP_TEXT_HINT_STYLE_MEDIUM = 2,
    GIMP_TEXT_HINT_STYLE_FULL = 3
} ;
#line 1388 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2141 GimpTextHintStyle;
#line 1404
enum __anonenum__2142 {
    GIMP_TEXT_JUSTIFY_LEFT = 0,
    GIMP_TEXT_JUSTIFY_RIGHT = 1,
    GIMP_TEXT_JUSTIFY_CENTER = 2,
    GIMP_TEXT_JUSTIFY_FILL = 3
} ;
#line 1410 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2142 GimpTextJustification;
#line 1428
enum __anonenum__2143 {
    GIMP_TRANSFER_SHADOWS = 0,
    GIMP_TRANSFER_MIDTONES = 1,
    GIMP_TRANSFER_HIGHLIGHTS = 2,
    GIMP_SHADOWS = 0,
    GIMP_MIDTONES = 1,
    GIMP_HIGHLIGHTS = 2
} ;
#line 1439 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2143 GimpTransferMode;
#line 1453
enum __anonenum__2144 {
    GIMP_TRANSFORM_FORWARD = 0,
    GIMP_TRANSFORM_BACKWARD = 1
} ;
#line 1457 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2144 GimpTransformDirection;
#line 1473
enum __anonenum__2145 {
    GIMP_TRANSFORM_RESIZE_ADJUST = 0,
    GIMP_TRANSFORM_RESIZE_CLIP = 1,
    GIMP_TRANSFORM_RESIZE_CROP = 2,
    GIMP_TRANSFORM_RESIZE_CROP_WITH_ASPECT = 3
} ;
#line 1479 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2145 GimpTransformResize;
#line 1494
enum __anonenum__2146 {
    GIMP_UNIT_PIXEL = 0,
    GIMP_UNIT_INCH = 1,
    GIMP_UNIT_MM = 2,
    GIMP_UNIT_POINT = 3,
    GIMP_UNIT_PICA = 4,
    GIMP_UNIT_END = 5,
    GIMP_UNIT_PERCENT = 65536
} ;
#line 1506 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2146 GimpUnit;
#line 1527
enum __anonenum__2147 {
    GIMP_USER_DIRECTORY_DESKTOP = 0,
    GIMP_USER_DIRECTORY_DOCUMENTS = 1,
    GIMP_USER_DIRECTORY_DOWNLOAD = 2,
    GIMP_USER_DIRECTORY_MUSIC = 3,
    GIMP_USER_DIRECTORY_PICTURES = 4,
    GIMP_USER_DIRECTORY_PUBLIC_SHARE = 5,
    GIMP_USER_DIRECTORY_TEMPLATES = 6,
    GIMP_USER_DIRECTORY_VIDEOS = 7
} ;
#line 1537 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2147 GimpUserDirectory;
#line 1551
enum __anonenum__2148 {
    GIMP_VECTORS_STROKE_TYPE_BEZIER = 0
} ;
#line 1554 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
typedef enum __anonenum__2148 GimpVectorsStrokeType;
#line 48 "/usr/include/gimp-2.0/libgimpbase/gimpbasetypes.h"
struct _GimpParasite ;
#line 48 "/usr/include/gimp-2.0/libgimpbase/gimpbasetypes.h"
typedef struct _GimpParasite GimpParasite;
#line 49
struct _GimpDatafileData ;
#line 49 "/usr/include/gimp-2.0/libgimpbase/gimpbasetypes.h"
typedef struct _GimpDatafileData GimpDatafileData;
#line 50
struct _GimpEnumDesc ;
#line 50 "/usr/include/gimp-2.0/libgimpbase/gimpbasetypes.h"
typedef struct _GimpEnumDesc GimpEnumDesc;
#line 51
struct _GimpFlagsDesc ;
#line 51 "/usr/include/gimp-2.0/libgimpbase/gimpbasetypes.h"
typedef struct _GimpFlagsDesc GimpFlagsDesc;
#line 52
struct _GimpValueArray ;
#line 52 "/usr/include/gimp-2.0/libgimpbase/gimpbasetypes.h"
typedef struct _GimpValueArray GimpValueArray;
#line 55 "/usr/include/gimp-2.0/libgimpbase/gimpbasetypes.h"
typedef void (*GimpDatafileLoaderFunc)(GimpDatafileData * , gpointer  );
#line 58
struct _GimpMetadata ;
#line 58 "/usr/include/gimp-2.0/libgimpbase/gimpbasetypes.h"
typedef struct _GimpMetadata GimpMetadata;
#line 70 "/usr/include/gimp-2.0/libgimpbase/gimpbasetypes.h"
struct _GimpEnumDesc {
   gint value ;
   gchar *value_desc ;
   gchar *value_help ;
};
#line 86 "/usr/include/gimp-2.0/libgimpbase/gimpbasetypes.h"
struct _GimpFlagsDesc {
   guint value ;
   gchar *value_desc ;
   gchar *value_help ;
};
#line 46 "/usr/include/gimp-2.0/libgimpbase/gimpcpuaccel.h"
enum __anonenum__2149 {
    GIMP_CPU_ACCEL_NONE = 0,
    GIMP_CPU_ACCEL_X86_MMX = (-0x7FFFFFFF-1),
    GIMP_CPU_ACCEL_X86_3DNOW = 1073741824,
    GIMP_CPU_ACCEL_X86_MMXEXT = 536870912,
    GIMP_CPU_ACCEL_X86_SSE = 268435456,
    GIMP_CPU_ACCEL_X86_SSE2 = 134217728,
    GIMP_CPU_ACCEL_X86_SSE3 = 33554432,
    GIMP_CPU_ACCEL_X86_SSSE3 = 16777216,
    GIMP_CPU_ACCEL_X86_SSE4_1 = 8388608,
    GIMP_CPU_ACCEL_X86_SSE4_2 = 4194304,
    GIMP_CPU_ACCEL_X86_AVX = 2097152,
    GIMP_CPU_ACCEL_PPC_ALTIVEC = 67108864
} ;
#line 64 "/usr/include/gimp-2.0/libgimpbase/gimpcpuaccel.h"
typedef enum __anonenum__2149 GimpCpuAccelFlags;
#line 47 "/usr/include/gimp-2.0/libgimpbase/gimpdatafiles.h"
struct _GimpDatafileData {
   gchar *filename ;
   gchar *dirname ;
   gchar *basename ;
   time_t atime ;
   time_t mtime ;
   time_t ctime ;
};
#line 45 "/usr/include/gimp-2.0/libgimpbase/gimpmetadata.h"
enum __anonenum__2150 {
    GIMP_METADATA_LOAD_COMMENT = 1,
    GIMP_METADATA_LOAD_RESOLUTION = 2,
    GIMP_METADATA_LOAD_ORIENTATION = 4,
    GIMP_METADATA_LOAD_COLORSPACE = 8,
    GIMP_METADATA_LOAD_ALL = -1
} ;
#line 53 "/usr/include/gimp-2.0/libgimpbase/gimpmetadata.h"
typedef enum __anonenum__2150 GimpMetadataLoadFlags;
#line 68
enum __anonenum__2151 {
    GIMP_METADATA_SAVE_EXIF = 1,
    GIMP_METADATA_SAVE_XMP = 2,
    GIMP_METADATA_SAVE_IPTC = 4,
    GIMP_METADATA_SAVE_THUMBNAIL = 8,
    GIMP_METADATA_SAVE_COLOR_PROFILE = 16,
    GIMP_METADATA_SAVE_ALL = -1
} ;
#line 77 "/usr/include/gimp-2.0/libgimpbase/gimpmetadata.h"
typedef enum __anonenum__2151 GimpMetadataSaveFlags;
#line 89
enum __anonenum__2152 {
    GIMP_METADATA_COLORSPACE_UNSPECIFIED = 0,
    GIMP_METADATA_COLORSPACE_UNCALIBRATED = 1,
    GIMP_METADATA_COLORSPACE_SRGB = 2,
    GIMP_METADATA_COLORSPACE_ADOBERGB = 3
} ;
#line 95 "/usr/include/gimp-2.0/libgimpbase/gimpmetadata.h"
typedef enum __anonenum__2152 GimpMetadataColorspace;
#line 79 "/usr/include/gimp-2.0/libgimpbase/gimpparasite.h"
struct _GimpParasite {
   gchar *name ;
   guint32 flags ;
   guint32 size ;
   gpointer data ;
};
#line 75 "/usr/include/gimp-2.0/libgimpbase/gimpvaluearray.h"
struct _GimpParamSpecValueArray ;
#line 75 "/usr/include/gimp-2.0/libgimpbase/gimpvaluearray.h"
typedef struct _GimpParamSpecValueArray GimpParamSpecValueArray;
#line 86 "/usr/include/gimp-2.0/libgimpbase/gimpvaluearray.h"
struct _GimpParamSpecValueArray {
   GParamSpec parent_instance ;
   GParamSpec *element_spec ;
   gint fixed_n_elements ;
};
#line 39 "/usr/include/gimp-2.0/libgimpbase/gimpsignal.h"
typedef void (*GimpSignalHandlerFunc)(gint  );
#line 40 "/usr/include/gimp-2.0/libgimpcolor/gimpcolormanaged.h"
struct _GimpColorManagedInterface ;
#line 40 "/usr/include/gimp-2.0/libgimpcolor/gimpcolormanaged.h"
typedef struct _GimpColorManagedInterface GimpColorManagedInterface;
#line 52 "/usr/include/gimp-2.0/libgimpcolor/gimpcolormanaged.h"
struct _GimpColorManagedInterface {
   GTypeInterface base_iface ;
   guint8 *(*get_icc_profile)(GimpColorManaged * , gsize * ) ;
   void (*profile_changed)(GimpColorManaged * ) ;
   GimpColorProfile *(*get_color_profile)(GimpColorManaged * ) ;
};
#line 43 "/usr/include/gimp-2.0/libgimpcolor/gimpcolorprofile.h"
struct _GimpColorProfileClass ;
#line 43 "/usr/include/gimp-2.0/libgimpcolor/gimpcolorprofile.h"
typedef struct _GimpColorProfileClass GimpColorProfileClass;
#line 44
struct _GimpColorProfilePrivate ;
#line 44 "/usr/include/gimp-2.0/libgimpcolor/gimpcolorprofile.h"
typedef struct _GimpColorProfilePrivate GimpColorProfilePrivate;
#line 46 "/usr/include/gimp-2.0/libgimpcolor/gimpcolorprofile.h"
struct _GimpColorProfile {
   GObject parent_instance ;
   GimpColorProfilePrivate *priv ;
};
#line 53 "/usr/include/gimp-2.0/libgimpcolor/gimpcolorprofile.h"
struct _GimpColorProfileClass {
   GObjectClass parent_class ;
   void (*_gimp_reserved1)(void) ;
   void (*_gimp_reserved2)(void) ;
   void (*_gimp_reserved3)(void) ;
   void (*_gimp_reserved4)(void) ;
};
#line 46 "/usr/include/gimp-2.0/libgimpcolor/gimpcolortransform.h"
enum __anonenum__2153 {
    GIMP_COLOR_TRANSFORM_FLAGS_NOOPTIMIZE = 256,
    GIMP_COLOR_TRANSFORM_FLAGS_GAMUT_CHECK = 4096,
    GIMP_COLOR_TRANSFORM_FLAGS_BLACK_POINT_COMPENSATION = 8192
} ;
#line 51 "/usr/include/gimp-2.0/libgimpcolor/gimpcolortransform.h"
typedef enum __anonenum__2153 GimpColorTransformFlags;
#line 62
struct _GimpColorTransformClass ;
#line 62 "/usr/include/gimp-2.0/libgimpcolor/gimpcolortransform.h"
typedef struct _GimpColorTransformClass GimpColorTransformClass;
#line 63
struct _GimpColorTransformPrivate ;
#line 63 "/usr/include/gimp-2.0/libgimpcolor/gimpcolortransform.h"
typedef struct _GimpColorTransformPrivate GimpColorTransformPrivate;
#line 65 "/usr/include/gimp-2.0/libgimpcolor/gimpcolortransform.h"
struct _GimpColorTransform {
   GObject parent_instance ;
   GimpColorTransformPrivate *priv ;
};
#line 72 "/usr/include/gimp-2.0/libgimpcolor/gimpcolortransform.h"
struct _GimpColorTransformClass {
   GObjectClass parent_class ;
   void (*progress)(GimpColorTransform * , gdouble  ) ;
   void (*_gimp_reserved1)(void) ;
   void (*_gimp_reserved2)(void) ;
   void (*_gimp_reserved3)(void) ;
   void (*_gimp_reserved4)(void) ;
};
#line 76 "/usr/include/gimp-2.0/libgimpcolor/gimprgb.h"
enum __anonenum__2154 {
    GIMP_RGB_COMPOSITE_NONE = 0,
    GIMP_RGB_COMPOSITE_NORMAL = 1,
    GIMP_RGB_COMPOSITE_BEHIND = 2
} ;
#line 81 "/usr/include/gimp-2.0/libgimpcolor/gimprgb.h"
typedef enum __anonenum__2154 GimpRGBCompositeMode;
#line 40 "/usr/include/gimp-2.0/libgimpconfig/gimpconfig-iface.h"
struct _GimpConfigInterface ;
#line 40 "/usr/include/gimp-2.0/libgimpconfig/gimpconfig-iface.h"
typedef struct _GimpConfigInterface GimpConfigInterface;
#line 42 "/usr/include/gimp-2.0/libgimpconfig/gimpconfig-iface.h"
struct _GimpConfigInterface {
   GTypeInterface base_iface ;
   gboolean (*serialize)(GimpConfig * , GimpConfigWriter * , gpointer  ) ;
   gboolean (*deserialize)(GimpConfig * , GScanner * , gint  , gpointer  ) ;
   gboolean (*serialize_property)(GimpConfig * , guint  , GValue * , GParamSpec * ,
                                  GimpConfigWriter * ) ;
   gboolean (*deserialize_property)(GimpConfig * , guint  , GValue * , GParamSpec * ,
                                    GScanner * , GTokenType * ) ;
   GimpConfig *(*duplicate)(GimpConfig * ) ;
   gboolean (*equal)(GimpConfig * , GimpConfig * ) ;
   void (*reset)(GimpConfig * ) ;
   gboolean (*copy)(GimpConfig * , GimpConfig * , GParamFlags  ) ;
};
#line 43 "/usr/include/gimp-2.0/libgimpconfig/gimpconfig-error.h"
enum __anonenum__2155 {
    GIMP_CONFIG_ERROR_OPEN = 0,
    GIMP_CONFIG_ERROR_OPEN_ENOENT = 1,
    GIMP_CONFIG_ERROR_WRITE = 2,
    GIMP_CONFIG_ERROR_PARSE = 3,
    GIMP_CONFIG_ERROR_VERSION = 4
} ;
#line 50 "/usr/include/gimp-2.0/libgimpconfig/gimpconfig-error.h"
typedef enum __anonenum__2155 GimpConfigError;
#line 58 "/usr/include/gimp-2.0/libgimpconfig/gimpconfig-path.h"
enum __anonenum__2156 {
    GIMP_CONFIG_PATH_FILE = 0,
    GIMP_CONFIG_PATH_FILE_LIST = 1,
    GIMP_CONFIG_PATH_DIR = 2,
    GIMP_CONFIG_PATH_DIR_LIST = 3
} ;
#line 64 "/usr/include/gimp-2.0/libgimpconfig/gimpconfig-path.h"
typedef enum __anonenum__2156 GimpConfigPathType;
#line 37 "/usr/include/gimp-2.0/libgimpconfig/gimpcolorconfig.h"
struct _GimpColorConfigClass ;
#line 37 "/usr/include/gimp-2.0/libgimpconfig/gimpcolorconfig.h"
typedef struct _GimpColorConfigClass GimpColorConfigClass;
#line 39 "/usr/include/gimp-2.0/libgimpconfig/gimpcolorconfig.h"
struct _GimpColorConfig {
   GObject parent_instance ;
   GimpColorManagementMode mode ;
   gchar *rgb_profile ;
   gchar *cmyk_profile ;
   gchar *display_profile ;
   gboolean display_profile_from_gdk ;
   gchar *printer_profile ;
   GimpColorRenderingIntent display_intent ;
   GimpColorRenderingIntent simulation_intent ;
   gchar *display_module ;
   gboolean simulation_gamut_check ;
   GimpRGB out_of_gamut_color ;
   gboolean display_use_black_point_compensation ;
   gboolean simulation_use_black_point_compensation ;
   gchar *gray_profile ;
   void (*_gimp_reserved3)(void) ;
   void (*_gimp_reserved4)(void) ;
   void (*_gimp_reserved5)(void) ;
   void (*_gimp_reserved6)(void) ;
   void (*_gimp_reserved7)(void) ;
   void (*_gimp_reserved8)(void) ;
};
#line 75 "/usr/include/gimp-2.0/libgimpconfig/gimpcolorconfig.h"
struct _GimpColorConfigClass {
   GObjectClass parent_class ;
};
#line 31 "/usr/include/gimp-2.0/libgimp/gimpenums.h"
enum __anonenum__2157 {
    GIMP_BRUSH_HARD = 0,
    GIMP_BRUSH_SOFT = 1
} ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpenums.h"
typedef enum __anonenum__2157 GimpBrushApplicationMode;
#line 42
enum __anonenum__2158 {
    GIMP_CONVERT_DITHER_NONE = 0,
    GIMP_CONVERT_DITHER_FS = 1,
    GIMP_CONVERT_DITHER_FS_LOWBLEED = 2,
    GIMP_CONVERT_DITHER_FIXED = 3
} ;
#line 48 "/usr/include/gimp-2.0/libgimp/gimpenums.h"
typedef enum __anonenum__2158 GimpConvertDitherType;
#line 55
enum __anonenum__2159 {
    GIMP_HISTOGRAM_VALUE = 0,
    GIMP_HISTOGRAM_RED = 1,
    GIMP_HISTOGRAM_GREEN = 2,
    GIMP_HISTOGRAM_BLUE = 3,
    GIMP_HISTOGRAM_ALPHA = 4,
    GIMP_HISTOGRAM_LUMINANCE = 5
} ;
#line 63 "/usr/include/gimp-2.0/libgimp/gimpenums.h"
typedef enum __anonenum__2159 GimpHistogramChannel;
#line 70
enum __anonenum__2160 {
    GIMP_LAYER_COLOR_SPACE_AUTO = 0,
    GIMP_LAYER_COLOR_SPACE_RGB_LINEAR = 1,
    GIMP_LAYER_COLOR_SPACE_RGB_PERCEPTUAL = 2
} ;
#line 75 "/usr/include/gimp-2.0/libgimp/gimpenums.h"
typedef enum __anonenum__2160 GimpLayerColorSpace;
#line 82
enum __anonenum__2161 {
    GIMP_LAYER_COMPOSITE_AUTO = 0,
    GIMP_LAYER_COMPOSITE_UNION = 1,
    GIMP_LAYER_COMPOSITE_CLIP_TO_BACKDROP = 2,
    GIMP_LAYER_COMPOSITE_CLIP_TO_LAYER = 3,
    GIMP_LAYER_COMPOSITE_INTERSECTION = 4
} ;
#line 89 "/usr/include/gimp-2.0/libgimp/gimpenums.h"
typedef enum __anonenum__2161 GimpLayerCompositeMode;
#line 96
enum __anonenum__2162 {
    GIMP_LAYER_MODE_NORMAL_LEGACY = 0,
    GIMP_LAYER_MODE_DISSOLVE = 1,
    GIMP_LAYER_MODE_BEHIND_LEGACY = 2,
    GIMP_LAYER_MODE_MULTIPLY_LEGACY = 3,
    GIMP_LAYER_MODE_SCREEN_LEGACY = 4,
    GIMP_LAYER_MODE_OVERLAY_LEGACY = 5,
    GIMP_LAYER_MODE_DIFFERENCE_LEGACY = 6,
    GIMP_LAYER_MODE_ADDITION_LEGACY = 7,
    GIMP_LAYER_MODE_SUBTRACT_LEGACY = 8,
    GIMP_LAYER_MODE_DARKEN_ONLY_LEGACY = 9,
    GIMP_LAYER_MODE_LIGHTEN_ONLY_LEGACY = 10,
    GIMP_LAYER_MODE_HSV_HUE_LEGACY = 11,
    GIMP_LAYER_MODE_HSV_SATURATION_LEGACY = 12,
    GIMP_LAYER_MODE_HSL_COLOR_LEGACY = 13,
    GIMP_LAYER_MODE_HSV_VALUE_LEGACY = 14,
    GIMP_LAYER_MODE_DIVIDE_LEGACY = 15,
    GIMP_LAYER_MODE_DODGE_LEGACY = 16,
    GIMP_LAYER_MODE_BURN_LEGACY = 17,
    GIMP_LAYER_MODE_HARDLIGHT_LEGACY = 18,
    GIMP_LAYER_MODE_SOFTLIGHT_LEGACY = 19,
    GIMP_LAYER_MODE_GRAIN_EXTRACT_LEGACY = 20,
    GIMP_LAYER_MODE_GRAIN_MERGE_LEGACY = 21,
    GIMP_LAYER_MODE_COLOR_ERASE_LEGACY = 22,
    GIMP_LAYER_MODE_OVERLAY = 23,
    GIMP_LAYER_MODE_LCH_HUE = 24,
    GIMP_LAYER_MODE_LCH_CHROMA = 25,
    GIMP_LAYER_MODE_LCH_COLOR = 26,
    GIMP_LAYER_MODE_LCH_LIGHTNESS = 27,
    GIMP_LAYER_MODE_NORMAL = 28,
    GIMP_LAYER_MODE_BEHIND = 29,
    GIMP_LAYER_MODE_MULTIPLY = 30,
    GIMP_LAYER_MODE_SCREEN = 31,
    GIMP_LAYER_MODE_DIFFERENCE = 32,
    GIMP_LAYER_MODE_ADDITION = 33,
    GIMP_LAYER_MODE_SUBTRACT = 34,
    GIMP_LAYER_MODE_DARKEN_ONLY = 35,
    GIMP_LAYER_MODE_LIGHTEN_ONLY = 36,
    GIMP_LAYER_MODE_HSV_HUE = 37,
    GIMP_LAYER_MODE_HSV_SATURATION = 38,
    GIMP_LAYER_MODE_HSL_COLOR = 39,
    GIMP_LAYER_MODE_HSV_VALUE = 40,
    GIMP_LAYER_MODE_DIVIDE = 41,
    GIMP_LAYER_MODE_DODGE = 42,
    GIMP_LAYER_MODE_BURN = 43,
    GIMP_LAYER_MODE_HARDLIGHT = 44,
    GIMP_LAYER_MODE_SOFTLIGHT = 45,
    GIMP_LAYER_MODE_GRAIN_EXTRACT = 46,
    GIMP_LAYER_MODE_GRAIN_MERGE = 47,
    GIMP_LAYER_MODE_VIVID_LIGHT = 48,
    GIMP_LAYER_MODE_PIN_LIGHT = 49,
    GIMP_LAYER_MODE_LINEAR_LIGHT = 50,
    GIMP_LAYER_MODE_HARD_MIX = 51,
    GIMP_LAYER_MODE_EXCLUSION = 52,
    GIMP_LAYER_MODE_LINEAR_BURN = 53,
    GIMP_LAYER_MODE_LUMA_DARKEN_ONLY = 54,
    GIMP_LAYER_MODE_LUMA_LIGHTEN_ONLY = 55,
    GIMP_LAYER_MODE_LUMINANCE = 56,
    GIMP_LAYER_MODE_COLOR_ERASE = 57,
    GIMP_LAYER_MODE_ERASE = 58,
    GIMP_LAYER_MODE_MERGE = 59,
    GIMP_LAYER_MODE_SPLIT = 60,
    GIMP_LAYER_MODE_PASS_THROUGH = 61
} ;
#line 160 "/usr/include/gimp-2.0/libgimp/gimpenums.h"
typedef enum __anonenum__2162 GimpLayerMode;
#line 31 "/usr/include/gimp-2.0/libgimp/gimptypes.h"
struct _GimpPlugInInfo ;
#line 31 "/usr/include/gimp-2.0/libgimp/gimptypes.h"
typedef struct _GimpPlugInInfo GimpPlugInInfo;
#line 32
struct _GimpTile ;
#line 32 "/usr/include/gimp-2.0/libgimp/gimptypes.h"
typedef struct _GimpTile GimpTile;
#line 33
struct _GimpDrawable ;
#line 33 "/usr/include/gimp-2.0/libgimp/gimptypes.h"
typedef struct _GimpDrawable GimpDrawable;
#line 34
struct _GimpPixelRgn ;
#line 34 "/usr/include/gimp-2.0/libgimp/gimptypes.h"
typedef struct _GimpPixelRgn GimpPixelRgn;
#line 35
struct _GimpParamDef ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimptypes.h"
typedef struct _GimpParamDef GimpParamDef;
#line 36
struct _GimpParamRegion ;
#line 36 "/usr/include/gimp-2.0/libgimp/gimptypes.h"
typedef struct _GimpParamRegion GimpParamRegion;
#line 37
union _GimpParamData ;
#line 37 "/usr/include/gimp-2.0/libgimp/gimptypes.h"
typedef union _GimpParamData GimpParamData;
#line 38
struct _GimpParam ;
#line 38 "/usr/include/gimp-2.0/libgimp/gimptypes.h"
typedef struct _GimpParam GimpParam;
#line 47 "/usr/include/gimp-2.0/libgimp/gimptypes.h"
typedef GimpLayerMode GimpLayerModeEffects;
#line 31 "/usr/include/gimp-2.0/libgimp/gimpbrushselect.h"
typedef void (*GimpRunBrushCallback)(gchar * , gdouble  , gint  , GimpLayerMode  ,
                                     gint  , gint  , guchar * , gboolean  , gpointer  );
#line 32 "/usr/include/gimp-2.0/libgimp/gimpdrawable.h"
struct _GimpDrawable {
   gint32 drawable_id ;
   guint width ;
   guint height ;
   guint bpp ;
   guint ntile_rows ;
   guint ntile_cols ;
   GimpTile *tiles ;
   GimpTile *shadow_tiles ;
};
#line 31 "/usr/include/gimp-2.0/libgimp/gimpfontselect.h"
typedef void (*GimpRunFontCallback)(gchar * , gboolean  , gpointer  );
#line 31 "/usr/include/gimp-2.0/libgimp/gimpgradientselect.h"
typedef void (*GimpRunGradientCallback)(gchar * , gint  , gdouble * , gboolean  ,
                                        gpointer  );
#line 31 "/usr/include/gimp-2.0/libgimp/gimppaletteselect.h"
typedef void (*GimpRunPaletteCallback)(gchar * , gboolean  , gpointer  );
#line 31 "/usr/include/gimp-2.0/libgimp/gimppatternselect.h"
typedef void (*GimpRunPatternCallback)(gchar * , gint  , gint  , gint  , guchar * ,
                                       gboolean  , gpointer  );
#line 43 "/usr/include/gimp-2.0/libgimp/gimppixbuf.h"
enum __anonenum__2163 {
    GIMP_PIXBUF_KEEP_ALPHA = 0,
    GIMP_PIXBUF_SMALL_CHECKS = 1,
    GIMP_PIXBUF_LARGE_CHECKS = 2
} ;
#line 48 "/usr/include/gimp-2.0/libgimp/gimppixbuf.h"
typedef enum __anonenum__2163 GimpPixbufTransparency;
#line 37 "/usr/include/gimp-2.0/libgimp/gimppixelfetcher.h"
enum __anonenum__2164 {
    GIMP_PIXEL_FETCHER_EDGE_NONE = 0,
    GIMP_PIXEL_FETCHER_EDGE_WRAP = 1,
    GIMP_PIXEL_FETCHER_EDGE_SMEAR = 2,
    GIMP_PIXEL_FETCHER_EDGE_BLACK = 3,
    GIMP_PIXEL_FETCHER_EDGE_BACKGROUND = 4
} ;
#line 44 "/usr/include/gimp-2.0/libgimp/gimppixelfetcher.h"
typedef enum __anonenum__2164 GimpPixelFetcherEdgeMode;
#line 47
struct _GimpPixelFetcher ;
#line 47 "/usr/include/gimp-2.0/libgimp/gimppixelfetcher.h"
typedef struct _GimpPixelFetcher GimpPixelFetcher;
#line 33 "/usr/include/gimp-2.0/libgimp/gimppixelrgn.h"
struct _GimpPixelRgn {
   guchar *data ;
   GimpDrawable *drawable ;
   gint bpp ;
   gint rowstride ;
   gint x ;
   gint y ;
   gint w ;
   gint h ;
   guint dirty ;
   guint shadow ;
   gint process_count ;
};
#line 31 "/usr/include/gimp-2.0/libgimp/gimpprogress.h"
struct _GimpProgressVtable ;
#line 31 "/usr/include/gimp-2.0/libgimp/gimpprogress.h"
typedef struct _GimpProgressVtable GimpProgressVtable;
#line 33 "/usr/include/gimp-2.0/libgimp/gimpprogress.h"
struct _GimpProgressVtable {
   void (*start)(gchar * , gboolean  , gpointer  ) ;
   void (*end)(gpointer  ) ;
   void (*set_text)(gchar * , gpointer  ) ;
   void (*set_value)(gdouble  , gpointer  ) ;
   void (*pulse)(gpointer  ) ;
   guint32 (*get_window)(gpointer  ) ;
   void (*_gimp_reserved1)(void) ;
   void (*_gimp_reserved2)(void) ;
   void (*_gimp_reserved3)(void) ;
   void (*_gimp_reserved4)(void) ;
   void (*_gimp_reserved5)(void) ;
   void (*_gimp_reserved6)(void) ;
   void (*_gimp_reserved7)(void) ;
   void (*_gimp_reserved8)(void) ;
};
#line 74 "/usr/include/gimp-2.0/libgimp/gimpprogress.h"
typedef void (*GimpProgressStartCallback)(gchar * , gboolean  , gpointer  );
#line 77 "/usr/include/gimp-2.0/libgimp/gimpprogress.h"
typedef void (*GimpProgressEndCallback)(gpointer  );
#line 78 "/usr/include/gimp-2.0/libgimp/gimpprogress.h"
typedef void (*GimpProgressTextCallback)(gchar * , gpointer  );
#line 80 "/usr/include/gimp-2.0/libgimp/gimpprogress.h"
typedef void (*GimpProgressValueCallback)(gdouble  , gpointer  );
#line 36 "/usr/include/gimp-2.0/libgimp/gimpregioniterator.h"
struct _GimpRgnIterator ;
#line 36 "/usr/include/gimp-2.0/libgimp/gimpregioniterator.h"
typedef struct _GimpRgnIterator GimpRgnIterator;
#line 38 "/usr/include/gimp-2.0/libgimp/gimpregioniterator.h"
typedef void (*GimpRgnFunc1)(guchar * , gint  , gpointer  );
#line 41 "/usr/include/gimp-2.0/libgimp/gimpregioniterator.h"
typedef void (*GimpRgnFunc2)(guchar * , guchar * , gint  , gpointer  );
#line 45 "/usr/include/gimp-2.0/libgimp/gimpregioniterator.h"
typedef void (*GimpRgnFuncSrc)(gint  , gint  , guchar * , gint  , gpointer  );
#line 50 "/usr/include/gimp-2.0/libgimp/gimpregioniterator.h"
typedef void (*GimpRgnFuncDest)(gint  , gint  , guchar * , gint  , gpointer  );
#line 55 "/usr/include/gimp-2.0/libgimp/gimpregioniterator.h"
typedef void (*GimpRgnFuncSrcDest)(gint  , gint  , guchar * , guchar * , gint  , gpointer  );
#line 33 "/usr/include/gimp-2.0/libgimp/gimptile.h"
struct _GimpTile {
   guint ewidth ;
   guint eheight ;
   guint bpp ;
   guint tile_num ;
   guint16 ref_count ;
   guint dirty ;
   guint shadow ;
   guchar *data ;
   GimpDrawable *drawable ;
};
#line 82 "/usr/include/gimp-2.0/libgimp/gimp.h"
typedef void (*GimpInitProc)(void);
#line 83 "/usr/include/gimp-2.0/libgimp/gimp.h"
typedef void (*GimpQuitProc)(void);
#line 84 "/usr/include/gimp-2.0/libgimp/gimp.h"
typedef void (*GimpQueryProc)(void);
#line 85 "/usr/include/gimp-2.0/libgimp/gimp.h"
typedef void (*GimpRunProc)(gchar * , gint  , GimpParam * , gint * , GimpParam ** );
#line 102 "/usr/include/gimp-2.0/libgimp/gimp.h"
struct _GimpPlugInInfo {
   GimpInitProc init_proc ;
   GimpQuitProc quit_proc ;
   GimpQueryProc query_proc ;
   GimpRunProc run_proc ;
};
#line 110 "/usr/include/gimp-2.0/libgimp/gimp.h"
struct _GimpParamDef {
   GimpPDBArgType type ;
   gchar *name ;
   gchar *description ;
};
#line 117 "/usr/include/gimp-2.0/libgimp/gimp.h"
struct _GimpParamRegion {
   gint32 x ;
   gint32 y ;
   gint32 width ;
   gint32 height ;
};
#line 125 "/usr/include/gimp-2.0/libgimp/gimp.h"
union _GimpParamData {
   gint32 d_int32 ;
   gint16 d_int16 ;
   guint8 d_int8 ;
   gdouble d_float ;
   gchar *d_string ;
   gint32 *d_int32array ;
   gint16 *d_int16array ;
   guint8 *d_int8array ;
   gdouble *d_floatarray ;
   gchar **d_stringarray ;
   GimpRGB *d_colorarray ;
   GimpRGB d_color ;
   GimpParamRegion d_region ;
   gint32 d_display ;
   gint32 d_image ;
   gint32 d_item ;
   gint32 d_layer ;
   gint32 d_layer_mask ;
   gint32 d_channel ;
   gint32 d_drawable ;
   gint32 d_selection ;
   gint32 d_boundary ;
   gint32 d_path ;
   gint32 d_vectors ;
   gint32 d_unit ;
   GimpParasite d_parasite ;
   gint32 d_tattoo ;
   GimpPDBStatusType d_status ;
};
#line 157 "/usr/include/gimp-2.0/libgimp/gimp.h"
struct _GimpParam {
   GimpPDBArgType type ;
   GimpParamData data ;
};
#line 113 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
enum __anonenum__2165 {
    STANDALONE = 0,
    SANE_GIMP_EXTENSION = 1
} ;
#line 118 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
struct __anonstruct_2166 {
   GtkWidget *shell ;
   GtkWidget *menubar ;
   GtkWidget *hruler ;
   GtkWidget *vruler ;
   GtkWidget *info_label ;
   GtkWidget *preview_button ;
   GtkWidget *scan_button ;
   Preview *preview ;
   gint32 mode ;
   size_t num_bytes ;
   size_t bytes_read ;
   Progress_t *progress ;
   int input_tag ;
   SANE_Parameters param ;
   int x ;
   int y ;
   GtkWidget *filename_entry ;
   FILE *out ;
   long header_size ;
   gboolean have_odd_byte ;
   guint8 odd_byte ;
   gint32 image_ID ;
   GimpDrawable *drawable ;
   guchar *tile ;
   unsigned int tile_offset ;
   GimpPixelRgn region ;
   int first_frame ;
};
#line 143 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 144
extern FILE *stdout ;
#line 145
extern FILE *stderr ;
#line 152
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 154
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 158
extern  __attribute__((__nothrow__)) int renameat(int __oldfd , char const   *__old ,
                                                  int __newfd , char const   *__new ) ;
#line 170
extern  __attribute__((__nothrow__)) int renameat2(int __oldfd , char const   *__old ,
                                                   int __newfd , char const   *__new ,
                                                   unsigned int __flags ) ;
#line 178
extern int fclose(FILE *__stream ) ;
#line 188
extern FILE *tmpfile(void) ;
#line 200
extern FILE *tmpfile64(void) ;
#line 205
extern  __attribute__((__nothrow__)) char *tmpnam(char [20] ) ;
#line 210
extern  __attribute__((__nothrow__)) char *tmpnam_r(char __s[20] ) ;
#line 222
extern  __attribute__((__nothrow__)) char *tempnam(char const   *__dir , char const   *__pfx ) ;
#line 230
extern int fflush(FILE *__stream ) ;
#line 239
extern int fflush_unlocked(FILE *__stream ) ;
#line 249
extern int fcloseall(void) ;
#line 258
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 265
extern FILE *freopen(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 283
extern FILE *fopen64(char const   *__filename , char const   *__modes ) ;
#line 286
extern FILE *freopen64(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 293
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 300
extern  __attribute__((__nothrow__)) FILE *fopencookie(void *__magic_cookie , char const   *__modes ,
                                                       cookie_io_functions_t __io_funcs ) ;
#line 308
extern  __attribute__((__nothrow__)) FILE *fmemopen(void *__s , size_t __len , char const   *__modes ) ;
#line 314
extern  __attribute__((__nothrow__)) FILE *open_memstream(char **__bufloc , size_t *__sizeloc ) ;
#line 328
extern  __attribute__((__nothrow__)) void setbuf(FILE *__stream , char *__buf ) ;
#line 332
extern  __attribute__((__nothrow__)) int setvbuf(FILE *__stream , char *__buf , int __modes ,
                                                 size_t __n ) ;
#line 338
extern  __attribute__((__nothrow__)) void setbuffer(FILE *__stream , char *__buf ,
                                                    size_t __size ) ;
#line 342
extern  __attribute__((__nothrow__)) void setlinebuf(FILE *__stream ) ;
#line 350
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 356
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 358
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 365
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 371
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 373
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 378
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 382
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 390
__inline extern  __attribute__((__nothrow__)) int vasprintf(char **__ptr , char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 393
__inline extern  __attribute__((__nothrow__)) int __asprintf(char **__ptr , char const   *__fmt 
                                                             , ...)  __attribute__((__gnu_inline__)) ;
#line 396
__inline extern  __attribute__((__nothrow__)) int asprintf(char **__ptr , char const   *__fmt 
                                                           , ...)  __attribute__((__gnu_inline__)) ;
#line 403
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 406
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 415
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 421
extern int scanf(char const   *__format  , ...) ;
#line 423
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 459
extern int vfscanf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 467
extern int vscanf(char const   *__format , __gnuc_va_list __arg ) ;
#line 471
extern  __attribute__((__nothrow__)) int vsscanf(char const   *__s , char const   *__format ,
                                                 __gnuc_va_list __arg ) ;
#line 513
extern int fgetc(FILE *__stream ) ;
#line 514
extern int getc(FILE *__stream ) ;
#line 520
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 527
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 528
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 538
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 549
extern int fputc(int __c , FILE *__stream ) ;
#line 550
extern int putc(int __c , FILE *__stream ) ;
#line 556
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 565
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 573
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 574
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 581
extern int getw(FILE *__stream ) ;
#line 584
extern int putw(int __w , FILE *__stream ) ;
#line 592
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 615
__inline extern char *fgets_unlocked(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 632
extern __ssize_t __getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 635
extern __ssize_t getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 645
__inline extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 655
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 661
extern int puts(char const   *__s ) ;
#line 668
extern int ungetc(int __c , FILE *__stream ) ;
#line 675
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 681
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 691
extern int fputs_unlocked(char const   *__s , FILE *__stream ) ;
#line 702
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 704
extern size_t fwrite_unlocked(void const   *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 713
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 718
extern long ftell(FILE *__stream ) ;
#line 723
extern void rewind(FILE *__stream ) ;
#line 736
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 741
extern __off_t ftello(FILE *__stream ) ;
#line 760
extern int fgetpos(FILE *__stream , fpos_t *__pos ) ;
#line 765
extern int fsetpos(FILE *__stream , fpos_t *__pos ) ;
#line 779
extern int fseeko64(FILE *__stream , __off64_t __off , int __whence ) ;
#line 780
extern __off64_t ftello64(FILE *__stream ) ;
#line 781
extern int fgetpos64(FILE *__stream , fpos64_t *__pos ) ;
#line 782
extern int fsetpos64(FILE *__stream , fpos64_t *__pos ) ;
#line 786
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 788
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 790
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 794
extern  __attribute__((__nothrow__)) void clearerr_unlocked(FILE *__stream ) ;
#line 795
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 796
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 804
extern void perror(char const   *__s ) ;
#line 809
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 814
extern  __attribute__((__nothrow__)) int fileno_unlocked(FILE *__stream ) ;
#line 823
extern int pclose(FILE *__stream ) ;
#line 829
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 837
extern  __attribute__((__nothrow__)) char *ctermid(char *__s ) ;
#line 844
extern char *cuserid(char *__s ) ;
#line 853
__inline extern  __attribute__((__nothrow__)) int obstack_printf(struct obstack *__obstack ,
                                                                 char const   *__fmt 
                                                                 , ...)  __attribute__((__gnu_inline__)) ;
#line 856
__inline extern  __attribute__((__nothrow__)) int obstack_vprintf(struct obstack *__obstack ,
                                                                  char const   *__fmt ,
                                                                  __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 867
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 871
extern  __attribute__((__nothrow__)) int ftrylockfile(FILE *__stream ) ;
#line 874
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 885
extern int __uflow(FILE * ) ;
#line 886
extern int __overflow(FILE * , int  ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 49
  __cil_tmp1 = getc(stdin);
  }
#line 49
  return (__cil_tmp1);
}
}
#line 56
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 56 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 58
  __cil_tmp2 = __builtin_expect((long )(__fp->_IO_read_ptr >= __fp->_IO_read_end),
                                (long )0);
  }
#line 58
  if (__cil_tmp2) {
    {
#line 58
    __cil_tmp3 = __uflow(__fp);
#line 58
    tmp = __cil_tmp3;
    }
  } else {
#line 58
    (__fp->_IO_read_ptr) ++;
#line 58
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 58
  return (tmp);
}
}
#line 73
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  char *__cil_tmp3 ;
  int tmp ;

  {
  {
#line 75
  __cil_tmp1 = __builtin_expect((long )(stdin->_IO_read_ptr >= stdin->_IO_read_end),
                                (long )0);
  }
#line 75
  if (__cil_tmp1) {
    {
#line 75
    __cil_tmp2 = __uflow(stdin);
#line 75
    tmp = __cil_tmp2;
    }
  } else {
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 75
  return (tmp);
}
}
#line 82
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 84
  __cil_tmp2 = putc(__c, stdout);
  }
#line 84
  return (__cil_tmp2);
}
}
#line 91
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 91 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 93
  __cil_tmp3 = __builtin_expect((long )(__stream->_IO_write_ptr >= __stream->_IO_write_end),
                                (long )0);
  }
#line 93
  if (__cil_tmp3) {
    {
#line 93
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 93
    tmp = __cil_tmp4;
    }
  } else {
#line 93
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 93
    (__stream->_IO_write_ptr) ++;
#line 93
    *__cil_tmp5 = (char )__c;
#line 93
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 93
  return (tmp);
}
}
#line 108
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 110
  __cil_tmp2 = __builtin_expect((long )(stdout->_IO_write_ptr >= stdout->_IO_write_end),
                                (long )0);
  }
#line 110
  if (__cil_tmp2) {
    {
#line 110
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp = __cil_tmp3;
    }
  } else {
#line 110
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    *__cil_tmp4 = (char )__c;
#line 110
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 110
  return (tmp);
}
}
#line 118
__inline extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 118 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream ) 
{ 
  __ssize_t __cil_tmp4 ;

  {
  {
#line 120
  __cil_tmp4 = __getdelim(__lineptr, __n, '\n', __stream);
  }
#line 120
  return (__cil_tmp4);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 16) != 0);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 32) != 0);
}
}
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern  __attribute__((__nothrow__)) int __sprintf_chk(char *__s , int __flag , size_t __slen ,
                                                       char const   *__format  , ...) ;
#line 29
extern  __attribute__((__nothrow__)) int __vsprintf_chk(char *__s , int __flag , size_t __slen ,
                                                        char const   *__format , __gnuc_va_list __ap ) ;
#line 36
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int sprintf(char *__s , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 38
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
  {
#line 38
  __cil_tmp4 = __builtin_va_arg_pack();
#line 38
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 38
  return (__cil_tmp5);
}
}
#line 49
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 49 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsprintf(char *__s , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 52
  __cil_tmp4 = __builtin_object_size(__s, 1);
#line 52
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 52
  return (__cil_tmp5);
}
}
#line 58
extern  __attribute__((__nothrow__)) int __snprintf_chk(char *__s , size_t __n , int __flag ,
                                                        size_t __slen , char const   *__format 
                                                        , ...) ;
#line 62
extern  __attribute__((__nothrow__)) int __vsnprintf_chk(char *__s , size_t __n ,
                                                         int __flag , size_t __slen ,
                                                         char const   *__format ,
                                                         __gnuc_va_list __ap ) ;
#line 68
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 68 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int snprintf(char *__s , size_t __n , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 71
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 71
  __cil_tmp5 = __builtin_va_arg_pack();
#line 71
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 71
  return (__cil_tmp6);
}
}
#line 82
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsnprintf(char *__s , size_t __n , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 85
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 85
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 85
  return (__cil_tmp6);
}
}
#line 93
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 95
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 96
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 98
extern int __vprintf_chk(int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 103
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 105
  __cil_tmp3 = __builtin_va_arg_pack();
#line 105
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 105
  return (__cil_tmp4);
}
}
#line 110
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 110 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int printf(char const   *__fmt  , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 112
  __cil_tmp2 = __builtin_va_arg_pack();
#line 112
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 112
  return (__cil_tmp3);
}
}
#line 122
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 122 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 125
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 125
  return (__cil_tmp3);
}
}
#line 132
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 132 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 135
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 135
  return (__cil_tmp4);
}
}
#line 139
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 141
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 147
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 147 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int dprintf(int __fd , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 149
  __cil_tmp3 = __builtin_va_arg_pack();
#line 149
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 149
  return (__cil_tmp4);
}
}
#line 158
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 158 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 160
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 160
  return (__cil_tmp4);
}
}
#line 166
extern  __attribute__((__nothrow__)) int __asprintf_chk(char **__ptr , int __flag ,
                                                        char const   *__fmt  , ...) ;
#line 169
extern  __attribute__((__nothrow__)) int __vasprintf_chk(char **__ptr , int __flag ,
                                                         char const   *__fmt , __gnuc_va_list __arg ) ;
#line 172
extern  __attribute__((__nothrow__)) int __obstack_printf_chk(struct obstack *__obstack ,
                                                              int __flag , char const   *__format 
                                                              , ...) ;
#line 176
extern  __attribute__((__nothrow__)) int __obstack_vprintf_chk(struct obstack *__obstack ,
                                                               int __flag , char const   *__format ,
                                                               __gnuc_va_list __args ) ;
#line 184
__inline extern  __attribute__((__nothrow__)) int asprintf(char **__ptr , char const   *__fmt 
                                                           , ...)  __attribute__((__gnu_inline__)) ;
#line 184 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int asprintf(char **__ptr , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 186
  __cil_tmp3 = __builtin_va_arg_pack();
#line 186
  __cil_tmp4 = __asprintf_chk(__ptr, 1, __fmt, __cil_tmp3);
  }
#line 186
  return (__cil_tmp4);
}
}
#line 199
__inline extern  __attribute__((__nothrow__)) int obstack_printf(struct obstack *__obstack ,
                                                                 char const   *__fmt 
                                                                 , ...)  __attribute__((__gnu_inline__)) ;
#line 199 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int obstack_printf(struct obstack *__obstack , char const   *__fmt 
                                   , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 202
  __cil_tmp3 = __builtin_va_arg_pack();
#line 202
  __cil_tmp4 = __obstack_printf_chk(__obstack, 1, __fmt, __cil_tmp3);
  }
#line 202
  return (__cil_tmp4);
}
}
#line 215
__inline extern  __attribute__((__nothrow__)) int vasprintf(char **__ptr , char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 215 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vasprintf(char **__ptr , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 218
  __cil_tmp4 = __vasprintf_chk(__ptr, 1, __fmt, __ap);
  }
#line 218
  return (__cil_tmp4);
}
}
#line 222
__inline extern  __attribute__((__nothrow__)) int obstack_vprintf(struct obstack *__obstack ,
                                                                  char const   *__fmt ,
                                                                  __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 222 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int obstack_vprintf(struct obstack *__obstack , char const   *__fmt ,
                                    __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 225
  __cil_tmp4 = __obstack_vprintf_chk(__obstack, 1, __fmt, __ap);
  }
#line 225
  return (__cil_tmp4);
}
}
#line 248
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 251
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 255
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 262
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 262 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets(char *__s , int __n , FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 264
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 264
  sz = __cil_tmp5;
#line 265
  __cil_tmp7 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 265
  __cil_tmp6 = __builtin_constant_p(__n);
  }
#line 265
  if (__cil_tmp6) {
#line 265
    if (__n > 0) {
#line 265
      if (__cil_tmp7) {
#line 265
        if ((unsigned long )__n <= sz / sizeof(char )) {
          {
#line 266
          __cil_tmp8 = __fgets_alias(__s, __n, __stream);
          }
#line 266
          return (__cil_tmp8);
        }
      }
    }
  }
  {
#line 267
  __cil_tmp10 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 267
  __cil_tmp9 = __builtin_constant_p(__n);
  }
#line 267
  if (__cil_tmp9) {
#line 267
    if (__n > 0) {
#line 267
      if (__cil_tmp10) {
#line 267
        if (! ((unsigned long )__n <= sz / sizeof(char ))) {
          {
#line 268
          __cil_tmp11 = __fgets_chk_warn(__s, sz, __n, __stream);
          }
#line 268
          return (__cil_tmp11);
        }
      }
    }
  }
  {
#line 269
  __cil_tmp12 = __fgets_chk(__s, sz, __n, __stream);
  }
#line 269
  return (__cil_tmp12);
}
}
#line 272
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 275
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 279
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 288
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 288 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  size_t __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 291
  __cil_tmp6 = __builtin_object_size(__ptr, 0);
#line 291
  sz = __cil_tmp6;
#line 292
  __cil_tmp8 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 292
  __cil_tmp7 = __builtin_constant_p(__n);
  }
#line 292
  if (__cil_tmp8) {
#line 292
    if ((unsigned long )__n <= sz / __size) {
      {
#line 293
      __cil_tmp9 = __fread_alias(__ptr, __size, __n, __stream);
      }
#line 293
      return (__cil_tmp9);
    }
  }
  {
#line 294
  __cil_tmp11 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 294
  __cil_tmp10 = __builtin_constant_p(__n);
  }
#line 294
  if (__cil_tmp11) {
#line 294
    if (! ((unsigned long )__n <= sz / __size)) {
      {
#line 295
      __cil_tmp12 = __fread_chk_warn(__ptr, sz, __size, __n, __stream);
      }
#line 295
      return (__cil_tmp12);
    }
  }
  {
#line 296
  __cil_tmp13 = __fread_chk(__ptr, sz, __size, __n, __stream);
  }
#line 296
  return (__cil_tmp13);
}
}
#line 300
extern char *__fgets_unlocked_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 303
extern char *__fgets_unlocked_alias(char *__s , int __n , FILE *__stream ) ;
#line 307
extern char *__fgets_unlocked_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 314
__inline extern char *fgets_unlocked(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 314 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets_unlocked(char *__s , int __n , FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 316
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 316
  sz = __cil_tmp5;
#line 317
  __cil_tmp7 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 317
  __cil_tmp6 = __builtin_constant_p(__n);
  }
#line 317
  if (__cil_tmp6) {
#line 317
    if (__n > 0) {
#line 317
      if (__cil_tmp7) {
#line 317
        if ((unsigned long )__n <= sz / sizeof(char )) {
          {
#line 318
          __cil_tmp8 = __fgets_unlocked_alias(__s, __n, __stream);
          }
#line 318
          return (__cil_tmp8);
        }
      }
    }
  }
  {
#line 319
  __cil_tmp10 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 319
  __cil_tmp9 = __builtin_constant_p(__n);
  }
#line 319
  if (__cil_tmp9) {
#line 319
    if (__n > 0) {
#line 319
      if (__cil_tmp10) {
#line 319
        if (! ((unsigned long )__n <= sz / sizeof(char ))) {
          {
#line 320
          __cil_tmp11 = __fgets_unlocked_chk_warn(__s, sz, __n, __stream);
          }
#line 320
          return (__cil_tmp11);
        }
      }
    }
  }
  {
#line 321
  __cil_tmp12 = __fgets_unlocked_chk(__s, sz, __n, __stream);
  }
#line 321
  return (__cil_tmp12);
}
}
#line 327
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 330
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 334
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 343
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 343 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int __cil_tmp14 ;
  char *__cil_tmp15 ;
  size_t __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  size_t __cil_tmp19 ;
  size_t __cil_tmp20 ;

  {
  {
#line 346
  __cil_tmp6 = __builtin_object_size(__ptr, 0);
#line 346
  sz = __cil_tmp6;
#line 347
  __cil_tmp8 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 347
  __cil_tmp7 = __builtin_constant_p(__n);
  }
#line 347
  if (__cil_tmp8) {
#line 347
    if ((unsigned long )__n <= sz / __size) {
      {
#line 350
      __cil_tmp10 = __builtin_constant_p(__n);
      }
      {
#line 350
      __cil_tmp9 = __builtin_constant_p(__size);
      }
#line 350
      if (__cil_tmp9) {
#line 350
        if (__cil_tmp10) {
#line 350
          if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 350
            if (__size * __n <= 8UL) {
#line 355
              __cnt = __size * __n;
#line 356
              __cptr = (char *)__ptr;
#line 357
              if (__cnt == 0UL) {
#line 358
                return ((size_t )0);
              }
              {
#line 360
              while (1) {
                while_continue: /* CIL Label */ ;
#line 360
                if (! (__cnt > 0UL)) {
#line 360
                  goto while_break;
                }
                {
#line 362
                __cil_tmp14 = getc_unlocked(__stream);
#line 362
                __c = __cil_tmp14;
                }
#line 363
                if (__c == -1) {
#line 364
                  goto while_break;
                }
#line 365
                __cil_tmp15 = __cptr;
#line 365
                __cptr ++;
#line 365
                *__cil_tmp15 = (char )__c;
#line 360
                __cnt --;
              }
              while_break: /* CIL Label */ ;
              }
#line 367
              return ((unsigned long )(__cptr - (char *)__ptr) / __size);
            }
          }
        }
      }
      {
#line 370
      __cil_tmp16 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
      }
#line 370
      return (__cil_tmp16);
    }
  }
  {
#line 372
  __cil_tmp18 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 372
  __cil_tmp17 = __builtin_constant_p(__n);
  }
#line 372
  if (__cil_tmp18) {
#line 372
    if (! ((unsigned long )__n <= sz / __size)) {
      {
#line 373
      __cil_tmp19 = __fread_unlocked_chk_warn(__ptr, sz, __size, __n, __stream);
      }
#line 373
      return (__cil_tmp19);
    }
  }
  {
#line 374
  __cil_tmp20 = __fread_unlocked_chk(__ptr, sz, __size, __n, __stream);
  }
#line 374
  return (__cil_tmp20);
}
}
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 184
extern  __attribute__((__nothrow__)) int setlogmask(int __mask ) ;
#line 190
__inline extern void syslog(int __pri , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 200
__inline extern void vsyslog(int __pri , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/syslog.h"
extern void __syslog_chk(int __pri , int __flag , char const   *__fmt  , ...) ;
#line 29
__inline extern void syslog(int __pri , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/syslog.h"
__inline extern void syslog(int __pri , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 31
  __cil_tmp3 = __builtin_va_arg_pack();
#line 31
  __syslog_chk(__pri, 1, __fmt, __cil_tmp3);
  }
  return;
}
}
#line 40
extern void __vsyslog_chk(int __pri , int __flag , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 45
__inline extern void vsyslog(int __pri , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 45 "/usr/include/x86_64-linux-gnu/bits/syslog.h"
__inline extern void vsyslog(int __pri , char const   *__fmt , __gnuc_va_list __ap ) 
{ 


  {
  {
#line 47
  __vsyslog_chk(__pri, 1, __fmt, __ap);
  }
  return;
}
}
#line 43 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 47
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 54
extern  __attribute__((__nothrow__)) void *memccpy(void *__dest , void const   *__src ,
                                                   int __c , size_t __n ) ;
#line 61
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 80
extern  __attribute__((__nothrow__)) int __memcmpeq(void const   *__s1 , void const   *__s2 ,
                                                    size_t __n ) ;
#line 107
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n ) ;
#line 120
extern  __attribute__((__nothrow__)) void *rawmemchr(void const   *__s , int __c ) ;
#line 133
extern  __attribute__((__nothrow__)) void *memrchr(void const   *__s , int __c , size_t __n ) ;
#line 141
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 144
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 149
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 152
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 156
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 159
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 163
extern  __attribute__((__nothrow__)) int strcoll(char const   *__s1 , char const   *__s2 ) ;
#line 166
extern  __attribute__((__nothrow__)) unsigned long strxfrm(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 175
extern  __attribute__((__nothrow__)) int strcoll_l(char const   *__s1 , char const   *__s2 ,
                                                   locale_t __l ) ;
#line 179
extern  __attribute__((__nothrow__)) size_t strxfrm_l(char *__dest , char const   *__src ,
                                                      size_t __n , locale_t __l ) ;
#line 187
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s ) ;
#line 195
extern  __attribute__((__nothrow__)) char *strndup(char const   *__string , size_t __n ) ;
#line 246
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 273
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 286
extern  __attribute__((__nothrow__)) char *strchrnul(char const   *__s , int __c ) ;
#line 293
extern  __attribute__((__nothrow__)) unsigned long strcspn(char const   *__s , char const   *__reject ) ;
#line 297
extern  __attribute__((__nothrow__)) unsigned long strspn(char const   *__s , char const   *__accept ) ;
#line 323
extern  __attribute__((__nothrow__)) char *strpbrk(char const   *__s , char const   *__accept ) ;
#line 350
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 356
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 361
extern  __attribute__((__nothrow__)) char *__strtok_r(char *__s , char const   *__delim ,
                                                      char **__save_ptr ) ;
#line 366
extern  __attribute__((__nothrow__)) char *strtok_r(char *__s , char const   *__delim ,
                                                    char **__save_ptr ) ;
#line 380
extern  __attribute__((__nothrow__)) char *strcasestr(char const   *__haystack , char const   *__needle ) ;
#line 389
extern  __attribute__((__nothrow__)) void *memmem(void const   *__haystack , size_t __haystacklen ,
                                                  void const   *__needle , size_t __needlelen ) ;
#line 397
extern  __attribute__((__nothrow__)) void *__mempcpy(void *__dest , void const   *__src ,
                                                     size_t __n ) ;
#line 400
__inline extern  __attribute__((__nothrow__)) void *mempcpy(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 407
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 413
extern  __attribute__((__nothrow__)) size_t strnlen(char const   *__string , size_t __maxlen ) ;
#line 419
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 444
extern  __attribute__((__nothrow__)) char *strerror_r(int __errnum , char *__buf ,
                                                      size_t __buflen ) ;
#line 450
extern  __attribute__((__nothrow__)) char const   *strerrordesc_np(int __err ) ;
#line 452
extern  __attribute__((__nothrow__)) char const   *strerrorname_np(int __err ) ;
#line 458
extern  __attribute__((__nothrow__)) char *strerror_l(int __errnum , locale_t __l ) ;
#line 34 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int bcmp(void const   *__s1 , void const   *__s2 ,
                                              size_t __n ) ;
#line 38
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 42
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 68
extern  __attribute__((__nothrow__)) char *index(char const   *__s , int __c ) ;
#line 96
extern  __attribute__((__nothrow__)) char *rindex(char const   *__s , int __c ) ;
#line 104
extern  __attribute__((__nothrow__)) int ffs(int __i ) ;
#line 110
extern  __attribute__((__nothrow__)) int ffsl(long __l ) ;
#line 111
extern  __attribute__((__nothrow__)) int ffsll(long long __ll ) ;
#line 116
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 120
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n ) ;
#line 128
extern  __attribute__((__nothrow__)) int strcasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                      locale_t __loc ) ;
#line 133
extern  __attribute__((__nothrow__)) int strncasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                       size_t __n , locale_t __loc ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bcopy(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 25
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 25
  __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
  return;
}
}
#line 30
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 32
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 32
  __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
  return;
}
}
#line 466 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 471
extern  __attribute__((__nothrow__)) char *strsep(char **__stringp , char const   *__delim ) ;
#line 478
extern  __attribute__((__nothrow__)) char *strsignal(int __sig ) ;
#line 482
extern  __attribute__((__nothrow__)) char const   *sigabbrev_np(int __sig ) ;
#line 485
extern  __attribute__((__nothrow__)) char const   *sigdescr_np(int __sig ) ;
#line 489
extern  __attribute__((__nothrow__)) char *__stpcpy(char *__dest , char const   *__src ) ;
#line 491
__inline extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 496
extern  __attribute__((__nothrow__)) char *__stpncpy(char *__dest , char const   *__src ,
                                                     size_t __n ) ;
#line 499
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 506
extern  __attribute__((__nothrow__)) int strverscmp(char const   *__s1 , char const   *__s2 ) ;
#line 510
extern  __attribute__((__nothrow__)) char *strfry(char *__string ) ;
#line 513
extern  __attribute__((__nothrow__)) void *memfrob(void *__s , size_t __n ) ;
#line 527
extern  __attribute__((__nothrow__)) char *basename(char const   *__filename ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 29
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 29
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 29
  return (__cil_tmp5);
}
}
#line 34
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memmove(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 36
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 36
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 36
  return (__cil_tmp5);
}
}
#line 42
__inline extern  __attribute__((__nothrow__)) void *mempcpy(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 42 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *mempcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 45
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 45
  __cil_tmp5 = __builtin___mempcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 45
  return (__cil_tmp5);
}
}
#line 57
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 57 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memset(void *__dest , int __ch , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 59
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 59
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 59
  return (__cil_tmp5);
}
}
#line 66
 __attribute__((__nothrow__)) void __explicit_bzero_chk(void *__dest , size_t __len ,
                                                        size_t __destlen ) ;
#line 70
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 70 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void explicit_bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 72
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 72
  __explicit_bzero_chk(__dest, __len, __cil_tmp3);
  }
  return;
}
}
#line 77
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 79
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 79
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 79
  return (__cil_tmp4);
}
}
#line 84
__inline extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 84 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 86
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 86
  __cil_tmp4 = __builtin___stpcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 86
  return (__cil_tmp4);
}
}
#line 92
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 92 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncpy(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 95
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 95
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 95
  return (__cil_tmp5);
}
}
#line 102
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 102 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpncpy(char *__dest , char const   *__src , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 104
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 104
  __cil_tmp5 = __builtin___stpncpy_chk(__dest, __src, __n, __cil_tmp4);
  }
#line 104
  return (__cil_tmp5);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcat(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 130
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 130
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 130
  return (__cil_tmp4);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncat(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 138
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 138
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 138
  return (__cil_tmp5);
}
}
#line 98 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 102
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 105
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 108
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 113
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 118
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 124
extern  __attribute__((__nothrow__)) float strtof(char const   *__nptr , char **__endptr ) ;
#line 127
extern  __attribute__((__nothrow__)) long double strtold(char const   *__nptr , char **__endptr ) ;
#line 141
extern  __attribute__((__nothrow__)) int strtof32(char const   *__nptr , char **__endptr ) ;
#line 147
extern  __attribute__((__nothrow__)) int strtof64(char const   *__nptr , char **__endptr ) ;
#line 153
extern  __attribute__((__nothrow__)) int strtof128(char const   *__nptr , char **__endptr ) ;
#line 159
extern  __attribute__((__nothrow__)) int strtof32x(char const   *__nptr , char **__endptr ) ;
#line 165
extern  __attribute__((__nothrow__)) int strtof64x(char const   *__nptr , char **__endptr ) ;
#line 177
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 181
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   *__nptr ,
                                                           char **__endptr , int __base ) ;
#line 188
extern  __attribute__((__nothrow__)) long long strtoq(char const   *__nptr , char **__endptr ,
                                                      int __base ) ;
#line 193
extern  __attribute__((__nothrow__)) unsigned long long strtouq(char const   *__nptr ,
                                                                char **__endptr ,
                                                                int __base ) ;
#line 201
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 206
extern  __attribute__((__nothrow__)) unsigned long long strtoull(char const   *__nptr ,
                                                                 char **__endptr ,
                                                                 int __base ) ;
#line 213
extern  __attribute__((__nothrow__)) int strfromd(char *__dest , size_t __size , char const   *__format ,
                                                  double __f ) ;
#line 217
extern  __attribute__((__nothrow__)) int strfromf(char *__dest , size_t __size , char const   *__format ,
                                                  float __f ) ;
#line 221
extern  __attribute__((__nothrow__)) int strfroml(char *__dest , size_t __size , char const   *__format ,
                                                  long double __f ) ;
#line 233
extern  __attribute__((__nothrow__)) int strfromf32(char *__dest , size_t __size ,
                                                    char const   *__format , int __f ) ;
#line 239
extern  __attribute__((__nothrow__)) int strfromf64(char *__dest , size_t __size ,
                                                    char const   *__format , int __f ) ;
#line 245
extern  __attribute__((__nothrow__)) int strfromf128(char *__dest , size_t __size ,
                                                     char const   *__format , int __f ) ;
#line 251
extern  __attribute__((__nothrow__)) int strfromf32x(char *__dest , size_t __size ,
                                                     char const   *__format , int __f ) ;
#line 257
extern  __attribute__((__nothrow__)) int strfromf64x(char *__dest , size_t __size ,
                                                     char const   *__format , int __f ) ;
#line 275
extern  __attribute__((__nothrow__)) long strtol_l(char const   *__nptr , char **__endptr ,
                                                   int __base , locale_t __loc ) ;
#line 279
extern  __attribute__((__nothrow__)) unsigned long strtoul_l(char const   *__nptr ,
                                                             char **__endptr , int __base ,
                                                             locale_t __loc ) ;
#line 285
extern  __attribute__((__nothrow__)) long long strtoll_l(char const   *__nptr , char **__endptr ,
                                                         int __base , locale_t __loc ) ;
#line 291
extern  __attribute__((__nothrow__)) unsigned long long strtoull_l(char const   *__nptr ,
                                                                   char **__endptr ,
                                                                   int __base , locale_t __loc ) ;
#line 296
extern  __attribute__((__nothrow__)) double strtod_l(char const   *__nptr , char **__endptr ,
                                                     locale_t __loc ) ;
#line 300
extern  __attribute__((__nothrow__)) float strtof_l(char const   *__nptr , char **__endptr ,
                                                    locale_t __loc ) ;
#line 304
extern  __attribute__((__nothrow__)) long double strtold_l(char const   *__nptr ,
                                                           char **__endptr , locale_t __loc ) ;
#line 317
extern  __attribute__((__nothrow__)) int strtof32_l(char const   *__nptr , char **__endptr ,
                                                    locale_t __loc ) ;
#line 324
extern  __attribute__((__nothrow__)) int strtof64_l(char const   *__nptr , char **__endptr ,
                                                    locale_t __loc ) ;
#line 331
extern  __attribute__((__nothrow__)) int strtof128_l(char const   *__nptr , char **__endptr ,
                                                     locale_t __loc ) ;
#line 338
extern  __attribute__((__nothrow__)) int strtof32x_l(char const   *__nptr , char **__endptr ,
                                                     locale_t __loc ) ;
#line 345
extern  __attribute__((__nothrow__)) int strtof64x_l(char const   *__nptr , char **__endptr ,
                                                     locale_t __loc ) ;
#line 362
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 362 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 364
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 364
  return ((int )__cil_tmp2);
}
}
#line 367
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 367 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 369
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 369
  return (__cil_tmp2);
}
}
#line 374
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 374 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 376
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 376
  return (__cil_tmp2);
}
}
#line 386
extern  __attribute__((__nothrow__)) char *l64a(long __n ) ;
#line 389
extern  __attribute__((__nothrow__)) long a64l(char const   *__s ) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 
  short __cil_tmp2 ;

  {
  {
#line 37
  __cil_tmp2 = __builtin_bswap16(__bsx);
  }
#line 37
  return (__cil_tmp2);
}
}
#line 49 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 52
  __cil_tmp2 = __builtin_bswap32(__bsx);
  }
#line 52
  return (__cil_tmp2);
}
}
#line 70 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 73
  __cil_tmp2 = __builtin_bswap64(__bsx);
  }
#line 73
  return (__cil_tmp2);
}
}
#line 33 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint16_t __uint16_identity(__uint16_t __x ) 
{ 


  {
#line 35
  return (__x);
}
}
#line 39 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint32_t __uint32_identity(__uint32_t __x ) 
{ 


  {
#line 41
  return (__x);
}
}
#line 45 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint64_t __uint64_identity(__uint64_t __x ) 
{ 


  {
#line 47
  return (__x);
}
}
#line 102 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                  struct timeval *__timeout ) ;
#line 127
extern int pselect(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                   struct timespec *__timeout , __sigset_t *__sigmask ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/select2.h"
extern long __fdelt_chk(long __d ) ;
#line 25
extern long __fdelt_warn(long __d ) ;
#line 402 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long random(void) ;
#line 405
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
#line 411
extern  __attribute__((__nothrow__)) char *initstate(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen ) ;
#line 416
extern  __attribute__((__nothrow__)) char *setstate(char *__statebuf ) ;
#line 435
extern  __attribute__((__nothrow__)) int random_r(struct random_data *__buf , int32_t *__result ) ;
#line 438
extern  __attribute__((__nothrow__)) int srandom_r(unsigned int __seed , struct random_data *__buf ) ;
#line 441
extern  __attribute__((__nothrow__)) int initstate_r(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen , struct random_data *__buf ) ;
#line 446
extern  __attribute__((__nothrow__)) int setstate_r(char *__statebuf , struct random_data *__buf ) ;
#line 454
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 456
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 460
extern  __attribute__((__nothrow__)) int rand_r(unsigned int *__seed ) ;
#line 468
extern  __attribute__((__nothrow__)) double drand48(void) ;
#line 469
extern  __attribute__((__nothrow__)) double erand48(unsigned short __xsubi[3] ) ;
#line 472
extern  __attribute__((__nothrow__)) long lrand48(void) ;
#line 473
extern  __attribute__((__nothrow__)) long nrand48(unsigned short __xsubi[3] ) ;
#line 477
extern  __attribute__((__nothrow__)) long mrand48(void) ;
#line 478
extern  __attribute__((__nothrow__)) long jrand48(unsigned short __xsubi[3] ) ;
#line 482
extern  __attribute__((__nothrow__)) void srand48(long __seedval ) ;
#line 483
extern  __attribute__((__nothrow__)) unsigned short *seed48(unsigned short __seed16v[3] ) ;
#line 485
extern  __attribute__((__nothrow__)) void lcong48(unsigned short __param[7] ) ;
#line 502
extern  __attribute__((__nothrow__)) int drand48_r(struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 504
extern  __attribute__((__nothrow__)) int erand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 509
extern  __attribute__((__nothrow__)) int lrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 512
extern  __attribute__((__nothrow__)) int nrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 518
extern  __attribute__((__nothrow__)) int mrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 521
extern  __attribute__((__nothrow__)) int jrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 527
extern  __attribute__((__nothrow__)) int srand48_r(long __seedval , struct drand48_data *__buffer ) ;
#line 530
extern  __attribute__((__nothrow__)) int seed48_r(unsigned short __seed16v[3] , struct drand48_data *__buffer ) ;
#line 533
extern  __attribute__((__nothrow__)) int lcong48_r(unsigned short __param[7] , struct drand48_data *__buffer ) ;
#line 540
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 551
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 555
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 563
extern  __attribute__((__nothrow__)) void *reallocarray(void *__ptr , size_t __nmemb ,
                                                        size_t __size ) ;
#line 32 "/usr/include/alloca.h"
extern  __attribute__((__nothrow__)) void *alloca(size_t __size ) ;
#line 580 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *valloc(size_t __size ) ;
#line 586
extern  __attribute__((__nothrow__)) int posix_memalign(void **__memptr , size_t __alignment ,
                                                        size_t __size ) ;
#line 592
extern  __attribute__((__nothrow__)) void *aligned_alloc(size_t __alignment , size_t __size ) ;
#line 598
extern  __attribute__((__nothrow__)) void abort(void) ;
#line 602
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) ) ;
#line 610
extern  __attribute__((__nothrow__)) int at_quick_exit(void (*__func)(void) ) ;
#line 617
extern  __attribute__((__nothrow__)) int on_exit(void (*__func)(int  , void * ) ,
                                                 void *__arg ) ;
#line 624
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 630
extern  __attribute__((__nothrow__)) void quick_exit(int __status ) ;
#line 636
extern  __attribute__((__nothrow__)) void _Exit(int __status ) ;
#line 641
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 646
extern  __attribute__((__nothrow__)) char *secure_getenv(char const   *__name ) ;
#line 654
extern  __attribute__((__nothrow__)) int putenv(char *__string ) ;
#line 660
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace ) ;
#line 664
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 671
extern  __attribute__((__nothrow__)) int clearenv(void) ;
#line 682
extern  __attribute__((__nothrow__)) char *mktemp(char *__template ) ;
#line 695
extern int mkstemp(char *__template ) ;
#line 705
extern int mkstemp64(char *__template ) ;
#line 717
extern int mkstemps(char *__template , int __suffixlen ) ;
#line 727
extern int mkstemps64(char *__template , int __suffixlen ) ;
#line 738
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template ) ;
#line 749
extern int mkostemp(char *__template , int __flags ) ;
#line 759
extern int mkostemp64(char *__template , int __flags ) ;
#line 769
extern int mkostemps(char *__template , int __suffixlen , int __flags ) ;
#line 781
extern int mkostemps64(char *__template , int __suffixlen , int __flags ) ;
#line 791
extern int system(char const   *__command ) ;
#line 797
extern  __attribute__((__nothrow__)) char *canonicalize_file_name(char const   *__name ) ;
#line 808
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 828
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;
  int __cil_tmp11 ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void const   *)((char const   *)__base + __idx * __size);
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 44
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  return ((void *)0);
}
}
#line 838 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) ;
#line 841
extern void qsort_r(void *__base , size_t __nmemb , size_t __size , __compar_d_fn_t __compar ,
                    void *__arg ) ;
#line 848
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 849
extern  __attribute__((__nothrow__)) long labs(long __x ) ;
#line 852
extern  __attribute__((__nothrow__)) long long llabs(long long __x ) ;
#line 860
extern  __attribute__((__nothrow__)) div_t div(int __numer , int __denom ) ;
#line 862
extern  __attribute__((__nothrow__)) ldiv_t ldiv(long __numer , long __denom ) ;
#line 866
extern  __attribute__((__nothrow__)) lldiv_t lldiv(long long __numer , long long __denom ) ;
#line 880
extern  __attribute__((__nothrow__)) char *ecvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 886
extern  __attribute__((__nothrow__)) char *fcvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 892
extern  __attribute__((__nothrow__)) char *gcvt(double __value , int __ndigit , char *__buf ) ;
#line 898
extern  __attribute__((__nothrow__)) char *qecvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 901
extern  __attribute__((__nothrow__)) char *qfcvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 904
extern  __attribute__((__nothrow__)) char *qgcvt(long double __value , int __ndigit ,
                                                 char *__buf ) ;
#line 910
extern  __attribute__((__nothrow__)) int ecvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 913
extern  __attribute__((__nothrow__)) int fcvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 917
extern  __attribute__((__nothrow__)) int qecvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 921
extern  __attribute__((__nothrow__)) int qfcvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 930
extern  __attribute__((__nothrow__)) int mblen(char const   *__s , size_t __n ) ;
#line 933
extern  __attribute__((__nothrow__)) int mbtowc(wchar_t *__pwc , char const   *__s ,
                                                size_t __n ) ;
#line 937
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 941
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 945
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 956
extern  __attribute__((__nothrow__)) int rpmatch(char const   *__response ) ;
#line 967
extern  __attribute__((__nothrow__)) int getsubopt(char **__optionp , char * const  *__tokens ,
                                                   char **__valuep ) ;
#line 978
extern int posix_openpt(int __oflag ) ;
#line 986
extern  __attribute__((__nothrow__)) int grantpt(int __fd ) ;
#line 990
extern  __attribute__((__nothrow__)) int unlockpt(int __fd ) ;
#line 995
extern  __attribute__((__nothrow__)) char *ptsname(int __fd ) ;
#line 1002
__inline extern  __attribute__((__nothrow__)) int ptsname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 1006
extern int getpt(void) ;
#line 1013
extern  __attribute__((__nothrow__)) int getloadavg(double __loadavg[] , int __nelem ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 29
extern  __attribute__((__nothrow__)) char *__realpath_chk_warn(char const   *__name ,
                                                               char *__resolved ,
                                                               size_t __resolvedlen ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 39
  __cil_tmp4 = __builtin_object_size(__resolved, 1);
#line 39
  sz = __cil_tmp4;
  }
#line 41
  if (sz == 0xffffffffffffffffUL) {
    {
#line 42
    __cil_tmp5 = __realpath_alias(__name, __resolved);
    }
#line 42
    return (__cil_tmp5);
  }
  {
#line 48
  __cil_tmp6 = __realpath_chk(__name, __resolved, sz);
  }
#line 48
  return (__cil_tmp6);
}
}
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 55
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 58
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 65
__inline extern  __attribute__((__nothrow__)) int ptsname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 65 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ptsname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 67
  __cil_tmp7 = __builtin_object_size(__buf, 1);
  }
  {
#line 67
  __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 67
  __cil_tmp6 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 67
  __cil_tmp4 = __builtin_constant_p(__buflen);
  }
#line 67
  if (__cil_tmp6 && (unsigned long )__buflen <= __cil_tmp7 / sizeof(char )) {
    {
#line 67
    __cil_tmp8 = __ptsname_r_alias(__fd, __buf, __buflen);
#line 67
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 67
    __cil_tmp12 = __builtin_object_size(__buf, 1);
    }
    {
#line 67
    __cil_tmp10 = __builtin_object_size(__buf, 1);
#line 67
    __cil_tmp11 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 67
    __cil_tmp9 = __builtin_constant_p(__buflen);
    }
#line 67
    if (__cil_tmp11 && ! ((unsigned long )__buflen <= __cil_tmp12 / sizeof(char ))) {
      {
#line 67
      __cil_tmp13 = __builtin_object_size(__buf, 1);
#line 67
      __cil_tmp14 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp13);
#line 67
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 67
      __cil_tmp15 = __builtin_object_size(__buf, 1);
#line 67
      __cil_tmp16 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp15);
#line 67
      tmp = __cil_tmp16;
      }
    }
#line 67
    tmp___0 = tmp;
  }
#line 67
  return (tmp___0);
}
}
#line 73
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 75
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 79
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 79 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int wctomb(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 88
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 88
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
#line 88
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 88
    if (16UL > __cil_tmp4) {
      {
#line 90
      __cil_tmp5 = __builtin_object_size(__s, 1);
#line 90
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 90
      return (__cil_tmp6);
    }
  }
  {
#line 91
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 91
  return (__cil_tmp7);
}
}
#line 95
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 99
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 104
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 112
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 112 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t mbstowcs(wchar_t *__dst , char const   *__src , size_t __len ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  size_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  size_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 115
  __cil_tmp7 = __builtin_object_size(__dst, 1);
  }
  {
#line 115
  __cil_tmp5 = __builtin_object_size(__dst, 1);
#line 115
  __cil_tmp6 = __builtin_constant_p((unsigned long )__len <= __cil_tmp5 / sizeof(wchar_t ));
  }
  {
#line 115
  __cil_tmp4 = __builtin_constant_p(__len);
  }
#line 115
  if (__cil_tmp6 && (unsigned long )__len <= __cil_tmp7 / sizeof(wchar_t )) {
    {
#line 115
    __cil_tmp8 = __mbstowcs_alias(__dst, __src, __len);
#line 115
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 115
    __cil_tmp12 = __builtin_object_size(__dst, 1);
    }
    {
#line 115
    __cil_tmp10 = __builtin_object_size(__dst, 1);
#line 115
    __cil_tmp11 = __builtin_constant_p((unsigned long )__len <= __cil_tmp10 / sizeof(wchar_t ));
    }
    {
#line 115
    __cil_tmp9 = __builtin_constant_p(__len);
    }
#line 115
    if (__cil_tmp11 && ! ((unsigned long )__len <= __cil_tmp12 / sizeof(wchar_t ))) {
      {
#line 115
      __cil_tmp13 = __builtin_object_size(__dst, 1);
#line 115
      __cil_tmp14 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp13 / sizeof(wchar_t ));
#line 115
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 115
      __cil_tmp15 = __builtin_object_size(__dst, 1);
#line 115
      __cil_tmp16 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp15 / sizeof(wchar_t ));
#line 115
      tmp = __cil_tmp16;
      }
    }
#line 115
    tmp___0 = tmp;
  }
#line 115
  return (tmp___0);
}
}
#line 121
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 125
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 137
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 137 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t wcstombs(char *__dst , wchar_t *__src , size_t __len ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  size_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  size_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 140
  __cil_tmp7 = __builtin_object_size(__dst, 1);
  }
  {
#line 140
  __cil_tmp5 = __builtin_object_size(__dst, 1);
#line 140
  __cil_tmp6 = __builtin_constant_p((unsigned long )__len <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 140
  __cil_tmp4 = __builtin_constant_p(__len);
  }
#line 140
  if (__cil_tmp6 && (unsigned long )__len <= __cil_tmp7 / sizeof(char )) {
    {
#line 140
    __cil_tmp8 = __wcstombs_alias(__dst, __src, __len);
#line 140
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 140
    __cil_tmp12 = __builtin_object_size(__dst, 1);
    }
    {
#line 140
    __cil_tmp10 = __builtin_object_size(__dst, 1);
#line 140
    __cil_tmp11 = __builtin_constant_p((unsigned long )__len <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 140
    __cil_tmp9 = __builtin_constant_p(__len);
    }
#line 140
    if (__cil_tmp11 && ! ((unsigned long )__len <= __cil_tmp12 / sizeof(char ))) {
      {
#line 140
      __cil_tmp13 = __builtin_object_size(__dst, 1);
#line 140
      __cil_tmp14 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp13);
#line 140
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 140
      __cil_tmp15 = __builtin_object_size(__dst, 1);
#line 140
      __cil_tmp16 = __wcstombs_chk(__dst, __src, __len, __cil_tmp15);
#line 140
      tmp = __cil_tmp16;
      }
    }
#line 140
    tmp___0 = tmp;
  }
#line 140
  return (tmp___0);
}
}
#line 31 "../include/getopt.h"
extern char *optarg ;
#line 45
extern int optind ;
#line 50
extern int opterr ;
#line 54
extern int optopt ;
#line 104
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 106
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option *longopts , int *longind ) ;
#line 108
extern int getopt_long_only(int argc , char * const  *argv , char const   *shortopts ,
                            struct option *longopts , int *longind ) ;
#line 113
extern int _getopt_internal(int argc , char * const  *argv , char const   *shortopts ,
                            struct option *longopts , int *longind , int long_only ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void) ;
#line 45
extern char *program_invocation_name ;
#line 46
extern char *program_invocation_short_name ;
#line 218 "/usr/include/sane/sane.h"
extern SANE_Status sane_init(SANE_Int *version_code , SANE_Auth_Callback authorize ) ;
#line 220
extern void sane_exit(void) ;
#line 221
extern SANE_Status sane_get_devices(SANE_Device ***device_list , SANE_Bool local_only ) ;
#line 223
extern SANE_Status sane_open(SANE_String_Const devicename , SANE_Handle *handle ) ;
#line 225
extern void sane_close(SANE_Handle handle ) ;
#line 227
extern SANE_Option_Descriptor *sane_get_option_descriptor(SANE_Handle handle , SANE_Int option ) ;
#line 228
extern SANE_Status sane_control_option(SANE_Handle handle , SANE_Int option , SANE_Action action ,
                                       void *value , SANE_Int *info ) ;
#line 231
extern SANE_Status sane_get_parameters(SANE_Handle handle , SANE_Parameters *params ) ;
#line 233
extern SANE_Status sane_start(SANE_Handle handle ) ;
#line 234
extern SANE_Status sane_read(SANE_Handle handle , SANE_Byte *data , SANE_Int max_length ,
                             SANE_Int *length ) ;
#line 236
extern void sane_cancel(SANE_Handle handle ) ;
#line 237
extern SANE_Status sane_set_io_mode(SANE_Handle handle , SANE_Bool non_blocking ) ;
#line 239
extern SANE_Status sane_get_select_fd(SANE_Handle handle , SANE_Int *fd ) ;
#line 241
extern SANE_String_Const sane_strstatus(SANE_Status status ) ;
#line 96 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/../include/sane/sanei_wire.h"
void sanei_w_init(Wire *w , void (*codec_init_func)(Wire * ) ) ;
#line 97
void sanei_w_exit(Wire *w ) ;
#line 98
void sanei_w_space(Wire *w , size_t howmuch ) ;
#line 99
void sanei_w_void(Wire *w ) ;
#line 100
void sanei_w_byte(Wire *w , SANE_Byte *v ) ;
#line 101
void sanei_w_char(Wire *w , SANE_Char *v ) ;
#line 102
void sanei_w_word(Wire *w , SANE_Word *v ) ;
#line 103
void sanei_w_bool(Wire *w , SANE_Bool *v ) ;
#line 104
void sanei_w_ptr(Wire *w , void **v , WireCodecFunc w_value , size_t value_size ) ;
#line 106
void sanei_w_string(Wire *w , SANE_String *v ) ;
#line 107
void sanei_w_status(Wire *w , SANE_Status *v ) ;
#line 108
void sanei_w_constraint_type(Wire *w , SANE_Constraint_Type *v ) ;
#line 109
void sanei_w_value_type(Wire *w , SANE_Value_Type *v ) ;
#line 110
void sanei_w_unit(Wire *w , SANE_Unit *v ) ;
#line 111
void sanei_w_action(Wire *w , SANE_Action *v ) ;
#line 112
void sanei_w_frame(Wire *w , SANE_Frame *v ) ;
#line 113
void sanei_w_range(Wire *w , SANE_Range *v ) ;
#line 114
extern void sanei_w_range_ptr(Wire *w , SANE_Range **v ) ;
#line 115
void sanei_w_device(Wire *w , SANE_Device *v ) ;
#line 116
void sanei_w_device_ptr(Wire *w , SANE_Device **v ) ;
#line 117
void sanei_w_option_descriptor(Wire *w , SANE_Option_Descriptor *v ) ;
#line 118
void sanei_w_option_descriptor_ptr(Wire *w , SANE_Option_Descriptor **v ) ;
#line 120
void sanei_w_parameters(Wire *w , SANE_Parameters *v ) ;
#line 122
void sanei_w_array(Wire *w , SANE_Word *len_ptr , void **v , WireCodecFunc w_element ,
                   size_t element_size ) ;
#line 125
void sanei_w_set_dir(Wire *w , WireDirection dir ) ;
#line 126
void sanei_w_call(Wire *w , SANE_Word procnum , WireCodecFunc w_arg , void *arg ,
                  WireCodecFunc w_reply , void *reply ) ;
#line 129
void sanei_w_reply(Wire *w , WireCodecFunc w_reply , void *reply ) ;
#line 130
void sanei_w_free(Wire *w , WireCodecFunc w_reply , void *reply ) ;
#line 163 "../include/sane/sanei.h"
extern SANE_Status sanei_check_value(SANE_Option_Descriptor *opt , void *value ) ;
#line 166
extern SANE_Status sanei_constrain_value(SANE_Option_Descriptor *opt , void *value ,
                                         SANE_Word *info ) ;
#line 170
int sanei_save_values(int fd , SANE_Handle device ) ;
#line 171
int sanei_load_values(int fd , SANE_Handle device ) ;
#line 113 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/../include/sane/sanei_debug.h"
int sanei_debug_sanei_wire  =    0;
#line 139
void sanei_debug_msg(int level , int max_level , char const   *be , char const   *fmt ,
                     va_list ap ) ;
#line 146
static void sanei_debug_sanei_wire_call(int level , char const   *msg  , ...) ;
#line 153 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/../include/sane/sanei_debug.h"
static void sanei_debug_sanei_wire_call(int level , char const   *msg  , ...) 
{ 
  va_list ap ;

  {
  {
#line 157
  __builtin_va_start((void *)ap, msg);
#line 158
  sanei_debug_msg(level, sanei_debug_sanei_wire, "sanei_wire?\366:V", msg, (void *)ap);
#line 159
  __builtin_va_end((void *)ap);
  }
  return;
}
}
#line 169
void sanei_init_debug(char const   *backend , int *var ) ;
#line 56 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_space(Wire *w , size_t howmuch ) 
{ 
  size_t nbytes ;
  size_t left_over ;
  int fd ;
  ssize_t nread ;
  ssize_t nwritten ;
  ssize_t __cil_tmp8 ;
  int *__cil_tmp9 ;
  int *__cil_tmp10 ;
  ssize_t __cil_tmp11 ;
  int *__cil_tmp12 ;
  int *__cil_tmp13 ;
  int *__cil_tmp14 ;

  {
  {
#line 59
  fd = w->io.fd;
#line 62
  sanei_debug_sanei_wire_call(3, "sanei_w_space: %lu bytes for wire %d\n", (u_long )howmuch,
                              fd);
  }
#line 64
  if (howmuch > w->buffer.size) {
    {
#line 65
    sanei_debug_sanei_wire_call(2, "sanei_w_space: bigger than buffer (%lu bytes), may be flush()\n",
                                (u_long )w->buffer.size);
    }
  }
#line 68
  if (w->status != 0) {
    {
#line 70
    sanei_debug_sanei_wire_call(1, "sanei_w_space: wire is in invalid state %d\n\366:V",
                                w->status);
    }
#line 72
    return;
  }
#line 75
  if (w->buffer.curr + howmuch > w->buffer.end) {
    {
#line 77
    sanei_debug_sanei_wire_call(4, "sanei_w_space: free buffer size is %lu\n", (u_long )(w->buffer.end - w->buffer.curr));
    }
    {
#line 81
    if ((unsigned int )w->direction == (unsigned int )0) {
#line 81
      goto case_0;
    }
#line 104
    if ((unsigned int )w->direction == (unsigned int )1) {
#line 104
      goto case_1;
    }
#line 144
    if ((unsigned int )w->direction == (unsigned int )2) {
#line 144
      goto case_2;
    }
#line 79
    goto switch_break;
    case_0: /* CIL Label */ 
#line 82
    nbytes = (size_t )(w->buffer.curr - w->buffer.start);
    {
#line 83
    w->buffer.curr = w->buffer.start;
#line 84
    sanei_debug_sanei_wire_call(4, "sanei_w_space: ENCODE: sending %lu bytes\n\344A\366:V",
                                (u_long )nbytes);
    }
    {
#line 86
    while (1) {
      while_continue: /* CIL Label */ ;
#line 86
      if (! (nbytes > 0UL)) {
#line 86
        goto while_break;
      }
      {
#line 88
      nwritten = (*(w->io.write))(fd, w->buffer.curr, nbytes);
      }
#line 89
      if (nwritten < 0L) {
        {
#line 91
        __cil_tmp9 = __errno_location();
#line 91
        sanei_debug_sanei_wire_call(1, "sanei_w_space: ENCODE: write failed (%d)\n%\001",
                                    *__cil_tmp9);
#line 92
        w->status = (int )__errno_location();
        }
#line 93
        return;
      }
#line 95
      w->buffer.curr += nwritten;
#line 96
      nbytes -= (unsigned long )nwritten;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 98
    w->buffer.curr = w->buffer.start;
#line 99
    w->buffer.end = w->buffer.start + w->buffer.size;
#line 100
    sanei_debug_sanei_wire_call(4, "sanei_w_space: ENCODE: free buffer is now %lu\n",
                                (u_long )w->buffer.size);
    }
#line 102
    goto switch_break;
    case_1: /* CIL Label */ 
#line 105
    left_over = (size_t )(w->buffer.end - w->buffer.curr);
#line 107
    if ((int )left_over < 0) {
      {
#line 109
      sanei_debug_sanei_wire_call(1, "sanei_w_space: DECODE: buffer underflow\n\220");
      }
#line 110
      return;
    }
#line 113
    if (left_over) {
      {
#line 115
      sanei_debug_sanei_wire_call(4, "sanei_w_space: DECODE: %lu bytes left in buffer\n\230\001",
                                  (u_long )left_over);
#line 117
      memmove(w->buffer.start, w->buffer.curr, left_over);
      }
    }
    {
#line 119
    w->buffer.curr = w->buffer.start;
#line 120
    w->buffer.end = w->buffer.start + left_over;
#line 122
    sanei_debug_sanei_wire_call(4, "sanei_w_space: DECODE: receiving data\n");
    }
    {
#line 123
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 125
      nread = (*(w->io.read))(fd, w->buffer.end, w->buffer.size - left_over);
      }
#line 127
      if (nread <= 0L) {
        {
#line 129
        __cil_tmp12 = __errno_location();
#line 129
        sanei_debug_sanei_wire_call(2, "sanei_w_space: DECODE: no data received (%d)\n",
                                    *__cil_tmp12);
        }
#line 131
        if (nread == 0L) {
          {
#line 132
          __cil_tmp13 = __errno_location();
#line 132
          *__cil_tmp13 = 22;
          }
        }
        {
#line 133
        w->status = (int )__errno_location();
        }
#line 134
        return;
      }
#line 136
      left_over += (unsigned long )nread;
#line 137
      w->buffer.end += nread;
#line 123
      if (! (left_over < howmuch)) {
#line 123
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 140
    sanei_debug_sanei_wire_call(4, "sanei_w_space: DECODE: %lu bytes read\n", (u_long )(w->buffer.end - w->buffer.start));
    }
#line 142
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 145
    sanei_debug_sanei_wire_call(4, "sanei_w_space: FREE: doing nothing for free operation\n");
    }
#line 146
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 149
  sanei_debug_sanei_wire_call(4, "sanei_w_space: done\n");
  }
  return;
}
}
#line 153 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_void(Wire *w ) 
{ 


  {
  {
#line 155
  sanei_debug_sanei_wire_call(3, "sanei_w_void: wire %d (void debug output)\n", w->io.fd);
  }
  return;
}
}
#line 159 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_array(Wire *w , SANE_Word *len_ptr , void **v , WireCodecFunc w_element ,
                   size_t element_size ) 
{ 
  SANE_Word len ;
  char *val ;
  int i ;
  void *__cil_tmp9 ;

  {
  {
#line 166
  sanei_debug_sanei_wire_call(3, "sanei_w_array: wire %d, elements of size %lu\n",
                              w->io.fd, (u_long )element_size);
  }
#line 169
  if ((unsigned int )w->direction == 2U) {
#line 171
    if (*v) {
#line 171
      if (*len_ptr) {
        {
#line 173
        sanei_debug_sanei_wire_call(4, "sanei_w_array: FREE: freeing array (%d elements)\n",
                                    *len_ptr);
#line 175
        val = *v;
#line 176
        i = 0;
        }
        {
#line 176
        while (1) {
          while_continue: /* CIL Label */ ;
#line 176
          if (! (i < *len_ptr)) {
#line 176
            goto while_break;
          }
          {
#line 178
          (*w_element)(w, val);
#line 179
          val += element_size;
          }
#line 176
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 181
        free(*v);
#line 182
        w->allocated_memory -= (unsigned long )*len_ptr * element_size;
        }
      } else {
        {
        {
#line 185
        sanei_debug_sanei_wire_call(1, "sanei_w_array: FREE: tried to free array but *len_ptr or *v was NULL\n");
        }
        }
      }
    } else {
      {
      {
#line 185
      sanei_debug_sanei_wire_call(1, "sanei_w_array: FREE: tried to free array but *len_ptr or *v was NULL\n");
      }
      }
    }
    {
#line 188
    sanei_debug_sanei_wire_call(4, "sanei_w_array: FREE: done\n");
    }
#line 189
    return;
  }
#line 192
  if ((unsigned int )w->direction == 0U) {
#line 193
    len = *len_ptr;
  }
  {
#line 194
  sanei_debug_sanei_wire_call(4, "sanei_w_array: send/receive array length\n");
#line 195
  sanei_w_word(w, & len);
  }
#line 197
  if (w->status) {
    {
#line 199
    sanei_debug_sanei_wire_call(1, "sanei_w_array: bad status: %d\n", w->status);
    }
#line 200
    return;
  }
  {
#line 202
  sanei_debug_sanei_wire_call(4, "sanei_w_array: array has %d elements\n", len);
  }
#line 204
  if ((unsigned int )w->direction == 1U) {
#line 206
    *len_ptr = len;
#line 207
    if (len) {
#line 209
      if ((unsigned int )len > 1048576U) {
        {
        {
        {
#line 213
        sanei_debug_sanei_wire_call(0, "sanei_w_array: DECODE: maximum amount of allocated memory exceeded (limit: %u, new allocation: %u, total: %u bytes)\n\251",
                                    1048576, (unsigned long )len * element_size, 1048576UL + (unsigned long )len * element_size);
        }
        }
#line 216
        w->status = 12;
        }
#line 217
        return;
      } else
#line 209
      if ((unsigned long )((unsigned int )len) * element_size > 1048576UL) {
        {
        {
        {
#line 213
        sanei_debug_sanei_wire_call(0, "sanei_w_array: DECODE: maximum amount of allocated memory exceeded (limit: %u, new allocation: %u, total: %u bytes)\n\251",
                                    1048576, (unsigned long )len * element_size, 1048576UL + (unsigned long )len * element_size);
        }
        }
#line 216
        w->status = 12;
        }
#line 217
        return;
      } else
#line 209
      if ((unsigned long )w->allocated_memory + (unsigned long )len * element_size > 1048576UL) {
        {
        {
        {
#line 213
        sanei_debug_sanei_wire_call(0, "sanei_w_array: DECODE: maximum amount of allocated memory exceeded (limit: %u, new allocation: %u, total: %u bytes)\n\251",
                                    1048576, (unsigned long )len * element_size, 1048576UL + (unsigned long )len * element_size);
        }
        }
#line 216
        w->status = 12;
        }
#line 217
        return;
      }
      {
#line 219
      *v = malloc((unsigned long )len * element_size);
      }
#line 220
      if (*v == (void *)0) {
        {
#line 223
        sanei_debug_sanei_wire_call(1, "sanei_w_array: DECODE: not enough free memory\n");
#line 224
        w->status = 12;
        }
#line 225
        return;
      }
      {
#line 227
      memset(*v, 0, (unsigned long )len * element_size);
#line 228
      w->allocated_memory += (unsigned long )len * element_size;
      }
    } else {
#line 231
      *v = (void *)0;
    }
  }
  {
#line 234
  val = *v;
#line 235
  sanei_debug_sanei_wire_call(4, "sanei_w_array: transferring array elements\n");
#line 236
  i = 0;
  }
  {
#line 236
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 236
    if (! (i < len)) {
#line 236
      goto while_break___0;
    }
    {
#line 238
    (*w_element)(w, val);
#line 239
    val += element_size;
    }
#line 240
    if (w->status) {
      {
#line 242
      sanei_debug_sanei_wire_call(1, "sanei_w_array: bad status: %d\n", w->status);
      }
#line 243
      return;
    }
#line 236
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 246
  sanei_debug_sanei_wire_call(4, "sanei_w_array: done\n");
  }
  return;
}
}
#line 250 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_ptr(Wire *w , void **v , WireCodecFunc w_value , size_t value_size ) 
{ 
  SANE_Word is_null ;
  void *__cil_tmp6 ;

  {
  {
#line 254
  sanei_debug_sanei_wire_call(3, "sanei_w_ptr: wire %d, value pointer at is %lu bytes\n",
                              w->io.fd, (u_long )value_size);
  }
#line 257
  if ((unsigned int )w->direction == 2U) {
#line 259
    if (*v) {
#line 259
      if (value_size) {
        {
#line 261
        sanei_debug_sanei_wire_call(4, "sanei_w_ptr: FREE: freeing value\n");
#line 262
        (*w_value)(w, *v);
#line 263
        free(*v);
#line 264
        w->allocated_memory -= value_size;
        }
      } else {
        {
        {
#line 267
        sanei_debug_sanei_wire_call(1, "sanei_w_ptr: FREE: tried to free value but *v or value_size was NULL\n");
        }
        }
      }
    } else {
      {
      {
#line 267
      sanei_debug_sanei_wire_call(1, "sanei_w_ptr: FREE: tried to free value but *v or value_size was NULL\n");
      }
      }
    }
    {
#line 270
    sanei_debug_sanei_wire_call(4, "sanei_w_ptr: FREE: done\n\220");
    }
#line 271
    return;
  }
#line 273
  if ((unsigned int )w->direction == 0U) {
#line 274
    is_null = *v == (void *)0;
  }
  {
#line 276
  sanei_debug_sanei_wire_call(4, "sanei_w_ptr: send/receive is_null\n");
#line 277
  sanei_w_word(w, & is_null);
  }
#line 278
  if (w->status) {
    {
#line 280
    sanei_debug_sanei_wire_call(1, "sanei_w_ptr: bad status: %d\n", w->status);
    }
#line 281
    return;
  }
#line 284
  if (! is_null) {
#line 286
    if ((unsigned int )w->direction == 1U) {
      {
#line 288
      sanei_debug_sanei_wire_call(4, "sanei_w_ptr: DECODE: receive data pointed at\n");
      }
#line 289
      if (value_size > 1048576UL) {
        {
#line 291
        sanei_debug_sanei_wire_call(0, "sanei_w_ptr: DECODE: maximum amount of allocated memory exceeded (limit: %u, new allocation: %u, total: %u bytes)\n",
                                    1048576, value_size, (unsigned long )w->allocated_memory + value_size);
#line 294
        w->status = 12;
        }
#line 295
        return;
      }
      {
#line 298
      *v = malloc(value_size);
      }
#line 299
      if (*v == (void *)0) {
        {
#line 302
        sanei_debug_sanei_wire_call(1, "sanei_w_ptr: DECODE: not enough free memory\n");
#line 303
        w->status = 12;
        }
#line 304
        return;
      }
      {
#line 306
      w->allocated_memory += value_size;
#line 307
      memset(*v, 0, value_size);
      }
    }
    {
#line 309
    (*w_value)(w, *v);
    }
  } else
#line 311
  if ((unsigned int )w->direction == 1U) {
#line 312
    *v = (void *)0;
  }
  {
#line 314
  sanei_debug_sanei_wire_call(4, "sanei_w_ptr: done\n");
  }
  return;
}
}
#line 318 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_byte(Wire *w , SANE_Byte *v ) 
{ 


  {
  {
#line 320
  sanei_debug_sanei_wire_call(3, "sanei_w_byte: wire %d\n", w->io.fd);
#line 321
  (*(w->codec.w_byte))(w, v);
  }
#line 322
  if ((unsigned int )w->direction != 2U) {
    {
#line 323
    sanei_debug_sanei_wire_call(4, "sanei_w_byte: value = %d\n", (int )*v);
    }
  }
  return;
}
}
#line 327 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_char(Wire *w , SANE_Char *v ) 
{ 


  {
  {
#line 329
  sanei_debug_sanei_wire_call(3, "sanei_w_char: wire %d\n", w->io.fd);
#line 330
  (*(w->codec.w_char))(w, v);
  }
#line 331
  if ((unsigned int )w->direction != 2U) {
    {
#line 332
    sanei_debug_sanei_wire_call(4, "sanei_w_char: value = %d\n", (int )*v);
    }
  }
  return;
}
}
#line 336 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_word(Wire *w , SANE_Word *v ) 
{ 


  {
  {
#line 338
  sanei_debug_sanei_wire_call(3, "sanei_w_word: wire %d\n", w->io.fd);
#line 339
  (*(w->codec.w_word))(w, v);
  }
#line 340
  if ((unsigned int )w->direction != 2U) {
    {
#line 341
    sanei_debug_sanei_wire_call(4, "sanei_w_word: value = %d\n", *v);
    }
  }
  return;
}
}
#line 345 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_string(Wire *w , SANE_String *v ) 
{ 


  {
  {
#line 347
  sanei_debug_sanei_wire_call(3, "sanei_w_string: wire %d\n\230\001", w->io.fd);
#line 348
  (*(w->codec.w_string))(w, v);
  }
#line 349
  if ((unsigned int )w->direction != 2U) {
#line 349
    if (w->status == 0) {
      {
#line 350
      sanei_debug_sanei_wire_call(4, "sanei_w_string: value = %s\n", *v);
      }
    }
  }
  return;
}
}
#line 354 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_status(Wire *w , SANE_Status *v ) 
{ 
  SANE_Word word ;

  {
  {
#line 356
  word = (SANE_Word )*v;
#line 358
  sanei_debug_sanei_wire_call(3, "sanei_w_status: wire %d\n\230\001", w->io.fd);
#line 360
  sanei_w_word(w, & word);
  }
#line 361
  if ((unsigned int )w->direction == 1U) {
#line 362
    *v = (SANE_Status )word;
  }
#line 364
  if ((unsigned int )w->direction != 2U) {
    {
#line 365
    sanei_debug_sanei_wire_call(4, "sanei_w_status: value = %d\n", word);
    }
  }
  return;
}
}
#line 369 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_bool(Wire *w , SANE_Bool *v ) 
{ 
  SANE_Word word ;
  char const   *tmp ;

  {
  {
#line 371
  word = *v;
#line 373
  sanei_debug_sanei_wire_call(3, "sanei_w_bool: wire %d\n", w->io.fd);
#line 374
  sanei_w_word(w, & word);
  }
#line 375
  if ((unsigned int )w->direction == 1U) {
#line 376
    *v = word;
  }
#line 378
  if ((unsigned int )w->direction != 2U) {
#line 379
    if (word == 1) {
#line 379
      tmp = "true";
    } else {
#line 379
      tmp = "false";
    }
    {
#line 379
    sanei_debug_sanei_wire_call(4, "sanei_w_bool: value = %s\n", tmp);
    }
  }
  return;
}
}
#line 384 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_constraint_type(Wire *w , SANE_Constraint_Type *v ) 
{ 
  SANE_Word word ;

  {
  {
#line 386
  word = (SANE_Word )*v;
#line 388
  sanei_debug_sanei_wire_call(3, "sanei_w_constraint_type: wire %d\n", w->io.fd);
#line 390
  sanei_w_word(w, & word);
  }
#line 391
  if ((unsigned int )w->direction == 1U) {
#line 392
    *v = (SANE_Constraint_Type )word;
  }
#line 394
  if ((unsigned int )w->direction != 2U) {
    {
#line 395
    sanei_debug_sanei_wire_call(4, "sanei_w_constraint_type: value = %d\n", word);
    }
  }
  return;
}
}
#line 399 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_value_type(Wire *w , SANE_Value_Type *v ) 
{ 
  SANE_Word word ;

  {
  {
#line 401
  word = (SANE_Word )*v;
#line 403
  sanei_debug_sanei_wire_call(3, "sanei_w_value_type: wire %d\n", w->io.fd);
#line 405
  sanei_w_word(w, & word);
  }
#line 406
  if ((unsigned int )w->direction == 1U) {
#line 407
    *v = (SANE_Value_Type )word;
  }
#line 408
  if ((unsigned int )w->direction != 2U) {
    {
#line 409
    sanei_debug_sanei_wire_call(4, "sanei_w_value_type: value = %d\n", word);
    }
  }
  return;
}
}
#line 413 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_unit(Wire *w , SANE_Unit *v ) 
{ 
  SANE_Word word ;

  {
  {
#line 415
  word = (SANE_Word )*v;
#line 417
  sanei_debug_sanei_wire_call(3, "sanei_w_unit: wire %d\n", w->io.fd);
#line 418
  sanei_w_word(w, & word);
  }
#line 419
  if ((unsigned int )w->direction == 1U) {
#line 420
    *v = (SANE_Unit )word;
  }
#line 422
  if ((unsigned int )w->direction != 2U) {
    {
#line 423
    sanei_debug_sanei_wire_call(4, "sanei_w_unit: value = %d\n", word);
    }
  }
  return;
}
}
#line 428 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_action(Wire *w , SANE_Action *v ) 
{ 
  SANE_Word word ;

  {
  {
#line 430
  word = (SANE_Word )*v;
#line 432
  sanei_debug_sanei_wire_call(3, "sanei_w_action: wire %d\n\230\001", w->io.fd);
#line 434
  sanei_w_word(w, & word);
  }
#line 435
  if ((unsigned int )w->direction == 1U) {
#line 436
    *v = (SANE_Action )word;
  }
#line 438
  if ((unsigned int )w->direction != 2U) {
    {
#line 439
    sanei_debug_sanei_wire_call(4, "sanei_w_action: value = %d\n", word);
    }
  }
  return;
}
}
#line 443 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_frame(Wire *w , SANE_Frame *v ) 
{ 
  SANE_Word word ;

  {
  {
#line 445
  word = (SANE_Word )*v;
#line 447
  sanei_debug_sanei_wire_call(3, "sanei_w_frame: wire %d\n", w->io.fd);
#line 449
  sanei_w_word(w, & word);
  }
#line 450
  if ((unsigned int )w->direction == 1U) {
#line 451
    *v = (SANE_Frame )word;
  }
#line 453
  if ((unsigned int )w->direction != 2U) {
    {
#line 454
    sanei_debug_sanei_wire_call(4, "sanei_w_frame: value = %d\n", word);
    }
  }
  return;
}
}
#line 458 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_range(Wire *w , SANE_Range *v ) 
{ 


  {
  {
#line 460
  sanei_debug_sanei_wire_call(3, "sanei_w_range: wire %d\n", w->io.fd);
#line 461
  sanei_w_word(w, & v->min);
#line 462
  sanei_w_word(w, & v->max);
#line 463
  sanei_w_word(w, & v->quant);
  }
#line 464
  if ((unsigned int )w->direction != 2U) {
    {
#line 465
    sanei_debug_sanei_wire_call(4, "sanei_w_range: min/max/step = %f/%f/%f\n", (double )v->min / (double )(1 << 16),
                                (double )v->max / (double )(1 << 16), (double )v->quant / (double )(1 << 16));
    }
  }
  return;
}
}
#line 470 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_device(Wire *w , SANE_Device *v ) 
{ 


  {
  {
#line 472
  sanei_debug_sanei_wire_call(3, "sanei_w_device: wire %d\n\230\001", w->io.fd);
#line 473
  sanei_w_string(w, (SANE_String *)(& v->name));
#line 474
  sanei_w_string(w, (SANE_String *)(& v->vendor));
#line 475
  sanei_w_string(w, (SANE_String *)(& v->model));
#line 476
  sanei_w_string(w, (SANE_String *)(& v->type));
  }
#line 477
  if ((unsigned int )w->direction != 2U) {
    {
#line 478
    sanei_debug_sanei_wire_call(4, "sanei_w_device: %s %s from %s (%s)\n", v->name,
                                v->model, v->vendor, v->type);
    }
  }
  return;
}
}
#line 483 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_device_ptr(Wire *w , SANE_Device **v ) 
{ 


  {
  {
#line 485
  sanei_debug_sanei_wire_call(3, "sanei_w_device_ptr: wire %d\n", w->io.fd);
#line 486
  sanei_w_ptr(w, (void **)v, (WireCodecFunc )(& sanei_w_device), sizeof(*(*v)));
  }
#line 487
  if ((unsigned int )w->direction != 2U) {
    {
#line 488
    sanei_debug_sanei_wire_call(4, "sanei_w_device_ptr: device struct at %p\n\230\001",
                                *v);
    }
  }
  return;
}
}
#line 492 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_option_descriptor(Wire *w , SANE_Option_Descriptor *v ) 
{ 
  SANE_Word len ;

  {
  {
#line 496
  sanei_debug_sanei_wire_call(3, "sanei_w_option_descriptor: wire %d\n", w->io.fd);
#line 498
  sanei_w_string(w, (SANE_String *)(& v->name));
#line 499
  sanei_w_string(w, (SANE_String *)(& v->title));
#line 500
  sanei_w_string(w, (SANE_String *)(& v->desc));
#line 501
  sanei_w_value_type(w, & v->type);
#line 502
  sanei_w_unit(w, & v->unit);
#line 503
  sanei_w_word(w, & v->size);
#line 504
  sanei_w_word(w, & v->cap);
#line 505
  sanei_w_constraint_type(w, & v->constraint_type);
  }
#line 507
  if ((unsigned int )w->direction != 2U) {
    {
#line 508
    sanei_debug_sanei_wire_call(4, "sanei_w_option_descriptor: option %s\n", v->name);
    }
  }
  {
#line 512
  if ((unsigned int )v->constraint_type == (unsigned int )0) {
#line 512
    goto case_0;
  }
#line 515
  if ((unsigned int )v->constraint_type == (unsigned int )1) {
#line 515
    goto case_1;
  }
#line 520
  if ((unsigned int )v->constraint_type == (unsigned int )2) {
#line 520
    goto case_2;
  }
#line 527
  if ((unsigned int )v->constraint_type == (unsigned int )3) {
#line 527
    goto case_3;
  }
#line 510
  goto switch_break;
  case_0: /* CIL Label */ 
#line 513
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 516
  sanei_w_ptr(w, (void **)(& v->constraint.range), (WireCodecFunc )(& sanei_w_range),
              sizeof(SANE_Range ));
  }
#line 518
  goto switch_break;
  case_2: /* CIL Label */ 
#line 521
  if ((unsigned int )w->direction != 1U) {
#line 522
    len = *(v->constraint.word_list + 0) + 1;
  }
  {
#line 523
  sanei_w_array(w, & len, (void **)(& v->constraint.word_list), w->codec.w_word, sizeof(SANE_Word ));
  }
#line 525
  goto switch_break;
  case_3: /* CIL Label */ 
#line 528
  if ((unsigned int )w->direction != 1U) {
#line 530
    len = 0;
    {
#line 530
    while (1) {
      while_continue: /* CIL Label */ ;
#line 530
      if (! *(v->constraint.string_list + len)) {
#line 530
        goto while_break;
      }

#line 530
      len ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 531
    len ++;
  }
  {
#line 533
  sanei_w_array(w, & len, (void **)(& v->constraint.string_list), w->codec.w_string,
                sizeof(SANE_String ));
  }
#line 535
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 537
  sanei_debug_sanei_wire_call(4, "sanei_w_option_descriptor: done\n\220");
  }
  return;
}
}
#line 541 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_option_descriptor_ptr(Wire *w , SANE_Option_Descriptor **v ) 
{ 


  {
  {
#line 543
  sanei_debug_sanei_wire_call(3, "sanei_w_option_descriptor_ptr: wire %d\n", w->io.fd);
#line 544
  sanei_w_ptr(w, (void **)v, (WireCodecFunc )(& sanei_w_option_descriptor), sizeof(*(*v)));
#line 546
  sanei_debug_sanei_wire_call(4, "sanei_w_option_descriptor_ptr: done\n");
  }
  return;
}
}
#line 550 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_parameters(Wire *w , SANE_Parameters *v ) 
{ 


  {
  {
#line 552
  sanei_debug_sanei_wire_call(3, "sanei_w_parameters: wire %d\n", w->io.fd);
#line 553
  sanei_w_frame(w, & v->format);
#line 554
  sanei_w_bool(w, & v->last_frame);
#line 555
  sanei_w_word(w, & v->bytes_per_line);
#line 556
  sanei_w_word(w, & v->pixels_per_line);
#line 557
  sanei_w_word(w, & v->lines);
#line 558
  sanei_w_word(w, & v->depth);
  }
#line 559
  if ((unsigned int )w->direction != 2U) {
    {
#line 560
    sanei_debug_sanei_wire_call(4, "sanei_w_parameters: format/last/bpl/ppl/lines/depth = %d/%d/%d/%d/%d/%d\n",
                                (unsigned int )v->format, v->last_frame, v->bytes_per_line,
                                v->pixels_per_line, v->lines, v->depth);
    }
  }
  return;
}
}
#line 567 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
static void flush(Wire *w ) 
{ 


  {
  {
#line 569
  sanei_debug_sanei_wire_call(3, "flush: wire %d\n", w->io.fd);
  }
#line 570
  if ((unsigned int )w->direction == 0U) {
    {
#line 571
    sanei_w_space(w, w->buffer.size + 1UL);
    }
  } else
#line 572
  if ((unsigned int )w->direction == 1U) {
#line 573
    w->buffer.end = w->buffer.start;
#line 573
    w->buffer.curr = w->buffer.end;
  }
#line 574
  if (w->status != 0) {
    {
#line 575
    sanei_debug_sanei_wire_call(2, "flush: error status %d\n", w->status);
    }
  }
  {
#line 576
  sanei_debug_sanei_wire_call(4, "flush: wire flushed\n");
  }
  return;
}
}
#line 580 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_set_dir(Wire *w , WireDirection dir ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 582
  if ((unsigned int )w->direction == 0U) {
#line 582
    tmp___0 = "ENCODE";
  } else {
#line 582
    if ((unsigned int )w->direction == 1U) {
#line 582
      tmp = "DECODE";
    } else {
#line 582
      tmp = "FREE";
    }
#line 582
    tmp___0 = tmp;
  }
  {
#line 582
  sanei_debug_sanei_wire_call(3, "sanei_w_set_dir: wire %d, old direction WIRE_%s\n\230\001",
                              w->io.fd, tmp___0);
  }
#line 585
  if (w->buffer.curr != w->buffer.end) {
#line 585
    if ((unsigned int )w->direction == 1U) {
      {
#line 586
      sanei_debug_sanei_wire_call(1, "sanei_w_set_dir: WARNING: will delete %lu bytes from buffer\n",
                                  (u_long )(w->buffer.end - w->buffer.curr));
      }
    }
  }
  {
#line 588
  flush(w);
#line 589
  w->direction = dir;
#line 590
  sanei_debug_sanei_wire_call(4, "sanei_w_set_dir: direction changed\n");
#line 591
  flush(w);
  }
#line 592
  if ((unsigned int )dir == 0U) {
#line 592
    tmp___2 = "ENCODE";
  } else {
#line 592
    if ((unsigned int )dir == 1U) {
#line 592
      tmp___1 = "DECODE";
    } else {
#line 592
      tmp___1 = "FREE";
    }
#line 592
    tmp___2 = tmp___1;
  }
  {
#line 592
  sanei_debug_sanei_wire_call(3, "sanei_w_set_dir: wire %d, new direction WIRE_%s\n\230\001",
                              w->io.fd, tmp___2);
  }
  return;
}
}
#line 598 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_call(Wire *w , SANE_Word procnum , WireCodecFunc w_arg , void *arg ,
                  WireCodecFunc w_reply , void *reply ) 
{ 


  {
  {
#line 604
  sanei_debug_sanei_wire_call(3, "sanei_w_call: wire %d (old status %d)\n", w->io.fd,
                              w->status);
#line 605
  w->status = 0;
#line 606
  sanei_w_set_dir(w, (WireDirection )0);
#line 608
  sanei_debug_sanei_wire_call(4, "sanei_w_call: sending request (procedure number: %d)\n",
                              procnum);
#line 609
  sanei_w_word(w, & procnum);
#line 610
  (*w_arg)(w, arg);
  }
#line 612
  if (w->status == 0) {
    {
#line 614
    sanei_debug_sanei_wire_call(4, "sanei_w_call: receiving reply\n");
#line 615
    sanei_w_set_dir(w, (WireDirection )1);
#line 616
    (*w_reply)(w, reply);
    }
  }
#line 619
  if (w->status != 0) {
    {
#line 620
    sanei_debug_sanei_wire_call(2, "sanei_w_call: error status %d\n", w->status);
    }
  }
  {
#line 621
  sanei_debug_sanei_wire_call(4, "sanei_w_call: done\n");
  }
  return;
}
}
#line 625 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_reply(Wire *w , WireCodecFunc w_reply , void *reply ) 
{ 


  {
  {
#line 627
  sanei_debug_sanei_wire_call(3, "sanei_w_reply: wire %d (old status %d)\n", w->io.fd,
                              w->status);
#line 628
  w->status = 0;
#line 629
  sanei_w_set_dir(w, (WireDirection )0);
#line 630
  (*w_reply)(w, reply);
#line 631
  flush(w);
  }
#line 632
  if (w->status != 0) {
    {
#line 633
    sanei_debug_sanei_wire_call(2, "sanei_w_reply: error status %d\n", w->status);
    }
  }
  {
#line 634
  sanei_debug_sanei_wire_call(4, "sanei_w_reply: done\n");
  }
  return;
}
}
#line 638 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_free(Wire *w , WireCodecFunc w_reply , void *reply ) 
{ 
  WireDirection saved_dir ;

  {
  {
#line 640
  saved_dir = w->direction;
#line 642
  sanei_debug_sanei_wire_call(3, "sanei_w_free: wire %d\n", w->io.fd);
#line 644
  w->direction = (WireDirection )2;
#line 645
  (*w_reply)(w, reply);
#line 646
  w->direction = saved_dir;
  }
#line 648
  if (w->status != 0) {
    {
#line 649
    sanei_debug_sanei_wire_call(2, "sanei_w_free: error status %d\n", w->status);
    }
  }
  {
#line 650
  sanei_debug_sanei_wire_call(4, "sanei_w_free: done\n");
  }
  return;
}
}
#line 654 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_init(Wire *w , void (*codec_init_func)(Wire * ) ) 
{ 
  void *__cil_tmp3 ;

  {
  {
#line 656
  sanei_init_debug("sanei_wire", & sanei_debug_sanei_wire);
#line 658
  sanei_debug_sanei_wire_call(3, "sanei_w_init: initializing\n");
#line 659
  w->status = 0;
#line 660
  w->direction = (WireDirection )0;
#line 661
  w->buffer.size = (size_t )8192;
#line 662
  w->buffer.start = (char *)malloc(w->buffer.size);
  }
#line 664
  if (w->buffer.start == (char *)0) {
    {
#line 667
    w->status = 12;
#line 668
    sanei_debug_sanei_wire_call(1, "sanei_w_init: not enough free memory\n");
    }
  }
#line 671
  w->buffer.curr = w->buffer.start;
#line 672
  w->buffer.end = w->buffer.start + w->buffer.size;
#line 673
  if (codec_init_func != (void (*)(Wire * ))0) {
    {
#line 675
    sanei_debug_sanei_wire_call(4, "sanei_w_init: initializing codec\n");
#line 676
    (*codec_init_func)(w);
    }
  }
  {
#line 678
  w->allocated_memory = 0;
#line 679
  sanei_debug_sanei_wire_call(4, "sanei_w_init: done\n");
  }
  return;
}
}
#line 683 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_wire.c"
void sanei_w_exit(Wire *w ) 
{ 


  {
  {
#line 685
  sanei_debug_sanei_wire_call(3, "sanei_w_exit: wire %d\n", w->io.fd);
  }
#line 686
  if (w->buffer.start) {
    {
#line 688
    sanei_debug_sanei_wire_call(4, "sanei_w_exit: freeing buffer\n");
#line 689
    free(w->buffer.start);
    }
  }
  {
#line 691
  w->buffer.start = (char *)0;
#line 692
  w->buffer.size = (size_t )0;
#line 693
  sanei_debug_sanei_wire_call(4, "sanei_w_exit: done\n");
  }
  return;
}
}
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type ) ;
#line 292
extern  __attribute__((__nothrow__)) int euidaccess(char const   *__name , int __type ) ;
#line 296
extern  __attribute__((__nothrow__)) int eaccess(char const   *__name , int __type ) ;
#line 300
extern  __attribute__((__nothrow__)) int execveat(int __fd , char const   *__path ,
                                                  char * const  __argv[] , char * const  __envp[] ,
                                                  int __flags ) ;
#line 309
extern  __attribute__((__nothrow__)) int faccessat(int __fd , char const   *__file ,
                                                   int __type , int __flag ) ;
#line 339
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 350
extern  __attribute__((__nothrow__)) __off64_t lseek64(int __fd , __off64_t __offset ,
                                                       int __whence ) ;
#line 358
extern int close(int __fd ) ;
#line 363
extern  __attribute__((__nothrow__)) void closefrom(int __lowfd ) ;
#line 371
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes )  __attribute__((__gnu_inline__)) ;
#line 378
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 389
__inline extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset )  __attribute__((__gnu_inline__)) ;
#line 398
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __n , __off_t __offset ) ;
#line 422
__inline extern ssize_t pread64(int __fd , void *__buf , size_t __nbytes , __off64_t __offset )  __attribute__((__gnu_inline__)) ;
#line 427
extern ssize_t pwrite64(int __fd , void const   *__buf , size_t __n , __off64_t __offset ) ;
#line 437
extern  __attribute__((__nothrow__)) int pipe(int __pipedes[2] ) ;
#line 442
extern  __attribute__((__nothrow__)) int pipe2(int __pipedes[2] , int __flags ) ;
#line 452
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 464
extern unsigned int sleep(unsigned int __seconds ) ;
#line 472
extern  __attribute__((__nothrow__)) __useconds_t ualarm(__useconds_t __value , __useconds_t __interval ) ;
#line 480
extern int usleep(__useconds_t __useconds ) ;
#line 489
extern int pause(void) ;
#line 493
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group ) ;
#line 498
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
#line 503
extern  __attribute__((__nothrow__)) int lchown(char const   *__file , __uid_t __owner ,
                                                __gid_t __group ) ;
#line 511
extern  __attribute__((__nothrow__)) int fchownat(int __fd , char const   *__file ,
                                                  __uid_t __owner , __gid_t __group ,
                                                  int __flag ) ;
#line 517
extern  __attribute__((__nothrow__)) int chdir(char const   *__path ) ;
#line 521
extern  __attribute__((__nothrow__)) int fchdir(int __fd ) ;
#line 531
__inline extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 537
extern  __attribute__((__nothrow__)) char *get_current_dir_name(void) ;
#line 545
__inline extern  __attribute__((__nothrow__)) char *getwd(char *__buf )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 552
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 555
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 560
extern  __attribute__((__nothrow__)) int dup3(int __fd , int __fd2 , int __flags ) ;
#line 564
extern char **__environ ;
#line 566
extern char **environ ;
#line 572
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  __argv[] ,
                                                char * const  __envp[] ) ;
#line 578
extern  __attribute__((__nothrow__)) int fexecve(int __fd , char * const  __argv[] ,
                                                 char * const  __envp[] ) ;
#line 584
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  __argv[] ) ;
#line 589
extern  __attribute__((__nothrow__)) int execle(char const   *__path , char const   *__arg 
                                                , ...) ;
#line 594
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...) ;
#line 599
extern  __attribute__((__nothrow__)) int execvp(char const   *__file , char * const  __argv[] ) ;
#line 605
extern  __attribute__((__nothrow__)) int execlp(char const   *__file , char const   *__arg 
                                                , ...) ;
#line 611
extern  __attribute__((__nothrow__)) int execvpe(char const   *__file , char * const  __argv[] ,
                                                 char * const  __envp[] ) ;
#line 619
extern  __attribute__((__nothrow__)) int nice(int __inc ) ;
#line 624
extern void _exit(int __status ) ;
#line 633
extern  __attribute__((__nothrow__)) long pathconf(char const   *__path , int __name ) ;
#line 637
extern  __attribute__((__nothrow__)) long fpathconf(int __fd , int __name ) ;
#line 640
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
#line 644
__inline extern  __attribute__((__nothrow__)) size_t confstr(int __name , char *__buf ,
                                                             size_t __len )  __attribute__((__gnu_inline__)) ;
#line 650
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 653
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
#line 656
extern  __attribute__((__nothrow__)) __pid_t getpgrp(void) ;
#line 659
extern  __attribute__((__nothrow__)) __pid_t __getpgid(__pid_t __pid ) ;
#line 661
extern  __attribute__((__nothrow__)) __pid_t getpgid(__pid_t __pid ) ;
#line 668
extern  __attribute__((__nothrow__)) int setpgid(__pid_t __pid , __pid_t __pgid ) ;
#line 682
extern  __attribute__((__nothrow__)) int setpgrp(void) ;
#line 689
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 693
extern  __attribute__((__nothrow__)) __pid_t getsid(__pid_t __pid ) ;
#line 697
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 700
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 703
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 706
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 711
__inline extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t __list[] )  __attribute__((__gnu_inline__)) ;
#line 715
extern  __attribute__((__nothrow__)) int group_member(__gid_t __gid ) ;
#line 722
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 727
extern  __attribute__((__nothrow__)) int setreuid(__uid_t __ruid , __uid_t __euid ) ;
#line 732
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 739
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 744
extern  __attribute__((__nothrow__)) int setregid(__gid_t __rgid , __gid_t __egid ) ;
#line 749
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 755
extern  __attribute__((__nothrow__)) int getresuid(__uid_t *__ruid , __uid_t *__euid ,
                                                   __uid_t *__suid ) ;
#line 760
extern  __attribute__((__nothrow__)) int getresgid(__gid_t *__rgid , __gid_t *__egid ,
                                                   __gid_t *__sgid ) ;
#line 765
extern  __attribute__((__nothrow__)) int setresuid(__uid_t __ruid , __uid_t __euid ,
                                                   __uid_t __suid ) ;
#line 770
extern  __attribute__((__nothrow__)) int setresgid(__gid_t __rgid , __gid_t __egid ,
                                                   __gid_t __sgid ) ;
#line 778
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 786
extern  __attribute__((__nothrow__)) int vfork(void) ;
#line 793
extern  __attribute__((__nothrow__)) __pid_t _Fork(void) ;
#line 799
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 803
__inline extern  __attribute__((__nothrow__)) int ttyname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 809
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 814
extern  __attribute__((__nothrow__)) int ttyslot(void) ;
#line 819
extern  __attribute__((__nothrow__)) int link(char const   *__from , char const   *__to ) ;
#line 825
extern  __attribute__((__nothrow__)) int linkat(int __fromfd , char const   *__from ,
                                                int __tofd , char const   *__to ,
                                                int __flags ) ;
#line 832
extern  __attribute__((__nothrow__)) int symlink(char const   *__from , char const   *__to ) ;
#line 838
__inline extern  __attribute__((__nothrow__)) ssize_t readlink(char const   *__path ,
                                                               char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 847
extern  __attribute__((__nothrow__)) int symlinkat(char const   *__from , int __tofd ,
                                                   char const   *__to ) ;
#line 851
__inline extern  __attribute__((__nothrow__)) ssize_t readlinkat(int __fd , char const   *__path ,
                                                                 char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 858
extern  __attribute__((__nothrow__)) int unlink(char const   *__name ) ;
#line 862
extern  __attribute__((__nothrow__)) int unlinkat(int __fd , char const   *__name ,
                                                  int __flag ) ;
#line 867
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path ) ;
#line 871
extern  __attribute__((__nothrow__)) __pid_t tcgetpgrp(int __fd ) ;
#line 874
extern  __attribute__((__nothrow__)) int tcsetpgrp(int __fd , __pid_t __pgrp_id ) ;
#line 881
extern char *getlogin(void) ;
#line 889
__inline extern int getlogin_r(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 895
extern  __attribute__((__nothrow__)) int setlogin(char const   *__name ) ;
#line 911
__inline extern  __attribute__((__nothrow__)) int gethostname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 919
extern  __attribute__((__nothrow__)) int sethostname(char const   *__name , size_t __len ) ;
#line 924
extern  __attribute__((__nothrow__)) int sethostid(long __id ) ;
#line 930
__inline extern  __attribute__((__nothrow__)) int getdomainname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 933
extern  __attribute__((__nothrow__)) int setdomainname(char const   *__name , size_t __len ) ;
#line 939
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 942
extern  __attribute__((__nothrow__)) int revoke(char const   *__file ) ;
#line 950
extern  __attribute__((__nothrow__)) int profil(unsigned short *__sample_buffer ,
                                                size_t __size , size_t __offset ,
                                                unsigned int __scale ) ;
#line 958
extern  __attribute__((__nothrow__)) int acct(char const   *__name ) ;
#line 962
extern  __attribute__((__nothrow__)) char *getusershell(void) ;
#line 963
extern  __attribute__((__nothrow__)) void endusershell(void) ;
#line 964
extern  __attribute__((__nothrow__)) void setusershell(void) ;
#line 970
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 977
extern  __attribute__((__nothrow__)) int chroot(char const   *__path ) ;
#line 981
extern char *getpass(char const   *__prompt ) ;
#line 989
extern int fsync(int __fd ) ;
#line 995
extern  __attribute__((__nothrow__)) int syncfs(int __fd ) ;
#line 1002
extern long gethostid(void) ;
#line 1005
extern  __attribute__((__nothrow__)) void sync(void) ;
#line 1011
extern  __attribute__((__nothrow__)) int getpagesize(void) ;
#line 1016
extern  __attribute__((__nothrow__)) int getdtablesize(void) ;
#line 1026
extern  __attribute__((__nothrow__)) int truncate(char const   *__file , __off_t __length ) ;
#line 1038
extern  __attribute__((__nothrow__)) int truncate64(char const   *__file , __off64_t __length ) ;
#line 1049
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
#line 1059
extern  __attribute__((__nothrow__)) int ftruncate64(int __fd , __off64_t __length ) ;
#line 1070
extern  __attribute__((__nothrow__)) int brk(void *__addr ) ;
#line 1076
extern  __attribute__((__nothrow__)) void *sbrk(intptr_t __delta ) ;
#line 1091
extern  __attribute__((__nothrow__)) long syscall(long __sysno  , ...) ;
#line 1114
extern int lockf(int __fd , int __cmd , __off_t __len ) ;
#line 1124
extern int lockf64(int __fd , int __cmd , __off64_t __len ) ;
#line 1142
ssize_t copy_file_range(int __infd , __off64_t *__pinoff , int __outfd , __off64_t *__poutoff ,
                        size_t __length , unsigned int __flags ) ;
#line 1150
extern int fdatasync(int __fildes ) ;
#line 1159
extern  __attribute__((__nothrow__)) char *crypt(char const   *__key , char const   *__salt ) ;
#line 1168
extern  __attribute__((__nothrow__)) void swab(void const   *__from , void *__to ,
                                               ssize_t __n ) ;
#line 1198
int getentropy(void *__buffer , size_t __length ) ;
#line 1208
extern  __attribute__((__nothrow__)) int close_range(unsigned int __fd , unsigned int __max_fd ,
                                                     int __flags ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
extern ssize_t __read_chk(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 26
extern ssize_t __read_alias(int __fd , void *__buf , size_t __nbytes ) ;
#line 29
extern ssize_t __read_chk_warn(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 36
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes )  __attribute__((__gnu_inline__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  ssize_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  ssize_t __cil_tmp16 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 38
  __cil_tmp7 = __builtin_object_size(__buf, 0);
  }
  {
#line 38
  __cil_tmp5 = __builtin_object_size(__buf, 0);
#line 38
  __cil_tmp6 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 38
  __cil_tmp4 = __builtin_constant_p(__nbytes);
  }
#line 38
  if (__cil_tmp6 && (unsigned long )__nbytes <= __cil_tmp7 / sizeof(char )) {
    {
#line 38
    __cil_tmp8 = __read_alias(__fd, __buf, __nbytes);
#line 38
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 38
    __cil_tmp12 = __builtin_object_size(__buf, 0);
    }
    {
#line 38
    __cil_tmp10 = __builtin_object_size(__buf, 0);
#line 38
    __cil_tmp11 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 38
    __cil_tmp9 = __builtin_constant_p(__nbytes);
    }
#line 38
    if (__cil_tmp11 && ! ((unsigned long )__nbytes <= __cil_tmp12 / sizeof(char ))) {
      {
#line 38
      __cil_tmp13 = __builtin_object_size(__buf, 0);
#line 38
      __cil_tmp14 = __read_chk_warn(__fd, __buf, __nbytes, __cil_tmp13);
#line 38
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 38
      __cil_tmp15 = __builtin_object_size(__buf, 0);
#line 38
      __cil_tmp16 = __read_chk(__fd, __buf, __nbytes, __cil_tmp15);
#line 38
      tmp = __cil_tmp16;
      }
    }
#line 38
    tmp___0 = tmp;
  }
#line 38
  return (tmp___0);
}
}
#line 44
extern ssize_t __pread_chk(int __fd , void *__buf , size_t __nbytes , __off_t __offset ,
                           size_t __bufsize ) ;
#line 47
extern ssize_t __pread64_chk(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ,
                             size_t __bufsize ) ;
#line 50
extern ssize_t __pread_alias(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
#line 54
extern ssize_t __pread64_alias(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ) ;
#line 58
extern ssize_t __pread_chk_warn(int __fd , void *__buf , size_t __nbytes , __off_t __offset ,
                                size_t __bufsize ) ;
#line 63
extern ssize_t __pread64_chk_warn(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ,
                                  size_t __bufsize ) ;
#line 72
__inline extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset )  __attribute__((__gnu_inline__)) ;
#line 72 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) 
{ 
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  ssize_t __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  ssize_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  ssize_t __cil_tmp17 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 74
  __cil_tmp8 = __builtin_object_size(__buf, 0);
  }
  {
#line 74
  __cil_tmp6 = __builtin_object_size(__buf, 0);
#line 74
  __cil_tmp7 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp6 / sizeof(char ));
  }
  {
#line 74
  __cil_tmp5 = __builtin_constant_p(__nbytes);
  }
#line 74
  if (__cil_tmp7 && (unsigned long )__nbytes <= __cil_tmp8 / sizeof(char )) {
    {
#line 74
    __cil_tmp9 = __pread_alias(__fd, __buf, __nbytes, __offset);
#line 74
    tmp___0 = __cil_tmp9;
    }
  } else {
    {
#line 74
    __cil_tmp13 = __builtin_object_size(__buf, 0);
    }
    {
#line 74
    __cil_tmp11 = __builtin_object_size(__buf, 0);
#line 74
    __cil_tmp12 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp11 / sizeof(char ));
    }
    {
#line 74
    __cil_tmp10 = __builtin_constant_p(__nbytes);
    }
#line 74
    if (__cil_tmp12 && ! ((unsigned long )__nbytes <= __cil_tmp13 / sizeof(char ))) {
      {
#line 74
      __cil_tmp14 = __builtin_object_size(__buf, 0);
#line 74
      __cil_tmp15 = __pread_chk_warn(__fd, __buf, __nbytes, __offset, __cil_tmp14);
#line 74
      tmp = __cil_tmp15;
      }
    } else {
      {
#line 74
      __cil_tmp16 = __builtin_object_size(__buf, 0);
#line 74
      __cil_tmp17 = __pread_chk(__fd, __buf, __nbytes, __offset, __cil_tmp16);
#line 74
      tmp = __cil_tmp17;
      }
    }
#line 74
    tmp___0 = tmp;
  }
#line 74
  return (tmp___0);
}
}
#line 90
__inline extern ssize_t pread64(int __fd , void *__buf , size_t __nbytes , __off64_t __offset )  __attribute__((__gnu_inline__)) ;
#line 90 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t pread64(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ) 
{ 
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  ssize_t __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  ssize_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  ssize_t __cil_tmp17 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 92
  __cil_tmp8 = __builtin_object_size(__buf, 0);
  }
  {
#line 92
  __cil_tmp6 = __builtin_object_size(__buf, 0);
#line 92
  __cil_tmp7 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp6 / sizeof(char ));
  }
  {
#line 92
  __cil_tmp5 = __builtin_constant_p(__nbytes);
  }
#line 92
  if (__cil_tmp7 && (unsigned long )__nbytes <= __cil_tmp8 / sizeof(char )) {
    {
#line 92
    __cil_tmp9 = __pread64_alias(__fd, __buf, __nbytes, __offset);
#line 92
    tmp___0 = __cil_tmp9;
    }
  } else {
    {
#line 92
    __cil_tmp13 = __builtin_object_size(__buf, 0);
    }
    {
#line 92
    __cil_tmp11 = __builtin_object_size(__buf, 0);
#line 92
    __cil_tmp12 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp11 / sizeof(char ));
    }
    {
#line 92
    __cil_tmp10 = __builtin_constant_p(__nbytes);
    }
#line 92
    if (__cil_tmp12 && ! ((unsigned long )__nbytes <= __cil_tmp13 / sizeof(char ))) {
      {
#line 92
      __cil_tmp14 = __builtin_object_size(__buf, 0);
#line 92
      __cil_tmp15 = __pread64_chk_warn(__fd, __buf, __nbytes, __offset, __cil_tmp14);
#line 92
      tmp = __cil_tmp15;
      }
    } else {
      {
#line 92
      __cil_tmp16 = __builtin_object_size(__buf, 0);
#line 92
      __cil_tmp17 = __pread64_chk(__fd, __buf, __nbytes, __offset, __cil_tmp16);
#line 92
      tmp = __cil_tmp17;
      }
    }
#line 92
    tmp___0 = tmp;
  }
#line 92
  return (tmp___0);
}
}
#line 100
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk(char const   *__path ,
                                                            char *__buf , size_t __len ,
                                                            size_t __buflen ) ;
#line 104
extern  __attribute__((__nothrow__)) ssize_t __readlink_alias(char const   *__path ,
                                                              char *__buf , size_t __len ) ;
#line 108
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk_warn(char const   *__path ,
                                                                 char *__buf , size_t __len ,
                                                                 size_t __buflen ) ;
#line 116
__inline extern  __attribute__((__nothrow__)) ssize_t readlink(char const   *__path ,
                                                               char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t readlink(char const   *__path , char *__buf , size_t __len ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  ssize_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  ssize_t __cil_tmp16 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 119
  __cil_tmp7 = __builtin_object_size(__buf, 1);
  }
  {
#line 119
  __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 119
  __cil_tmp6 = __builtin_constant_p((unsigned long )__len <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 119
  __cil_tmp4 = __builtin_constant_p(__len);
  }
#line 119
  if (__cil_tmp6 && (unsigned long )__len <= __cil_tmp7 / sizeof(char )) {
    {
#line 119
    __cil_tmp8 = __readlink_alias(__path, __buf, __len);
#line 119
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 119
    __cil_tmp12 = __builtin_object_size(__buf, 1);
    }
    {
#line 119
    __cil_tmp10 = __builtin_object_size(__buf, 1);
#line 119
    __cil_tmp11 = __builtin_constant_p((unsigned long )__len <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 119
    __cil_tmp9 = __builtin_constant_p(__len);
    }
#line 119
    if (__cil_tmp11 && ! ((unsigned long )__len <= __cil_tmp12 / sizeof(char ))) {
      {
#line 119
      __cil_tmp13 = __builtin_object_size(__buf, 1);
#line 119
      __cil_tmp14 = __readlink_chk_warn(__path, __buf, __len, __cil_tmp13);
#line 119
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 119
      __cil_tmp15 = __builtin_object_size(__buf, 1);
#line 119
      __cil_tmp16 = __readlink_chk(__path, __buf, __len, __cil_tmp15);
#line 119
      tmp = __cil_tmp16;
      }
    }
#line 119
    tmp___0 = tmp;
  }
#line 119
  return (tmp___0);
}
}
#line 126
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk(int __fd , char const   *__path ,
                                                              char *__buf , size_t __len ,
                                                              size_t __buflen ) ;
#line 130
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_alias(int __fd , char const   *__path ,
                                                                char *__buf , size_t __len ) ;
#line 135
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk_warn(int __fd , char const   *__path ,
                                                                   char *__buf , size_t __len ,
                                                                   size_t __buflen ) ;
#line 144
__inline extern  __attribute__((__nothrow__)) ssize_t readlinkat(int __fd , char const   *__path ,
                                                                 char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t readlinkat(int __fd , char const   *__path , char *__buf ,
                                   size_t __len ) 
{ 
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  ssize_t __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  ssize_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  ssize_t __cil_tmp17 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 147
  __cil_tmp8 = __builtin_object_size(__buf, 1);
  }
  {
#line 147
  __cil_tmp6 = __builtin_object_size(__buf, 1);
#line 147
  __cil_tmp7 = __builtin_constant_p((unsigned long )__len <= __cil_tmp6 / sizeof(char ));
  }
  {
#line 147
  __cil_tmp5 = __builtin_constant_p(__len);
  }
#line 147
  if (__cil_tmp7 && (unsigned long )__len <= __cil_tmp8 / sizeof(char )) {
    {
#line 147
    __cil_tmp9 = __readlinkat_alias(__fd, __path, __buf, __len);
#line 147
    tmp___0 = __cil_tmp9;
    }
  } else {
    {
#line 147
    __cil_tmp13 = __builtin_object_size(__buf, 1);
    }
    {
#line 147
    __cil_tmp11 = __builtin_object_size(__buf, 1);
#line 147
    __cil_tmp12 = __builtin_constant_p((unsigned long )__len <= __cil_tmp11 / sizeof(char ));
    }
    {
#line 147
    __cil_tmp10 = __builtin_constant_p(__len);
    }
#line 147
    if (__cil_tmp12 && ! ((unsigned long )__len <= __cil_tmp13 / sizeof(char ))) {
      {
#line 147
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 147
      __cil_tmp15 = __readlinkat_chk_warn(__fd, __path, __buf, __len, __cil_tmp14);
#line 147
      tmp = __cil_tmp15;
      }
    } else {
      {
#line 147
      __cil_tmp16 = __builtin_object_size(__buf, 1);
#line 147
      __cil_tmp17 = __readlinkat_chk(__fd, __path, __buf, __len, __cil_tmp16);
#line 147
      tmp = __cil_tmp17;
      }
    }
#line 147
    tmp___0 = tmp;
  }
#line 147
  return (tmp___0);
}
}
#line 153
extern  __attribute__((__nothrow__)) char *__getcwd_chk(char *__buf , size_t __size ,
                                                        size_t __buflen ) ;
#line 155
extern  __attribute__((__nothrow__)) char *__getcwd_alias(char *__buf , size_t __size ) ;
#line 157
extern  __attribute__((__nothrow__)) char *__getcwd_chk_warn(char *__buf , size_t __size ,
                                                             size_t __buflen ) ;
#line 164
__inline extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 164 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *getcwd(char *__buf , size_t __size ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  char *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  char *__cil_tmp15 ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 166
  __cil_tmp6 = __builtin_object_size(__buf, 1);
  }
  {
#line 166
  __cil_tmp4 = __builtin_object_size(__buf, 1);
#line 166
  __cil_tmp5 = __builtin_constant_p((unsigned long )__size <= __cil_tmp4 / sizeof(char ));
  }
  {
#line 166
  __cil_tmp3 = __builtin_constant_p(__size);
  }
#line 166
  if (__cil_tmp5 && (unsigned long )__size <= __cil_tmp6 / sizeof(char )) {
    {
#line 166
    __cil_tmp7 = __getcwd_alias(__buf, __size);
#line 166
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 166
    __cil_tmp11 = __builtin_object_size(__buf, 1);
    }
    {
#line 166
    __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 166
    __cil_tmp10 = __builtin_constant_p((unsigned long )__size <= __cil_tmp9 / sizeof(char ));
    }
    {
#line 166
    __cil_tmp8 = __builtin_constant_p(__size);
    }
#line 166
    if (__cil_tmp10 && ! ((unsigned long )__size <= __cil_tmp11 / sizeof(char ))) {
      {
#line 166
      __cil_tmp12 = __builtin_object_size(__buf, 1);
#line 166
      __cil_tmp13 = __getcwd_chk_warn(__buf, __size, __cil_tmp12);
#line 166
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 166
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 166
      __cil_tmp15 = __getcwd_chk(__buf, __size, __cil_tmp14);
#line 166
      tmp = __cil_tmp15;
      }
    }
#line 166
    tmp___0 = tmp;
  }
#line 166
  return (tmp___0);
}
}
#line 172
extern  __attribute__((__nothrow__)) char *__getwd_chk(char *__buf , size_t buflen ) ;
#line 174
extern  __attribute__((__nothrow__)) char *__getwd_warn(char *__buf ) ;
#line 179
__inline extern  __attribute__((__nothrow__)) char *getwd(char *__buf )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 179 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *getwd(char *__buf ) 
{ 
  unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 181
  __cil_tmp2 = __builtin_object_size(__buf, 1);
  }
#line 181
  if (__cil_tmp2 != 0xffffffffffffffffUL) {
    {
#line 182
    __cil_tmp3 = __builtin_object_size(__buf, 1);
#line 182
    __cil_tmp4 = __getwd_chk(__buf, __cil_tmp3);
    }
#line 182
    return (__cil_tmp4);
  }
  {
#line 183
  __cil_tmp5 = __getwd_warn(__buf);
  }
#line 183
  return (__cil_tmp5);
}
}
#line 187
extern  __attribute__((__nothrow__)) size_t __confstr_chk(int __name , char *__buf ,
                                                          size_t __len , size_t __buflen ) ;
#line 190
extern  __attribute__((__nothrow__)) size_t __confstr_alias(int __name , char *__buf ,
                                                            size_t __len ) ;
#line 193
extern  __attribute__((__nothrow__)) size_t __confstr_chk_warn(int __name , char *__buf ,
                                                               size_t __len , size_t __buflen ) ;
#line 200
__inline extern  __attribute__((__nothrow__)) size_t confstr(int __name , char *__buf ,
                                                             size_t __len )  __attribute__((__gnu_inline__)) ;
#line 200 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern size_t confstr(int __name , char *__buf , size_t __len ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  size_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  size_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 202
  __cil_tmp7 = __builtin_object_size(__buf, 1);
  }
  {
#line 202
  __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 202
  __cil_tmp6 = __builtin_constant_p((unsigned long )__len <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 202
  __cil_tmp4 = __builtin_constant_p(__len);
  }
#line 202
  if (__cil_tmp6 && (unsigned long )__len <= __cil_tmp7 / sizeof(char )) {
    {
#line 202
    __cil_tmp8 = __confstr_alias(__name, __buf, __len);
#line 202
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 202
    __cil_tmp12 = __builtin_object_size(__buf, 1);
    }
    {
#line 202
    __cil_tmp10 = __builtin_object_size(__buf, 1);
#line 202
    __cil_tmp11 = __builtin_constant_p((unsigned long )__len <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 202
    __cil_tmp9 = __builtin_constant_p(__len);
    }
#line 202
    if (__cil_tmp11 && ! ((unsigned long )__len <= __cil_tmp12 / sizeof(char ))) {
      {
#line 202
      __cil_tmp13 = __builtin_object_size(__buf, 1);
#line 202
      __cil_tmp14 = __confstr_chk_warn(__name, __buf, __len, __cil_tmp13);
#line 202
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 202
      __cil_tmp15 = __builtin_object_size(__buf, 1);
#line 202
      __cil_tmp16 = __confstr_chk(__name, __buf, __len, __cil_tmp15);
#line 202
      tmp = __cil_tmp16;
      }
    }
#line 202
    tmp___0 = tmp;
  }
#line 202
  return (tmp___0);
}
}
#line 208
extern  __attribute__((__nothrow__)) int __getgroups_chk(int __size , __gid_t __list[] ,
                                                         size_t __listlen ) ;
#line 210
extern  __attribute__((__nothrow__)) int __getgroups_alias(int __size , __gid_t __list[] ) ;
#line 212
extern  __attribute__((__nothrow__)) int __getgroups_chk_warn(int __size , __gid_t __list[] ,
                                                              size_t __listlen ) ;
#line 219
__inline extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t __list[] )  __attribute__((__gnu_inline__)) ;
#line 219 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getgroups(int __size , __gid_t __list[] ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 221
  __cil_tmp6 = __builtin_object_size(__list, 1);
  }
  {
#line 221
  __cil_tmp4 = __builtin_object_size(__list, 1);
#line 221
  __cil_tmp5 = __builtin_constant_p((unsigned long )__size <= __cil_tmp4 / sizeof(__gid_t ));
  }
  {
#line 221
  __cil_tmp3 = __builtin_constant_p(__size);
  }
#line 221
  if (((__cil_tmp3 && __size > 0) && __cil_tmp5) && (unsigned long )__size <= __cil_tmp6 / sizeof(__gid_t )) {
    {
#line 221
    __cil_tmp7 = __getgroups_alias(__size, __list);
#line 221
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 221
    __cil_tmp11 = __builtin_object_size(__list, 1);
    }
    {
#line 221
    __cil_tmp9 = __builtin_object_size(__list, 1);
#line 221
    __cil_tmp10 = __builtin_constant_p((unsigned long )__size <= __cil_tmp9 / sizeof(__gid_t ));
    }
    {
#line 221
    __cil_tmp8 = __builtin_constant_p(__size);
    }
#line 221
    if (((__cil_tmp8 && __size > 0) && __cil_tmp10) && ! ((unsigned long )__size <= __cil_tmp11 / sizeof(__gid_t ))) {
      {
#line 221
      __cil_tmp12 = __builtin_object_size(__list, 1);
#line 221
      __cil_tmp13 = __getgroups_chk_warn(__size, __list, __cil_tmp12);
#line 221
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 221
      __cil_tmp14 = __builtin_object_size(__list, 1);
#line 221
      __cil_tmp15 = __getgroups_chk(__size, __list, __cil_tmp14);
#line 221
      tmp = __cil_tmp15;
      }
    }
#line 221
    tmp___0 = tmp;
  }
#line 221
  return (tmp___0);
}
}
#line 227
extern  __attribute__((__nothrow__)) int __ttyname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 230
extern  __attribute__((__nothrow__)) int __ttyname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 233
extern  __attribute__((__nothrow__)) int __ttyname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 240
__inline extern  __attribute__((__nothrow__)) int ttyname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 240 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ttyname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 242
  __cil_tmp7 = __builtin_object_size(__buf, 1);
  }
  {
#line 242
  __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 242
  __cil_tmp6 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 242
  __cil_tmp4 = __builtin_constant_p(__buflen);
  }
#line 242
  if (__cil_tmp6 && (unsigned long )__buflen <= __cil_tmp7 / sizeof(char )) {
    {
#line 242
    __cil_tmp8 = __ttyname_r_alias(__fd, __buf, __buflen);
#line 242
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 242
    __cil_tmp12 = __builtin_object_size(__buf, 1);
    }
    {
#line 242
    __cil_tmp10 = __builtin_object_size(__buf, 1);
#line 242
    __cil_tmp11 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 242
    __cil_tmp9 = __builtin_constant_p(__buflen);
    }
#line 242
    if (__cil_tmp11 && ! ((unsigned long )__buflen <= __cil_tmp12 / sizeof(char ))) {
      {
#line 242
      __cil_tmp13 = __builtin_object_size(__buf, 1);
#line 242
      __cil_tmp14 = __ttyname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp13);
#line 242
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 242
      __cil_tmp15 = __builtin_object_size(__buf, 1);
#line 242
      __cil_tmp16 = __ttyname_r_chk(__fd, __buf, __buflen, __cil_tmp15);
#line 242
      tmp = __cil_tmp16;
      }
    }
#line 242
    tmp___0 = tmp;
  }
#line 242
  return (tmp___0);
}
}
#line 249
extern int __getlogin_r_chk(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 251
extern int __getlogin_r_alias(char *__buf , size_t __buflen ) ;
#line 253
extern int __getlogin_r_chk_warn(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 260
__inline extern int getlogin_r(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 260 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getlogin_r(char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 262
  __cil_tmp6 = __builtin_object_size(__buf, 1);
  }
  {
#line 262
  __cil_tmp4 = __builtin_object_size(__buf, 1);
#line 262
  __cil_tmp5 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp4 / sizeof(char ));
  }
  {
#line 262
  __cil_tmp3 = __builtin_constant_p(__buflen);
  }
#line 262
  if (__cil_tmp5 && (unsigned long )__buflen <= __cil_tmp6 / sizeof(char )) {
    {
#line 262
    __cil_tmp7 = __getlogin_r_alias(__buf, __buflen);
#line 262
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 262
    __cil_tmp11 = __builtin_object_size(__buf, 1);
    }
    {
#line 262
    __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 262
    __cil_tmp10 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp9 / sizeof(char ));
    }
    {
#line 262
    __cil_tmp8 = __builtin_constant_p(__buflen);
    }
#line 262
    if (__cil_tmp10 && ! ((unsigned long )__buflen <= __cil_tmp11 / sizeof(char ))) {
      {
#line 262
      __cil_tmp12 = __builtin_object_size(__buf, 1);
#line 262
      __cil_tmp13 = __getlogin_r_chk_warn(__buf, __buflen, __cil_tmp12);
#line 262
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 262
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 262
      __cil_tmp15 = __getlogin_r_chk(__buf, __buflen, __cil_tmp14);
#line 262
      tmp = __cil_tmp15;
      }
    }
#line 262
    tmp___0 = tmp;
  }
#line 262
  return (tmp___0);
}
}
#line 270
extern  __attribute__((__nothrow__)) int __gethostname_chk(char *__buf , size_t __buflen ,
                                                           size_t __nreal ) ;
#line 272
extern  __attribute__((__nothrow__)) int __gethostname_alias(char *__buf , size_t __buflen ) ;
#line 275
extern  __attribute__((__nothrow__)) int __gethostname_chk_warn(char *__buf , size_t __buflen ,
                                                                size_t __nreal ) ;
#line 282
__inline extern  __attribute__((__nothrow__)) int gethostname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 282 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int gethostname(char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 284
  __cil_tmp6 = __builtin_object_size(__buf, 1);
  }
  {
#line 284
  __cil_tmp4 = __builtin_object_size(__buf, 1);
#line 284
  __cil_tmp5 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp4 / sizeof(char ));
  }
  {
#line 284
  __cil_tmp3 = __builtin_constant_p(__buflen);
  }
#line 284
  if (__cil_tmp5 && (unsigned long )__buflen <= __cil_tmp6 / sizeof(char )) {
    {
#line 284
    __cil_tmp7 = __gethostname_alias(__buf, __buflen);
#line 284
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 284
    __cil_tmp11 = __builtin_object_size(__buf, 1);
    }
    {
#line 284
    __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 284
    __cil_tmp10 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp9 / sizeof(char ));
    }
    {
#line 284
    __cil_tmp8 = __builtin_constant_p(__buflen);
    }
#line 284
    if (__cil_tmp10 && ! ((unsigned long )__buflen <= __cil_tmp11 / sizeof(char ))) {
      {
#line 284
      __cil_tmp12 = __builtin_object_size(__buf, 1);
#line 284
      __cil_tmp13 = __gethostname_chk_warn(__buf, __buflen, __cil_tmp12);
#line 284
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 284
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 284
      __cil_tmp15 = __gethostname_chk(__buf, __buflen, __cil_tmp14);
#line 284
      tmp = __cil_tmp15;
      }
    }
#line 284
    tmp___0 = tmp;
  }
#line 284
  return (tmp___0);
}
}
#line 292
extern  __attribute__((__nothrow__)) int __getdomainname_chk(char *__buf , size_t __buflen ,
                                                             size_t __nreal ) ;
#line 294
extern  __attribute__((__nothrow__)) int __getdomainname_alias(char *__buf , size_t __buflen ) ;
#line 298
extern  __attribute__((__nothrow__)) int __getdomainname_chk_warn(char *__buf , size_t __buflen ,
                                                                  size_t __nreal ) ;
#line 306
__inline extern  __attribute__((__nothrow__)) int getdomainname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 306 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getdomainname(char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 308
  __cil_tmp6 = __builtin_object_size(__buf, 1);
  }
  {
#line 308
  __cil_tmp4 = __builtin_object_size(__buf, 1);
#line 308
  __cil_tmp5 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp4 / sizeof(char ));
  }
  {
#line 308
  __cil_tmp3 = __builtin_constant_p(__buflen);
  }
#line 308
  if (__cil_tmp5 && (unsigned long )__buflen <= __cil_tmp6 / sizeof(char )) {
    {
#line 308
    __cil_tmp7 = __getdomainname_alias(__buf, __buflen);
#line 308
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 308
    __cil_tmp11 = __builtin_object_size(__buf, 1);
    }
    {
#line 308
    __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 308
    __cil_tmp10 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp9 / sizeof(char ));
    }
    {
#line 308
    __cil_tmp8 = __builtin_constant_p(__buflen);
    }
#line 308
    if (__cil_tmp10 && ! ((unsigned long )__buflen <= __cil_tmp11 / sizeof(char ))) {
      {
#line 308
      __cil_tmp12 = __builtin_object_size(__buf, 1);
#line 308
      __cil_tmp13 = __getdomainname_chk_warn(__buf, __buflen, __cil_tmp12);
#line 308
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 308
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 308
      __cil_tmp15 = __getdomainname_chk(__buf, __buflen, __cil_tmp14);
#line 308
      tmp = __cil_tmp15;
      }
    }
#line 308
    tmp___0 = tmp;
  }
#line 308
  return (tmp___0);
}
}
#line 34 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h"
extern  __attribute__((__nothrow__)) __pid_t gettid(void) ;
#line 60 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/../include/sane/sanei_codec_ascii.h"
void sanei_codec_ascii_init(Wire *w ) ;
#line 59 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_save_values.c"
int sanei_save_values(int fd , SANE_Handle device ) 
{ 
  SANE_Option_Descriptor *opt ;
  size_t word_array_size ;
  SANE_Word *word_array ;
  size_t str_size ;
  SANE_String str ;
  SANE_Word word ;
  Wire w ;
  int i ;
  SANE_Option_Descriptor *__cil_tmp11 ;
  SANE_Status __cil_tmp12 ;
  SANE_Int len ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  SANE_Status __cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  SANE_Status __cil_tmp19 ;

  {
  {
#line 62
  word_array_size = (size_t )0;
#line 63
  word_array = (SANE_Word *)0;
#line 64
  str_size = (size_t )0;
#line 65
  str = (SANE_String )0;
#line 70
  w.io.fd = fd;
#line 75
  w.io.read = & read;
#line 76
  w.io.write = & write;
#line 78
  sanei_w_init(& w, & sanei_codec_ascii_init);
#line 79
  sanei_w_set_dir(& w, (WireDirection )0);
#line 81
  i = 0;
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! opt) {
#line 81
      goto while_break;
    }
#line 83
    if (! opt->name) {
#line 87
      goto while_continue;
    } else
#line 83
    if ((opt->cap & (1 | (1 << 2))) != (1 | (1 << 2))) {
#line 87
      goto while_continue;
    }
    {
#line 93
    if ((unsigned int )opt->type == (unsigned int )2) {
#line 93
      goto case_2;
    }
#line 93
    if ((unsigned int )opt->type == (unsigned int )1) {
#line 93
      goto case_2;
    }
#line 93
    if ((unsigned int )opt->type == (unsigned int )0) {
#line 93
      goto case_2;
    }
#line 134
    if ((unsigned int )opt->type == (unsigned int )3) {
#line 134
      goto case_3;
    }
#line 158
    if ((unsigned int )opt->type == (unsigned int )5) {
#line 158
      goto case_5;
    }
#line 158
    if ((unsigned int )opt->type == (unsigned int )4) {
#line 158
      goto case_5;
    }
#line 89
    goto switch_break;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 94
    if ((unsigned long )opt->size == sizeof(SANE_Word )) {
      {
#line 96
      __cil_tmp12 = sane_control_option(device, i, (SANE_Action )0, & word, (SANE_Int *)0);
      }
#line 96
      if ((unsigned int )__cil_tmp12 != 0U) {
#line 99
        goto while_continue;
      }
      {
#line 100
      sanei_w_string(& w, (SANE_String *)(& opt->name));
#line 101
      sanei_w_word(& w, & word);
      }
    } else {
#line 105
      len = (SANE_Int )((unsigned long )opt->size / sizeof(SANE_Word ));
#line 107
      if ((unsigned long )opt->size > word_array_size) {
#line 109
        word_array_size = ((unsigned long )opt->size + 32UL * sizeof(SANE_Word )) & ~ (32UL * sizeof(SANE_Word ) - 1UL);
#line 112
        if (word_array) {
          {
#line 113
          word_array = (SANE_Word *)realloc(word_array, word_array_size);
          }
        } else {
          {
#line 115
          word_array = (SANE_Word *)malloc(word_array_size);
          }
        }
#line 117
        if (word_array == (SANE_Word *)0) {
#line 120
          w.status = 12;
#line 121
          return (1);
        }
      }
      {
#line 124
      __cil_tmp16 = sane_control_option(device, i, (SANE_Action )0, word_array, (SANE_Int *)0);
      }
#line 124
      if ((unsigned int )__cil_tmp16 != 0U) {
#line 127
        goto while_continue;
      }
      {
#line 128
      sanei_w_string(& w, (SANE_String *)(& opt->name));
#line 129
      sanei_w_array(& w, & len, (void **)(& word_array), (WireCodecFunc )(& sanei_w_word),
                    sizeof(SANE_Word ));
      }
    }
#line 132
    goto switch_break;
    case_3: /* CIL Label */ 
#line 135
    if ((unsigned long )opt->size > str_size) {
#line 137
      str_size = (size_t )((opt->size + 1024) & -1024);
#line 138
      if (str) {
        {
#line 139
        str = (SANE_String )realloc(str, str_size);
        }
      } else {
        {
#line 141
        str = (SANE_String )malloc(str_size);
        }
      }
#line 143
      if (str == (SANE_String )0) {
#line 146
        w.status = 12;
#line 147
        return (1);
      }
    }
    {
#line 150
    __cil_tmp19 = sane_control_option(device, i, (SANE_Action )0, str, (SANE_Int *)0);
    }
#line 150
    if ((unsigned int )__cil_tmp19 != 0U) {
#line 152
      goto while_continue;
    }
    {
#line 153
    sanei_w_string(& w, (SANE_String *)(& opt->name));
#line 154
    sanei_w_string(& w, & str);
    }
#line 155
    goto switch_break;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 159
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 81
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 162
  sanei_w_set_dir(& w, (WireDirection )1);
  }
#line 164
  if (word_array) {
    {
#line 165
    free(word_array);
    }
  }
#line 166
  if (str) {
    {
#line 167
    free(str);
    }
  }
#line 168
  return (0);
}
}
#line 88 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_load_values.c"
int sanei_load_values(int fd , SANE_Handle device ) 
{ 
  SANE_Option_Descriptor *opt ;
  SANE_Word *word_array ;
  SANE_String name ;
  SANE_String str ;
  u_long *caused_reload ;
  SANE_Int num_options ;
  SANE_Status status ;
  int i ;
  int keep_going ;
  SANE_Word word ;
  SANE_Int info ;
  __off_t offset ;
  size_t size ;
  char *buf ;
  Wire w ;
  __off_t __cil_tmp18 ;
  void *__cil_tmp19 ;
  SANE_Option_Descriptor *__cil_tmp20 ;
  int __cil_tmp21 ;
  SANE_Status __cil_tmp22 ;
  SANE_Int len ;
  SANE_Status __cil_tmp24 ;
  void *__cil_tmp25 ;
  SANE_Status __cil_tmp26 ;

  {
  {
#line 104
  offset = lseek(fd, (__off_t )0, 1);
#line 105
  w.io.fd = fd;
#line 110
  w.io.read = & read;
#line 111
  w.io.write = & write;
#line 113
  sanei_w_init(& w, & sanei_codec_ascii_init);
#line 114
  sanei_w_set_dir(& w, (WireDirection )1);
#line 115
  keep_going = 0;
#line 117
  sane_control_option(device, 0, (SANE_Action )0, & num_options, (SANE_Int *)0);
#line 118
  size = ((((unsigned long )num_options + 8UL * sizeof(u_long )) - 1UL) / (8UL * sizeof(u_long ))) * sizeof(long );
#line 119
  caused_reload = (u_long *)__builtin_alloca(size);
#line 120
  memset(caused_reload, 0, size);
  }
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 124
    sanei_w_space(& w, (size_t )3);
    }
#line 126
    if (! w.status) {
      {
#line 127
      sanei_w_string(& w, & name);
      }
    }
#line 129
    if (w.status) {
#line 131
      if (keep_going) {
        {
#line 133
        lseek(fd, offset, 0);
#line 134
        sanei_w_set_dir(& w, (WireDirection )1);
#line 135
        keep_going = 0;
        }
#line 136
        goto while_continue;
      }
#line 138
      return (0);
    }
#line 141
    status = (SANE_Status )0;
#line 142
    info = 0;
#line 143
    i = 1;
    {
#line 143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 143
      if (! opt) {
#line 143
        goto while_break___0;
      }
      {
#line 145
      __cil_tmp21 = strcmp(opt->name, (char const   *)name);
      }
#line 145
      if (! opt->name) {
#line 146
        goto while_continue___0;
      } else
#line 145
      if (__cil_tmp21 != 0) {
#line 146
        goto while_continue___0;
      }
#line 148
      if ((*(caused_reload + (unsigned long )i / (8UL * sizeof(u_long ))) & (1UL << (unsigned long )i % (8UL * sizeof(u_long )))) != 0UL) {
#line 149
        goto while_continue___0;
      }
      {
#line 155
      if ((unsigned int )opt->type == (unsigned int )2) {
#line 155
        goto case_2;
      }
#line 155
      if ((unsigned int )opt->type == (unsigned int )1) {
#line 155
        goto case_2;
      }
#line 155
      if ((unsigned int )opt->type == (unsigned int )0) {
#line 155
        goto case_2;
      }
#line 181
      if ((unsigned int )opt->type == (unsigned int )3) {
#line 181
        goto case_3;
      }
#line 193
      if ((unsigned int )opt->type == (unsigned int )5) {
#line 193
        goto case_5;
      }
#line 193
      if ((unsigned int )opt->type == (unsigned int )4) {
#line 193
        goto case_5;
      }
#line 151
      goto switch_break;
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 156
      if ((unsigned long )opt->size == sizeof(SANE_Word )) {
        {
#line 158
        sanei_w_word(& w, & word);
#line 159
        status = sane_control_option(device, i, (SANE_Action )1, & word, & info);
        }
      } else {
        {
#line 167
        sanei_w_array(& w, & len, (void **)(& word_array), (WireCodecFunc )(& sanei_w_word),
                      sizeof(SANE_Word ));
#line 170
        status = sane_control_option(device, i, (SANE_Action )1, word_array, & info);
#line 173
        w.direction = (WireDirection )2;
#line 174
        sanei_w_array(& w, & len, (void **)(& word_array), (WireCodecFunc )(& sanei_w_word),
                      sizeof(SANE_Word ));
#line 177
        w.direction = (WireDirection )1;
        }
      }
#line 179
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 182
      sanei_w_string(& w, & str);
      }
      {
#line 183
      buf = (char *)malloc((unsigned long )opt->size);
#line 184
      strncpy(buf, (char const   *)str, (unsigned long )opt->size);
#line 185
      *(buf + (opt->size - 1)) = (char )'\000';
#line 186
      sanei_w_free(& w, (WireCodecFunc )(& sanei_w_string), & str);
#line 188
      status = sane_control_option(device, i, (SANE_Action )1, buf, & info);
      }
#line 190
      goto switch_break;
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
#line 194
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 196
      goto while_break___0;
#line 143
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 198
    sanei_w_free(& w, (WireCodecFunc )(& sanei_w_string), & name);
    }
#line 200
    if ((unsigned int )status == 0U) {
#line 200
      if (info & (1 << 1)) {
#line 202
        *(caused_reload + (unsigned long )i / (8UL * sizeof(u_long ))) |= 1UL << (unsigned long )i % (8UL * sizeof(u_long ));
#line 203
        keep_going = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  return (0);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t **__ctype_tolower_loc(void) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t **__ctype_toupper_loc(void) ;
#line 108
extern  __attribute__((__nothrow__)) int isalnum(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int isalpha(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int iscntrl(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int isdigit(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int islower(int  ) ;
#line 113
extern  __attribute__((__nothrow__)) int isgraph(int  ) ;
#line 114
extern  __attribute__((__nothrow__)) int isprint(int  ) ;
#line 115
extern  __attribute__((__nothrow__)) int ispunct(int  ) ;
#line 116
extern  __attribute__((__nothrow__)) int isspace(int  ) ;
#line 117
extern  __attribute__((__nothrow__)) int isupper(int  ) ;
#line 118
extern  __attribute__((__nothrow__)) int isxdigit(int  ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 130
extern  __attribute__((__nothrow__)) int isblank(int  ) ;
#line 135
extern  __attribute__((__nothrow__)) int isctype(int __c , int __mask ) ;
#line 142
extern  __attribute__((__nothrow__)) int isascii(int __c ) ;
#line 146
extern  __attribute__((__nothrow__)) int toascii(int __c ) ;
#line 150
extern  __attribute__((__nothrow__)) int _toupper(int  ) ;
#line 151
extern  __attribute__((__nothrow__)) int _tolower(int  ) ;
#line 207
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 207 "/usr/include/ctype.h"
__inline extern int tolower(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 209
  if (__c >= -128 && __c < 256) {
    {
#line 209
    __cil_tmp2 = __ctype_tolower_loc();
#line 209
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 209
    tmp = __c;
  }
#line 209
  return (tmp);
}
}
#line 213
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 213 "/usr/include/ctype.h"
__inline extern int toupper(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 215
  if (__c >= -128 && __c < 256) {
    {
#line 215
    __cil_tmp2 = __ctype_toupper_loc();
#line 215
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 215
    tmp = __c;
  }
#line 215
  return (tmp);
}
}
#line 251
extern  __attribute__((__nothrow__)) int isalnum_l(int  , locale_t  ) ;
#line 252
extern  __attribute__((__nothrow__)) int isalpha_l(int  , locale_t  ) ;
#line 253
extern  __attribute__((__nothrow__)) int iscntrl_l(int  , locale_t  ) ;
#line 254
extern  __attribute__((__nothrow__)) int isdigit_l(int  , locale_t  ) ;
#line 255
extern  __attribute__((__nothrow__)) int islower_l(int  , locale_t  ) ;
#line 256
extern  __attribute__((__nothrow__)) int isgraph_l(int  , locale_t  ) ;
#line 257
extern  __attribute__((__nothrow__)) int isprint_l(int  , locale_t  ) ;
#line 258
extern  __attribute__((__nothrow__)) int ispunct_l(int  , locale_t  ) ;
#line 259
extern  __attribute__((__nothrow__)) int isspace_l(int  , locale_t  ) ;
#line 260
extern  __attribute__((__nothrow__)) int isupper_l(int  , locale_t  ) ;
#line 261
extern  __attribute__((__nothrow__)) int isxdigit_l(int  , locale_t  ) ;
#line 263
extern  __attribute__((__nothrow__)) int isblank_l(int  , locale_t  ) ;
#line 267
extern  __attribute__((__nothrow__)) int __tolower_l(int __c , locale_t __l ) ;
#line 268
extern  __attribute__((__nothrow__)) int tolower_l(int __c , locale_t __l ) ;
#line 271
extern  __attribute__((__nothrow__)) int __toupper_l(int __c , locale_t __l ) ;
#line 272
extern  __attribute__((__nothrow__)) int toupper_l(int __c , locale_t __l ) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int stat(char const   *__file , struct stat *__buf ) ;
#line 210
extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__buf ) ;
#line 240
extern  __attribute__((__nothrow__)) int stat64(char const   *__file , struct stat64 *__buf ) ;
#line 242
extern  __attribute__((__nothrow__)) int fstat64(int __fd , struct stat64 *__buf ) ;
#line 264
extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   *__file ,
                                                 struct stat *__buf , int __flag ) ;
#line 291
extern  __attribute__((__nothrow__)) int fstatat64(int __fd , char const   *__file ,
                                                   struct stat64 *__buf , int __flag ) ;
#line 313
extern  __attribute__((__nothrow__)) int lstat(char const   *__file , struct stat *__buf ) ;
#line 338
extern  __attribute__((__nothrow__)) int lstat64(char const   *__file , struct stat64 *__buf ) ;
#line 352
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode ) ;
#line 359
extern  __attribute__((__nothrow__)) int lchmod(char const   *__file , __mode_t __mode ) ;
#line 365
extern  __attribute__((__nothrow__)) int fchmod(int __fd , __mode_t __mode ) ;
#line 371
extern  __attribute__((__nothrow__)) int fchmodat(int __fd , char const   *__file ,
                                                  __mode_t __mode , int __flag ) ;
#line 380
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 385
extern  __attribute__((__nothrow__)) __mode_t getumask(void) ;
#line 389
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode ) ;
#line 396
extern  __attribute__((__nothrow__)) int mkdirat(int __fd , char const   *__path ,
                                                 __mode_t __mode ) ;
#line 404
extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                               __dev_t __dev ) ;
#line 411
extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                 __mode_t __mode , __dev_t __dev ) ;
#line 418
extern  __attribute__((__nothrow__)) int mkfifo(char const   *__path , __mode_t __mode ) ;
#line 425
extern  __attribute__((__nothrow__)) int mkfifoat(int __fd , char const   *__path ,
                                                  __mode_t __mode ) ;
#line 433
extern  __attribute__((__nothrow__)) int utimensat(int __fd , char const   *__path ,
                                                   struct timespec __times[2] , int __flags ) ;
#line 452
extern  __attribute__((__nothrow__)) int futimens(int __fd , struct timespec __times[2] ) ;
#line 60 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h"
 __attribute__((__nothrow__)) int statx(int __dirfd , char const   *__path , int __flags ,
                                        unsigned int __mask , struct statx *__buf ) ;
#line 113 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/../include/sane/sanei_debug.h"
int sanei_debug_sanei_debug  =    0;
#line 146
static void sanei_debug_sanei_debug_call(int level , char const   *msg  , ...) ;
#line 153 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/../include/sane/sanei_debug.h"
static void sanei_debug_sanei_debug_call(int level , char const   *msg  , ...) 
{ 
  va_list ap ;

  {
  {
#line 157
  __builtin_va_start((void *)ap, msg);
#line 158
  sanei_debug_msg(level, sanei_debug_sanei_debug, "sanei_debug", msg, (void *)ap);
#line 159
  __builtin_va_end((void *)ap);
  }
  return;
}
}
#line 69 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_init_debug.c"
void sanei_init_debug(char const   *backend , int *var ) 
{ 
  char ch ;
  char buf[256] ;
  char const   *val ;
  unsigned int i ;
  char *__cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 71
  buf = "SANE_DEBUG_";
#line 75
  *var = 0;
#line 77
  i = (unsigned int )11;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! ((int )ch != 0)) {
#line 77
      goto while_break;
    }
#line 79
    if ((unsigned long )i >= sizeof(buf) - 1UL) {
#line 80
      goto while_break;
    }
#line 81
    buf[i] = (char )0;
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 83
  buf[i] = (char )'\000';
#line 85
  __cil_tmp7 = getenv((char const   *)((char *)buf));
#line 85
  val = (char const   *)__cil_tmp7;
  }
#line 87
  if (! val) {
#line 88
    return;
  }
  {
#line 90
  *var = atoi(val);
#line 92
  sanei_debug_sanei_debug_call(0, "Setting debug level of %s to %d.\n", backend, *var);
  }
  return;
}
}
#line 96 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_init_debug.c"
void sanei_debug_msg(int level , int max_level , char const   *be , char const   *fmt ,
                     va_list ap ) 
{ 
  char *msg ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  void *__cil_tmp11 ;

  {
#line 101
  if (max_level >= level) {
    {
#line 103
    __cil_tmp7 = fileno(stderr);
#line 103
    __cil_tmp8 = isfdtype(__cil_tmp7, 49152);
    }
#line 103
    if (1 == __cil_tmp8) {
      {
#line 105
      __cil_tmp10 = strlen(fmt);
      }
      {
#line 105
      __cil_tmp9 = strlen(be);
#line 105
      __cil_tmp11 = malloc(sizeof(char ) * ((__cil_tmp9 + __cil_tmp10) + 4UL));
#line 105
      msg = (char *)__cil_tmp11;
      }
#line 106
      if (msg == (void *)0) {
        {
#line 108
        syslog(7, "[sanei_debug] malloc() failed\n");
#line 109
        vsyslog(7, fmt, ap);
        }
      } else {
        {
#line 113
        sprintf(msg, "[%s] %s", be, fmt);
#line 114
        vsyslog(7, (char const   *)msg, ap);
#line 115
        free(msg);
        }
      }
    } else {
      {
#line 120
      fprintf(stderr, "[%s] ", be);
#line 121
      vfprintf(stderr, fmt, ap);
      }
    }
  }
  return;
}
}
#line 59 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/../include/sane/sanei_codec_bin.h"
void sanei_codec_bin_init(Wire *w ) ;
#line 52 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_codec_bin.c"
static void bin_w_byte(Wire *w , void *v ) 
{ 
  SANE_Byte *b ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 54
  b = v;
#line 56
  sanei_w_space(w, (size_t )1);
  }
#line 57
  if (w->status) {
#line 58
    return;
  }
  {
#line 62
  if ((unsigned int )w->direction == (unsigned int )0) {
#line 62
    goto case_0;
  }
#line 66
  if ((unsigned int )w->direction == (unsigned int )1) {
#line 66
    goto case_1;
  }
#line 70
  if ((unsigned int )w->direction == (unsigned int )2) {
#line 70
    goto case_2;
  }
#line 60
  goto switch_break;
  case_0: /* CIL Label */ 
#line 63
  __cil_tmp4 = w->buffer.curr;
#line 63
  (w->buffer.curr) ++;
#line 63
  *__cil_tmp4 = (char )*b;
#line 64
  goto switch_break;
  case_1: /* CIL Label */ 
#line 67
  __cil_tmp5 = w->buffer.curr;
#line 67
  (w->buffer.curr) ++;
#line 67
  *b = (SANE_Byte )*__cil_tmp5;
#line 68
  goto switch_break;
  case_2: /* CIL Label */ 
#line 71
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
#line 76 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_codec_bin.c"
static void bin_w_string(Wire *w , void *v ) 
{ 
  SANE_Word len ;
  SANE_String *s ;
  unsigned long __cil_tmp5 ;

  {
#line 79
  s = v;
#line 81
  if ((unsigned int )w->direction != 1U) {
#line 83
    len = 0;
#line 84
    if (*s) {
      {
#line 85
      __cil_tmp5 = strlen((char const   *)*s);
#line 85
      len = (SANE_Word )(__cil_tmp5 + 1UL);
      }
    }
  }
  {
#line 87
  sanei_w_array(w, & len, v, w->codec.w_byte, (size_t )1);
  }
#line 89
  if ((unsigned int )w->direction == 1U) {
#line 91
    if (len == 0) {
#line 92
      *s = (SANE_String )0;
    } else
#line 93
    if (w->status == 0) {
#line 94
      *((*s + len) - 1) = (SANE_Char )'\000';
    }
  }
  return;
}
}
#line 99 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_codec_bin.c"
static void bin_w_word(Wire *w , void *v ) 
{ 
  SANE_Word val ;
  SANE_Word *word ;

  {
  {
#line 101
  word = v;
#line 103
  sanei_w_space(w, (size_t )4);
  }
#line 104
  if (w->status) {
#line 105
    return;
  }
  {
#line 108
  if ((unsigned int )w->direction == (unsigned int )0) {
#line 108
    goto case_0;
  }
#line 118
  if ((unsigned int )w->direction == (unsigned int )1) {
#line 118
    goto case_1;
  }
#line 127
  if ((unsigned int )w->direction == (unsigned int )2) {
#line 127
    goto case_2;
  }
#line 106
  goto switch_break;
  case_0: /* CIL Label */ 
#line 109
  val = *word;
#line 111
  *(w->buffer.curr + 0) = (char )((val >> 24) & 255);
#line 112
  *(w->buffer.curr + 1) = (char )((val >> 16) & 255);
#line 113
  *(w->buffer.curr + 2) = (char )((val >> 8) & 255);
#line 114
  *(w->buffer.curr + 3) = (char )(val & 255);
#line 115
  w->buffer.curr += 4;
#line 116
  goto switch_break;
  case_1: /* CIL Label */ 
#line 119
  val = (((((int )*(w->buffer.curr + 0) & 255) << 24) | (((int )*(w->buffer.curr + 1) & 255) << 16)) | (((int )*(w->buffer.curr + 2) & 255) << 8)) | ((int )*(w->buffer.curr + 3) & 255);
#line 123
  *word = val;
#line 124
  w->buffer.curr += 4;
#line 125
  goto switch_break;
  case_2: /* CIL Label */ 
#line 128
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
#line 133 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_codec_bin.c"
void sanei_codec_bin_init(Wire *w ) 
{ 


  {
#line 135
  w->codec.w_byte = & bin_w_byte;
#line 136
  w->codec.w_char = & bin_w_byte;
#line 137
  w->codec.w_word = & bin_w_word;
#line 138
  w->codec.w_string = & bin_w_string;
  return;
}
}
#line 52 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_codec_ascii.c"
static char const   *hexdigit  =    "0123456789abcdef\220";
#line 55 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_codec_ascii.c"
static void skip_ws(Wire *w ) 
{ 
  unsigned short const   **__cil_tmp2 ;

  {
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 59
    sanei_w_space(w, (size_t )1);
    }
#line 60
    if (w->status != 0) {
#line 61
      return;
    }
    {
#line 63
    __cil_tmp2 = __ctype_b_loc();
    }
#line 63
    if (! ((int )*(*__cil_tmp2 + (int )*(w->buffer.curr)) & 8192)) {
#line 64
      return;
    }
#line 66
    (w->buffer.curr) ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 71 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_codec_ascii.c"
static unsigned int get_digit(Wire *w ) 
{ 
  unsigned int digit ;

  {
  {
#line 75
  sanei_w_space(w, (size_t )1);
#line 76
  digit = (unsigned int )-48;
  }
#line 77
  if (digit > 9U) {
#line 78
    digit -= (unsigned int )39;
  }
#line 79
  if (digit > 15U) {
#line 81
    w->status = 22;
#line 82
    return ((unsigned int )0);
  }
#line 84
  return (digit);
}
}
#line 88 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_codec_ascii.c"
static SANE_Byte get_byte(Wire *w ) 
{ 
  unsigned int __cil_tmp2 ;
  unsigned int __cil_tmp3 ;

  {
  {
#line 90
  __cil_tmp3 = get_digit(w);
  }
  {
#line 90
  __cil_tmp2 = get_digit(w);
  }
#line 90
  return ((SANE_Byte )((__cil_tmp2 << 4) | __cil_tmp3));
}
}
#line 94 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_codec_ascii.c"
static void ascii_w_byte(Wire *w , void *v ) 
{ 
  SANE_Byte *b ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  SANE_Byte __cil_tmp7 ;

  {
#line 96
  b = v;
  {
#line 100
  if ((unsigned int )w->direction == (unsigned int )0) {
#line 100
    goto case_0;
  }
#line 107
  if ((unsigned int )w->direction == (unsigned int )1) {
#line 107
    goto case_1;
  }
#line 112
  if ((unsigned int )w->direction == (unsigned int )2) {
#line 112
    goto case_2;
  }
#line 98
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 101
  sanei_w_space(w, (size_t )3);
  }
#line 102
  __cil_tmp4 = w->buffer.curr;
#line 102
  (w->buffer.curr) ++;
#line 102
  *__cil_tmp4 = *(hexdigit + (((int )*b >> 4) & 15));
#line 103
  __cil_tmp5 = w->buffer.curr;
#line 103
  (w->buffer.curr) ++;
#line 103
  *__cil_tmp5 = *(hexdigit + ((int )*b & 15));
#line 104
  __cil_tmp6 = w->buffer.curr;
#line 104
  (w->buffer.curr) ++;
#line 104
  *__cil_tmp6 = (char )'\n';
#line 105
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 108
  skip_ws(w);
  }
  {
#line 109
  *b = get_byte(w);
  }
#line 110
  goto switch_break;
  case_2: /* CIL Label */ 
#line 113
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
#line 118 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_codec_ascii.c"
static void ascii_w_char(Wire *w , void *v ) 
{ 
  SANE_Char *c ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 120
  c = v;
  {
#line 124
  if ((unsigned int )w->direction == (unsigned int )0) {
#line 124
    goto case_0;
  }
#line 134
  if ((unsigned int )w->direction == (unsigned int )1) {
#line 134
    goto case_1;
  }
#line 154
  if ((unsigned int )w->direction == (unsigned int )2) {
#line 154
    goto case_2;
  }
#line 122
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 125
  sanei_w_space(w, (size_t )5);
  }
#line 126
  __cil_tmp4 = w->buffer.curr;
#line 126
  (w->buffer.curr) ++;
#line 126
  *__cil_tmp4 = (char )'\'';
#line 127
  if ((int )*c == 39) {
#line 128
    __cil_tmp5 = w->buffer.curr;
#line 128
    (w->buffer.curr) ++;
#line 128
    *__cil_tmp5 = (char )'\\';
  } else
#line 127
  if ((int )*c == 92) {
#line 128
    __cil_tmp5 = w->buffer.curr;
#line 128
    (w->buffer.curr) ++;
#line 128
    *__cil_tmp5 = (char )'\\';
  }
#line 129
  __cil_tmp6 = w->buffer.curr;
#line 129
  (w->buffer.curr) ++;
#line 129
  *__cil_tmp6 = *c;
#line 130
  __cil_tmp7 = w->buffer.curr;
#line 130
  (w->buffer.curr) ++;
#line 130
  *__cil_tmp7 = (char )'\'';
#line 131
  __cil_tmp8 = w->buffer.curr;
#line 131
  (w->buffer.curr) ++;
#line 131
  *__cil_tmp8 = (char )'\n';
#line 132
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 135
  sanei_w_space(w, (size_t )4);
  }
#line 136
  __cil_tmp9 = w->buffer.curr;
#line 136
  (w->buffer.curr) ++;
#line 136
  if ((int )*__cil_tmp9 != 39) {
#line 138
    w->status = 22;
#line 139
    return;
  }
#line 141
  __cil_tmp10 = w->buffer.curr;
#line 141
  (w->buffer.curr) ++;
#line 141
  *c = *__cil_tmp10;
#line 142
  if ((int )*c == 92) {
    {
#line 144
    sanei_w_space(w, (size_t )2);
#line 145
    __cil_tmp11 = w->buffer.curr;
#line 145
    (w->buffer.curr) ++;
#line 145
    *c = *__cil_tmp11;
    }
  }
#line 147
  __cil_tmp12 = w->buffer.curr;
#line 147
  (w->buffer.curr) ++;
#line 147
  if ((int )*__cil_tmp12 != 39) {
#line 149
    w->status = 22;
#line 150
    return;
  }
#line 152
  goto switch_break;
  case_2: /* CIL Label */ 
#line 155
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
#line 160 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_codec_ascii.c"
static void ascii_w_string(Wire *w , void *v ) 
{ 
  size_t len ;
  size_t alloced_len ;
  SANE_String *s ;
  char *str ;
  char ch ;
  int done ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  size_t __cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 163
  s = v;
  {
#line 169
  if ((unsigned int )w->direction == (unsigned int )0) {
#line 169
    goto case_0;
  }
#line 197
  if ((unsigned int )w->direction == (unsigned int )1) {
#line 197
    goto case_1;
  }
#line 271
  if ((unsigned int )w->direction == (unsigned int )2) {
#line 271
    goto case_2;
  }
#line 167
  goto switch_break;
  case_0: /* CIL Label */ 
#line 170
  if (*s) {
    {
#line 172
    sanei_w_space(w, (size_t )1);
#line 173
    __cil_tmp9 = w->buffer.curr;
#line 173
    (w->buffer.curr) ++;
#line 173
    *__cil_tmp9 = (char )'\"';
#line 174
    str = *s;
    }
    {
#line 175
    while (1) {
      while_continue: /* CIL Label */ ;
#line 175
      __cil_tmp10 = str;
#line 175
      str ++;
#line 175
      ch = *__cil_tmp10;
#line 175
      if (! ch) {
#line 175
        goto while_break;
      }
      {
#line 177
      sanei_w_space(w, (size_t )2);
      }
#line 178
      if ((int )ch == 34) {
#line 179
        __cil_tmp11 = w->buffer.curr;
#line 179
        (w->buffer.curr) ++;
#line 179
        *__cil_tmp11 = (char )'\\';
      } else
#line 178
      if ((int )ch == 92) {
#line 179
        __cil_tmp11 = w->buffer.curr;
#line 179
        (w->buffer.curr) ++;
#line 179
        *__cil_tmp11 = (char )'\\';
      }
#line 180
      __cil_tmp12 = w->buffer.curr;
#line 180
      (w->buffer.curr) ++;
#line 180
      *__cil_tmp12 = ch;
    }
    while_break: /* CIL Label */ ;
    }
#line 182
    __cil_tmp13 = w->buffer.curr;
#line 182
    (w->buffer.curr) ++;
#line 182
    *__cil_tmp13 = (char )'\"';
  } else {
    {
#line 186
    sanei_w_space(w, (size_t )5);
#line 187
    __cil_tmp14 = w->buffer.curr;
#line 187
    (w->buffer.curr) ++;
#line 187
    *__cil_tmp14 = (char )'(';
#line 188
    __cil_tmp15 = w->buffer.curr;
#line 188
    (w->buffer.curr) ++;
#line 188
    *__cil_tmp15 = (char )'n';
#line 189
    __cil_tmp16 = w->buffer.curr;
#line 189
    (w->buffer.curr) ++;
#line 189
    *__cil_tmp16 = (char )'i';
#line 190
    __cil_tmp17 = w->buffer.curr;
#line 190
    (w->buffer.curr) ++;
#line 190
    *__cil_tmp17 = (char )'l';
#line 191
    __cil_tmp18 = w->buffer.curr;
#line 191
    (w->buffer.curr) ++;
#line 191
    *__cil_tmp18 = (char )')';
    }
  }
  {
#line 193
  sanei_w_space(w, (size_t )1);
#line 194
  __cil_tmp19 = w->buffer.curr;
#line 194
  (w->buffer.curr) ++;
#line 194
  *__cil_tmp19 = (char )'\n';
  }
#line 195
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 198
  skip_ws(w);
  }
  {
#line 199
  sanei_w_space(w, (size_t )1);
#line 200
  __cil_tmp20 = w->buffer.curr;
#line 200
  (w->buffer.curr) ++;
#line 200
  ch = *__cil_tmp20;
  }
#line 201
  if ((int )ch == 34) {
#line 203
    len = (size_t )0;
#line 203
    alloced_len = len;
#line 204
    str = (char *)0;
#line 205
    done = 0;
    {
#line 206
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 208
      sanei_w_space(w, (size_t )1);
      }
#line 209
      if (w->status != 0) {
#line 210
        return;
      }
#line 212
      __cil_tmp21 = w->buffer.curr;
#line 212
      (w->buffer.curr) ++;
#line 212
      ch = *__cil_tmp21;
#line 213
      if ((int )ch == 34) {
#line 214
        done = 1;
      }
#line 216
      if ((int )ch == 92) {
        {
#line 218
        sanei_w_space(w, (size_t )1);
#line 219
        __cil_tmp22 = w->buffer.curr;
#line 219
        (w->buffer.curr) ++;
#line 219
        ch = *__cil_tmp22;
        }
      }
#line 222
      if (len >= alloced_len) {
#line 224
        alloced_len += (unsigned long )1024;
#line 225
        if (! str) {
          {
#line 226
          str = (char *)malloc(alloced_len);
          }
        } else {
          {
#line 228
          str = (char *)realloc(str, alloced_len);
          }
        }
#line 230
        if (str == (char *)0) {
#line 233
          w->status = 12;
#line 234
          return;
        }
      }
#line 237
      __cil_tmp25 = len;
#line 237
      len ++;
#line 237
      *(str + __cil_tmp25) = ch;
#line 206
      if (! (! done)) {
#line 206
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 241
    *(str + (len - 1UL)) = (char )'\000';
#line 242
    *s = (SANE_String )realloc(str, len);
    }
#line 244
    if (*s == (SANE_String )0) {
#line 247
      w->status = 12;
#line 248
      return;
    }
  } else
#line 251
  if ((int )ch == 40) {
    {
#line 253
    sanei_w_space(w, (size_t )4);
#line 254
    __cil_tmp30 = w->buffer.curr;
#line 254
    (w->buffer.curr) ++;
    }
#line 254
    __cil_tmp29 = w->buffer.curr;
#line 254
    (w->buffer.curr) ++;
#line 254
    __cil_tmp28 = w->buffer.curr;
#line 254
    (w->buffer.curr) ++;
#line 254
    __cil_tmp27 = w->buffer.curr;
#line 254
    (w->buffer.curr) ++;
#line 254
    if ((int )*__cil_tmp27 != 110) {
#line 259
      w->status = 22;
#line 260
      return;
    } else
#line 254
    if ((int )*__cil_tmp28 != 105) {
#line 259
      w->status = 22;
#line 260
      return;
    } else
#line 254
    if ((int )*__cil_tmp29 != 108) {
#line 259
      w->status = 22;
#line 260
      return;
    } else
#line 254
    if ((int )*__cil_tmp30 != 41) {
#line 259
      w->status = 22;
#line 260
      return;
    }
#line 262
    *s = (SANE_String )0;
  } else {
#line 266
    w->status = 22;
#line 267
    return;
  }
#line 269
  goto switch_break;
  case_2: /* CIL Label */ 
#line 272
  if (*s) {
    {
#line 273
    free(*s);
    }
  }
#line 274
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
#line 279 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_codec_ascii.c"
static void ascii_w_word(Wire *w , void *v ) 
{ 
  SANE_Word val ;
  SANE_Word *word ;
  int i ;
  int is_negative ;
  char buf[16] ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  char *__cil_tmp10 ;
  unsigned short const   **__cil_tmp11 ;
  char *__cil_tmp12 ;
  SANE_Word tmp ;

  {
#line 281
  word = v;
#line 282
  is_negative = 0;
  {
#line 287
  if ((unsigned int )w->direction == (unsigned int )0) {
#line 287
    goto case_0;
  }
#line 310
  if ((unsigned int )w->direction == (unsigned int )1) {
#line 310
    goto case_1;
  }
#line 333
  if ((unsigned int )w->direction == (unsigned int )2) {
#line 333
    goto case_2;
  }
#line 285
  goto switch_break;
  case_0: /* CIL Label */ 
#line 288
  val = *word;
#line 289
  i = (int )(sizeof(buf) - 1UL);
#line 290
  if (val < 0) {
#line 292
    is_negative = 1;
#line 293
    val = - val;
  }
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    __cil_tmp8 = i;
#line 297
    i --;
#line 297
    buf[__cil_tmp8] = (char )(48 + val % 10);
#line 298
    val /= 10;
#line 295
    if (! val) {
#line 295
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  if (is_negative) {
#line 302
    __cil_tmp9 = i;
#line 302
    i --;
#line 302
    buf[__cil_tmp9] = (char )'-';
  }
  {
#line 304
  sanei_w_space(w, sizeof(buf) - (unsigned long )i);
#line 305
  memcpy(w->buffer.curr, ((char *)buf + i) + 1, (sizeof(buf) - (unsigned long )i) - 1UL);
#line 306
  w->buffer.curr += (sizeof(buf) - (unsigned long )i) - 1UL;
#line 307
  __cil_tmp10 = w->buffer.curr;
#line 307
  (w->buffer.curr) ++;
#line 307
  *__cil_tmp10 = (char )'\n';
  }
#line 308
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 311
  skip_ws(w);
  }
  {
#line 312
  val = 0;
#line 313
  sanei_w_space(w, (size_t )1);
  }
#line 314
  if ((int )*(w->buffer.curr) == 45) {
#line 316
    is_negative = 1;
#line 317
    (w->buffer.curr) ++;
  }
  {
#line 319
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 321
    sanei_w_space(w, (size_t )1);
    }
#line 322
    if (w->status != 0) {
#line 323
      return;
    }
    {
#line 325
    __cil_tmp11 = __ctype_b_loc();
    }
#line 325
    if (! ((int )*(*__cil_tmp11 + (int )*(w->buffer.curr)) & 2048)) {
#line 326
      goto while_break___0;
    }
#line 328
    __cil_tmp12 = w->buffer.curr;
#line 328
    (w->buffer.curr) ++;
#line 328
    val = 10 * val + ((int )*__cil_tmp12 - 48);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 330
  if (is_negative) {
#line 330
    tmp = - val;
  } else {
#line 330
    tmp = val;
  }
#line 330
  *word = tmp;
#line 331
  goto switch_break;
  case_2: /* CIL Label */ 
#line 334
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
#line 339 "/root/oss-experiment/data/sane-frontends-1.0.14/sanei/sanei_codec_ascii.c"
void sanei_codec_ascii_init(Wire *w ) 
{ 


  {
#line 341
  w->codec.w_byte = & ascii_w_byte;
#line 342
  w->codec.w_char = & ascii_w_char;
#line 343
  w->codec.w_word = & ascii_w_word;
#line 344
  w->codec.w_string = & ascii_w_string;
  return;
}
}
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__)) void __assert_fail(char const   *__assertion ,
                                                        char const   *__file , unsigned int __line ,
                                                        char const   *__function ) ;
#line 74
extern  __attribute__((__nothrow__)) void __assert_perror_fail(int __errnum , char const   *__file ,
                                                               unsigned int __line ,
                                                               char const   *__function ) ;
#line 81
extern  __attribute__((__nothrow__)) void __assert(char const   *__assertion , char const   *__file ,
                                                   int __line ) ;
#line 72 "/usr/include/pwd.h"
extern void setpwent(void) ;
#line 78
extern void endpwent(void) ;
#line 84
extern struct passwd *getpwent(void) ;
#line 94
extern struct passwd *fgetpwent(FILE *__stream ) ;
#line 102
extern int putpwent(struct passwd *__p , FILE *__f ) ;
#line 110
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 116
extern struct passwd *getpwnam(char const   *__name ) ;
#line 139
extern int getpwent_r(struct passwd *__resultbuf , char *__buffer , size_t __buflen ,
                      struct passwd **__result ) ;
#line 146
extern int getpwuid_r(__uid_t __uid , struct passwd *__resultbuf , char *__buffer ,
                      size_t __buflen , struct passwd **__result ) ;
#line 153
extern int getpwnam_r(char const   *__name , struct passwd *__resultbuf , char *__buffer ,
                      size_t __buflen , struct passwd **__result ) ;
#line 169
extern int fgetpwent_r(FILE *__stream , struct passwd *__resultbuf , char *__buffer ,
                       size_t __buflen , struct passwd **__result ) ;
#line 188
extern int getpw(__uid_t __uid , char *__buffer ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h"
extern  __attribute__((__nothrow__)) long __sysconf(int __name ) ;
#line 78 "/usr/include/x86_64-linux-gnu/bits/time.h"
extern  __attribute__((__nothrow__)) int clock_adjtime(__clockid_t __clock_id , struct timex *__utx ) ;
#line 72 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
#line 76
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 79
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 ) ;
#line 83
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 100
extern  __attribute__((__nothrow__)) size_t strftime(char *__s , size_t __maxsize ,
                                                     char const   *__format , struct tm *__tp ) ;
#line 107
extern  __attribute__((__nothrow__)) char *strptime(char const   *__s , char const   *__fmt ,
                                                    struct tm *__tp ) ;
#line 116
extern  __attribute__((__nothrow__)) size_t strftime_l(char *__s , size_t __maxsize ,
                                                       char const   *__format , struct tm *__tp ,
                                                       locale_t __loc ) ;
#line 123
extern  __attribute__((__nothrow__)) char *strptime_l(char const   *__s , char const   *__fmt ,
                                                      struct tm *__tp , locale_t __loc ) ;
#line 132
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t *__timer ) ;
#line 136
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t *__timer ) ;
#line 154
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t *__timer , struct tm *__tp ) ;
#line 159
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t *__timer , struct tm *__tp ) ;
#line 179
extern  __attribute__((__nothrow__)) char *asctime(struct tm *__tp ) ;
#line 183
extern  __attribute__((__nothrow__)) char *ctime(time_t *__timer ) ;
#line 197
extern  __attribute__((__nothrow__)) char *asctime_r(struct tm *__tp , char *__buf ) ;
#line 202
extern  __attribute__((__nothrow__)) char *ctime_r(time_t *__timer , char *__buf ) ;
#line 217
extern char *__tzname[2] ;
#line 218
extern int __daylight ;
#line 219
extern long __timezone ;
#line 224
extern char *tzname[2] ;
#line 228
extern  __attribute__((__nothrow__)) void tzset(void) ;
#line 232
extern int daylight ;
#line 233
extern long timezone ;
#line 249
extern  __attribute__((__nothrow__)) time_t timegm(struct tm *__tp ) ;
#line 251
extern  __attribute__((__nothrow__)) time_t timelocal(struct tm *__tp ) ;
#line 262
extern  __attribute__((__nothrow__)) int dysize(int __year ) ;
#line 272
extern int nanosleep(struct timespec *__requested_time , struct timespec *__remaining ) ;
#line 276
extern  __attribute__((__nothrow__)) int clock_getres(clockid_t __clock_id , struct timespec *__res ) ;
#line 279
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 282
extern  __attribute__((__nothrow__)) int clock_settime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 311
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec *__req ,
                           struct timespec *__rem ) ;
#line 326
extern  __attribute__((__nothrow__)) int clock_getcpuclockid(pid_t __pid , clockid_t *__clock_id ) ;
#line 331
extern  __attribute__((__nothrow__)) int timer_create(clockid_t __clock_id , struct sigevent *__evp ,
                                                      timer_t *__timerid ) ;
#line 336
extern  __attribute__((__nothrow__)) int timer_delete(timer_t __timerid ) ;
#line 340
extern  __attribute__((__nothrow__)) int timer_settime(timer_t __timerid , int __flags ,
                                                       struct itimerspec *__value ,
                                                       struct itimerspec *__ovalue ) ;
#line 345
extern  __attribute__((__nothrow__)) int timer_gettime(timer_t __timerid , struct itimerspec *__value ) ;
#line 364
extern  __attribute__((__nothrow__)) int timer_getoverrun(timer_t __timerid ) ;
#line 371
extern  __attribute__((__nothrow__)) int timespec_get(struct timespec *__ts , int __base ) ;
#line 387
extern  __attribute__((__nothrow__)) int timespec_getres(struct timespec *__ts , int __base ) ;
#line 413
extern int getdate_err ;
#line 422
extern struct tm *getdate(char const   *__string ) ;
#line 436
extern int getdate_r(char const   *__string , struct tm *__resbufp ) ;
#line 70 "/usr/include/glib-2.0/glib/garray.h"
extern GArray *g_array_new(gboolean zero_terminated , gboolean clear_ , guint element_size ) ;
#line 74
extern gpointer g_array_steal(GArray *array , gsize *len ) ;
#line 77
extern GArray *g_array_sized_new(gboolean zero_terminated , gboolean clear_ , guint element_size ,
                                 guint reserved_size ) ;
#line 82
extern GArray *g_array_copy(GArray *array ) ;
#line 84
extern gchar *g_array_free(GArray *array , gboolean free_segment ) ;
#line 87
extern GArray *g_array_ref(GArray *array ) ;
#line 89
extern void g_array_unref(GArray *array ) ;
#line 91
extern guint g_array_get_element_size(GArray *array ) ;
#line 93
extern GArray *g_array_append_vals(GArray *array , gconstpointer data , guint len ) ;
#line 97
extern GArray *g_array_prepend_vals(GArray *array , gconstpointer data , guint len ) ;
#line 101
extern GArray *g_array_insert_vals(GArray *array , guint index_ , gconstpointer data ,
                                   guint len ) ;
#line 106
extern GArray *g_array_set_size(GArray *array , guint length ) ;
#line 109
extern GArray *g_array_remove_index(GArray *array , guint index_ ) ;
#line 112
extern GArray *g_array_remove_index_fast(GArray *array , guint index_ ) ;
#line 115
extern GArray *g_array_remove_range(GArray *array , guint index_ , guint length ) ;
#line 119
extern void g_array_sort(GArray *array , GCompareFunc compare_func ) ;
#line 122
extern void g_array_sort_with_data(GArray *array , GCompareDataFunc compare_func ,
                                   gpointer user_data ) ;
#line 126
extern gboolean g_array_binary_search(GArray *array , gconstpointer target , GCompareFunc compare_func ,
                                      guint *out_match_index ) ;
#line 131
extern void g_array_set_clear_func(GArray *array , GDestroyNotify clear_func ) ;
#line 140
extern GPtrArray *g_ptr_array_new(void) ;
#line 142
extern GPtrArray *g_ptr_array_new_with_free_func(GDestroyNotify element_free_func ) ;
#line 144
extern gpointer *g_ptr_array_steal(GPtrArray *array , gsize *len ) ;
#line 147
extern GPtrArray *g_ptr_array_copy(GPtrArray *array , GCopyFunc func , gpointer user_data ) ;
#line 151
extern GPtrArray *g_ptr_array_sized_new(guint reserved_size ) ;
#line 153
extern GPtrArray *g_ptr_array_new_full(guint reserved_size , GDestroyNotify element_free_func ) ;
#line 156
extern gpointer *g_ptr_array_free(GPtrArray *array , gboolean free_seg ) ;
#line 159
extern GPtrArray *g_ptr_array_ref(GPtrArray *array ) ;
#line 161
extern void g_ptr_array_unref(GPtrArray *array ) ;
#line 163
extern void g_ptr_array_set_free_func(GPtrArray *array , GDestroyNotify element_free_func ) ;
#line 166
extern void g_ptr_array_set_size(GPtrArray *array , gint length ) ;
#line 169
extern gpointer g_ptr_array_remove_index(GPtrArray *array , guint index_ ) ;
#line 172
extern gpointer g_ptr_array_remove_index_fast(GPtrArray *array , guint index_ ) ;
#line 175
extern gpointer g_ptr_array_steal_index(GPtrArray *array , guint index_ ) ;
#line 178
extern gpointer g_ptr_array_steal_index_fast(GPtrArray *array , guint index_ ) ;
#line 181
extern gboolean g_ptr_array_remove(GPtrArray *array , gpointer data ) ;
#line 184
extern gboolean g_ptr_array_remove_fast(GPtrArray *array , gpointer data ) ;
#line 187
extern GPtrArray *g_ptr_array_remove_range(GPtrArray *array , guint index_ , guint length ) ;
#line 191
extern void g_ptr_array_add(GPtrArray *array , gpointer data ) ;
#line 194
extern void g_ptr_array_extend(GPtrArray *array_to_extend , GPtrArray *array , GCopyFunc func ,
                               gpointer user_data ) ;
#line 199
extern void g_ptr_array_extend_and_steal(GPtrArray *array_to_extend , GPtrArray *array ) ;
#line 202
extern void g_ptr_array_insert(GPtrArray *array , gint index_ , gpointer data ) ;
#line 206
extern void g_ptr_array_sort(GPtrArray *array , GCompareFunc compare_func ) ;
#line 209
extern void g_ptr_array_sort_with_data(GPtrArray *array , GCompareDataFunc compare_func ,
                                       gpointer user_data ) ;
#line 213
extern void g_ptr_array_foreach(GPtrArray *array , GFunc func , gpointer user_data ) ;
#line 217
extern gboolean g_ptr_array_find(GPtrArray *haystack , gconstpointer needle , guint *index_ ) ;
#line 221
extern gboolean g_ptr_array_find_with_equal_func(GPtrArray *haystack , gconstpointer needle ,
                                                 GEqualFunc equal_func , guint *index_ ) ;
#line 232
extern GByteArray *g_byte_array_new(void) ;
#line 234
extern GByteArray *g_byte_array_new_take(guint8 *data , gsize len ) ;
#line 237
extern guint8 *g_byte_array_steal(GByteArray *array , gsize *len ) ;
#line 240
extern GByteArray *g_byte_array_sized_new(guint reserved_size ) ;
#line 242
extern guint8 *g_byte_array_free(GByteArray *array , gboolean free_segment ) ;
#line 245
extern GBytes *g_byte_array_free_to_bytes(GByteArray *array ) ;
#line 247
extern GByteArray *g_byte_array_ref(GByteArray *array ) ;
#line 249
extern void g_byte_array_unref(GByteArray *array ) ;
#line 251
extern GByteArray *g_byte_array_append(GByteArray *array , guint8 *data , guint len ) ;
#line 255
extern GByteArray *g_byte_array_prepend(GByteArray *array , guint8 *data , guint len ) ;
#line 259
extern GByteArray *g_byte_array_set_size(GByteArray *array , guint length ) ;
#line 262
extern GByteArray *g_byte_array_remove_index(GByteArray *array , guint index_ ) ;
#line 265
extern GByteArray *g_byte_array_remove_index_fast(GByteArray *array , guint index_ ) ;
#line 268
extern GByteArray *g_byte_array_remove_range(GByteArray *array , guint index_ , guint length ) ;
#line 272
extern void g_byte_array_sort(GByteArray *array , GCompareFunc compare_func ) ;
#line 275
extern void g_byte_array_sort_with_data(GByteArray *array , GCompareDataFunc compare_func ,
                                        gpointer user_data ) ;
#line 33 "/usr/include/glib-2.0/glib/gatomic.h"
extern gint g_atomic_int_get(gint *atomic ) ;
#line 35
extern void g_atomic_int_set(gint *atomic , gint newval ) ;
#line 38
extern void g_atomic_int_inc(gint *atomic ) ;
#line 40
extern gboolean g_atomic_int_dec_and_test(gint *atomic ) ;
#line 42
extern gboolean g_atomic_int_compare_and_exchange(gint *atomic , gint oldval , gint newval ) ;
#line 46
extern gint g_atomic_int_add(gint *atomic , gint val ) ;
#line 49
extern guint g_atomic_int_and(guint *atomic , guint val ) ;
#line 52
extern guint g_atomic_int_or(guint *atomic , guint val ) ;
#line 55
extern guint g_atomic_int_xor(guint *atomic , guint val ) ;
#line 59
extern gpointer g_atomic_pointer_get(void const   *atomic ) ;
#line 61
extern void g_atomic_pointer_set(void *atomic , gpointer newval ) ;
#line 64
extern gboolean g_atomic_pointer_compare_and_exchange(void *atomic , gpointer oldval ,
                                                      gpointer newval ) ;
#line 68
extern gssize g_atomic_pointer_add(void *atomic , gssize val ) ;
#line 71
extern gsize g_atomic_pointer_and(void *atomic , gsize val ) ;
#line 74
extern gsize g_atomic_pointer_or(void *atomic , gsize val ) ;
#line 77
extern gsize g_atomic_pointer_xor(void *atomic , gsize val ) ;
#line 81
extern gint g_atomic_int_exchange_and_add(gint *atomic , gint val ) ;
#line 41 "/usr/include/glib-2.0/glib/gquark.h"
extern GQuark g_quark_try_string(gchar *string ) ;
#line 43
extern GQuark g_quark_from_static_string(gchar *string ) ;
#line 45
extern GQuark g_quark_from_string(gchar *string ) ;
#line 47
extern gchar *g_quark_to_string(GQuark quark ) ;
#line 62
extern gchar *g_intern_string(gchar *string ) ;
#line 64
extern gchar *g_intern_static_string(gchar *string ) ;
#line 176 "/usr/include/glib-2.0/glib/gerror.h"
extern GQuark g_error_domain_register_static(char const   *error_type_name , gsize error_type_private_size ,
                                             GErrorInitFunc error_type_init , GErrorCopyFunc error_type_copy ,
                                             GErrorClearFunc error_type_clear ) ;
#line 183
extern GQuark g_error_domain_register(char const   *error_type_name , gsize error_type_private_size ,
                                      GErrorInitFunc error_type_init , GErrorCopyFunc error_type_copy ,
                                      GErrorClearFunc error_type_clear ) ;
#line 190
extern GError *g_error_new(GQuark domain , gint code , gchar *format  , ...) ;
#line 196
extern GError *g_error_new_literal(GQuark domain , gint code , gchar *message ) ;
#line 200
extern GError *g_error_new_valist(GQuark domain , gint code , gchar *format , va_list args ) ;
#line 206
extern void g_error_free(GError *error ) ;
#line 208
extern GError *g_error_copy(GError *error ) ;
#line 211
extern gboolean g_error_matches(GError *error , GQuark domain , gint code ) ;
#line 219
extern void g_set_error(GError **err , GQuark domain , gint code , gchar *format 
                        , ...) ;
#line 226
extern void g_set_error_literal(GError **err , GQuark domain , gint code , gchar *message ) ;
#line 234
extern void g_propagate_error(GError **dest , GError *src ) ;
#line 239
extern void g_clear_error(GError **err ) ;
#line 243
extern void g_prefix_error(GError **err , gchar *format  , ...) ;
#line 249
extern void g_prefix_error_literal(GError **err , gchar *prefix ) ;
#line 254
extern void g_propagate_prefixed_error(GError **dest , GError *src , gchar *format 
                                       , ...) ;
#line 51 "/usr/include/glib-2.0/glib/gutils.h"
extern gchar *g_get_user_name(void) ;
#line 53
extern gchar *g_get_real_name(void) ;
#line 55
extern gchar *g_get_home_dir(void) ;
#line 57
extern gchar *g_get_tmp_dir(void) ;
#line 59
extern gchar *g_get_host_name(void) ;
#line 61
extern gchar *g_get_prgname(void) ;
#line 63
extern void g_set_prgname(gchar *prgname ) ;
#line 65
extern gchar *g_get_application_name(void) ;
#line 67
extern void g_set_application_name(gchar *application_name ) ;
#line 69
extern gchar *g_get_os_info(gchar *key_name ) ;
#line 193
extern void g_reload_user_special_dirs_cache(void) ;
#line 195
extern gchar *g_get_user_data_dir(void) ;
#line 197
extern gchar *g_get_user_config_dir(void) ;
#line 199
extern gchar *g_get_user_cache_dir(void) ;
#line 201
extern gchar *g_get_user_state_dir(void) ;
#line 203
extern gchar * const  *g_get_system_data_dirs(void) ;
#line 225
extern gchar * const  *g_get_system_config_dirs(void) ;
#line 228
extern gchar *g_get_user_runtime_dir(void) ;
#line 266
extern gchar *g_get_user_special_dir(GUserDirectory directory ) ;
#line 286
extern guint g_parse_debug_string(gchar *string , GDebugKey *keys , guint nkeys ) ;
#line 291
extern gint g_snprintf(gchar *string , gulong n , gchar *format  , ...) ;
#line 296
extern gint g_vsnprintf(gchar *string , gulong n , gchar *format , va_list args ) ;
#line 303
extern void g_nullify_pointer(gpointer *nullify_location ) ;
#line 314
extern gchar *g_format_size_full(guint64 size , GFormatSizeFlags flags ) ;
#line 317
extern gchar *g_format_size(guint64 size ) ;
#line 320
extern gchar *g_format_size_for_display(goffset size ) ;
#line 338
extern void g_atexit(GVoidFunc func ) ;
#line 357
extern gchar *g_find_program_in_path(gchar *program ) ;
#line 375
extern gint g_bit_nth_lsf(gulong mask , gint nth_bit ) ;
#line 378
extern gint g_bit_nth_msf(gulong mask , gint nth_bit ) ;
#line 381
extern guint g_bit_storage(gulong number ) ;
#line 384 "/usr/include/glib-2.0/glib/gutils.h"
__inline static gint g_bit_nth_lsf_impl(gulong mask , gint nth_bit ) 
{ 
  long __cil_tmp3 ;
  gint __cil_tmp4 ;

  {
  {
#line 387
  __cil_tmp3 = __builtin_expect((long )0, (long )0);
  }
#line 387
  if (__cil_tmp3) {
#line 388
    nth_bit = - 1;
  }
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (! (nth_bit < 63)) {
#line 389
      goto while_break;
    }
#line 391
    nth_bit ++;
#line 392
    if (mask & (1UL << nth_bit)) {
#line 393
      return (nth_bit);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 395
  return (- 1);
}
}
#line 399 "/usr/include/glib-2.0/glib/gutils.h"
__inline static gint g_bit_nth_msf_impl(gulong mask , gint nth_bit ) 
{ 
  long __cil_tmp3 ;
  gint __cil_tmp4 ;

  {
  {
#line 402
  __cil_tmp3 = __builtin_expect((long )0, (long )0);
  }
#line 402
  if (nth_bit < 0) {
#line 403
    nth_bit = 64;
  } else
#line 402
  if (__cil_tmp3) {
#line 403
    nth_bit = 64;
  }
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 404
    if (! (nth_bit > 0)) {
#line 404
      goto while_break;
    }
#line 406
    __cil_tmp4 = nth_bit;
#line 406
    nth_bit --;
#line 407
    if (mask & (1UL << nth_bit)) {
#line 408
      return (nth_bit);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  return (- 1);
}
}
#line 414 "/usr/include/glib-2.0/glib/gutils.h"
__inline static guint g_bit_storage_impl(gulong number ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  unsigned int tmp ;

  {
  {
#line 417
  __cil_tmp2 = __builtin_expect((long )0, (long )1);
  }
#line 417
  if (__cil_tmp2) {
    {
#line 417
    __cil_tmp3 = __builtin_clzl(number);
#line 417
    tmp = (63U ^ (guint )__cil_tmp3) + 1U;
    }
  } else {
#line 417
    tmp = (unsigned int )1;
  }
#line 417
  return (tmp);
}
}
#line 40 "/usr/include/glib-2.0/glib/gthread.h"
extern GQuark g_thread_error_quark(void) ;
#line 141
extern GThread *g_thread_ref(GThread *thread ) ;
#line 143
extern void g_thread_unref(GThread *thread ) ;
#line 145
extern GThread *g_thread_new(gchar *name , GThreadFunc func , gpointer data ) ;
#line 149
extern GThread *g_thread_try_new(gchar *name , GThreadFunc func , gpointer data ,
                                 GError **error ) ;
#line 154
extern GThread *g_thread_self(void) ;
#line 156
extern void g_thread_exit(gpointer retval ) ;
#line 158
extern gpointer g_thread_join(GThread *thread ) ;
#line 160
extern void g_thread_yield(void) ;
#line 164
extern void g_mutex_init(GMutex *mutex ) ;
#line 166
extern void g_mutex_clear(GMutex *mutex ) ;
#line 168
extern void g_mutex_lock(GMutex *mutex ) ;
#line 170
extern gboolean g_mutex_trylock(GMutex *mutex ) ;
#line 172
extern void g_mutex_unlock(GMutex *mutex ) ;
#line 175
extern void g_rw_lock_init(GRWLock *rw_lock ) ;
#line 177
extern void g_rw_lock_clear(GRWLock *rw_lock ) ;
#line 179
extern void g_rw_lock_writer_lock(GRWLock *rw_lock ) ;
#line 181
extern gboolean g_rw_lock_writer_trylock(GRWLock *rw_lock ) ;
#line 183
extern void g_rw_lock_writer_unlock(GRWLock *rw_lock ) ;
#line 185
extern void g_rw_lock_reader_lock(GRWLock *rw_lock ) ;
#line 187
extern gboolean g_rw_lock_reader_trylock(GRWLock *rw_lock ) ;
#line 189
extern void g_rw_lock_reader_unlock(GRWLock *rw_lock ) ;
#line 192
extern void g_rec_mutex_init(GRecMutex *rec_mutex ) ;
#line 194
extern void g_rec_mutex_clear(GRecMutex *rec_mutex ) ;
#line 196
extern void g_rec_mutex_lock(GRecMutex *rec_mutex ) ;
#line 198
extern gboolean g_rec_mutex_trylock(GRecMutex *rec_mutex ) ;
#line 200
extern void g_rec_mutex_unlock(GRecMutex *rec_mutex ) ;
#line 203
extern void g_cond_init(GCond *cond ) ;
#line 205
extern void g_cond_clear(GCond *cond ) ;
#line 207
extern void g_cond_wait(GCond *cond , GMutex *mutex ) ;
#line 210
extern void g_cond_signal(GCond *cond ) ;
#line 212
extern void g_cond_broadcast(GCond *cond ) ;
#line 214
extern gboolean g_cond_wait_until(GCond *cond , GMutex *mutex , gint64 end_time ) ;
#line 219
extern gpointer g_private_get(GPrivate *key ) ;
#line 221
extern void g_private_set(GPrivate *key , gpointer value ) ;
#line 224
extern void g_private_replace(GPrivate *key , gpointer value ) ;
#line 228
extern gpointer g_once_impl(GOnce *once , GThreadFunc func , gpointer arg ) ;
#line 232
extern gboolean g_once_init_enter(void *location ) ;
#line 234
extern void g_once_init_leave(void *location , gsize result ) ;
#line 277
extern guint g_get_num_processors(void) ;
#line 331 "/usr/include/glib-2.0/glib/gthread.h"
__inline static GMutexLocker *g_mutex_locker_new(GMutex *mutex ) 
{ 


  {
  {
#line 333
  g_mutex_lock(mutex);
  }
#line 334
  return ((GMutexLocker *)mutex);
}
}
#line 349 "/usr/include/glib-2.0/glib/gthread.h"
__inline static void g_mutex_locker_free(GMutexLocker *locker ) 
{ 


  {
  {
#line 351
  g_mutex_unlock((GMutex *)locker);
  }
  return;
}
}
#line 407 "/usr/include/glib-2.0/glib/gthread.h"
__inline static GRecMutexLocker *g_rec_mutex_locker_new(GRecMutex *rec_mutex ) 
{ 


  {
  {
#line 409
  g_rec_mutex_lock(rec_mutex);
  }
#line 410
  return ((GRecMutexLocker *)rec_mutex);
}
}
#line 427 "/usr/include/glib-2.0/glib/gthread.h"
__inline static void g_rec_mutex_locker_free(GRecMutexLocker *locker ) 
{ 


  {
  {
#line 429
  g_rec_mutex_unlock((GRecMutex *)locker);
  }
  return;
}
}
#line 517 "/usr/include/glib-2.0/glib/gthread.h"
__inline static GRWLockWriterLocker *g_rw_lock_writer_locker_new(GRWLock *rw_lock ) 
{ 


  {
  {
#line 519
  g_rw_lock_writer_lock(rw_lock);
  }
#line 520
  return ((GRWLockWriterLocker *)rw_lock);
}
}
#line 538 "/usr/include/glib-2.0/glib/gthread.h"
__inline static void g_rw_lock_writer_locker_free(GRWLockWriterLocker *locker ) 
{ 


  {
  {
#line 540
  g_rw_lock_writer_unlock((GRWLock *)locker);
  }
  return;
}
}
#line 572 "/usr/include/glib-2.0/glib/gthread.h"
__inline static GRWLockReaderLocker *g_rw_lock_reader_locker_new(GRWLock *rw_lock ) 
{ 


  {
  {
#line 574
  g_rw_lock_reader_lock(rw_lock);
  }
#line 575
  return ((GRWLockReaderLocker *)rw_lock);
}
}
#line 593 "/usr/include/glib-2.0/glib/gthread.h"
__inline static void g_rw_lock_reader_locker_free(GRWLockReaderLocker *locker ) 
{ 


  {
  {
#line 595
  g_rw_lock_reader_unlock((GRWLock *)locker);
  }
  return;
}
}
#line 39 "/usr/include/glib-2.0/glib/gasyncqueue.h"
extern GAsyncQueue *g_async_queue_new(void) ;
#line 41
extern GAsyncQueue *g_async_queue_new_full(GDestroyNotify item_free_func ) ;
#line 43
extern void g_async_queue_lock(GAsyncQueue *queue ) ;
#line 45
extern void g_async_queue_unlock(GAsyncQueue *queue ) ;
#line 47
extern GAsyncQueue *g_async_queue_ref(GAsyncQueue *queue ) ;
#line 49
extern void g_async_queue_unref(GAsyncQueue *queue ) ;
#line 52
extern void g_async_queue_ref_unlocked(GAsyncQueue *queue ) ;
#line 55
extern void g_async_queue_unref_and_unlock(GAsyncQueue *queue ) ;
#line 58
extern void g_async_queue_push(GAsyncQueue *queue , gpointer data ) ;
#line 61
extern void g_async_queue_push_unlocked(GAsyncQueue *queue , gpointer data ) ;
#line 64
extern void g_async_queue_push_sorted(GAsyncQueue *queue , gpointer data , GCompareDataFunc func ,
                                      gpointer user_data ) ;
#line 69
extern void g_async_queue_push_sorted_unlocked(GAsyncQueue *queue , gpointer data ,
                                               GCompareDataFunc func , gpointer user_data ) ;
#line 74
extern gpointer g_async_queue_pop(GAsyncQueue *queue ) ;
#line 76
extern gpointer g_async_queue_pop_unlocked(GAsyncQueue *queue ) ;
#line 78
extern gpointer g_async_queue_try_pop(GAsyncQueue *queue ) ;
#line 80
extern gpointer g_async_queue_try_pop_unlocked(GAsyncQueue *queue ) ;
#line 82
extern gpointer g_async_queue_timeout_pop(GAsyncQueue *queue , guint64 timeout ) ;
#line 85
extern gpointer g_async_queue_timeout_pop_unlocked(GAsyncQueue *queue , guint64 timeout ) ;
#line 88
extern gint g_async_queue_length(GAsyncQueue *queue ) ;
#line 90
extern gint g_async_queue_length_unlocked(GAsyncQueue *queue ) ;
#line 92
extern void g_async_queue_sort(GAsyncQueue *queue , GCompareDataFunc func , gpointer user_data ) ;
#line 96
extern void g_async_queue_sort_unlocked(GAsyncQueue *queue , GCompareDataFunc func ,
                                        gpointer user_data ) ;
#line 101
extern gboolean g_async_queue_remove(GAsyncQueue *queue , gpointer item ) ;
#line 104
extern gboolean g_async_queue_remove_unlocked(GAsyncQueue *queue , gpointer item ) ;
#line 107
extern void g_async_queue_push_front(GAsyncQueue *queue , gpointer item ) ;
#line 110
extern void g_async_queue_push_front_unlocked(GAsyncQueue *queue , gpointer item ) ;
#line 115
extern gpointer g_async_queue_timed_pop(GAsyncQueue *queue , GTimeVal *end_time ) ;
#line 118
extern gpointer g_async_queue_timed_pop_unlocked(GAsyncQueue *queue , GTimeVal *end_time ) ;
#line 77 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t __sysv_signal(int __sig , __sighandler_t __handler ) ;
#line 80
extern  __attribute__((__nothrow__)) __sighandler_t sysv_signal(int __sig , __sighandler_t __handler ) ;
#line 88
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , __sighandler_t __handler ) ;
#line 112
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 119
extern  __attribute__((__nothrow__)) int killpg(__pid_t __pgrp , int __sig ) ;
#line 123
extern  __attribute__((__nothrow__)) int raise(int __sig ) ;
#line 127
extern  __attribute__((__nothrow__)) __sighandler_t ssignal(int __sig , __sighandler_t __handler ) ;
#line 129
extern  __attribute__((__nothrow__)) int gsignal(int __sig ) ;
#line 134
extern void psignal(int __sig , char const   *__s ) ;
#line 137
extern void psiginfo(siginfo_t *__pinfo , char const   *__s ) ;
#line 151
extern int sigpause(int __sig ) ;
#line 173
extern  __attribute__((__nothrow__)) int sigblock(int __mask ) ;
#line 176
extern  __attribute__((__nothrow__)) int sigsetmask(int __mask ) ;
#line 179
extern  __attribute__((__nothrow__)) int siggetmask(void) ;
#line 199
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set ) ;
#line 202
extern  __attribute__((__nothrow__)) int sigfillset(sigset_t *__set ) ;
#line 205
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo ) ;
#line 208
extern  __attribute__((__nothrow__)) int sigdelset(sigset_t *__set , int __signo ) ;
#line 211
extern  __attribute__((__nothrow__)) int sigismember(sigset_t *__set , int __signo ) ;
#line 216
extern  __attribute__((__nothrow__)) int sigisemptyset(sigset_t *__set ) ;
#line 219
extern  __attribute__((__nothrow__)) int sigandset(sigset_t *__set , sigset_t *__left ,
                                                   sigset_t *__right ) ;
#line 223
extern  __attribute__((__nothrow__)) int sigorset(sigset_t *__set , sigset_t *__left ,
                                                  sigset_t *__right ) ;
#line 232
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t *__set ,
                                                     sigset_t *__oset ) ;
#line 240
extern int sigsuspend(sigset_t *__set ) ;
#line 243
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction *__act ,
                                                   struct sigaction *__oact ) ;
#line 247
extern  __attribute__((__nothrow__)) int sigpending(sigset_t *__set ) ;
#line 255
extern int sigwait(sigset_t *__set , int *__sig ) ;
#line 264
extern int sigwaitinfo(sigset_t *__set , siginfo_t *__info ) ;
#line 273
extern int sigtimedwait(sigset_t *__set , siginfo_t *__info , struct timespec *__timeout ) ;
#line 292
extern  __attribute__((__nothrow__)) int sigqueue(__pid_t __pid , int __sig , union sigval __val ) ;
#line 304
extern  __attribute__((__nothrow__)) int sigreturn(struct sigcontext *__scp ) ;
#line 324
extern  __attribute__((__nothrow__)) int siginterrupt(int __sig , int __interrupt ) ;
#line 333
extern  __attribute__((__nothrow__)) int sigaltstack(stack_t *__ss , stack_t *__oss ) ;
#line 347
extern  __attribute__((__nothrow__)) int sigstack(struct sigstack *__ss , struct sigstack *__oss ) ;
#line 355
extern  __attribute__((__nothrow__)) int sighold(int __sig ) ;
#line 359
extern  __attribute__((__nothrow__)) int sigrelse(int __sig ) ;
#line 363
extern  __attribute__((__nothrow__)) int sigignore(int __sig ) ;
#line 367
extern  __attribute__((__nothrow__)) __sighandler_t sigset(int __sig , __sighandler_t __disp ) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int pthread_sigmask(int __how , __sigset_t *__newmask ,
                                                         __sigset_t *__oldmask ) ;
#line 36
extern  __attribute__((__nothrow__)) int pthread_kill(pthread_t __threadid , int __signo ) ;
#line 40
extern  __attribute__((__nothrow__)) int pthread_sigqueue(pthread_t __threadid , int __signo ,
                                                          union sigval __value ) ;
#line 383 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int __libc_current_sigrtmin(void) ;
#line 385
extern  __attribute__((__nothrow__)) int __libc_current_sigrtmax(void) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/signal_ext.h"
extern int tgkill(__pid_t __tgid , __pid_t __tid , int __signal ) ;
#line 41 "/usr/include/glib-2.0/glib/gbacktrace.h"
extern void g_on_error_query(gchar *prg_name ) ;
#line 43
extern void g_on_error_stack_trace(gchar *prg_name ) ;
#line 31 "/usr/include/glib-2.0/glib/gbase64.h"
extern gsize g_base64_encode_step(guchar *in , gsize len , gboolean break_lines ,
                                  gchar *out , gint *state , gint *save ) ;
#line 38
extern gsize g_base64_encode_close(gboolean break_lines , gchar *out , gint *state ,
                                   gint *save ) ;
#line 43
extern gchar *g_base64_encode(guchar *data , gsize len ) ;
#line 46
extern gsize g_base64_decode_step(gchar *in , gsize len , guchar *out , gint *state ,
                                  guint *save ) ;
#line 52
extern guchar *g_base64_decode(gchar *text , gsize *out_len ) ;
#line 55
extern guchar *g_base64_decode_inplace(gchar *text , gsize *out_len ) ;
#line 33 "/usr/include/glib-2.0/glib/gbitlock.h"
extern void g_bit_lock(gint *address , gint lock_bit ) ;
#line 36
extern gboolean g_bit_trylock(gint *address , gint lock_bit ) ;
#line 39
extern void g_bit_unlock(gint *address , gint lock_bit ) ;
#line 43
extern void g_pointer_bit_lock(void *address , gint lock_bit ) ;
#line 46
extern gboolean g_pointer_bit_trylock(void *address , gint lock_bit ) ;
#line 49
extern void g_pointer_bit_unlock(void *address , gint lock_bit ) ;
#line 57 "/usr/include/glib-2.0/glib/gtimezone.h"
extern GTimeZone *g_time_zone_new(gchar *identifier ) ;
#line 59
extern GTimeZone *g_time_zone_new_identifier(gchar *identifier ) ;
#line 61
extern GTimeZone *g_time_zone_new_utc(void) ;
#line 63
extern GTimeZone *g_time_zone_new_local(void) ;
#line 65
extern GTimeZone *g_time_zone_new_offset(gint32 seconds ) ;
#line 68
extern GTimeZone *g_time_zone_ref(GTimeZone *tz ) ;
#line 70
extern void g_time_zone_unref(GTimeZone *tz ) ;
#line 73
extern gint g_time_zone_find_interval(GTimeZone *tz , GTimeType type , gint64 time_ ) ;
#line 78
extern gint g_time_zone_adjust_time(GTimeZone *tz , GTimeType type , gint64 *time_ ) ;
#line 83
extern gchar *g_time_zone_get_abbreviation(GTimeZone *tz , gint interval ) ;
#line 86
extern gint32 g_time_zone_get_offset(GTimeZone *tz , gint interval ) ;
#line 89
extern gboolean g_time_zone_is_dst(GTimeZone *tz , gint interval ) ;
#line 92
extern gchar *g_time_zone_get_identifier(GTimeZone *tz ) ;
#line 99 "/usr/include/glib-2.0/glib/gdatetime.h"
extern void g_date_time_unref(GDateTime *datetime ) ;
#line 101
extern GDateTime *g_date_time_ref(GDateTime *datetime ) ;
#line 104
extern GDateTime *g_date_time_new_now(GTimeZone *tz ) ;
#line 106
extern GDateTime *g_date_time_new_now_local(void) ;
#line 108
extern GDateTime *g_date_time_new_now_utc(void) ;
#line 111
extern GDateTime *g_date_time_new_from_unix_local(gint64 t ) ;
#line 113
extern GDateTime *g_date_time_new_from_unix_utc(gint64 t ) ;
#line 117
extern GDateTime *g_date_time_new_from_timeval_local(GTimeVal *tv ) ;
#line 119
extern GDateTime *g_date_time_new_from_timeval_utc(GTimeVal *tv ) ;
#line 123
extern GDateTime *g_date_time_new_from_iso8601(gchar *text , GTimeZone *default_tz ) ;
#line 127
extern GDateTime *g_date_time_new(GTimeZone *tz , gint year , gint month , gint day ,
                                  gint hour , gint minute , gdouble seconds ) ;
#line 135
extern GDateTime *g_date_time_new_local(gint year , gint month , gint day , gint hour ,
                                        gint minute , gdouble seconds ) ;
#line 142
extern GDateTime *g_date_time_new_utc(gint year , gint month , gint day , gint hour ,
                                      gint minute , gdouble seconds ) ;
#line 151
extern GDateTime *g_date_time_add(GDateTime *datetime , GTimeSpan timespan ) ;
#line 156
extern GDateTime *g_date_time_add_years(GDateTime *datetime , gint years ) ;
#line 160
extern GDateTime *g_date_time_add_months(GDateTime *datetime , gint months ) ;
#line 164
extern GDateTime *g_date_time_add_weeks(GDateTime *datetime , gint weeks ) ;
#line 168
extern GDateTime *g_date_time_add_days(GDateTime *datetime , gint days ) ;
#line 173
extern GDateTime *g_date_time_add_hours(GDateTime *datetime , gint hours ) ;
#line 177
extern GDateTime *g_date_time_add_minutes(GDateTime *datetime , gint minutes ) ;
#line 181
extern GDateTime *g_date_time_add_seconds(GDateTime *datetime , gdouble seconds ) ;
#line 186
extern GDateTime *g_date_time_add_full(GDateTime *datetime , gint years , gint months ,
                                       gint days , gint hours , gint minutes , gdouble seconds ) ;
#line 195
extern gint g_date_time_compare(gconstpointer dt1 , gconstpointer dt2 ) ;
#line 198
extern GTimeSpan g_date_time_difference(GDateTime *end , GDateTime *begin ) ;
#line 201
extern guint g_date_time_hash(gconstpointer datetime ) ;
#line 203
extern gboolean g_date_time_equal(gconstpointer dt1 , gconstpointer dt2 ) ;
#line 207
extern void g_date_time_get_ymd(GDateTime *datetime , gint *year , gint *month , gint *day ) ;
#line 213
extern gint g_date_time_get_year(GDateTime *datetime ) ;
#line 215
extern gint g_date_time_get_month(GDateTime *datetime ) ;
#line 217
extern gint g_date_time_get_day_of_month(GDateTime *datetime ) ;
#line 220
extern gint g_date_time_get_week_numbering_year(GDateTime *datetime ) ;
#line 222
extern gint g_date_time_get_week_of_year(GDateTime *datetime ) ;
#line 224
extern gint g_date_time_get_day_of_week(GDateTime *datetime ) ;
#line 227
extern gint g_date_time_get_day_of_year(GDateTime *datetime ) ;
#line 230
extern gint g_date_time_get_hour(GDateTime *datetime ) ;
#line 232
extern gint g_date_time_get_minute(GDateTime *datetime ) ;
#line 234
extern gint g_date_time_get_second(GDateTime *datetime ) ;
#line 236
extern gint g_date_time_get_microsecond(GDateTime *datetime ) ;
#line 238
extern gdouble g_date_time_get_seconds(GDateTime *datetime ) ;
#line 241
extern gint64 g_date_time_to_unix(GDateTime *datetime ) ;
#line 244
extern gboolean g_date_time_to_timeval(GDateTime *datetime , GTimeVal *tv ) ;
#line 249
extern GTimeSpan g_date_time_get_utc_offset(GDateTime *datetime ) ;
#line 251
extern GTimeZone *g_date_time_get_timezone(GDateTime *datetime ) ;
#line 253
extern gchar *g_date_time_get_timezone_abbreviation(GDateTime *datetime ) ;
#line 255
extern gboolean g_date_time_is_daylight_savings(GDateTime *datetime ) ;
#line 258
extern GDateTime *g_date_time_to_timezone(GDateTime *datetime , GTimeZone *tz ) ;
#line 261
extern GDateTime *g_date_time_to_local(GDateTime *datetime ) ;
#line 263
extern GDateTime *g_date_time_to_utc(GDateTime *datetime ) ;
#line 266
extern gchar *g_date_time_format(GDateTime *datetime , gchar *format ) ;
#line 269
extern gchar *g_date_time_format_iso8601(GDateTime *datetime ) ;
#line 71 "/usr/include/glib-2.0/glib/gbookmarkfile.h"
extern GQuark g_bookmark_file_error_quark(void) ;
#line 81
extern GBookmarkFile *g_bookmark_file_new(void) ;
#line 83
extern void g_bookmark_file_free(GBookmarkFile *bookmark ) ;
#line 86
extern gboolean g_bookmark_file_load_from_file(GBookmarkFile *bookmark , gchar *filename ,
                                               GError **error ) ;
#line 90
extern gboolean g_bookmark_file_load_from_data(GBookmarkFile *bookmark , gchar *data ,
                                               gsize length , GError **error ) ;
#line 95
extern gboolean g_bookmark_file_load_from_data_dirs(GBookmarkFile *bookmark , gchar *file ,
                                                    gchar **full_path , GError **error ) ;
#line 100
extern gchar *g_bookmark_file_to_data(GBookmarkFile *bookmark , gsize *length , GError **error ) ;
#line 104
extern gboolean g_bookmark_file_to_file(GBookmarkFile *bookmark , gchar *filename ,
                                        GError **error ) ;
#line 109
extern void g_bookmark_file_set_title(GBookmarkFile *bookmark , gchar *uri , gchar *title ) ;
#line 113
extern gchar *g_bookmark_file_get_title(GBookmarkFile *bookmark , gchar *uri , GError **error ) ;
#line 117
extern void g_bookmark_file_set_description(GBookmarkFile *bookmark , gchar *uri ,
                                            gchar *description ) ;
#line 121
extern gchar *g_bookmark_file_get_description(GBookmarkFile *bookmark , gchar *uri ,
                                              GError **error ) ;
#line 125
extern void g_bookmark_file_set_mime_type(GBookmarkFile *bookmark , gchar *uri , gchar *mime_type ) ;
#line 129
extern gchar *g_bookmark_file_get_mime_type(GBookmarkFile *bookmark , gchar *uri ,
                                            GError **error ) ;
#line 133
extern void g_bookmark_file_set_groups(GBookmarkFile *bookmark , gchar *uri , gchar **groups ,
                                       gsize length ) ;
#line 138
extern void g_bookmark_file_add_group(GBookmarkFile *bookmark , gchar *uri , gchar *group ) ;
#line 142
extern gboolean g_bookmark_file_has_group(GBookmarkFile *bookmark , gchar *uri , gchar *group ,
                                          GError **error ) ;
#line 147
extern gchar **g_bookmark_file_get_groups(GBookmarkFile *bookmark , gchar *uri , gsize *length ,
                                          GError **error ) ;
#line 152
extern void g_bookmark_file_add_application(GBookmarkFile *bookmark , gchar *uri ,
                                            gchar *name , gchar *exec ) ;
#line 157
extern gboolean g_bookmark_file_has_application(GBookmarkFile *bookmark , gchar *uri ,
                                                gchar *name , GError **error ) ;
#line 162
extern gchar **g_bookmark_file_get_applications(GBookmarkFile *bookmark , gchar *uri ,
                                                gsize *length , GError **error ) ;
#line 167
extern gboolean g_bookmark_file_set_app_info(GBookmarkFile *bookmark , gchar *uri ,
                                             gchar *name , gchar *exec , gint count ,
                                             time_t stamp , GError **error ) ;
#line 175
extern gboolean g_bookmark_file_set_application_info(GBookmarkFile *bookmark , char const   *uri ,
                                                     char const   *name , char const   *exec ,
                                                     int count , GDateTime *stamp ,
                                                     GError **error ) ;
#line 183
extern gboolean g_bookmark_file_get_app_info(GBookmarkFile *bookmark , gchar *uri ,
                                             gchar *name , gchar **exec , guint *count ,
                                             time_t *stamp , GError **error ) ;
#line 191
extern gboolean g_bookmark_file_get_application_info(GBookmarkFile *bookmark , char const   *uri ,
                                                     char const   *name , char **exec ,
                                                     unsigned int *count , GDateTime **stamp ,
                                                     GError **error ) ;
#line 199
extern void g_bookmark_file_set_is_private(GBookmarkFile *bookmark , gchar *uri ,
                                           gboolean is_private ) ;
#line 203
extern gboolean g_bookmark_file_get_is_private(GBookmarkFile *bookmark , gchar *uri ,
                                               GError **error ) ;
#line 207
extern void g_bookmark_file_set_icon(GBookmarkFile *bookmark , gchar *uri , gchar *href ,
                                     gchar *mime_type ) ;
#line 212
extern gboolean g_bookmark_file_get_icon(GBookmarkFile *bookmark , gchar *uri , gchar **href ,
                                         gchar **mime_type , GError **error ) ;
#line 218
extern void g_bookmark_file_set_added(GBookmarkFile *bookmark , gchar *uri , time_t added ) ;
#line 222
extern void g_bookmark_file_set_added_date_time(GBookmarkFile *bookmark , char const   *uri ,
                                                GDateTime *added ) ;
#line 226
extern time_t g_bookmark_file_get_added(GBookmarkFile *bookmark , gchar *uri , GError **error ) ;
#line 230
extern GDateTime *g_bookmark_file_get_added_date_time(GBookmarkFile *bookmark , char const   *uri ,
                                                      GError **error ) ;
#line 234
extern void g_bookmark_file_set_modified(GBookmarkFile *bookmark , gchar *uri , time_t modified ) ;
#line 238
extern void g_bookmark_file_set_modified_date_time(GBookmarkFile *bookmark , char const   *uri ,
                                                   GDateTime *modified ) ;
#line 242
extern time_t g_bookmark_file_get_modified(GBookmarkFile *bookmark , gchar *uri ,
                                           GError **error ) ;
#line 246
extern GDateTime *g_bookmark_file_get_modified_date_time(GBookmarkFile *bookmark ,
                                                         char const   *uri , GError **error ) ;
#line 250
extern void g_bookmark_file_set_visited(GBookmarkFile *bookmark , gchar *uri , time_t visited ) ;
#line 254
extern void g_bookmark_file_set_visited_date_time(GBookmarkFile *bookmark , char const   *uri ,
                                                  GDateTime *visited ) ;
#line 258
extern time_t g_bookmark_file_get_visited(GBookmarkFile *bookmark , gchar *uri , GError **error ) ;
#line 262
extern GDateTime *g_bookmark_file_get_visited_date_time(GBookmarkFile *bookmark ,
                                                        char const   *uri , GError **error ) ;
#line 266
extern gboolean g_bookmark_file_has_item(GBookmarkFile *bookmark , gchar *uri ) ;
#line 269
extern gint g_bookmark_file_get_size(GBookmarkFile *bookmark ) ;
#line 271
extern gchar **g_bookmark_file_get_uris(GBookmarkFile *bookmark , gsize *length ) ;
#line 274
extern gboolean g_bookmark_file_remove_group(GBookmarkFile *bookmark , gchar *uri ,
                                             gchar *group , GError **error ) ;
#line 279
extern gboolean g_bookmark_file_remove_application(GBookmarkFile *bookmark , gchar *uri ,
                                                   gchar *name , GError **error ) ;
#line 284
extern gboolean g_bookmark_file_remove_item(GBookmarkFile *bookmark , gchar *uri ,
                                            GError **error ) ;
#line 288
extern gboolean g_bookmark_file_move_item(GBookmarkFile *bookmark , gchar *old_uri ,
                                          gchar *new_uri , GError **error ) ;
#line 35 "/usr/include/glib-2.0/glib/gbytes.h"
extern GBytes *g_bytes_new(gconstpointer data , gsize size ) ;
#line 39
extern GBytes *g_bytes_new_take(gpointer data , gsize size ) ;
#line 43
extern GBytes *g_bytes_new_static(gconstpointer data , gsize size ) ;
#line 47
extern GBytes *g_bytes_new_with_free_func(gconstpointer data , gsize size , GDestroyNotify free_func ,
                                          gpointer user_data ) ;
#line 53
extern GBytes *g_bytes_new_from_bytes(GBytes *bytes , gsize offset , gsize length ) ;
#line 58
extern gconstpointer g_bytes_get_data(GBytes *bytes , gsize *size ) ;
#line 62
extern gsize g_bytes_get_size(GBytes *bytes ) ;
#line 65
extern GBytes *g_bytes_ref(GBytes *bytes ) ;
#line 68
extern void g_bytes_unref(GBytes *bytes ) ;
#line 71
extern gpointer g_bytes_unref_to_data(GBytes *bytes , gsize *size ) ;
#line 75
extern GByteArray *g_bytes_unref_to_array(GBytes *bytes ) ;
#line 78
extern guint g_bytes_hash(gconstpointer bytes ) ;
#line 81
extern gboolean g_bytes_equal(gconstpointer bytes1 , gconstpointer bytes2 ) ;
#line 85
extern gint g_bytes_compare(gconstpointer bytes1 , gconstpointer bytes2 ) ;
#line 89
extern gconstpointer g_bytes_get_region(GBytes *bytes , gsize element_size , gsize offset ,
                                        gsize n_elements ) ;
#line 31 "/usr/include/glib-2.0/glib/gcharset.h"
extern gboolean g_get_charset(char const   **charset ) ;
#line 33
extern gchar *g_get_codeset(void) ;
#line 35
extern gboolean g_get_console_charset(char const   **charset ) ;
#line 38
extern gchar * const  *g_get_language_names(void) ;
#line 40
extern gchar * const  *g_get_language_names_with_category(gchar *category_name ) ;
#line 43
extern gchar **g_get_locale_variants(gchar *locale ) ;
#line 68 "/usr/include/glib-2.0/glib/gchecksum.h"
extern gssize g_checksum_type_get_length(GChecksumType checksum_type ) ;
#line 71
extern GChecksum *g_checksum_new(GChecksumType checksum_type ) ;
#line 73
extern void g_checksum_reset(GChecksum *checksum ) ;
#line 75
extern GChecksum *g_checksum_copy(GChecksum *checksum ) ;
#line 77
extern void g_checksum_free(GChecksum *checksum ) ;
#line 79
extern void g_checksum_update(GChecksum *checksum , guchar *data , gssize length ) ;
#line 83
extern gchar *g_checksum_get_string(GChecksum *checksum ) ;
#line 85
extern void g_checksum_get_digest(GChecksum *checksum , guint8 *buffer , gsize *digest_len ) ;
#line 90
extern gchar *g_compute_checksum_for_data(GChecksumType checksum_type , guchar *data ,
                                          gsize length ) ;
#line 94
extern gchar *g_compute_checksum_for_string(GChecksumType checksum_type , gchar *str ,
                                            gssize length ) ;
#line 99
extern gchar *g_compute_checksum_for_bytes(GChecksumType checksum_type , GBytes *data ) ;
#line 75 "/usr/include/glib-2.0/glib/gconvert.h"
extern GQuark g_convert_error_quark(void) ;
#line 86
extern GIConv g_iconv_open(gchar *to_codeset , gchar *from_codeset ) ;
#line 89
extern gsize g_iconv(GIConv converter , gchar **inbuf , gsize *inbytes_left , gchar **outbuf ,
                     gsize *outbytes_left ) ;
#line 95
extern gint g_iconv_close(GIConv converter ) ;
#line 99
extern gchar *g_convert(gchar *str , gssize len , gchar *to_codeset , gchar *from_codeset ,
                        gsize *bytes_read , gsize *bytes_written , GError **error ) ;
#line 107
extern gchar *g_convert_with_iconv(gchar *str , gssize len , GIConv converter , gsize *bytes_read ,
                                   gsize *bytes_written , GError **error ) ;
#line 114
extern gchar *g_convert_with_fallback(gchar *str , gssize len , gchar *to_codeset ,
                                      gchar *from_codeset , gchar *fallback , gsize *bytes_read ,
                                      gsize *bytes_written , GError **error ) ;
#line 127
extern gchar *g_locale_to_utf8(gchar *opsysstring , gssize len , gsize *bytes_read ,
                               gsize *bytes_written , GError **error ) ;
#line 133
extern gchar *g_locale_from_utf8(gchar *utf8string , gssize len , gsize *bytes_read ,
                                 gsize *bytes_written , GError **error ) ;
#line 143
extern gchar *g_filename_to_utf8(gchar *opsysstring , gssize len , gsize *bytes_read ,
                                 gsize *bytes_written , GError **error ) ;
#line 149
extern gchar *g_filename_from_utf8(gchar *utf8string , gssize len , gsize *bytes_read ,
                                   gsize *bytes_written , GError **error ) ;
#line 156
extern gchar *g_filename_from_uri(gchar *uri , gchar **hostname , GError **error ) ;
#line 161
extern gchar *g_filename_to_uri(gchar *filename , gchar *hostname , GError **error ) ;
#line 165
extern gchar *g_filename_display_name(gchar *filename ) ;
#line 167
extern gboolean g_get_filename_charsets(gchar ***filename_charsets ) ;
#line 170
extern gchar *g_filename_display_basename(gchar *filename ) ;
#line 173
extern gchar **g_uri_list_extract_uris(gchar *uri_list ) ;
#line 45 "/usr/include/glib-2.0/glib/gdataset.h"
extern void g_datalist_init(GData **datalist ) ;
#line 47
extern void g_datalist_clear(GData **datalist ) ;
#line 49
extern gpointer g_datalist_id_get_data(GData **datalist , GQuark key_id ) ;
#line 52
extern void g_datalist_id_set_data_full(GData **datalist , GQuark key_id , gpointer data ,
                                        GDestroyNotify destroy_func ) ;
#line 60
extern gpointer g_datalist_id_dup_data(GData **datalist , GQuark key_id , GDuplicateFunc dup_func ,
                                       gpointer user_data ) ;
#line 65
extern gboolean g_datalist_id_replace_data(GData **datalist , GQuark key_id , gpointer oldval ,
                                           gpointer newval , GDestroyNotify destroy ,
                                           GDestroyNotify *old_destroy ) ;
#line 73
extern gpointer g_datalist_id_remove_no_notify(GData **datalist , GQuark key_id ) ;
#line 76
extern void g_datalist_foreach(GData **datalist , GDataForeachFunc func , gpointer user_data ) ;
#line 90
extern void g_datalist_set_flags(GData **datalist , guint flags ) ;
#line 93
extern void g_datalist_unset_flags(GData **datalist , guint flags ) ;
#line 96
extern guint g_datalist_get_flags(GData **datalist ) ;
#line 114
extern void g_dataset_destroy(gconstpointer dataset_location ) ;
#line 116
extern gpointer g_dataset_id_get_data(gconstpointer dataset_location , GQuark key_id ) ;
#line 119
extern gpointer g_datalist_get_data(GData **datalist , gchar *key ) ;
#line 122
extern void g_dataset_id_set_data_full(gconstpointer dataset_location , GQuark key_id ,
                                       gpointer data , GDestroyNotify destroy_func ) ;
#line 127
extern gpointer g_dataset_id_remove_no_notify(gconstpointer dataset_location , GQuark key_id ) ;
#line 130
extern void g_dataset_foreach(gconstpointer dataset_location , GDataForeachFunc func ,
                              gpointer user_data ) ;
#line 121 "/usr/include/glib-2.0/glib/gdate.h"
extern GDate *g_date_new(void) ;
#line 123
extern GDate *g_date_new_dmy(GDateDay day , GDateMonth month , GDateYear year ) ;
#line 127
extern GDate *g_date_new_julian(guint32 julian_day ) ;
#line 129
extern void g_date_free(GDate *date ) ;
#line 131
extern GDate *g_date_copy(GDate *date ) ;
#line 139
extern gboolean g_date_valid(GDate *date ) ;
#line 141
extern gboolean g_date_valid_day(GDateDay day ) ;
#line 143
extern gboolean g_date_valid_month(GDateMonth month ) ;
#line 145
extern gboolean g_date_valid_year(GDateYear year ) ;
#line 147
extern gboolean g_date_valid_weekday(GDateWeekday weekday ) ;
#line 149
extern gboolean g_date_valid_julian(guint32 julian_date ) ;
#line 151
extern gboolean g_date_valid_dmy(GDateDay day , GDateMonth month , GDateYear year ) ;
#line 156
extern GDateWeekday g_date_get_weekday(GDate *date ) ;
#line 158
extern GDateMonth g_date_get_month(GDate *date ) ;
#line 160
extern GDateYear g_date_get_year(GDate *date ) ;
#line 162
extern GDateDay g_date_get_day(GDate *date ) ;
#line 164
extern guint32 g_date_get_julian(GDate *date ) ;
#line 166
extern guint g_date_get_day_of_year(GDate *date ) ;
#line 174
extern guint g_date_get_monday_week_of_year(GDate *date ) ;
#line 176
extern guint g_date_get_sunday_week_of_year(GDate *date ) ;
#line 178
extern guint g_date_get_iso8601_week_of_year(GDate *date ) ;
#line 185
extern void g_date_clear(GDate *date , guint n_dates ) ;
#line 193
extern void g_date_set_parse(GDate *date , gchar *str ) ;
#line 196
extern void g_date_set_time_t(GDate *date , time_t timet ) ;
#line 200
extern void g_date_set_time_val(GDate *date , GTimeVal *timeval ) ;
#line 203
extern void g_date_set_time(GDate *date , GTime time_ ) ;
#line 207
extern void g_date_set_month(GDate *date , GDateMonth month ) ;
#line 210
extern void g_date_set_day(GDate *date , GDateDay day ) ;
#line 213
extern void g_date_set_year(GDate *date , GDateYear year ) ;
#line 216
extern void g_date_set_dmy(GDate *date , GDateDay day , GDateMonth month , GDateYear y ) ;
#line 221
extern void g_date_set_julian(GDate *date , guint32 julian_date ) ;
#line 224
extern gboolean g_date_is_first_of_month(GDate *date ) ;
#line 226
extern gboolean g_date_is_last_of_month(GDate *date ) ;
#line 230
extern void g_date_add_days(GDate *date , guint n_days ) ;
#line 233
extern void g_date_subtract_days(GDate *date , guint n_days ) ;
#line 238
extern void g_date_add_months(GDate *date , guint n_months ) ;
#line 241
extern void g_date_subtract_months(GDate *date , guint n_months ) ;
#line 246
extern void g_date_add_years(GDate *date , guint n_years ) ;
#line 249
extern void g_date_subtract_years(GDate *date , guint n_years ) ;
#line 252
extern gboolean g_date_is_leap_year(GDateYear year ) ;
#line 254
extern guint8 g_date_get_days_in_month(GDateMonth month , GDateYear year ) ;
#line 257
extern guint8 g_date_get_monday_weeks_in_year(GDateYear year ) ;
#line 259
extern guint8 g_date_get_sunday_weeks_in_year(GDateYear year ) ;
#line 264
extern gint g_date_days_between(GDate *date1 , GDate *date2 ) ;
#line 269
extern gint g_date_compare(GDate *lhs , GDate *rhs ) ;
#line 272
extern void g_date_to_struct_tm(GDate *date , struct tm *tm ) ;
#line 276
extern void g_date_clamp(GDate *date , GDate *min_date , GDate *max_date ) ;
#line 282
extern void g_date_order(GDate *date1 , GDate *date2 ) ;
#line 288
extern gsize g_date_strftime(gchar *s , gsize slen , gchar *format , GDate *date ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 141
extern DIR *fdopendir(int __fd ) ;
#line 149
extern int closedir(DIR *__dirp ) ;
#line 162
extern struct dirent *readdir(DIR *__dirp ) ;
#line 173
extern struct dirent64 *readdir64(DIR *__dirp ) ;
#line 183
extern int readdir_r(DIR *__dirp , struct dirent *__entry , struct dirent **__result ) ;
#line 201
extern int readdir64_r(DIR *__dirp , struct dirent64 *__entry , struct dirent64 **__result ) ;
#line 209
extern  __attribute__((__nothrow__)) void rewinddir(DIR *__dirp ) ;
#line 215
extern  __attribute__((__nothrow__)) void seekdir(DIR *__dirp , long __pos ) ;
#line 218
extern  __attribute__((__nothrow__)) long telldir(DIR *__dirp ) ;
#line 224
extern  __attribute__((__nothrow__)) int dirfd(DIR *__dirp ) ;
#line 255
extern int scandir(char const   *__dir , struct dirent ***__namelist , int (*__selector)(struct dirent * ) ,
                   int (*__cmp)(struct dirent ** , struct dirent ** ) ) ;
#line 278
extern int scandir64(char const   *__dir , struct dirent64 ***__namelist , int (*__selector)(struct dirent64 * ) ,
                     int (*__cmp)(struct dirent64 ** , struct dirent64 ** ) ) ;
#line 293
extern int scandirat(int __dfd , char const   *__dir , struct dirent ***__namelist ,
                     int (*__selector)(struct dirent * ) , int (*__cmp)(struct dirent ** ,
                                                                        struct dirent ** ) ) ;
#line 315
extern int scandirat64(int __dfd , char const   *__dir , struct dirent64 ***__namelist ,
                       int (*__selector)(struct dirent64 * ) , int (*__cmp)(struct dirent64 ** ,
                                                                            struct dirent64 ** ) ) ;
#line 325
extern  __attribute__((__nothrow__)) int alphasort(struct dirent **__e1 , struct dirent **__e2 ) ;
#line 340
extern  __attribute__((__nothrow__)) int alphasort64(struct dirent64 **__e1 , struct dirent64 **__e2 ) ;
#line 353
extern  __attribute__((__nothrow__)) __ssize_t getdirentries(int __fd , char *__buf ,
                                                             size_t __nbytes , __off_t *__basep ) ;
#line 370
extern  __attribute__((__nothrow__)) __ssize_t getdirentries64(int __fd , char *__buf ,
                                                               size_t __nbytes , __off64_t *__basep ) ;
#line 380
extern  __attribute__((__nothrow__)) int versionsort(struct dirent **__e1 , struct dirent **__e2 ) ;
#line 396
extern  __attribute__((__nothrow__)) int versionsort64(struct dirent64 **__e1 , struct dirent64 **__e2 ) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/dirent_ext.h"
extern  __attribute__((__nothrow__)) __ssize_t getdents64(int __fd , void *__buffer ,
                                                          size_t __length ) ;
#line 40 "/usr/include/glib-2.0/glib/gdir.h"
extern GDir *g_dir_open(gchar *path , guint flags , GError **error ) ;
#line 44
extern gchar *g_dir_read_name(GDir *dir ) ;
#line 46
extern void g_dir_rewind(GDir *dir ) ;
#line 48
extern void g_dir_close(GDir *dir ) ;
#line 37 "/usr/include/glib-2.0/glib/genviron.h"
extern gchar *g_getenv(gchar *variable ) ;
#line 39
extern gboolean g_setenv(gchar *variable , gchar *value , gboolean overwrite ) ;
#line 43
extern void g_unsetenv(gchar *variable ) ;
#line 45
extern gchar **g_listenv(void) ;
#line 48
extern gchar **g_get_environ(void) ;
#line 50
extern gchar *g_environ_getenv(gchar **envp , gchar *variable ) ;
#line 53
extern gchar **g_environ_setenv(gchar **envp , gchar *variable , gchar *value , gboolean overwrite ) ;
#line 58
extern gchar **g_environ_unsetenv(gchar **envp , gchar *variable ) ;
#line 109 "/usr/include/glib-2.0/glib/gfileutils.h"
extern GQuark g_file_error_quark(void) ;
#line 112
extern GFileError g_file_error_from_errno(gint err_no ) ;
#line 115
extern gboolean g_file_test(gchar *filename , GFileTest test ) ;
#line 118
extern gboolean g_file_get_contents(gchar *filename , gchar **contents , gsize *length ,
                                    GError **error ) ;
#line 123
extern gboolean g_file_set_contents(gchar *filename , gchar *contents , gssize length ,
                                    GError **error ) ;
#line 129
extern gboolean g_file_set_contents_full(gchar *filename , gchar *contents , gssize length ,
                                         GFileSetContentsFlags flags , int mode ,
                                         GError **error ) ;
#line 137
extern gchar *g_file_read_link(gchar *filename , GError **error ) ;
#line 142
extern gchar *g_mkdtemp(gchar *tmpl ) ;
#line 144
extern gchar *g_mkdtemp_full(gchar *tmpl , gint mode ) ;
#line 149
extern gint g_mkstemp(gchar *tmpl ) ;
#line 151
extern gint g_mkstemp_full(gchar *tmpl , gint flags , gint mode ) ;
#line 157
extern gint g_file_open_tmp(gchar *tmpl , gchar **name_used , GError **error ) ;
#line 161
extern gchar *g_dir_make_tmp(gchar *tmpl , GError **error ) ;
#line 165
extern gchar *g_build_path(gchar *separator , gchar *first_element  , ...) ;
#line 169
extern gchar *g_build_pathv(gchar *separator , gchar **args ) ;
#line 173
extern gchar *g_build_filename(gchar *first_element  , ...) ;
#line 176
extern gchar *g_build_filenamev(gchar **args ) ;
#line 178
extern gchar *g_build_filename_valist(gchar *first_element , va_list *args ) ;
#line 182
extern gint g_mkdir_with_parents(gchar *pathname , gint mode ) ;
#line 200
extern gboolean g_path_is_absolute(gchar *file_name ) ;
#line 202
extern gchar *g_path_skip_root(gchar *file_name ) ;
#line 205
extern gchar *g_basename(gchar *file_name ) ;
#line 209
extern gchar *g_get_current_dir(void) ;
#line 211
extern gchar *g_path_get_basename(gchar *file_name ) ;
#line 213
extern gchar *g_path_get_dirname(gchar *file_name ) ;
#line 216
extern gchar *g_canonicalize_filename(gchar *filename , gchar *relative_to ) ;
#line 37 "/usr/include/glib-2.0/glib/ggettext.h"
extern gchar *g_strip_context(gchar *msgid , gchar *msgval ) ;
#line 41
extern gchar *g_dgettext(gchar *domain , gchar *msgid ) ;
#line 44
extern gchar *g_dcgettext(gchar *domain , gchar *msgid , gint category ) ;
#line 48
extern gchar *g_dngettext(gchar *domain , gchar *msgid , gchar *msgid_plural , gulong n ) ;
#line 53
extern gchar *g_dpgettext(gchar *domain , gchar *msgctxtid , gsize msgidoffset ) ;
#line 57
extern gchar *g_dpgettext2(gchar *domain , gchar *context , gchar *msgid ) ;
#line 72 "/usr/include/glib-2.0/glib/gmem.h"
extern void g_free(gpointer mem ) ;
#line 75
extern void g_clear_pointer(gpointer *pp , GDestroyNotify destroy ) ;
#line 79
extern gpointer g_malloc(gsize n_bytes ) ;
#line 81
extern gpointer g_malloc0(gsize n_bytes ) ;
#line 83
extern gpointer g_realloc(gpointer mem , gsize n_bytes ) ;
#line 86
extern gpointer g_try_malloc(gsize n_bytes ) ;
#line 88
extern gpointer g_try_malloc0(gsize n_bytes ) ;
#line 90
extern gpointer g_try_realloc(gpointer mem , gsize n_bytes ) ;
#line 94
extern gpointer g_malloc_n(gsize n_blocks , gsize n_block_bytes ) ;
#line 97
extern gpointer g_malloc0_n(gsize n_blocks , gsize n_block_bytes ) ;
#line 100
extern gpointer g_realloc_n(gpointer mem , gsize n_blocks , gsize n_block_bytes ) ;
#line 104
extern gpointer g_try_malloc_n(gsize n_blocks , gsize n_block_bytes ) ;
#line 107
extern gpointer g_try_malloc0_n(gsize n_blocks , gsize n_block_bytes ) ;
#line 110
extern gpointer g_try_realloc_n(gpointer mem , gsize n_blocks , gsize n_block_bytes ) ;
#line 115
extern gpointer g_aligned_alloc(gsize n_blocks , gsize n_block_bytes , gsize alignment ) ;
#line 119
extern gpointer g_aligned_alloc0(gsize n_blocks , gsize n_block_bytes , gsize alignment ) ;
#line 123
extern void g_aligned_free(gpointer mem ) ;
#line 216 "/usr/include/glib-2.0/glib/gmem.h"
__inline static gpointer g_steal_pointer(gpointer pp ) 
{ 
  gpointer *ptr ;
  gpointer ref ;

  {
#line 218
  ptr = (gpointer *)pp;
#line 221
  ref = *ptr;
#line 222
  *ptr = (void *)0;
#line 224
  return (ref);
}
}
#line 393
extern void g_mem_set_vtable(GMemVTable *vtable ) ;
#line 395
extern gboolean g_mem_is_system_malloc(void) ;
#line 397
extern gboolean g_mem_gc_friendly ;
#line 401
extern GMemVTable *glib_mem_profiler_table ;
#line 403
extern void g_mem_profile(void) ;
#line 99 "/usr/include/glib-2.0/glib/gnode.h"
extern GNode *g_node_new(gpointer data ) ;
#line 101
extern void g_node_destroy(GNode *root ) ;
#line 103
extern void g_node_unlink(GNode *node ) ;
#line 105
extern GNode *g_node_copy_deep(GNode *node , GCopyFunc copy_func , gpointer data ) ;
#line 109
extern GNode *g_node_copy(GNode *node ) ;
#line 111
extern GNode *g_node_insert(GNode *parent , gint position , GNode *node ) ;
#line 115
extern GNode *g_node_insert_before(GNode *parent , GNode *sibling , GNode *node ) ;
#line 119
extern GNode *g_node_insert_after(GNode *parent , GNode *sibling , GNode *node ) ;
#line 123
extern GNode *g_node_prepend(GNode *parent , GNode *node ) ;
#line 126
extern guint g_node_n_nodes(GNode *root , GTraverseFlags flags ) ;
#line 129
extern GNode *g_node_get_root(GNode *node ) ;
#line 131
extern gboolean g_node_is_ancestor(GNode *node , GNode *descendant ) ;
#line 134
extern guint g_node_depth(GNode *node ) ;
#line 136
extern GNode *g_node_find(GNode *root , GTraverseType order , GTraverseFlags flags ,
                          gpointer data ) ;
#line 224
extern void g_node_traverse(GNode *root , GTraverseType order , GTraverseFlags flags ,
                            gint max_depth , GNodeTraverseFunc func , gpointer data ) ;
#line 237
extern guint g_node_max_height(GNode *root ) ;
#line 240
extern void g_node_children_foreach(GNode *node , GTraverseFlags flags , GNodeForeachFunc func ,
                                    gpointer data ) ;
#line 245
extern void g_node_reverse_children(GNode *node ) ;
#line 247
extern guint g_node_n_children(GNode *node ) ;
#line 249
extern GNode *g_node_nth_child(GNode *node , guint n ) ;
#line 252
extern GNode *g_node_last_child(GNode *node ) ;
#line 254
extern GNode *g_node_find_child(GNode *node , GTraverseFlags flags , gpointer data ) ;
#line 258
extern gint g_node_child_position(GNode *node , GNode *child ) ;
#line 261
extern gint g_node_child_index(GNode *node , gpointer data ) ;
#line 265
extern GNode *g_node_first_sibling(GNode *node ) ;
#line 267
extern GNode *g_node_last_sibling(GNode *node ) ;
#line 49 "/usr/include/glib-2.0/glib/glist.h"
extern GList *g_list_alloc(void) ;
#line 51
extern void g_list_free(GList *list ) ;
#line 53
extern void g_list_free_1(GList *list ) ;
#line 56
extern void g_list_free_full(GList *list , GDestroyNotify free_func ) ;
#line 59
extern GList *g_list_append(GList *list , gpointer data ) ;
#line 62
extern GList *g_list_prepend(GList *list , gpointer data ) ;
#line 65
extern GList *g_list_insert(GList *list , gpointer data , gint position ) ;
#line 69
extern GList *g_list_insert_sorted(GList *list , gpointer data , GCompareFunc func ) ;
#line 73
extern GList *g_list_insert_sorted_with_data(GList *list , gpointer data , GCompareDataFunc func ,
                                             gpointer user_data ) ;
#line 78
extern GList *g_list_insert_before(GList *list , GList *sibling , gpointer data ) ;
#line 82
extern GList *g_list_insert_before_link(GList *list , GList *sibling , GList *link_ ) ;
#line 86
extern GList *g_list_concat(GList *list1 , GList *list2 ) ;
#line 89
extern GList *g_list_remove(GList *list , gconstpointer data ) ;
#line 92
extern GList *g_list_remove_all(GList *list , gconstpointer data ) ;
#line 95
extern GList *g_list_remove_link(GList *list , GList *llink ) ;
#line 98
extern GList *g_list_delete_link(GList *list , GList *link_ ) ;
#line 101
extern GList *g_list_reverse(GList *list ) ;
#line 103
extern GList *g_list_copy(GList *list ) ;
#line 106
extern GList *g_list_copy_deep(GList *list , GCopyFunc func , gpointer user_data ) ;
#line 111
extern GList *g_list_nth(GList *list , guint n ) ;
#line 114
extern GList *g_list_nth_prev(GList *list , guint n ) ;
#line 117
extern GList *g_list_find(GList *list , gconstpointer data ) ;
#line 120
extern GList *g_list_find_custom(GList *list , gconstpointer data , GCompareFunc func ) ;
#line 124
extern gint g_list_position(GList *list , GList *llink ) ;
#line 127
extern gint g_list_index(GList *list , gconstpointer data ) ;
#line 130
extern GList *g_list_last(GList *list ) ;
#line 132
extern GList *g_list_first(GList *list ) ;
#line 134
extern guint g_list_length(GList *list ) ;
#line 136
extern void g_list_foreach(GList *list , GFunc func , gpointer user_data ) ;
#line 140
extern GList *g_list_sort(GList *list , GCompareFunc compare_func ) ;
#line 143
extern GList *g_list_sort_with_data(GList *list , GCompareDataFunc compare_func ,
                                    gpointer user_data ) ;
#line 147
extern gpointer g_list_nth_data(GList *list , guint n ) ;
#line 151
extern void g_clear_list(GList **list_ptr , GDestroyNotify destroy ) ;
#line 57 "/usr/include/glib-2.0/glib/ghash.h"
extern GHashTable *g_hash_table_new(GHashFunc hash_func , GEqualFunc key_equal_func ) ;
#line 60
extern GHashTable *g_hash_table_new_full(GHashFunc hash_func , GEqualFunc key_equal_func ,
                                         GDestroyNotify key_destroy_func , GDestroyNotify value_destroy_func ) ;
#line 65
extern GHashTable *g_hash_table_new_similar(GHashTable *other_hash_table ) ;
#line 67
extern void g_hash_table_destroy(GHashTable *hash_table ) ;
#line 69
extern gboolean g_hash_table_insert(GHashTable *hash_table , gpointer key , gpointer value ) ;
#line 73
extern gboolean g_hash_table_replace(GHashTable *hash_table , gpointer key , gpointer value ) ;
#line 77
extern gboolean g_hash_table_add(GHashTable *hash_table , gpointer key ) ;
#line 80
extern gboolean g_hash_table_remove(GHashTable *hash_table , gconstpointer key ) ;
#line 83
extern void g_hash_table_remove_all(GHashTable *hash_table ) ;
#line 85
extern gboolean g_hash_table_steal(GHashTable *hash_table , gconstpointer key ) ;
#line 88
extern gboolean g_hash_table_steal_extended(GHashTable *hash_table , gconstpointer lookup_key ,
                                            gpointer *stolen_key , gpointer *stolen_value ) ;
#line 93
extern void g_hash_table_steal_all(GHashTable *hash_table ) ;
#line 95
extern gpointer g_hash_table_lookup(GHashTable *hash_table , gconstpointer key ) ;
#line 98
extern gboolean g_hash_table_contains(GHashTable *hash_table , gconstpointer key ) ;
#line 101
extern gboolean g_hash_table_lookup_extended(GHashTable *hash_table , gconstpointer lookup_key ,
                                             gpointer *orig_key , gpointer *value ) ;
#line 106
extern void g_hash_table_foreach(GHashTable *hash_table , GHFunc func , gpointer user_data ) ;
#line 110
extern gpointer g_hash_table_find(GHashTable *hash_table , GHRFunc predicate , gpointer user_data ) ;
#line 114
extern guint g_hash_table_foreach_remove(GHashTable *hash_table , GHRFunc func , gpointer user_data ) ;
#line 118
extern guint g_hash_table_foreach_steal(GHashTable *hash_table , GHRFunc func , gpointer user_data ) ;
#line 122
extern guint g_hash_table_size(GHashTable *hash_table ) ;
#line 124
extern GList *g_hash_table_get_keys(GHashTable *hash_table ) ;
#line 126
extern GList *g_hash_table_get_values(GHashTable *hash_table ) ;
#line 128
extern gpointer *g_hash_table_get_keys_as_array(GHashTable *hash_table , guint *length ) ;
#line 132
extern void g_hash_table_iter_init(GHashTableIter *iter , GHashTable *hash_table ) ;
#line 135
extern gboolean g_hash_table_iter_next(GHashTableIter *iter , gpointer *key , gpointer *value ) ;
#line 139
extern GHashTable *g_hash_table_iter_get_hash_table(GHashTableIter *iter ) ;
#line 141
extern void g_hash_table_iter_remove(GHashTableIter *iter ) ;
#line 143
extern void g_hash_table_iter_replace(GHashTableIter *iter , gpointer value ) ;
#line 146
extern void g_hash_table_iter_steal(GHashTableIter *iter ) ;
#line 149
extern GHashTable *g_hash_table_ref(GHashTable *hash_table ) ;
#line 151
extern void g_hash_table_unref(GHashTable *hash_table ) ;
#line 159
extern gboolean g_str_equal(gconstpointer v1 , gconstpointer v2 ) ;
#line 162
extern guint g_str_hash(gconstpointer v ) ;
#line 165
extern gboolean g_int_equal(gconstpointer v1 , gconstpointer v2 ) ;
#line 168
extern guint g_int_hash(gconstpointer v ) ;
#line 171
extern gboolean g_int64_equal(gconstpointer v1 , gconstpointer v2 ) ;
#line 174
extern guint g_int64_hash(gconstpointer v ) ;
#line 177
extern gboolean g_double_equal(gconstpointer v1 , gconstpointer v2 ) ;
#line 180
extern guint g_double_hash(gconstpointer v ) ;
#line 183
extern guint g_direct_hash(gconstpointer v ) ;
#line 185
extern gboolean g_direct_equal(gconstpointer v1 , gconstpointer v2 ) ;
#line 43 "/usr/include/glib-2.0/glib/ghmac.h"
extern GHmac *g_hmac_new(GChecksumType digest_type , guchar *key , gsize key_len ) ;
#line 47
extern GHmac *g_hmac_copy(GHmac *hmac ) ;
#line 49
extern GHmac *g_hmac_ref(GHmac *hmac ) ;
#line 51
extern void g_hmac_unref(GHmac *hmac ) ;
#line 53
extern void g_hmac_update(GHmac *hmac , guchar *data , gssize length ) ;
#line 57
extern gchar *g_hmac_get_string(GHmac *hmac ) ;
#line 59
extern void g_hmac_get_digest(GHmac *hmac , guint8 *buffer , gsize *digest_len ) ;
#line 64
extern gchar *g_compute_hmac_for_data(GChecksumType digest_type , guchar *key , gsize key_len ,
                                      guchar *data , gsize length ) ;
#line 70
extern gchar *g_compute_hmac_for_string(GChecksumType digest_type , guchar *key ,
                                        gsize key_len , gchar *str , gssize length ) ;
#line 76
extern gchar *g_compute_hmac_for_bytes(GChecksumType digest_type , GBytes *key , GBytes *data ) ;
#line 105 "/usr/include/glib-2.0/glib/ghook.h"
extern void g_hook_list_init(GHookList *hook_list , guint hook_size ) ;
#line 108
extern void g_hook_list_clear(GHookList *hook_list ) ;
#line 110
extern GHook *g_hook_alloc(GHookList *hook_list ) ;
#line 112
extern void g_hook_free(GHookList *hook_list , GHook *hook ) ;
#line 115
extern GHook *g_hook_ref(GHookList *hook_list , GHook *hook ) ;
#line 118
extern void g_hook_unref(GHookList *hook_list , GHook *hook ) ;
#line 121
extern gboolean g_hook_destroy(GHookList *hook_list , gulong hook_id ) ;
#line 124
extern void g_hook_destroy_link(GHookList *hook_list , GHook *hook ) ;
#line 127
extern void g_hook_prepend(GHookList *hook_list , GHook *hook ) ;
#line 130
extern void g_hook_insert_before(GHookList *hook_list , GHook *sibling , GHook *hook ) ;
#line 134
extern void g_hook_insert_sorted(GHookList *hook_list , GHook *hook , GHookCompareFunc func ) ;
#line 138
extern GHook *g_hook_get(GHookList *hook_list , gulong hook_id ) ;
#line 141
extern GHook *g_hook_find(GHookList *hook_list , gboolean need_valids , GHookFindFunc func ,
                          gpointer data ) ;
#line 146
extern GHook *g_hook_find_data(GHookList *hook_list , gboolean need_valids , gpointer data ) ;
#line 150
extern GHook *g_hook_find_func(GHookList *hook_list , gboolean need_valids , gpointer func ) ;
#line 154
extern GHook *g_hook_find_func_data(GHookList *hook_list , gboolean need_valids ,
                                    gpointer func , gpointer data ) ;
#line 160
extern GHook *g_hook_first_valid(GHookList *hook_list , gboolean may_be_in_call ) ;
#line 166
extern GHook *g_hook_next_valid(GHookList *hook_list , GHook *hook , gboolean may_be_in_call ) ;
#line 171
extern gint g_hook_compare_ids(GHook *new_hook , GHook *sibling ) ;
#line 179
extern void g_hook_list_invoke(GHookList *hook_list , gboolean may_recurse ) ;
#line 185
extern void g_hook_list_invoke_check(GHookList *hook_list , gboolean may_recurse ) ;
#line 190
extern void g_hook_list_marshal(GHookList *hook_list , gboolean may_recurse , GHookMarshaller marshaller ,
                                gpointer marshal_data ) ;
#line 195
extern void g_hook_list_marshal_check(GHookList *hook_list , gboolean may_recurse ,
                                      GHookCheckMarshaller marshaller , gpointer marshal_data ) ;
#line 30 "/usr/include/glib-2.0/glib/ghostutils.h"
extern gboolean g_hostname_is_non_ascii(gchar *hostname ) ;
#line 32
extern gboolean g_hostname_is_ascii_encoded(gchar *hostname ) ;
#line 34
extern gboolean g_hostname_is_ip_address(gchar *hostname ) ;
#line 37
extern gchar *g_hostname_to_ascii(gchar *hostname ) ;
#line 39
extern gchar *g_hostname_to_unicode(gchar *hostname ) ;
#line 114 "/usr/include/glib-2.0/glib/gpoll.h"
extern gint g_poll(GPollFD *fds , guint nfds , gint timeout ) ;
#line 48 "/usr/include/glib-2.0/glib/gslist.h"
extern GSList *g_slist_alloc(void) ;
#line 50
extern void g_slist_free(GSList *list ) ;
#line 52
extern void g_slist_free_1(GSList *list ) ;
#line 55
extern void g_slist_free_full(GSList *list , GDestroyNotify free_func ) ;
#line 58
extern GSList *g_slist_append(GSList *list , gpointer data ) ;
#line 61
extern GSList *g_slist_prepend(GSList *list , gpointer data ) ;
#line 64
extern GSList *g_slist_insert(GSList *list , gpointer data , gint position ) ;
#line 68
extern GSList *g_slist_insert_sorted(GSList *list , gpointer data , GCompareFunc func ) ;
#line 72
extern GSList *g_slist_insert_sorted_with_data(GSList *list , gpointer data , GCompareDataFunc func ,
                                               gpointer user_data ) ;
#line 77
extern GSList *g_slist_insert_before(GSList *slist , GSList *sibling , gpointer data ) ;
#line 81
extern GSList *g_slist_concat(GSList *list1 , GSList *list2 ) ;
#line 84
extern GSList *g_slist_remove(GSList *list , gconstpointer data ) ;
#line 87
extern GSList *g_slist_remove_all(GSList *list , gconstpointer data ) ;
#line 90
extern GSList *g_slist_remove_link(GSList *list , GSList *link_ ) ;
#line 93
extern GSList *g_slist_delete_link(GSList *list , GSList *link_ ) ;
#line 96
extern GSList *g_slist_reverse(GSList *list ) ;
#line 98
extern GSList *g_slist_copy(GSList *list ) ;
#line 101
extern GSList *g_slist_copy_deep(GSList *list , GCopyFunc func , gpointer user_data ) ;
#line 105
extern GSList *g_slist_nth(GSList *list , guint n ) ;
#line 108
extern GSList *g_slist_find(GSList *list , gconstpointer data ) ;
#line 111
extern GSList *g_slist_find_custom(GSList *list , gconstpointer data , GCompareFunc func ) ;
#line 115
extern gint g_slist_position(GSList *list , GSList *llink ) ;
#line 118
extern gint g_slist_index(GSList *list , gconstpointer data ) ;
#line 121
extern GSList *g_slist_last(GSList *list ) ;
#line 123
extern guint g_slist_length(GSList *list ) ;
#line 125
extern void g_slist_foreach(GSList *list , GFunc func , gpointer user_data ) ;
#line 129
extern GSList *g_slist_sort(GSList *list , GCompareFunc compare_func ) ;
#line 132
extern GSList *g_slist_sort_with_data(GSList *list , GCompareDataFunc compare_func ,
                                      gpointer user_data ) ;
#line 136
extern gpointer g_slist_nth_data(GSList *list , guint n ) ;
#line 140
extern void g_clear_slist(GSList **slist_ptr , GDestroyNotify destroy ) ;
#line 380 "/usr/include/glib-2.0/glib/gmain.h"
extern GMainContext *g_main_context_new(void) ;
#line 383
extern GMainContext *g_main_context_new_with_flags(GMainContextFlags flags ) ;
#line 386
extern GMainContext *g_main_context_ref(GMainContext *context ) ;
#line 388
extern void g_main_context_unref(GMainContext *context ) ;
#line 390
extern GMainContext *g_main_context_default(void) ;
#line 393
extern gboolean g_main_context_iteration(GMainContext *context , gboolean may_block ) ;
#line 396
extern gboolean g_main_context_pending(GMainContext *context ) ;
#line 401
extern GSource *g_main_context_find_source_by_id(GMainContext *context , guint source_id ) ;
#line 404
extern GSource *g_main_context_find_source_by_user_data(GMainContext *context , gpointer user_data ) ;
#line 407
extern GSource *g_main_context_find_source_by_funcs_user_data(GMainContext *context ,
                                                              GSourceFuncs *funcs ,
                                                              gpointer user_data ) ;
#line 414
extern void g_main_context_wakeup(GMainContext *context ) ;
#line 416
extern gboolean g_main_context_acquire(GMainContext *context ) ;
#line 418
extern void g_main_context_release(GMainContext *context ) ;
#line 420
extern gboolean g_main_context_is_owner(GMainContext *context ) ;
#line 422
extern gboolean g_main_context_wait(GMainContext *context , GCond *cond , GMutex *mutex ) ;
#line 427
extern gboolean g_main_context_prepare(GMainContext *context , gint *priority ) ;
#line 430
extern gint g_main_context_query(GMainContext *context , gint max_priority , gint *timeout_ ,
                                 GPollFD *fds , gint n_fds ) ;
#line 436
extern gboolean g_main_context_check(GMainContext *context , gint max_priority , GPollFD *fds ,
                                     gint n_fds ) ;
#line 441
extern void g_main_context_dispatch(GMainContext *context ) ;
#line 444
extern void g_main_context_set_poll_func(GMainContext *context , GPollFunc func ) ;
#line 447
extern GPollFunc g_main_context_get_poll_func(GMainContext *context ) ;
#line 452
extern void g_main_context_add_poll(GMainContext *context , GPollFD *fd , gint priority ) ;
#line 456
extern void g_main_context_remove_poll(GMainContext *context , GPollFD *fd ) ;
#line 460
extern gint g_main_depth(void) ;
#line 462
extern GSource *g_main_current_source(void) ;
#line 467
extern void g_main_context_push_thread_default(GMainContext *context ) ;
#line 469
extern void g_main_context_pop_thread_default(GMainContext *context ) ;
#line 471
extern GMainContext *g_main_context_get_thread_default(void) ;
#line 473
extern GMainContext *g_main_context_ref_thread_default(void) ;
#line 532 "/usr/include/glib-2.0/glib/gmain.h"
__inline static GMainContextPusher *g_main_context_pusher_new(GMainContext *main_context ) 
{ 


  {
  {
#line 534
  g_main_context_push_thread_default(main_context);
  }
#line 535
  return ((GMainContextPusher *)main_context);
}
}
#line 554 "/usr/include/glib-2.0/glib/gmain.h"
__inline static void g_main_context_pusher_free(GMainContextPusher *pusher ) 
{ 


  {
  {
#line 556
  g_main_context_pop_thread_default((GMainContext *)pusher);
  }
  return;
}
}
#line 563
extern GMainLoop *g_main_loop_new(GMainContext *context , gboolean is_running ) ;
#line 566
extern void g_main_loop_run(GMainLoop *loop ) ;
#line 568
extern void g_main_loop_quit(GMainLoop *loop ) ;
#line 570
extern GMainLoop *g_main_loop_ref(GMainLoop *loop ) ;
#line 572
extern void g_main_loop_unref(GMainLoop *loop ) ;
#line 574
extern gboolean g_main_loop_is_running(GMainLoop *loop ) ;
#line 576
extern GMainContext *g_main_loop_get_context(GMainLoop *loop ) ;
#line 581
extern GSource *g_source_new(GSourceFuncs *source_funcs , guint struct_size ) ;
#line 586
extern void g_source_set_dispose_function(GSource *source , GSourceDisposeFunc dispose ) ;
#line 591
extern GSource *g_source_ref(GSource *source ) ;
#line 593
extern void g_source_unref(GSource *source ) ;
#line 596
extern guint g_source_attach(GSource *source , GMainContext *context ) ;
#line 599
extern void g_source_destroy(GSource *source ) ;
#line 602
extern void g_source_set_priority(GSource *source , gint priority ) ;
#line 605
extern gint g_source_get_priority(GSource *source ) ;
#line 607
extern void g_source_set_can_recurse(GSource *source , gboolean can_recurse ) ;
#line 610
extern gboolean g_source_get_can_recurse(GSource *source ) ;
#line 612
extern guint g_source_get_id(GSource *source ) ;
#line 615
extern GMainContext *g_source_get_context(GSource *source ) ;
#line 618
extern void g_source_set_callback(GSource *source , GSourceFunc func , gpointer data ,
                                  GDestroyNotify notify ) ;
#line 624
extern void g_source_set_funcs(GSource *source , GSourceFuncs *funcs ) ;
#line 627
extern gboolean g_source_is_destroyed(GSource *source ) ;
#line 630
extern void g_source_set_name(GSource *source , char const   *name ) ;
#line 633
extern void g_source_set_static_name(GSource *source , char const   *name ) ;
#line 636
extern char const   *g_source_get_name(GSource *source ) ;
#line 638
extern void g_source_set_name_by_id(guint tag , char const   *name ) ;
#line 642
extern void g_source_set_ready_time(GSource *source , gint64 ready_time ) ;
#line 645
extern gint64 g_source_get_ready_time(GSource *source ) ;
#line 649
extern gpointer g_source_add_unix_fd(GSource *source , gint fd , GIOCondition events ) ;
#line 653
extern void g_source_modify_unix_fd(GSource *source , gpointer tag , GIOCondition new_events ) ;
#line 657
extern void g_source_remove_unix_fd(GSource *source , gpointer tag ) ;
#line 660
extern GIOCondition g_source_query_unix_fd(GSource *source , gpointer tag ) ;
#line 666
extern void g_source_set_callback_indirect(GSource *source , gpointer callback_data ,
                                           GSourceCallbackFuncs *callback_funcs ) ;
#line 671
extern void g_source_add_poll(GSource *source , GPollFD *fd ) ;
#line 674
extern void g_source_remove_poll(GSource *source , GPollFD *fd ) ;
#line 678
extern void g_source_add_child_source(GSource *source , GSource *child_source ) ;
#line 681
extern void g_source_remove_child_source(GSource *source , GSource *child_source ) ;
#line 686
extern void g_source_get_current_time(GSource *source , GTimeVal *timeval ) ;
#line 691
extern gint64 g_source_get_time(GSource *source ) ;
#line 700
extern GSource *g_idle_source_new(void) ;
#line 702
extern GSource *g_child_watch_source_new(GPid pid ) ;
#line 704
extern GSource *g_timeout_source_new(guint interval ) ;
#line 706
extern GSource *g_timeout_source_new_seconds(guint interval ) ;
#line 712
extern void g_get_current_time(GTimeVal *result ) ;
#line 716
extern gint64 g_get_monotonic_time(void) ;
#line 718
extern gint64 g_get_real_time(void) ;
#line 723
extern gboolean g_source_remove(guint tag ) ;
#line 725
extern gboolean g_source_remove_by_user_data(gpointer user_data ) ;
#line 727
extern gboolean g_source_remove_by_funcs_user_data(GSourceFuncs *funcs , gpointer user_data ) ;
#line 744
extern void g_clear_handle_id(guint *tag_ptr , GClearHandleFunc clear_func ) ;
#line 764
extern guint g_timeout_add_full(gint priority , guint interval , GSourceFunc function ,
                                gpointer data , GDestroyNotify notify ) ;
#line 770
extern guint g_timeout_add(guint interval , GSourceFunc function , gpointer data ) ;
#line 774
extern guint g_timeout_add_seconds_full(gint priority , guint interval , GSourceFunc function ,
                                        gpointer data , GDestroyNotify notify ) ;
#line 780
extern guint g_timeout_add_seconds(guint interval , GSourceFunc function , gpointer data ) ;
#line 784
extern guint g_child_watch_add_full(gint priority , GPid pid , GChildWatchFunc function ,
                                    gpointer data , GDestroyNotify notify ) ;
#line 790
extern guint g_child_watch_add(GPid pid , GChildWatchFunc function , gpointer data ) ;
#line 794
extern guint g_idle_add(GSourceFunc function , gpointer data ) ;
#line 797
extern guint g_idle_add_full(gint priority , GSourceFunc function , gpointer data ,
                             GDestroyNotify notify ) ;
#line 802
extern gboolean g_idle_remove_by_data(gpointer data ) ;
#line 805
extern void g_main_context_invoke_full(GMainContext *context , gint priority , GSourceFunc function ,
                                       gpointer data , GDestroyNotify notify ) ;
#line 811
extern void g_main_context_invoke(GMainContext *context , GSourceFunc function , gpointer data ) ;
#line 817 "/usr/include/glib-2.0/glib/gmain.h"
__inline static int g_steal_fd(int *fd_ptr ) 
{ 
  int fd ;

  {
#line 819
  fd = *fd_ptr;
#line 820
  *fd_ptr = - 1;
#line 821
  return (fd);
}
}
#line 825
extern GSourceFuncs g_timeout_funcs ;
#line 826
extern GSourceFuncs g_child_watch_funcs ;
#line 827
extern GSourceFuncs g_idle_funcs ;
#line 829
extern GSourceFuncs g_unix_signal_funcs ;
#line 830
extern GSourceFuncs g_unix_fd_source_funcs ;
#line 650 "/usr/include/glib-2.0/glib/gunicode.h"
extern guint32 g_unicode_script_to_iso15924(GUnicodeScript script ) ;
#line 652
extern GUnicodeScript g_unicode_script_from_iso15924(guint32 iso15924 ) ;
#line 657
extern gboolean g_unichar_isalnum(gunichar c ) ;
#line 659
extern gboolean g_unichar_isalpha(gunichar c ) ;
#line 661
extern gboolean g_unichar_iscntrl(gunichar c ) ;
#line 663
extern gboolean g_unichar_isdigit(gunichar c ) ;
#line 665
extern gboolean g_unichar_isgraph(gunichar c ) ;
#line 667
extern gboolean g_unichar_islower(gunichar c ) ;
#line 669
extern gboolean g_unichar_isprint(gunichar c ) ;
#line 671
extern gboolean g_unichar_ispunct(gunichar c ) ;
#line 673
extern gboolean g_unichar_isspace(gunichar c ) ;
#line 675
extern gboolean g_unichar_isupper(gunichar c ) ;
#line 677
extern gboolean g_unichar_isxdigit(gunichar c ) ;
#line 679
extern gboolean g_unichar_istitle(gunichar c ) ;
#line 681
extern gboolean g_unichar_isdefined(gunichar c ) ;
#line 683
extern gboolean g_unichar_iswide(gunichar c ) ;
#line 685
extern gboolean g_unichar_iswide_cjk(gunichar c ) ;
#line 687
extern gboolean g_unichar_iszerowidth(gunichar c ) ;
#line 689
extern gboolean g_unichar_ismark(gunichar c ) ;
#line 694
extern gunichar g_unichar_toupper(gunichar c ) ;
#line 696
extern gunichar g_unichar_tolower(gunichar c ) ;
#line 698
extern gunichar g_unichar_totitle(gunichar c ) ;
#line 703
extern gint g_unichar_digit_value(gunichar c ) ;
#line 706
extern gint g_unichar_xdigit_value(gunichar c ) ;
#line 710
extern GUnicodeType g_unichar_type(gunichar c ) ;
#line 714
extern GUnicodeBreakType g_unichar_break_type(gunichar c ) ;
#line 718
extern gint g_unichar_combining_class(gunichar uc ) ;
#line 721
extern gboolean g_unichar_get_mirror_char(gunichar ch , gunichar *mirrored_ch ) ;
#line 725
extern GUnicodeScript g_unichar_get_script(gunichar ch ) ;
#line 729
extern gboolean g_unichar_validate(gunichar ch ) ;
#line 733
extern gboolean g_unichar_compose(gunichar a , gunichar b , gunichar *ch ) ;
#line 737
extern gboolean g_unichar_decompose(gunichar ch , gunichar *a , gunichar *b ) ;
#line 742
extern gsize g_unichar_fully_decompose(gunichar ch , gboolean compat , gunichar *result ,
                                       gsize result_len ) ;
#line 763
extern void g_unicode_canonical_ordering(gunichar *string , gsize len ) ;
#line 768
extern gunichar *g_unicode_canonical_decomposition(gunichar ch , gsize *result_len ) ;
#line 773
extern gchar * const  g_utf8_skip ;
#line 794
extern gunichar g_utf8_get_char(gchar *p ) ;
#line 796
extern gunichar g_utf8_get_char_validated(gchar *p , gssize max_len ) ;
#line 800
extern gchar *g_utf8_offset_to_pointer(gchar *str , glong offset ) ;
#line 803
extern glong g_utf8_pointer_to_offset(gchar *str , gchar *pos ) ;
#line 806
extern gchar *g_utf8_prev_char(gchar *p ) ;
#line 808
extern gchar *g_utf8_find_next_char(gchar *p , gchar *end ) ;
#line 811
extern gchar *g_utf8_find_prev_char(gchar *str , gchar *p ) ;
#line 815
extern glong g_utf8_strlen(gchar *p , gssize max ) ;
#line 819
extern gchar *g_utf8_substring(gchar *str , glong start_pos , glong end_pos ) ;
#line 824
extern gchar *g_utf8_strncpy(gchar *dest , gchar *src , gsize n ) ;
#line 831
extern gchar *g_utf8_strchr(gchar *p , gssize len , gunichar c ) ;
#line 835
extern gchar *g_utf8_strrchr(gchar *p , gssize len , gunichar c ) ;
#line 839
extern gchar *g_utf8_strreverse(gchar *str , gssize len ) ;
#line 843
extern gunichar2 *g_utf8_to_utf16(gchar *str , glong len , glong *items_read , glong *items_written ,
                                  GError **error ) ;
#line 849
extern gunichar *g_utf8_to_ucs4(gchar *str , glong len , glong *items_read , glong *items_written ,
                                GError **error ) ;
#line 855
extern gunichar *g_utf8_to_ucs4_fast(gchar *str , glong len , glong *items_written ) ;
#line 859
extern gunichar *g_utf16_to_ucs4(gunichar2 *str , glong len , glong *items_read ,
                                 glong *items_written , GError **error ) ;
#line 865
extern gchar *g_utf16_to_utf8(gunichar2 *str , glong len , glong *items_read , glong *items_written ,
                              GError **error ) ;
#line 871
extern gunichar2 *g_ucs4_to_utf16(gunichar *str , glong len , glong *items_read ,
                                  glong *items_written , GError **error ) ;
#line 877
extern gchar *g_ucs4_to_utf8(gunichar *str , glong len , glong *items_read , glong *items_written ,
                             GError **error ) ;
#line 884
extern gint g_unichar_to_utf8(gunichar c , gchar *outbuf ) ;
#line 888
extern gboolean g_utf8_validate(gchar *str , gssize max_len , gchar **end ) ;
#line 892
extern gboolean g_utf8_validate_len(gchar *str , gsize max_len , gchar **end ) ;
#line 897
extern gchar *g_utf8_strup(gchar *str , gssize len ) ;
#line 900
extern gchar *g_utf8_strdown(gchar *str , gssize len ) ;
#line 903
extern gchar *g_utf8_casefold(gchar *str , gssize len ) ;
#line 942
extern gchar *g_utf8_normalize(gchar *str , gssize len , GNormalizeMode mode ) ;
#line 947
extern gint g_utf8_collate(gchar *str1 , gchar *str2 ) ;
#line 950
extern gchar *g_utf8_collate_key(gchar *str , gssize len ) ;
#line 953
extern gchar *g_utf8_collate_key_for_filename(gchar *str , gssize len ) ;
#line 957
extern gchar *g_utf8_make_valid(gchar *str , gssize len ) ;
#line 49 "/usr/include/glib-2.0/glib/gstring.h"
extern GString *g_string_new(gchar *init ) ;
#line 51
extern GString *g_string_new_len(gchar *init , gssize len ) ;
#line 54
extern GString *g_string_sized_new(gsize dfl_size ) ;
#line 56
extern gchar *g_string_free(GString *string , gboolean free_segment ) ;
#line 59
extern GBytes *g_string_free_to_bytes(GString *string ) ;
#line 61
extern gboolean g_string_equal(GString *v , GString *v2 ) ;
#line 64
extern guint g_string_hash(GString *str ) ;
#line 66
extern GString *g_string_assign(GString *string , gchar *rval ) ;
#line 69
extern GString *g_string_truncate(GString *string , gsize len ) ;
#line 72
extern GString *g_string_set_size(GString *string , gsize len ) ;
#line 75
extern GString *g_string_insert_len(GString *string , gssize pos , gchar *val , gssize len ) ;
#line 80
extern GString *g_string_append(GString *string , gchar *val ) ;
#line 83
extern GString *g_string_append_len(GString *string , gchar *val , gssize len ) ;
#line 87
extern GString *g_string_append_c(GString *string , gchar c ) ;
#line 90
extern GString *g_string_append_unichar(GString *string , gunichar wc ) ;
#line 93
extern GString *g_string_prepend(GString *string , gchar *val ) ;
#line 96
extern GString *g_string_prepend_c(GString *string , gchar c ) ;
#line 99
extern GString *g_string_prepend_unichar(GString *string , gunichar wc ) ;
#line 102
extern GString *g_string_prepend_len(GString *string , gchar *val , gssize len ) ;
#line 106
extern GString *g_string_insert(GString *string , gssize pos , gchar *val ) ;
#line 110
extern GString *g_string_insert_c(GString *string , gssize pos , gchar c ) ;
#line 114
extern GString *g_string_insert_unichar(GString *string , gssize pos , gunichar wc ) ;
#line 118
extern GString *g_string_overwrite(GString *string , gsize pos , gchar *val ) ;
#line 122
extern GString *g_string_overwrite_len(GString *string , gsize pos , gchar *val ,
                                       gssize len ) ;
#line 127
extern GString *g_string_erase(GString *string , gssize pos , gssize len ) ;
#line 131
extern guint g_string_replace(GString *string , gchar *find , gchar *replace , guint limit ) ;
#line 136
extern GString *g_string_ascii_down(GString *string ) ;
#line 138
extern GString *g_string_ascii_up(GString *string ) ;
#line 140
extern void g_string_vprintf(GString *string , gchar *format , va_list args ) ;
#line 145
extern void g_string_printf(GString *string , gchar *format  , ...) ;
#line 149
extern void g_string_append_vprintf(GString *string , gchar *format , va_list args ) ;
#line 154
extern void g_string_append_printf(GString *string , gchar *format  , ...) ;
#line 158
extern GString *g_string_append_uri_escaped(GString *string , gchar *unescaped , gchar *reserved_chars_allowed ,
                                            gboolean allow_utf8 ) ;
#line 166 "/usr/include/glib-2.0/glib/gstring.h"
__inline static GString *g_string_append_c_inline(GString *gstring , gchar c ) 
{ 
  gsize __cil_tmp3 ;

  {
#line 169
  if (gstring->len + 1UL < gstring->allocated_len) {
#line 171
    __cil_tmp3 = gstring->len;
#line 171
    (gstring->len) ++;
#line 171
    *(gstring->str + __cil_tmp3) = c;
#line 172
    *(gstring->str + gstring->len) = (gchar )0;
  } else {
    {
#line 175
    g_string_insert_c(gstring, (gssize )(- 1), c);
    }
  }
#line 176
  return (gstring);
}
}
#line 183
extern GString *g_string_down(GString *string ) ;
#line 185
extern GString *g_string_up(GString *string ) ;
#line 159 "/usr/include/glib-2.0/glib/giochannel.h"
extern void g_io_channel_init(GIOChannel *channel ) ;
#line 161
extern GIOChannel *g_io_channel_ref(GIOChannel *channel ) ;
#line 163
extern void g_io_channel_unref(GIOChannel *channel ) ;
#line 166
extern GIOError g_io_channel_read(GIOChannel *channel , gchar *buf , gsize count ,
                                  gsize *bytes_read ) ;
#line 172
extern GIOError g_io_channel_write(GIOChannel *channel , gchar *buf , gsize count ,
                                   gsize *bytes_written ) ;
#line 178
extern GIOError g_io_channel_seek(GIOChannel *channel , gint64 offset , GSeekType type ) ;
#line 183
extern void g_io_channel_close(GIOChannel *channel ) ;
#line 186
extern GIOStatus g_io_channel_shutdown(GIOChannel *channel , gboolean flush , GError **err ) ;
#line 190
extern guint g_io_add_watch_full(GIOChannel *channel , gint priority , GIOCondition condition ,
                                 GIOFunc func , gpointer user_data , GDestroyNotify notify ) ;
#line 197
extern GSource *g_io_create_watch(GIOChannel *channel , GIOCondition condition ) ;
#line 200
extern guint g_io_add_watch(GIOChannel *channel , GIOCondition condition , GIOFunc func ,
                            gpointer user_data ) ;
#line 209
extern void g_io_channel_set_buffer_size(GIOChannel *channel , gsize size ) ;
#line 212
extern gsize g_io_channel_get_buffer_size(GIOChannel *channel ) ;
#line 214
extern GIOCondition g_io_channel_get_buffer_condition(GIOChannel *channel ) ;
#line 216
extern GIOStatus g_io_channel_set_flags(GIOChannel *channel , GIOFlags flags , GError **error ) ;
#line 220
extern GIOFlags g_io_channel_get_flags(GIOChannel *channel ) ;
#line 222
extern void g_io_channel_set_line_term(GIOChannel *channel , gchar *line_term , gint length ) ;
#line 226
extern gchar *g_io_channel_get_line_term(GIOChannel *channel , gint *length ) ;
#line 229
extern void g_io_channel_set_buffered(GIOChannel *channel , gboolean buffered ) ;
#line 232
extern gboolean g_io_channel_get_buffered(GIOChannel *channel ) ;
#line 234
extern GIOStatus g_io_channel_set_encoding(GIOChannel *channel , gchar *encoding ,
                                           GError **error ) ;
#line 238
extern gchar *g_io_channel_get_encoding(GIOChannel *channel ) ;
#line 240
extern void g_io_channel_set_close_on_unref(GIOChannel *channel , gboolean do_close ) ;
#line 243
extern gboolean g_io_channel_get_close_on_unref(GIOChannel *channel ) ;
#line 247
extern GIOStatus g_io_channel_flush(GIOChannel *channel , GError **error ) ;
#line 250
extern GIOStatus g_io_channel_read_line(GIOChannel *channel , gchar **str_return ,
                                        gsize *length , gsize *terminator_pos , GError **error ) ;
#line 256
extern GIOStatus g_io_channel_read_line_string(GIOChannel *channel , GString *buffer ,
                                               gsize *terminator_pos , GError **error ) ;
#line 261
extern GIOStatus g_io_channel_read_to_end(GIOChannel *channel , gchar **str_return ,
                                          gsize *length , GError **error ) ;
#line 266
extern GIOStatus g_io_channel_read_chars(GIOChannel *channel , gchar *buf , gsize count ,
                                         gsize *bytes_read , GError **error ) ;
#line 272
extern GIOStatus g_io_channel_read_unichar(GIOChannel *channel , gunichar *thechar ,
                                           GError **error ) ;
#line 276
extern GIOStatus g_io_channel_write_chars(GIOChannel *channel , gchar *buf , gssize count ,
                                          gsize *bytes_written , GError **error ) ;
#line 282
extern GIOStatus g_io_channel_write_unichar(GIOChannel *channel , gunichar thechar ,
                                            GError **error ) ;
#line 286
extern GIOStatus g_io_channel_seek_position(GIOChannel *channel , gint64 offset ,
                                            GSeekType type , GError **error ) ;
#line 291
extern GIOChannel *g_io_channel_new_file(gchar *filename , gchar *mode , GError **error ) ;
#line 298
extern GQuark g_io_channel_error_quark(void) ;
#line 300
extern GIOChannelError g_io_channel_error_from_errno(gint en ) ;
#line 321
extern GIOChannel *g_io_channel_unix_new(int fd ) ;
#line 323
extern gint g_io_channel_unix_get_fd(GIOChannel *channel ) ;
#line 327
extern GSourceFuncs g_io_watch_funcs ;
#line 46 "/usr/include/glib-2.0/glib/gkeyfile.h"
extern GQuark g_key_file_error_quark(void) ;
#line 58
extern GKeyFile *g_key_file_new(void) ;
#line 60
extern GKeyFile *g_key_file_ref(GKeyFile *key_file ) ;
#line 62
extern void g_key_file_unref(GKeyFile *key_file ) ;
#line 64
extern void g_key_file_free(GKeyFile *key_file ) ;
#line 66
extern void g_key_file_set_list_separator(GKeyFile *key_file , gchar separator ) ;
#line 69
extern gboolean g_key_file_load_from_file(GKeyFile *key_file , gchar *file , GKeyFileFlags flags ,
                                          GError **error ) ;
#line 74
extern gboolean g_key_file_load_from_data(GKeyFile *key_file , gchar *data , gsize length ,
                                          GKeyFileFlags flags , GError **error ) ;
#line 80
extern gboolean g_key_file_load_from_bytes(GKeyFile *key_file , GBytes *bytes , GKeyFileFlags flags ,
                                           GError **error ) ;
#line 85
extern gboolean g_key_file_load_from_dirs(GKeyFile *key_file , gchar *file , gchar **search_dirs ,
                                          gchar **full_path , GKeyFileFlags flags ,
                                          GError **error ) ;
#line 92
extern gboolean g_key_file_load_from_data_dirs(GKeyFile *key_file , gchar *file ,
                                               gchar **full_path , GKeyFileFlags flags ,
                                               GError **error ) ;
#line 98
extern gchar *g_key_file_to_data(GKeyFile *key_file , gsize *length , GError **error ) ;
#line 102
extern gboolean g_key_file_save_to_file(GKeyFile *key_file , gchar *filename , GError **error ) ;
#line 106
extern gchar *g_key_file_get_start_group(GKeyFile *key_file ) ;
#line 108
extern gchar **g_key_file_get_groups(GKeyFile *key_file , gsize *length ) ;
#line 111
extern gchar **g_key_file_get_keys(GKeyFile *key_file , gchar *group_name , gsize *length ,
                                   GError **error ) ;
#line 116
extern gboolean g_key_file_has_group(GKeyFile *key_file , gchar *group_name ) ;
#line 119
extern gboolean g_key_file_has_key(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   GError **error ) ;
#line 124
extern gchar *g_key_file_get_value(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   GError **error ) ;
#line 129
extern void g_key_file_set_value(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                 gchar *value ) ;
#line 134
extern gchar *g_key_file_get_string(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                    GError **error ) ;
#line 139
extern void g_key_file_set_string(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                  gchar *string ) ;
#line 144
extern gchar *g_key_file_get_locale_string(GKeyFile *key_file , gchar *group_name ,
                                           gchar *key , gchar *locale , GError **error ) ;
#line 150
extern gchar *g_key_file_get_locale_for_key(GKeyFile *key_file , gchar *group_name ,
                                            gchar *key , gchar *locale ) ;
#line 155
extern void g_key_file_set_locale_string(GKeyFile *key_file , gchar *group_name ,
                                         gchar *key , gchar *locale , gchar *string ) ;
#line 161
extern gboolean g_key_file_get_boolean(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                       GError **error ) ;
#line 166
extern void g_key_file_set_boolean(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   gboolean value ) ;
#line 171
extern gint g_key_file_get_integer(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   GError **error ) ;
#line 176
extern void g_key_file_set_integer(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   gint value ) ;
#line 181
extern gint64 g_key_file_get_int64(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   GError **error ) ;
#line 186
extern void g_key_file_set_int64(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                 gint64 value ) ;
#line 191
extern guint64 g_key_file_get_uint64(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                     GError **error ) ;
#line 196
extern void g_key_file_set_uint64(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                  guint64 value ) ;
#line 201
extern gdouble g_key_file_get_double(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                     GError **error ) ;
#line 206
extern void g_key_file_set_double(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                  gdouble value ) ;
#line 211
extern gchar **g_key_file_get_string_list(GKeyFile *key_file , gchar *group_name ,
                                          gchar *key , gsize *length , GError **error ) ;
#line 217
extern void g_key_file_set_string_list(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                       gchar * const  list[] , gsize length ) ;
#line 223
extern gchar **g_key_file_get_locale_string_list(GKeyFile *key_file , gchar *group_name ,
                                                 gchar *key , gchar *locale , gsize *length ,
                                                 GError **error ) ;
#line 230
extern void g_key_file_set_locale_string_list(GKeyFile *key_file , gchar *group_name ,
                                              gchar *key , gchar *locale , gchar * const  list[] ,
                                              gsize length ) ;
#line 237
extern gboolean *g_key_file_get_boolean_list(GKeyFile *key_file , gchar *group_name ,
                                             gchar *key , gsize *length , GError **error ) ;
#line 243
extern void g_key_file_set_boolean_list(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                        gboolean list[] , gsize length ) ;
#line 249
extern gint *g_key_file_get_integer_list(GKeyFile *key_file , gchar *group_name ,
                                         gchar *key , gsize *length , GError **error ) ;
#line 255
extern void g_key_file_set_double_list(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                       gdouble list[] , gsize length ) ;
#line 261
extern gdouble *g_key_file_get_double_list(GKeyFile *key_file , gchar *group_name ,
                                           gchar *key , gsize *length , GError **error ) ;
#line 267
extern void g_key_file_set_integer_list(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                        gint list[] , gsize length ) ;
#line 273
extern gboolean g_key_file_set_comment(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                       gchar *comment , GError **error ) ;
#line 279
extern gchar *g_key_file_get_comment(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                     GError **error ) ;
#line 285
extern gboolean g_key_file_remove_comment(GKeyFile *key_file , gchar *group_name ,
                                          gchar *key , GError **error ) ;
#line 290
extern gboolean g_key_file_remove_key(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                      GError **error ) ;
#line 295
extern gboolean g_key_file_remove_group(GKeyFile *key_file , gchar *group_name , GError **error ) ;
#line 35 "/usr/include/glib-2.0/glib/gmappedfile.h"
extern GMappedFile *g_mapped_file_new(gchar *filename , gboolean writable , GError **error ) ;
#line 39
extern GMappedFile *g_mapped_file_new_from_fd(gint fd , gboolean writable , GError **error ) ;
#line 43
extern gsize g_mapped_file_get_length(GMappedFile *file ) ;
#line 45
extern gchar *g_mapped_file_get_contents(GMappedFile *file ) ;
#line 47
extern GBytes *g_mapped_file_get_bytes(GMappedFile *file ) ;
#line 49
extern GMappedFile *g_mapped_file_ref(GMappedFile *file ) ;
#line 51
extern void g_mapped_file_unref(GMappedFile *file ) ;
#line 54
extern void g_mapped_file_free(GMappedFile *file ) ;
#line 73 "/usr/include/glib-2.0/glib/gmarkup.h"
extern GQuark g_markup_error_quark(void) ;
#line 187
extern GMarkupParseContext *g_markup_parse_context_new(GMarkupParser *parser , GMarkupParseFlags flags ,
                                                       gpointer user_data , GDestroyNotify user_data_dnotify ) ;
#line 192
extern GMarkupParseContext *g_markup_parse_context_ref(GMarkupParseContext *context ) ;
#line 194
extern void g_markup_parse_context_unref(GMarkupParseContext *context ) ;
#line 196
extern void g_markup_parse_context_free(GMarkupParseContext *context ) ;
#line 198
extern gboolean g_markup_parse_context_parse(GMarkupParseContext *context , gchar *text ,
                                             gssize text_len , GError **error ) ;
#line 203
extern void g_markup_parse_context_push(GMarkupParseContext *context , GMarkupParser *parser ,
                                        gpointer user_data ) ;
#line 207
extern gpointer g_markup_parse_context_pop(GMarkupParseContext *context ) ;
#line 210
extern gboolean g_markup_parse_context_end_parse(GMarkupParseContext *context , GError **error ) ;
#line 213
extern gchar *g_markup_parse_context_get_element(GMarkupParseContext *context ) ;
#line 215
extern GSList *g_markup_parse_context_get_element_stack(GMarkupParseContext *context ) ;
#line 219
extern void g_markup_parse_context_get_position(GMarkupParseContext *context , gint *line_number ,
                                                gint *char_number ) ;
#line 223
extern gpointer g_markup_parse_context_get_user_data(GMarkupParseContext *context ) ;
#line 227
extern gchar *g_markup_escape_text(gchar *text , gssize length ) ;
#line 231
extern gchar *g_markup_printf_escaped(char const   *format  , ...) ;
#line 234
extern gchar *g_markup_vprintf_escaped(char const   *format , va_list args ) ;
#line 251
extern gboolean g_markup_collect_attributes(gchar *element_name , gchar **attribute_names ,
                                            gchar **attribute_values , GError **error ,
                                            GMarkupCollectType first_type , gchar *first_attr 
                                            , ...) ;
#line 296 "/usr/include/glib-2.0/glib/gvarianttype.h"
extern gboolean g_variant_type_string_is_valid(gchar *type_string ) ;
#line 298
extern gboolean g_variant_type_string_scan(gchar *string , gchar *limit , gchar **endptr ) ;
#line 304
extern void g_variant_type_free(GVariantType *type ) ;
#line 306
extern GVariantType *g_variant_type_copy(GVariantType *type ) ;
#line 308
extern GVariantType *g_variant_type_new(gchar *type_string ) ;
#line 312
extern gsize g_variant_type_get_string_length(GVariantType *type ) ;
#line 314
extern gchar *g_variant_type_peek_string(GVariantType *type ) ;
#line 316
extern gchar *g_variant_type_dup_string(GVariantType *type ) ;
#line 320
extern gboolean g_variant_type_is_definite(GVariantType *type ) ;
#line 322
extern gboolean g_variant_type_is_container(GVariantType *type ) ;
#line 324
extern gboolean g_variant_type_is_basic(GVariantType *type ) ;
#line 326
extern gboolean g_variant_type_is_maybe(GVariantType *type ) ;
#line 328
extern gboolean g_variant_type_is_array(GVariantType *type ) ;
#line 330
extern gboolean g_variant_type_is_tuple(GVariantType *type ) ;
#line 332
extern gboolean g_variant_type_is_dict_entry(GVariantType *type ) ;
#line 334
extern gboolean g_variant_type_is_variant(GVariantType *type ) ;
#line 338
extern guint g_variant_type_hash(gconstpointer type ) ;
#line 340
extern gboolean g_variant_type_equal(gconstpointer type1 , gconstpointer type2 ) ;
#line 345
extern gboolean g_variant_type_is_subtype_of(GVariantType *type , GVariantType *supertype ) ;
#line 350
extern GVariantType *g_variant_type_element(GVariantType *type ) ;
#line 352
extern GVariantType *g_variant_type_first(GVariantType *type ) ;
#line 354
extern GVariantType *g_variant_type_next(GVariantType *type ) ;
#line 356
extern gsize g_variant_type_n_items(GVariantType *type ) ;
#line 358
extern GVariantType *g_variant_type_key(GVariantType *type ) ;
#line 360
extern GVariantType *g_variant_type_value(GVariantType *type ) ;
#line 364
extern GVariantType *g_variant_type_new_array(GVariantType *element ) ;
#line 366
extern GVariantType *g_variant_type_new_maybe(GVariantType *element ) ;
#line 368
extern GVariantType *g_variant_type_new_tuple(GVariantType * const  *items , gint length ) ;
#line 371
extern GVariantType *g_variant_type_new_dict_entry(GVariantType *key , GVariantType *value ) ;
#line 376
extern GVariantType *g_variant_type_checked_(gchar * ) ;
#line 378
extern gsize g_variant_type_string_get_depth_(gchar *type_string ) ;
#line 59 "/usr/include/glib-2.0/glib/gvariant.h"
extern void g_variant_unref(GVariant *value ) ;
#line 61
extern GVariant *g_variant_ref(GVariant *value ) ;
#line 63
extern GVariant *g_variant_ref_sink(GVariant *value ) ;
#line 65
extern gboolean g_variant_is_floating(GVariant *value ) ;
#line 67
extern GVariant *g_variant_take_ref(GVariant *value ) ;
#line 70
extern GVariantType *g_variant_get_type(GVariant *value ) ;
#line 72
extern gchar *g_variant_get_type_string(GVariant *value ) ;
#line 74
extern gboolean g_variant_is_of_type(GVariant *value , GVariantType *type ) ;
#line 77
extern gboolean g_variant_is_container(GVariant *value ) ;
#line 79
extern GVariantClass g_variant_classify(GVariant *value ) ;
#line 81
extern GVariant *g_variant_new_boolean(gboolean value ) ;
#line 83
extern GVariant *g_variant_new_byte(guint8 value ) ;
#line 85
extern GVariant *g_variant_new_int16(gint16 value ) ;
#line 87
extern GVariant *g_variant_new_uint16(guint16 value ) ;
#line 89
extern GVariant *g_variant_new_int32(gint32 value ) ;
#line 91
extern GVariant *g_variant_new_uint32(guint32 value ) ;
#line 93
extern GVariant *g_variant_new_int64(gint64 value ) ;
#line 95
extern GVariant *g_variant_new_uint64(guint64 value ) ;
#line 97
extern GVariant *g_variant_new_handle(gint32 value ) ;
#line 99
extern GVariant *g_variant_new_double(gdouble value ) ;
#line 101
extern GVariant *g_variant_new_string(gchar *string ) ;
#line 103
extern GVariant *g_variant_new_take_string(gchar *string ) ;
#line 105
extern GVariant *g_variant_new_printf(gchar *format_string  , ...) ;
#line 108
extern GVariant *g_variant_new_object_path(gchar *object_path ) ;
#line 110
extern gboolean g_variant_is_object_path(gchar *string ) ;
#line 112
extern GVariant *g_variant_new_signature(gchar *signature ) ;
#line 114
extern gboolean g_variant_is_signature(gchar *string ) ;
#line 116
extern GVariant *g_variant_new_variant(GVariant *value ) ;
#line 118
extern GVariant *g_variant_new_strv(gchar * const  *strv , gssize length ) ;
#line 121
extern GVariant *g_variant_new_objv(gchar * const  *strv , gssize length ) ;
#line 124
extern GVariant *g_variant_new_bytestring(gchar *string ) ;
#line 126
extern GVariant *g_variant_new_bytestring_array(gchar * const  *strv , gssize length ) ;
#line 129
extern GVariant *g_variant_new_fixed_array(GVariantType *element_type , gconstpointer elements ,
                                           gsize n_elements , gsize element_size ) ;
#line 134
extern gboolean g_variant_get_boolean(GVariant *value ) ;
#line 136
extern guint8 g_variant_get_byte(GVariant *value ) ;
#line 138
extern gint16 g_variant_get_int16(GVariant *value ) ;
#line 140
extern guint16 g_variant_get_uint16(GVariant *value ) ;
#line 142
extern gint32 g_variant_get_int32(GVariant *value ) ;
#line 144
extern guint32 g_variant_get_uint32(GVariant *value ) ;
#line 146
extern gint64 g_variant_get_int64(GVariant *value ) ;
#line 148
extern guint64 g_variant_get_uint64(GVariant *value ) ;
#line 150
extern gint32 g_variant_get_handle(GVariant *value ) ;
#line 152
extern gdouble g_variant_get_double(GVariant *value ) ;
#line 154
extern GVariant *g_variant_get_variant(GVariant *value ) ;
#line 156
extern gchar *g_variant_get_string(GVariant *value , gsize *length ) ;
#line 159
extern gchar *g_variant_dup_string(GVariant *value , gsize *length ) ;
#line 162
extern gchar **g_variant_get_strv(GVariant *value , gsize *length ) ;
#line 165
extern gchar **g_variant_dup_strv(GVariant *value , gsize *length ) ;
#line 168
extern gchar **g_variant_get_objv(GVariant *value , gsize *length ) ;
#line 171
extern gchar **g_variant_dup_objv(GVariant *value , gsize *length ) ;
#line 174
extern gchar *g_variant_get_bytestring(GVariant *value ) ;
#line 176
extern gchar *g_variant_dup_bytestring(GVariant *value , gsize *length ) ;
#line 179
extern gchar **g_variant_get_bytestring_array(GVariant *value , gsize *length ) ;
#line 182
extern gchar **g_variant_dup_bytestring_array(GVariant *value , gsize *length ) ;
#line 186
extern GVariant *g_variant_new_maybe(GVariantType *child_type , GVariant *child ) ;
#line 189
extern GVariant *g_variant_new_array(GVariantType *child_type , GVariant * const  *children ,
                                     gsize n_children ) ;
#line 193
extern GVariant *g_variant_new_tuple(GVariant * const  *children , gsize n_children ) ;
#line 196
extern GVariant *g_variant_new_dict_entry(GVariant *key , GVariant *value ) ;
#line 200
extern GVariant *g_variant_get_maybe(GVariant *value ) ;
#line 202
extern gsize g_variant_n_children(GVariant *value ) ;
#line 204
extern void g_variant_get_child(GVariant *value , gsize index_ , gchar *format_string 
                                , ...) ;
#line 209
extern GVariant *g_variant_get_child_value(GVariant *value , gsize index_ ) ;
#line 212
extern gboolean g_variant_lookup(GVariant *dictionary , gchar *key , gchar *format_string 
                                 , ...) ;
#line 217
extern GVariant *g_variant_lookup_value(GVariant *dictionary , gchar *key , GVariantType *expected_type ) ;
#line 221
extern gconstpointer g_variant_get_fixed_array(GVariant *value , gsize *n_elements ,
                                               gsize element_size ) ;
#line 226
extern gsize g_variant_get_size(GVariant *value ) ;
#line 228
extern gconstpointer g_variant_get_data(GVariant *value ) ;
#line 230
extern GBytes *g_variant_get_data_as_bytes(GVariant *value ) ;
#line 232
extern void g_variant_store(GVariant *value , gpointer data ) ;
#line 236
extern gchar *g_variant_print(GVariant *value , gboolean type_annotate ) ;
#line 239
extern GString *g_variant_print_string(GVariant *value , GString *string , gboolean type_annotate ) ;
#line 244
extern guint g_variant_hash(gconstpointer value ) ;
#line 246
extern gboolean g_variant_equal(gconstpointer one , gconstpointer two ) ;
#line 250
extern GVariant *g_variant_get_normal_form(GVariant *value ) ;
#line 252
extern gboolean g_variant_is_normal_form(GVariant *value ) ;
#line 254
extern GVariant *g_variant_byteswap(GVariant *value ) ;
#line 257
extern GVariant *g_variant_new_from_bytes(GVariantType *type , GBytes *bytes , gboolean trusted ) ;
#line 261
extern GVariant *g_variant_new_from_data(GVariantType *type , gconstpointer data ,
                                         gsize size , gboolean trusted , GDestroyNotify notify ,
                                         gpointer user_data ) ;
#line 275
extern GVariantIter *g_variant_iter_new(GVariant *value ) ;
#line 277
extern gsize g_variant_iter_init(GVariantIter *iter , GVariant *value ) ;
#line 280
extern GVariantIter *g_variant_iter_copy(GVariantIter *iter ) ;
#line 282
extern gsize g_variant_iter_n_children(GVariantIter *iter ) ;
#line 284
extern void g_variant_iter_free(GVariantIter *iter ) ;
#line 286
extern GVariant *g_variant_iter_next_value(GVariantIter *iter ) ;
#line 288
extern gboolean g_variant_iter_next(GVariantIter *iter , gchar *format_string  , ...) ;
#line 292
extern gboolean g_variant_iter_loop(GVariantIter *iter , gchar *format_string  , ...) ;
#line 336
extern GQuark g_variant_parser_get_error_quark(void) ;
#line 339
extern GQuark g_variant_parse_error_quark(void) ;
#line 375
extern GVariantBuilder *g_variant_builder_new(GVariantType *type ) ;
#line 377
extern void g_variant_builder_unref(GVariantBuilder *builder ) ;
#line 379
extern GVariantBuilder *g_variant_builder_ref(GVariantBuilder *builder ) ;
#line 381
extern void g_variant_builder_init(GVariantBuilder *builder , GVariantType *type ) ;
#line 384
extern GVariant *g_variant_builder_end(GVariantBuilder *builder ) ;
#line 386
extern void g_variant_builder_clear(GVariantBuilder *builder ) ;
#line 388
extern void g_variant_builder_open(GVariantBuilder *builder , GVariantType *type ) ;
#line 391
extern void g_variant_builder_close(GVariantBuilder *builder ) ;
#line 393
extern void g_variant_builder_add_value(GVariantBuilder *builder , GVariant *value ) ;
#line 396
extern void g_variant_builder_add(GVariantBuilder *builder , gchar *format_string 
                                  , ...) ;
#line 400
extern void g_variant_builder_add_parsed(GVariantBuilder *builder , gchar *format 
                                         , ...) ;
#line 405
extern GVariant *g_variant_new(gchar *format_string  , ...) ;
#line 408
extern void g_variant_get(GVariant *value , gchar *format_string  , ...) ;
#line 412
extern GVariant *g_variant_new_va(gchar *format_string , gchar **endptr , va_list *app ) ;
#line 416
extern void g_variant_get_va(GVariant *value , gchar *format_string , gchar **endptr ,
                             va_list *app ) ;
#line 421
extern gboolean g_variant_check_format_string(GVariant *value , gchar *format_string ,
                                              gboolean copy_only ) ;
#line 426
extern GVariant *g_variant_parse(GVariantType *type , gchar *text , gchar *limit ,
                                 gchar **endptr , GError **error ) ;
#line 432
extern GVariant *g_variant_new_parsed(gchar *format  , ...) ;
#line 435
extern GVariant *g_variant_new_parsed_va(gchar *format , va_list *app ) ;
#line 439
extern gchar *g_variant_parse_error_print_context(GError *error , gchar *source_str ) ;
#line 443
extern gint g_variant_compare(gconstpointer one , gconstpointer two ) ;
#line 498
extern GVariantDict *g_variant_dict_new(GVariant *from_asv ) ;
#line 501
extern void g_variant_dict_init(GVariantDict *dict , GVariant *from_asv ) ;
#line 505
extern gboolean g_variant_dict_lookup(GVariantDict *dict , gchar *key , gchar *format_string 
                                      , ...) ;
#line 510
extern GVariant *g_variant_dict_lookup_value(GVariantDict *dict , gchar *key , GVariantType *expected_type ) ;
#line 514
extern gboolean g_variant_dict_contains(GVariantDict *dict , gchar *key ) ;
#line 517
extern void g_variant_dict_insert(GVariantDict *dict , gchar *key , gchar *format_string 
                                  , ...) ;
#line 522
extern void g_variant_dict_insert_value(GVariantDict *dict , gchar *key , GVariant *value ) ;
#line 526
extern gboolean g_variant_dict_remove(GVariantDict *dict , gchar *key ) ;
#line 529
extern void g_variant_dict_clear(GVariantDict *dict ) ;
#line 531
extern GVariant *g_variant_dict_end(GVariantDict *dict ) ;
#line 533
extern GVariantDict *g_variant_dict_ref(GVariantDict *dict ) ;
#line 535
extern void g_variant_dict_unref(GVariantDict *dict ) ;
#line 43 "/usr/include/glib-2.0/glib/gmessages.h"
extern gsize g_printf_string_upper_bound(gchar *format , va_list args ) ;
#line 81
extern guint g_log_set_handler(gchar *log_domain , GLogLevelFlags log_levels , GLogFunc log_func ,
                               gpointer user_data ) ;
#line 86
extern guint g_log_set_handler_full(gchar *log_domain , GLogLevelFlags log_levels ,
                                    GLogFunc log_func , gpointer user_data , GDestroyNotify destroy ) ;
#line 92
extern void g_log_remove_handler(gchar *log_domain , guint handler_id ) ;
#line 95
extern void g_log_default_handler(gchar *log_domain , GLogLevelFlags log_level , gchar *message ,
                                  gpointer unused_data ) ;
#line 100
extern GLogFunc g_log_set_default_handler(GLogFunc log_func , gpointer user_data ) ;
#line 103
extern void g_log(gchar *log_domain , GLogLevelFlags log_level , gchar *format  , ...) ;
#line 108
extern void g_logv(gchar *log_domain , GLogLevelFlags log_level , gchar *format ,
                   va_list args ) ;
#line 113
extern GLogLevelFlags g_log_set_fatal_mask(gchar *log_domain , GLogLevelFlags fatal_mask ) ;
#line 116
extern GLogLevelFlags g_log_set_always_fatal(GLogLevelFlags fatal_mask ) ;
#line 201
extern void g_log_structured(gchar *log_domain , GLogLevelFlags log_level  , ...) ;
#line 205
extern void g_log_structured_array(GLogLevelFlags log_level , GLogField *fields ,
                                   gsize n_fields ) ;
#line 210
extern void g_log_variant(gchar *log_domain , GLogLevelFlags log_level , GVariant *fields ) ;
#line 215
extern void g_log_set_writer_func(GLogWriterFunc func , gpointer user_data , GDestroyNotify user_data_free ) ;
#line 220
extern gboolean g_log_writer_supports_color(gint output_fd ) ;
#line 222
extern gboolean g_log_writer_is_journald(gint output_fd ) ;
#line 225
extern gchar *g_log_writer_format_fields(GLogLevelFlags log_level , GLogField *fields ,
                                         gsize n_fields , gboolean use_color ) ;
#line 231
extern GLogWriterOutput g_log_writer_journald(GLogLevelFlags log_level , GLogField *fields ,
                                              gsize n_fields , gpointer user_data ) ;
#line 236
extern GLogWriterOutput g_log_writer_standard_streams(GLogLevelFlags log_level , GLogField *fields ,
                                                      gsize n_fields , gpointer user_data ) ;
#line 241
extern GLogWriterOutput g_log_writer_default(GLogLevelFlags log_level , GLogField *fields ,
                                             gsize n_fields , gpointer user_data ) ;
#line 247
extern void g_log_writer_default_set_use_stderr(gboolean use_stderr ) ;
#line 249
extern gboolean g_log_writer_default_would_drop(GLogLevelFlags log_level , char const   *log_domain ) ;
#line 254
extern gboolean g_log_get_debug_enabled(void) ;
#line 256
extern void g_log_set_debug_enabled(gboolean enabled ) ;
#line 276
void _g_log_fallback_handler(gchar *log_domain , GLogLevelFlags log_level , gchar *message ,
                             gpointer unused_data ) ;
#line 283
extern void g_return_if_fail_warning(char const   *log_domain , char const   *pretty_function ,
                                     char const   *expression ) ;
#line 287
extern void g_warn_message(char const   *domain , char const   *file , int line ,
                           char const   *func , char const   *warnexpr ) ;
#line 294
extern void g_assert_warning(char const   *log_domain , char const   *file , int const   line ,
                             char const   *pretty_function , char const   *expression ) ;
#line 301
extern void g_log_structured_standard(gchar *log_domain , GLogLevelFlags log_level ,
                                      gchar *file , gchar *line , gchar *func , gchar *message_format 
                                      , ...) ;
#line 517
extern void g_print(gchar *format  , ...) ;
#line 520
extern GPrintFunc g_set_print_handler(GPrintFunc func ) ;
#line 522
extern void g_printerr(gchar *format  , ...) ;
#line 525
extern GPrintFunc g_set_printerr_handler(GPrintFunc func ) ;
#line 214 "/usr/include/glib-2.0/glib/goption.h"
extern GQuark g_option_error_quark(void) ;
#line 308
extern GOptionContext *g_option_context_new(gchar *parameter_string ) ;
#line 310
extern void g_option_context_set_summary(GOptionContext *context , gchar *summary ) ;
#line 313
extern gchar *g_option_context_get_summary(GOptionContext *context ) ;
#line 315
extern void g_option_context_set_description(GOptionContext *context , gchar *description ) ;
#line 318
extern gchar *g_option_context_get_description(GOptionContext *context ) ;
#line 320
extern void g_option_context_free(GOptionContext *context ) ;
#line 322
extern void g_option_context_set_help_enabled(GOptionContext *context , gboolean help_enabled ) ;
#line 325
extern gboolean g_option_context_get_help_enabled(GOptionContext *context ) ;
#line 327
extern void g_option_context_set_ignore_unknown_options(GOptionContext *context ,
                                                        gboolean ignore_unknown ) ;
#line 330
extern gboolean g_option_context_get_ignore_unknown_options(GOptionContext *context ) ;
#line 333
extern void g_option_context_set_strict_posix(GOptionContext *context , gboolean strict_posix ) ;
#line 336
extern gboolean g_option_context_get_strict_posix(GOptionContext *context ) ;
#line 339
extern void g_option_context_add_main_entries(GOptionContext *context , GOptionEntry *entries ,
                                              gchar *translation_domain ) ;
#line 343
extern gboolean g_option_context_parse(GOptionContext *context , gint *argc , gchar ***argv ,
                                       GError **error ) ;
#line 348
extern gboolean g_option_context_parse_strv(GOptionContext *context , gchar ***arguments ,
                                            GError **error ) ;
#line 352
extern void g_option_context_set_translate_func(GOptionContext *context , GTranslateFunc func ,
                                                gpointer data , GDestroyNotify destroy_notify ) ;
#line 357
extern void g_option_context_set_translation_domain(GOptionContext *context , gchar *domain ) ;
#line 361
extern void g_option_context_add_group(GOptionContext *context , GOptionGroup *group ) ;
#line 364
extern void g_option_context_set_main_group(GOptionContext *context , GOptionGroup *group ) ;
#line 367
extern GOptionGroup *g_option_context_get_main_group(GOptionContext *context ) ;
#line 369
extern gchar *g_option_context_get_help(GOptionContext *context , gboolean main_help ,
                                        GOptionGroup *group ) ;
#line 374
extern GOptionGroup *g_option_group_new(gchar *name , gchar *description , gchar *help_description ,
                                        gpointer user_data , GDestroyNotify destroy ) ;
#line 380
extern void g_option_group_set_parse_hooks(GOptionGroup *group , GOptionParseFunc pre_parse_func ,
                                           GOptionParseFunc post_parse_func ) ;
#line 384
extern void g_option_group_set_error_hook(GOptionGroup *group , GOptionErrorFunc error_func ) ;
#line 387
extern void g_option_group_free(GOptionGroup *group ) ;
#line 389
extern GOptionGroup *g_option_group_ref(GOptionGroup *group ) ;
#line 391
extern void g_option_group_unref(GOptionGroup *group ) ;
#line 393
extern void g_option_group_add_entries(GOptionGroup *group , GOptionEntry *entries ) ;
#line 396
extern void g_option_group_set_translate_func(GOptionGroup *group , GTranslateFunc func ,
                                              gpointer data , GDestroyNotify destroy_notify ) ;
#line 401
extern void g_option_group_set_translation_domain(GOptionGroup *group , gchar *domain ) ;
#line 33 "/usr/include/glib-2.0/glib/gpattern.h"
extern GPatternSpec *g_pattern_spec_new(gchar *pattern ) ;
#line 35
extern void g_pattern_spec_free(GPatternSpec *pspec ) ;
#line 37
extern GPatternSpec *g_pattern_spec_copy(GPatternSpec *pspec ) ;
#line 39
extern gboolean g_pattern_spec_equal(GPatternSpec *pspec1 , GPatternSpec *pspec2 ) ;
#line 42
extern gboolean g_pattern_spec_match(GPatternSpec *pspec , gsize string_length , gchar *string ,
                                     gchar *string_reversed ) ;
#line 47
extern gboolean g_pattern_spec_match_string(GPatternSpec *pspec , gchar *string ) ;
#line 50
extern gboolean g_pattern_match(GPatternSpec *pspec , guint string_length , gchar *string ,
                                gchar *string_reversed ) ;
#line 55
extern gboolean g_pattern_match_string(GPatternSpec *pspec , gchar *string ) ;
#line 58
extern gboolean g_pattern_match_simple(gchar *pattern , gchar *string ) ;
#line 46 "/usr/include/glib-2.0/glib/gprimes.h"
extern guint g_spaced_primes_closest(guint num ) ;
#line 37 "/usr/include/glib-2.0/glib/gqsort.h"
extern void g_qsort_with_data(gconstpointer pbase , gint total_elems , gsize size ,
                              GCompareDataFunc compare_func , gpointer user_data ) ;
#line 73 "/usr/include/glib-2.0/glib/gqueue.h"
extern GQueue *g_queue_new(void) ;
#line 75
extern void g_queue_free(GQueue *queue ) ;
#line 77
extern void g_queue_free_full(GQueue *queue , GDestroyNotify free_func ) ;
#line 80
extern void g_queue_init(GQueue *queue ) ;
#line 82
extern void g_queue_clear(GQueue *queue ) ;
#line 84
extern gboolean g_queue_is_empty(GQueue *queue ) ;
#line 86
extern void g_queue_clear_full(GQueue *queue , GDestroyNotify free_func ) ;
#line 89
extern guint g_queue_get_length(GQueue *queue ) ;
#line 91
extern void g_queue_reverse(GQueue *queue ) ;
#line 93
extern GQueue *g_queue_copy(GQueue *queue ) ;
#line 95
extern void g_queue_foreach(GQueue *queue , GFunc func , gpointer user_data ) ;
#line 99
extern GList *g_queue_find(GQueue *queue , gconstpointer data ) ;
#line 102
extern GList *g_queue_find_custom(GQueue *queue , gconstpointer data , GCompareFunc func ) ;
#line 106
extern void g_queue_sort(GQueue *queue , GCompareDataFunc compare_func , gpointer user_data ) ;
#line 111
extern void g_queue_push_head(GQueue *queue , gpointer data ) ;
#line 114
extern void g_queue_push_tail(GQueue *queue , gpointer data ) ;
#line 117
extern void g_queue_push_nth(GQueue *queue , gpointer data , gint n ) ;
#line 121
extern gpointer g_queue_pop_head(GQueue *queue ) ;
#line 123
extern gpointer g_queue_pop_tail(GQueue *queue ) ;
#line 125
extern gpointer g_queue_pop_nth(GQueue *queue , guint n ) ;
#line 128
extern gpointer g_queue_peek_head(GQueue *queue ) ;
#line 130
extern gpointer g_queue_peek_tail(GQueue *queue ) ;
#line 132
extern gpointer g_queue_peek_nth(GQueue *queue , guint n ) ;
#line 135
extern gint g_queue_index(GQueue *queue , gconstpointer data ) ;
#line 138
extern gboolean g_queue_remove(GQueue *queue , gconstpointer data ) ;
#line 141
extern guint g_queue_remove_all(GQueue *queue , gconstpointer data ) ;
#line 144
extern void g_queue_insert_before(GQueue *queue , GList *sibling , gpointer data ) ;
#line 148
extern void g_queue_insert_before_link(GQueue *queue , GList *sibling , GList *link_ ) ;
#line 153
extern void g_queue_insert_after(GQueue *queue , GList *sibling , gpointer data ) ;
#line 157
extern void g_queue_insert_after_link(GQueue *queue , GList *sibling , GList *link_ ) ;
#line 162
extern void g_queue_insert_sorted(GQueue *queue , gpointer data , GCompareDataFunc func ,
                                  gpointer user_data ) ;
#line 168
extern void g_queue_push_head_link(GQueue *queue , GList *link_ ) ;
#line 171
extern void g_queue_push_tail_link(GQueue *queue , GList *link_ ) ;
#line 174
extern void g_queue_push_nth_link(GQueue *queue , gint n , GList *link_ ) ;
#line 178
extern GList *g_queue_pop_head_link(GQueue *queue ) ;
#line 180
extern GList *g_queue_pop_tail_link(GQueue *queue ) ;
#line 182
extern GList *g_queue_pop_nth_link(GQueue *queue , guint n ) ;
#line 185
extern GList *g_queue_peek_head_link(GQueue *queue ) ;
#line 187
extern GList *g_queue_peek_tail_link(GQueue *queue ) ;
#line 189
extern GList *g_queue_peek_nth_link(GQueue *queue , guint n ) ;
#line 192
extern gint g_queue_link_index(GQueue *queue , GList *link_ ) ;
#line 195
extern void g_queue_unlink(GQueue *queue , GList *link_ ) ;
#line 198
extern void g_queue_delete_link(GQueue *queue , GList *link_ ) ;
#line 48 "/usr/include/glib-2.0/glib/grand.h"
extern GRand *g_rand_new_with_seed(guint32 seed ) ;
#line 50
extern GRand *g_rand_new_with_seed_array(guint32 *seed , guint seed_length ) ;
#line 53
extern GRand *g_rand_new(void) ;
#line 55
extern void g_rand_free(GRand *rand_ ) ;
#line 57
extern GRand *g_rand_copy(GRand *rand_ ) ;
#line 59
extern void g_rand_set_seed(GRand *rand_ , guint32 seed ) ;
#line 62
extern void g_rand_set_seed_array(GRand *rand_ , guint32 *seed , guint seed_length ) ;
#line 69
extern guint32 g_rand_int(GRand *rand_ ) ;
#line 71
extern gint32 g_rand_int_range(GRand *rand_ , gint32 begin , gint32 end ) ;
#line 75
extern gdouble g_rand_double(GRand *rand_ ) ;
#line 77
extern gdouble g_rand_double_range(GRand *rand_ , gdouble begin , gdouble end ) ;
#line 81
extern void g_random_set_seed(guint32 seed ) ;
#line 86
extern guint32 g_random_int(void) ;
#line 88
extern gint32 g_random_int_range(gint32 begin , gint32 end ) ;
#line 91
extern gdouble g_random_double(void) ;
#line 93
extern gdouble g_random_double_range(gdouble begin , gdouble end ) ;
#line 31 "/usr/include/glib-2.0/glib/grcbox.h"
extern gpointer g_rc_box_alloc(gsize block_size ) ;
#line 33
extern gpointer g_rc_box_alloc0(gsize block_size ) ;
#line 35
extern gpointer g_rc_box_dup(gsize block_size , gconstpointer mem_block ) ;
#line 38
extern gpointer g_rc_box_acquire(gpointer mem_block ) ;
#line 40
extern void g_rc_box_release(gpointer mem_block ) ;
#line 42
extern void g_rc_box_release_full(gpointer mem_block , GDestroyNotify clear_func ) ;
#line 46
extern gsize g_rc_box_get_size(gpointer mem_block ) ;
#line 49
extern gpointer g_atomic_rc_box_alloc(gsize block_size ) ;
#line 51
extern gpointer g_atomic_rc_box_alloc0(gsize block_size ) ;
#line 53
extern gpointer g_atomic_rc_box_dup(gsize block_size , gconstpointer mem_block ) ;
#line 56
extern gpointer g_atomic_rc_box_acquire(gpointer mem_block ) ;
#line 58
extern void g_atomic_rc_box_release(gpointer mem_block ) ;
#line 60
extern void g_atomic_rc_box_release_full(gpointer mem_block , GDestroyNotify clear_func ) ;
#line 64
extern gsize g_atomic_rc_box_get_size(gpointer mem_block ) ;
#line 32 "/usr/include/glib-2.0/glib/grefcount.h"
extern void g_ref_count_init(grefcount *rc ) ;
#line 34
extern void g_ref_count_inc(grefcount *rc ) ;
#line 36
extern gboolean g_ref_count_dec(grefcount *rc ) ;
#line 38
extern gboolean g_ref_count_compare(grefcount *rc , gint val ) ;
#line 42
extern void g_atomic_ref_count_init(gatomicrefcount *arc ) ;
#line 44
extern void g_atomic_ref_count_inc(gatomicrefcount *arc ) ;
#line 46
extern gboolean g_atomic_ref_count_dec(gatomicrefcount *arc ) ;
#line 48
extern gboolean g_atomic_ref_count_compare(gatomicrefcount *arc , gint val ) ;
#line 27 "/usr/include/glib-2.0/glib/grefstring.h"
extern char *g_ref_string_new(char const   *str ) ;
#line 29
extern char *g_ref_string_new_len(char const   *str , gssize len ) ;
#line 32
extern char *g_ref_string_new_intern(char const   *str ) ;
#line 35
extern char *g_ref_string_acquire(char *str ) ;
#line 37
extern void g_ref_string_release(char *str ) ;
#line 40
extern gsize g_ref_string_length(char *str ) ;
#line 215 "/usr/include/glib-2.0/glib/gregex.h"
extern GQuark g_regex_error_quark(void) ;
#line 447
extern GRegex *g_regex_new(gchar *pattern , GRegexCompileFlags compile_options , GRegexMatchFlags match_options ,
                           GError **error ) ;
#line 452
extern GRegex *g_regex_ref(GRegex *regex ) ;
#line 454
extern void g_regex_unref(GRegex *regex ) ;
#line 456
extern gchar *g_regex_get_pattern(GRegex *regex ) ;
#line 458
extern gint g_regex_get_max_backref(GRegex *regex ) ;
#line 460
extern gint g_regex_get_capture_count(GRegex *regex ) ;
#line 462
extern gboolean g_regex_get_has_cr_or_lf(GRegex *regex ) ;
#line 464
extern gint g_regex_get_max_lookbehind(GRegex *regex ) ;
#line 466
extern gint g_regex_get_string_number(GRegex *regex , gchar *name ) ;
#line 469
extern gchar *g_regex_escape_string(gchar *string , gint length ) ;
#line 472
extern gchar *g_regex_escape_nul(gchar *string , gint length ) ;
#line 476
extern GRegexCompileFlags g_regex_get_compile_flags(GRegex *regex ) ;
#line 478
extern GRegexMatchFlags g_regex_get_match_flags(GRegex *regex ) ;
#line 482
extern gboolean g_regex_match_simple(gchar *pattern , gchar *string , GRegexCompileFlags compile_options ,
                                     GRegexMatchFlags match_options ) ;
#line 487
extern gboolean g_regex_match(GRegex *regex , gchar *string , GRegexMatchFlags match_options ,
                              GMatchInfo **match_info ) ;
#line 492
extern gboolean g_regex_match_full(GRegex *regex , gchar *string , gssize string_len ,
                                   gint start_position , GRegexMatchFlags match_options ,
                                   GMatchInfo **match_info , GError **error ) ;
#line 500
extern gboolean g_regex_match_all(GRegex *regex , gchar *string , GRegexMatchFlags match_options ,
                                  GMatchInfo **match_info ) ;
#line 505
extern gboolean g_regex_match_all_full(GRegex *regex , gchar *string , gssize string_len ,
                                       gint start_position , GRegexMatchFlags match_options ,
                                       GMatchInfo **match_info , GError **error ) ;
#line 515
extern gchar **g_regex_split_simple(gchar *pattern , gchar *string , GRegexCompileFlags compile_options ,
                                    GRegexMatchFlags match_options ) ;
#line 520
extern gchar **g_regex_split(GRegex *regex , gchar *string , GRegexMatchFlags match_options ) ;
#line 524
extern gchar **g_regex_split_full(GRegex *regex , gchar *string , gssize string_len ,
                                  gint start_position , GRegexMatchFlags match_options ,
                                  gint max_tokens , GError **error ) ;
#line 534
extern gchar *g_regex_replace(GRegex *regex , gchar *string , gssize string_len ,
                              gint start_position , gchar *replacement , GRegexMatchFlags match_options ,
                              GError **error ) ;
#line 542
extern gchar *g_regex_replace_literal(GRegex *regex , gchar *string , gssize string_len ,
                                      gint start_position , gchar *replacement , GRegexMatchFlags match_options ,
                                      GError **error ) ;
#line 550
extern gchar *g_regex_replace_eval(GRegex *regex , gchar *string , gssize string_len ,
                                   gint start_position , GRegexMatchFlags match_options ,
                                   GRegexEvalCallback eval , gpointer user_data ,
                                   GError **error ) ;
#line 559
extern gboolean g_regex_check_replacement(gchar *replacement , gboolean *has_references ,
                                          GError **error ) ;
#line 565
extern GRegex *g_match_info_get_regex(GMatchInfo *match_info ) ;
#line 567
extern gchar *g_match_info_get_string(GMatchInfo *match_info ) ;
#line 570
extern GMatchInfo *g_match_info_ref(GMatchInfo *match_info ) ;
#line 572
extern void g_match_info_unref(GMatchInfo *match_info ) ;
#line 574
extern void g_match_info_free(GMatchInfo *match_info ) ;
#line 576
extern gboolean g_match_info_next(GMatchInfo *match_info , GError **error ) ;
#line 579
extern gboolean g_match_info_matches(GMatchInfo *match_info ) ;
#line 581
extern gint g_match_info_get_match_count(GMatchInfo *match_info ) ;
#line 583
extern gboolean g_match_info_is_partial_match(GMatchInfo *match_info ) ;
#line 585
extern gchar *g_match_info_expand_references(GMatchInfo *match_info , gchar *string_to_expand ,
                                             GError **error ) ;
#line 589
extern gchar *g_match_info_fetch(GMatchInfo *match_info , gint match_num ) ;
#line 592
extern gboolean g_match_info_fetch_pos(GMatchInfo *match_info , gint match_num , gint *start_pos ,
                                       gint *end_pos ) ;
#line 597
extern gchar *g_match_info_fetch_named(GMatchInfo *match_info , gchar *name ) ;
#line 600
extern gboolean g_match_info_fetch_named_pos(GMatchInfo *match_info , gchar *name ,
                                             gint *start_pos , gint *end_pos ) ;
#line 605
extern gchar **g_match_info_fetch_all(GMatchInfo *match_info ) ;
#line 214 "/usr/include/glib-2.0/glib/gscanner.h"
extern GScanner *g_scanner_new(GScannerConfig *config_templ ) ;
#line 216
extern void g_scanner_destroy(GScanner *scanner ) ;
#line 218
extern void g_scanner_input_file(GScanner *scanner , gint input_fd ) ;
#line 221
extern void g_scanner_sync_file_offset(GScanner *scanner ) ;
#line 223
extern void g_scanner_input_text(GScanner *scanner , gchar *text , guint text_len ) ;
#line 227
extern GTokenType g_scanner_get_next_token(GScanner *scanner ) ;
#line 229
extern GTokenType g_scanner_peek_next_token(GScanner *scanner ) ;
#line 231
extern GTokenType g_scanner_cur_token(GScanner *scanner ) ;
#line 233
extern GTokenValue g_scanner_cur_value(GScanner *scanner ) ;
#line 235
extern guint g_scanner_cur_line(GScanner *scanner ) ;
#line 237
extern guint g_scanner_cur_position(GScanner *scanner ) ;
#line 239
extern gboolean g_scanner_eof(GScanner *scanner ) ;
#line 241
extern guint g_scanner_set_scope(GScanner *scanner , guint scope_id ) ;
#line 244
extern void g_scanner_scope_add_symbol(GScanner *scanner , guint scope_id , gchar *symbol ,
                                       gpointer value ) ;
#line 249
extern void g_scanner_scope_remove_symbol(GScanner *scanner , guint scope_id , gchar *symbol ) ;
#line 253
extern gpointer g_scanner_scope_lookup_symbol(GScanner *scanner , guint scope_id ,
                                              gchar *symbol ) ;
#line 257
extern void g_scanner_scope_foreach_symbol(GScanner *scanner , guint scope_id , GHFunc func ,
                                           gpointer user_data ) ;
#line 262
extern gpointer g_scanner_lookup_symbol(GScanner *scanner , gchar *symbol ) ;
#line 265
extern void g_scanner_unexp_token(GScanner *scanner , GTokenType expected_token ,
                                  gchar *identifier_spec , gchar *symbol_spec , gchar *symbol_name ,
                                  gchar *message , gint is_error ) ;
#line 273
extern void g_scanner_error(GScanner *scanner , gchar *format  , ...) ;
#line 277
extern void g_scanner_warn(GScanner *scanner , gchar *format  , ...) ;
#line 40 "/usr/include/glib-2.0/glib/gsequence.h"
extern GSequence *g_sequence_new(GDestroyNotify data_destroy ) ;
#line 42
extern void g_sequence_free(GSequence *seq ) ;
#line 44
extern gint g_sequence_get_length(GSequence *seq ) ;
#line 46
extern void g_sequence_foreach(GSequence *seq , GFunc func , gpointer user_data ) ;
#line 50
extern void g_sequence_foreach_range(GSequenceIter *begin , GSequenceIter *end , GFunc func ,
                                     gpointer user_data ) ;
#line 55
extern void g_sequence_sort(GSequence *seq , GCompareDataFunc cmp_func , gpointer cmp_data ) ;
#line 59
extern void g_sequence_sort_iter(GSequence *seq , GSequenceIterCompareFunc cmp_func ,
                                 gpointer cmp_data ) ;
#line 63
extern gboolean g_sequence_is_empty(GSequence *seq ) ;
#line 68
extern GSequenceIter *g_sequence_get_begin_iter(GSequence *seq ) ;
#line 70
extern GSequenceIter *g_sequence_get_end_iter(GSequence *seq ) ;
#line 72
extern GSequenceIter *g_sequence_get_iter_at_pos(GSequence *seq , gint pos ) ;
#line 75
extern GSequenceIter *g_sequence_append(GSequence *seq , gpointer data ) ;
#line 78
extern GSequenceIter *g_sequence_prepend(GSequence *seq , gpointer data ) ;
#line 81
extern GSequenceIter *g_sequence_insert_before(GSequenceIter *iter , gpointer data ) ;
#line 84
extern void g_sequence_move(GSequenceIter *src , GSequenceIter *dest ) ;
#line 87
extern void g_sequence_swap(GSequenceIter *a , GSequenceIter *b ) ;
#line 90
extern GSequenceIter *g_sequence_insert_sorted(GSequence *seq , gpointer data , GCompareDataFunc cmp_func ,
                                               gpointer cmp_data ) ;
#line 95
extern GSequenceIter *g_sequence_insert_sorted_iter(GSequence *seq , gpointer data ,
                                                    GSequenceIterCompareFunc iter_cmp ,
                                                    gpointer cmp_data ) ;
#line 100
extern void g_sequence_sort_changed(GSequenceIter *iter , GCompareDataFunc cmp_func ,
                                    gpointer cmp_data ) ;
#line 104
extern void g_sequence_sort_changed_iter(GSequenceIter *iter , GSequenceIterCompareFunc iter_cmp ,
                                         gpointer cmp_data ) ;
#line 108
extern void g_sequence_remove(GSequenceIter *iter ) ;
#line 110
extern void g_sequence_remove_range(GSequenceIter *begin , GSequenceIter *end ) ;
#line 113
extern void g_sequence_move_range(GSequenceIter *dest , GSequenceIter *begin , GSequenceIter *end ) ;
#line 117
extern GSequenceIter *g_sequence_search(GSequence *seq , gpointer data , GCompareDataFunc cmp_func ,
                                        gpointer cmp_data ) ;
#line 122
extern GSequenceIter *g_sequence_search_iter(GSequence *seq , gpointer data , GSequenceIterCompareFunc iter_cmp ,
                                             gpointer cmp_data ) ;
#line 127
extern GSequenceIter *g_sequence_lookup(GSequence *seq , gpointer data , GCompareDataFunc cmp_func ,
                                        gpointer cmp_data ) ;
#line 132
extern GSequenceIter *g_sequence_lookup_iter(GSequence *seq , gpointer data , GSequenceIterCompareFunc iter_cmp ,
                                             gpointer cmp_data ) ;
#line 140
extern gpointer g_sequence_get(GSequenceIter *iter ) ;
#line 142
extern void g_sequence_set(GSequenceIter *iter , gpointer data ) ;
#line 147
extern gboolean g_sequence_iter_is_begin(GSequenceIter *iter ) ;
#line 149
extern gboolean g_sequence_iter_is_end(GSequenceIter *iter ) ;
#line 151
extern GSequenceIter *g_sequence_iter_next(GSequenceIter *iter ) ;
#line 153
extern GSequenceIter *g_sequence_iter_prev(GSequenceIter *iter ) ;
#line 155
extern gint g_sequence_iter_get_position(GSequenceIter *iter ) ;
#line 157
extern GSequenceIter *g_sequence_iter_move(GSequenceIter *iter , gint delta ) ;
#line 160
extern GSequence *g_sequence_iter_get_sequence(GSequenceIter *iter ) ;
#line 165
extern gint g_sequence_iter_compare(GSequenceIter *a , GSequenceIter *b ) ;
#line 168
extern GSequenceIter *g_sequence_range_get_midpoint(GSequenceIter *begin , GSequenceIter *end ) ;
#line 42 "/usr/include/glib-2.0/glib/gshell.h"
extern GQuark g_shell_error_quark(void) ;
#line 45
extern gchar *g_shell_quote(gchar *unquoted_string ) ;
#line 47
extern gchar *g_shell_unquote(gchar *quoted_string , GError **error ) ;
#line 50
extern gboolean g_shell_parse_argv(gchar *command_line , gint *argcp , gchar ***argvp ,
                                   GError **error ) ;
#line 33 "/usr/include/glib-2.0/glib/gslice.h"
extern gpointer g_slice_alloc(gsize block_size ) ;
#line 35
extern gpointer g_slice_alloc0(gsize block_size ) ;
#line 37
extern gpointer g_slice_copy(gsize block_size , gconstpointer mem_block ) ;
#line 40
extern void g_slice_free1(gsize block_size , gpointer mem_block ) ;
#line 43
extern void g_slice_free_chain_with_offset(gsize block_size , gpointer mem_chain ,
                                           gsize next_offset ) ;
#line 102
extern void g_slice_set_config(GSliceConfig ckey , gint64 value ) ;
#line 104
extern gint64 g_slice_get_config(GSliceConfig ckey ) ;
#line 106
extern gint64 *g_slice_get_config_state(GSliceConfig ckey , gint64 address , guint *n_values ) ;
#line 185 "/usr/include/glib-2.0/glib/gspawn.h"
extern GQuark g_spawn_error_quark(void) ;
#line 187
extern GQuark g_spawn_exit_error_quark(void) ;
#line 190
extern gboolean g_spawn_async(gchar *working_directory , gchar **argv , gchar **envp ,
                              GSpawnFlags flags , GSpawnChildSetupFunc child_setup ,
                              gpointer user_data , GPid *child_pid , GError **error ) ;
#line 204
extern gboolean g_spawn_async_with_pipes(gchar *working_directory , gchar **argv ,
                                         gchar **envp , GSpawnFlags flags , GSpawnChildSetupFunc child_setup ,
                                         gpointer user_data , GPid *child_pid , gint *standard_input ,
                                         gint *standard_output , gint *standard_error ,
                                         GError **error ) ;
#line 217
extern gboolean g_spawn_async_with_pipes_and_fds(gchar *working_directory , gchar * const  *argv ,
                                                 gchar * const  *envp , GSpawnFlags flags ,
                                                 GSpawnChildSetupFunc child_setup ,
                                                 gpointer user_data , gint stdin_fd ,
                                                 gint stdout_fd , gint stderr_fd ,
                                                 gint *source_fds , gint *target_fds ,
                                                 gsize n_fds , GPid *child_pid_out ,
                                                 gint *stdin_pipe_out , gint *stdout_pipe_out ,
                                                 gint *stderr_pipe_out , GError **error ) ;
#line 237
extern gboolean g_spawn_async_with_fds(gchar *working_directory , gchar **argv , gchar **envp ,
                                       GSpawnFlags flags , GSpawnChildSetupFunc child_setup ,
                                       gpointer user_data , GPid *child_pid , gint stdin_fd ,
                                       gint stdout_fd , gint stderr_fd , GError **error ) ;
#line 254
extern gboolean g_spawn_sync(gchar *working_directory , gchar **argv , gchar **envp ,
                             GSpawnFlags flags , GSpawnChildSetupFunc child_setup ,
                             gpointer user_data , gchar **standard_output , gchar **standard_error ,
                             gint *wait_status , GError **error ) ;
#line 266
extern gboolean g_spawn_command_line_sync(gchar *command_line , gchar **standard_output ,
                                          gchar **standard_error , gint *wait_status ,
                                          GError **error ) ;
#line 272
extern gboolean g_spawn_command_line_async(gchar *command_line , GError **error ) ;
#line 276
extern gboolean g_spawn_check_wait_status(gint wait_status , GError **error ) ;
#line 280
extern gboolean g_spawn_check_exit_status(gint wait_status , GError **error ) ;
#line 284
extern void g_spawn_close_pid(GPid pid ) ;
#line 54 "/usr/include/glib-2.0/glib/gstrfuncs.h"
extern guint16 * const  g_ascii_table ;
#line 90
extern gchar g_ascii_tolower(gchar c ) ;
#line 92
extern gchar g_ascii_toupper(gchar c ) ;
#line 95
extern gint g_ascii_digit_value(gchar c ) ;
#line 97
extern gint g_ascii_xdigit_value(gchar c ) ;
#line 104
extern gchar *g_strdelimit(gchar *string , gchar *delimiters , gchar new_delimiter ) ;
#line 108
extern gchar *g_strcanon(gchar *string , gchar *valid_chars , gchar substitutor ) ;
#line 112
extern gchar *g_strerror(gint errnum ) ;
#line 114
extern gchar *g_strsignal(gint signum ) ;
#line 116
extern gchar *g_strreverse(gchar *string ) ;
#line 118
extern gsize g_strlcpy(gchar *dest , gchar *src , gsize dest_size ) ;
#line 122
extern gsize g_strlcat(gchar *dest , gchar *src , gsize dest_size ) ;
#line 126
extern gchar *g_strstr_len(gchar *haystack , gssize haystack_len , gchar *needle ) ;
#line 130
extern gchar *g_strrstr(gchar *haystack , gchar *needle ) ;
#line 133
extern gchar *g_strrstr_len(gchar *haystack , gssize haystack_len , gchar *needle ) ;
#line 138
extern gboolean g_str_has_suffix(gchar *str , gchar *suffix ) ;
#line 141
extern gboolean g_str_has_prefix(gchar *str , gchar *prefix ) ;
#line 147
extern gdouble g_strtod(gchar *nptr , gchar **endptr ) ;
#line 150
extern gdouble g_ascii_strtod(gchar *nptr , gchar **endptr ) ;
#line 153
extern guint64 g_ascii_strtoull(gchar *nptr , gchar **endptr , guint base ) ;
#line 157
extern gint64 g_ascii_strtoll(gchar *nptr , gchar **endptr , guint base ) ;
#line 165
extern gchar *g_ascii_dtostr(gchar *buffer , gint buf_len , gdouble d ) ;
#line 169
extern gchar *g_ascii_formatd(gchar *buffer , gint buf_len , gchar *format , gdouble d ) ;
#line 176
extern gchar *g_strchug(gchar *string ) ;
#line 179
extern gchar *g_strchomp(gchar *string ) ;
#line 184
extern gint g_ascii_strcasecmp(gchar *s1 , gchar *s2 ) ;
#line 187
extern gint g_ascii_strncasecmp(gchar *s1 , gchar *s2 , gsize n ) ;
#line 191
extern gchar *g_ascii_strdown(gchar *str , gssize len ) ;
#line 194
extern gchar *g_ascii_strup(gchar *str , gssize len ) ;
#line 198
extern gboolean g_str_is_ascii(gchar *str ) ;
#line 201
extern gint g_strcasecmp(gchar *s1 , gchar *s2 ) ;
#line 204
extern gint g_strncasecmp(gchar *s1 , gchar *s2 , guint n ) ;
#line 208
extern gchar *g_strdown(gchar *string ) ;
#line 210
extern gchar *g_strup(gchar *string ) ;
#line 217
extern gchar *g_strdup(gchar *str ) ;
#line 219
extern gchar *g_strdup_printf(gchar *format  , ...) ;
#line 222
extern gchar *g_strdup_vprintf(gchar *format , va_list args ) ;
#line 225
extern gchar *g_strndup(gchar *str , gsize n ) ;
#line 228
extern gchar *g_strnfill(gsize length , gchar fill_char ) ;
#line 231
extern gchar *g_strconcat(gchar *string1  , ...) ;
#line 234
extern gchar *g_strjoin(gchar *separator  , ...) ;
#line 242
extern gchar *g_strcompress(gchar *source ) ;
#line 253
extern gchar *g_strescape(gchar *source , gchar *exceptions ) ;
#line 257
extern gpointer g_memdup(gconstpointer mem , guint byte_size ) ;
#line 261
extern gpointer g_memdup2(gconstpointer mem , gsize byte_size ) ;
#line 275
extern gchar **g_strsplit(gchar *string , gchar *delimiter , gint max_tokens ) ;
#line 279
extern gchar **g_strsplit_set(gchar *string , gchar *delimiters , gint max_tokens ) ;
#line 283
extern gchar *g_strjoinv(gchar *separator , gchar **str_array ) ;
#line 286
extern void g_strfreev(gchar **str_array ) ;
#line 288
extern gchar **g_strdupv(gchar **str_array ) ;
#line 290
extern guint g_strv_length(gchar **str_array ) ;
#line 293
extern gchar *g_stpcpy(gchar *dest , char const   *src ) ;
#line 297
extern gchar *g_str_to_ascii(gchar *str , gchar *from_locale ) ;
#line 301
extern gchar **g_str_tokenize_and_fold(gchar *string , gchar *translit_locale , gchar ***ascii_alternates ) ;
#line 306
extern gboolean g_str_match_string(gchar *search_term , gchar *potential_hit , gboolean accept_alternates ) ;
#line 311
extern gboolean g_strv_contains(gchar * const  *strv , gchar *str ) ;
#line 315
extern gboolean g_strv_equal(gchar * const  *strv1 , gchar * const  *strv2 ) ;
#line 346
extern GQuark g_number_parser_error_quark(void) ;
#line 349
extern gboolean g_ascii_string_to_signed(gchar *str , guint base , gint64 min , gint64 max ,
                                         gint64 *out_num , GError **error ) ;
#line 357
extern gboolean g_ascii_string_to_unsigned(gchar *str , guint base , guint64 min ,
                                           guint64 max , guint64 *out_num , GError **error ) ;
#line 39 "/usr/include/glib-2.0/glib/gstringchunk.h"
extern GStringChunk *g_string_chunk_new(gsize size ) ;
#line 41
extern void g_string_chunk_free(GStringChunk *chunk ) ;
#line 43
extern void g_string_chunk_clear(GStringChunk *chunk ) ;
#line 45
extern gchar *g_string_chunk_insert(GStringChunk *chunk , gchar *string ) ;
#line 48
extern gchar *g_string_chunk_insert_len(GStringChunk *chunk , gchar *string , gssize len ) ;
#line 52
extern gchar *g_string_chunk_insert_const(GStringChunk *chunk , gchar *string ) ;
#line 42 "/usr/include/glib-2.0/glib/gstrvbuilder.h"
extern GStrvBuilder *g_strv_builder_new(void) ;
#line 45
extern void g_strv_builder_unref(GStrvBuilder *builder ) ;
#line 48
extern GStrvBuilder *g_strv_builder_ref(GStrvBuilder *builder ) ;
#line 51
extern void g_strv_builder_add(GStrvBuilder *builder , char const   *value ) ;
#line 55
extern void g_strv_builder_addv(GStrvBuilder *builder , char const   **value ) ;
#line 59
extern void g_strv_builder_add_many(GStrvBuilder *builder  , ...) ;
#line 63
extern GStrv g_strv_builder_end(GStrvBuilder *builder ) ;
#line 239 "/usr/include/glib-2.0/glib/gtestutils.h"
extern int g_strcmp0(char const   *str1 , char const   *str2 ) ;
#line 244
extern void g_test_minimized_result(double minimized_quantity , char const   *format 
                                    , ...) ;
#line 248
extern void g_test_maximized_result(double maximized_quantity , char const   *format 
                                    , ...) ;
#line 254
extern void g_test_init(int *argc , char ***argv  , ...) ;
#line 321
extern gboolean g_test_subprocess(void) ;
#line 325
extern int g_test_run(void) ;
#line 328
extern void g_test_add_func(char const   *testpath , GTestFunc test_func ) ;
#line 332
extern void g_test_add_data_func(char const   *testpath , gconstpointer test_data ,
                                 GTestDataFunc test_func ) ;
#line 337
extern void g_test_add_data_func_full(char const   *testpath , gpointer test_data ,
                                      GTestDataFunc test_func , GDestroyNotify data_free_func ) ;
#line 344
extern char const   *g_test_get_path(void) ;
#line 348
extern void g_test_fail(void) ;
#line 350
extern void g_test_fail_printf(char const   *format  , ...) ;
#line 353
extern void g_test_incomplete(gchar *msg ) ;
#line 355
extern void g_test_incomplete_printf(char const   *format  , ...) ;
#line 358
extern void g_test_skip(gchar *msg ) ;
#line 360
extern void g_test_skip_printf(char const   *format  , ...) ;
#line 363
extern gboolean g_test_failed(void) ;
#line 365
extern void g_test_set_nonfatal_assertions(void) ;
#line 400
extern void g_test_message(char const   *format  , ...) ;
#line 403
extern void g_test_bug_base(char const   *uri_pattern ) ;
#line 405
extern void g_test_bug(char const   *bug_uri_snippet ) ;
#line 407
extern void g_test_summary(char const   *summary ) ;
#line 410
extern void g_test_timer_start(void) ;
#line 412
extern double g_test_timer_elapsed(void) ;
#line 414
extern double g_test_timer_last(void) ;
#line 418
extern void g_test_queue_free(gpointer gfree_pointer ) ;
#line 420
extern void g_test_queue_destroy(GDestroyNotify destroy_func , gpointer destroy_data ) ;
#line 454
extern gboolean g_test_trap_fork(guint64 usec_timeout , GTestTrapFlags test_trap_flags ) ;
#line 466
extern void g_test_trap_subprocess(char const   *test_path , guint64 usec_timeout ,
                                   GTestSubprocessFlags test_flags ) ;
#line 471
extern gboolean g_test_trap_has_passed(void) ;
#line 473
extern gboolean g_test_trap_reached_timeout(void) ;
#line 484
extern gint32 g_test_rand_int(void) ;
#line 486
extern gint32 g_test_rand_int_range(gint32 begin , gint32 end ) ;
#line 489
extern double g_test_rand_double(void) ;
#line 491
extern double g_test_rand_double_range(double range_start , double range_end ) ;
#line 500
extern GTestCase *g_test_create_case(char const   *test_name , gsize data_size , gconstpointer test_data ,
                                     GTestFixtureFunc data_setup , GTestFixtureFunc data_test ,
                                     GTestFixtureFunc data_teardown ) ;
#line 507
extern GTestSuite *g_test_create_suite(char const   *suite_name ) ;
#line 509
extern GTestSuite *g_test_get_root(void) ;
#line 511
extern void g_test_suite_add(GTestSuite *suite , GTestCase *test_case ) ;
#line 514
extern void g_test_suite_add_suite(GTestSuite *suite , GTestSuite *nestedsuite ) ;
#line 517
extern int g_test_run_suite(GTestSuite *suite ) ;
#line 520
extern void g_test_case_free(GTestCase *test_case ) ;
#line 523
extern void g_test_suite_free(GTestSuite *suite ) ;
#line 526
extern void g_test_trap_assertions(char const   *domain , char const   *file , int line ,
                                   char const   *func , guint64 assertion_flags ,
                                   char const   *pattern ) ;
#line 533
extern void g_assertion_message(char const   *domain , char const   *file , int line ,
                                char const   *func , char const   *message ) ;
#line 540
extern void g_assertion_message_expr(char const   *domain , char const   *file , int line ,
                                     char const   *func , char const   *expr ) ;
#line 546
extern void g_assertion_message_cmpstr(char const   *domain , char const   *file ,
                                       int line , char const   *func , char const   *expr ,
                                       char const   *arg1 , char const   *cmp , char const   *arg2 ) ;
#line 556
extern void g_assertion_message_cmpstrv(char const   *domain , char const   *file ,
                                        int line , char const   *func , char const   *expr ,
                                        char const   * const  *arg1 , char const   * const  *arg2 ,
                                        gsize first_wrong_idx ) ;
#line 565
extern void g_assertion_message_cmpnum(char const   *domain , char const   *file ,
                                       int line , char const   *func , char const   *expr ,
                                       long double arg1 , char const   *cmp , long double arg2 ,
                                       char numtype ) ;
#line 575
extern void g_assertion_message_error(char const   *domain , char const   *file ,
                                      int line , char const   *func , char const   *expr ,
                                      GError *error , GQuark error_domain , int error_code ) ;
#line 584
extern void g_test_add_vtable(char const   *testpath , gsize data_size , gconstpointer test_data ,
                              GTestFixtureFunc data_setup , GTestFixtureFunc data_test ,
                              GTestFixtureFunc data_teardown ) ;
#line 598
extern GTestConfig * const  g_test_config_vars ;
#line 637
extern char const   *g_test_log_type_name(GTestLogType log_type ) ;
#line 639
extern GTestLogBuffer *g_test_log_buffer_new(void) ;
#line 641
extern void g_test_log_buffer_free(GTestLogBuffer *tbuffer ) ;
#line 643
extern void g_test_log_buffer_push(GTestLogBuffer *tbuffer , guint n_bytes , guint8 *bytes ) ;
#line 647
extern GTestLogMsg *g_test_log_buffer_pop(GTestLogBuffer *tbuffer ) ;
#line 649
extern void g_test_log_msg_free(GTestLogMsg *tmsg ) ;
#line 670
extern void g_test_log_set_fatal_handler(GTestLogFatalFunc log_func , gpointer user_data ) ;
#line 674
extern void g_test_expect_message(gchar *log_domain , GLogLevelFlags log_level , gchar *pattern ) ;
#line 678
extern void g_test_assert_expected_messages_internal(char const   *domain , char const   *file ,
                                                     int line , char const   *func ) ;
#line 690
extern gchar *g_test_build_filename(GTestFileType file_type , gchar *first_path  , ...) ;
#line 694
extern gchar *g_test_get_dir(GTestFileType file_type ) ;
#line 696
extern gchar *g_test_get_filename(GTestFileType file_type , gchar *first_path  , ...) ;
#line 49 "/usr/include/glib-2.0/glib/gthreadpool.h"
extern GThreadPool *g_thread_pool_new(GFunc func , gpointer user_data , gint max_threads ,
                                      gboolean exclusive , GError **error ) ;
#line 55
extern GThreadPool *g_thread_pool_new_full(GFunc func , gpointer user_data , GDestroyNotify item_free_func ,
                                           gint max_threads , gboolean exclusive ,
                                           GError **error ) ;
#line 62
extern void g_thread_pool_free(GThreadPool *pool , gboolean immediate , gboolean wait_ ) ;
#line 66
extern gboolean g_thread_pool_push(GThreadPool *pool , gpointer data , GError **error ) ;
#line 70
extern guint g_thread_pool_unprocessed(GThreadPool *pool ) ;
#line 72
extern void g_thread_pool_set_sort_function(GThreadPool *pool , GCompareDataFunc func ,
                                            gpointer user_data ) ;
#line 76
extern gboolean g_thread_pool_move_to_front(GThreadPool *pool , gpointer data ) ;
#line 80
extern gboolean g_thread_pool_set_max_threads(GThreadPool *pool , gint max_threads ,
                                              GError **error ) ;
#line 84
extern gint g_thread_pool_get_max_threads(GThreadPool *pool ) ;
#line 86
extern guint g_thread_pool_get_num_threads(GThreadPool *pool ) ;
#line 89
extern void g_thread_pool_set_max_unused_threads(gint max_threads ) ;
#line 91
extern gint g_thread_pool_get_max_unused_threads(void) ;
#line 93
extern guint g_thread_pool_get_num_unused_threads(void) ;
#line 95
extern void g_thread_pool_stop_unused_threads(void) ;
#line 97
extern void g_thread_pool_set_max_idle_time(guint interval ) ;
#line 99
extern guint g_thread_pool_get_max_idle_time(void) ;
#line 45 "/usr/include/glib-2.0/glib/gtimer.h"
extern GTimer *g_timer_new(void) ;
#line 47
extern void g_timer_destroy(GTimer *timer ) ;
#line 49
extern void g_timer_start(GTimer *timer ) ;
#line 51
extern void g_timer_stop(GTimer *timer ) ;
#line 53
extern void g_timer_reset(GTimer *timer ) ;
#line 55
extern void g_timer_continue(GTimer *timer ) ;
#line 57
extern gdouble g_timer_elapsed(GTimer *timer , gulong *microseconds ) ;
#line 60
extern gboolean g_timer_is_active(GTimer *timer ) ;
#line 63
extern void g_usleep(gulong microseconds ) ;
#line 67
extern void g_time_val_add(GTimeVal *time_ , glong microseconds ) ;
#line 70
extern gboolean g_time_val_from_iso8601(gchar *iso_date , GTimeVal *time_ ) ;
#line 73
extern gchar *g_time_val_to_iso8601(GTimeVal *time_ ) ;
#line 45 "/usr/include/glib-2.0/glib/gtrashstack.h"
extern void g_trash_stack_push(GTrashStack **stack_p , gpointer data_p ) ;
#line 48
extern gpointer g_trash_stack_pop(GTrashStack **stack_p ) ;
#line 50
extern gpointer g_trash_stack_peek(GTrashStack **stack_p ) ;
#line 52
extern guint g_trash_stack_height(GTrashStack **stack_p ) ;
#line 72 "/usr/include/glib-2.0/glib/gtree.h"
extern GTree *g_tree_new(GCompareFunc key_compare_func ) ;
#line 74
extern GTree *g_tree_new_with_data(GCompareDataFunc key_compare_func , gpointer key_compare_data ) ;
#line 77
extern GTree *g_tree_new_full(GCompareDataFunc key_compare_func , gpointer key_compare_data ,
                              GDestroyNotify key_destroy_func , GDestroyNotify value_destroy_func ) ;
#line 82
extern GTreeNode *g_tree_node_first(GTree *tree ) ;
#line 84
extern GTreeNode *g_tree_node_last(GTree *tree ) ;
#line 86
extern GTreeNode *g_tree_node_previous(GTreeNode *node ) ;
#line 88
extern GTreeNode *g_tree_node_next(GTreeNode *node ) ;
#line 90
extern GTree *g_tree_ref(GTree *tree ) ;
#line 92
extern void g_tree_unref(GTree *tree ) ;
#line 94
extern void g_tree_destroy(GTree *tree ) ;
#line 96
extern GTreeNode *g_tree_insert_node(GTree *tree , gpointer key , gpointer value ) ;
#line 100
extern void g_tree_insert(GTree *tree , gpointer key , gpointer value ) ;
#line 104
extern GTreeNode *g_tree_replace_node(GTree *tree , gpointer key , gpointer value ) ;
#line 108
extern void g_tree_replace(GTree *tree , gpointer key , gpointer value ) ;
#line 112
extern gboolean g_tree_remove(GTree *tree , gconstpointer key ) ;
#line 116
extern void g_tree_remove_all(GTree *tree ) ;
#line 119
extern gboolean g_tree_steal(GTree *tree , gconstpointer key ) ;
#line 122
extern gpointer g_tree_node_key(GTreeNode *node ) ;
#line 124
extern gpointer g_tree_node_value(GTreeNode *node ) ;
#line 126
extern GTreeNode *g_tree_lookup_node(GTree *tree , gconstpointer key ) ;
#line 129
extern gpointer g_tree_lookup(GTree *tree , gconstpointer key ) ;
#line 132
extern gboolean g_tree_lookup_extended(GTree *tree , gconstpointer lookup_key , gpointer *orig_key ,
                                       gpointer *value ) ;
#line 137
extern void g_tree_foreach(GTree *tree , GTraverseFunc func , gpointer user_data ) ;
#line 141
extern void g_tree_foreach_node(GTree *tree , GTraverseNodeFunc func , gpointer user_data ) ;
#line 146
extern void g_tree_traverse(GTree *tree , GTraverseFunc traverse_func , GTraverseType traverse_type ,
                            gpointer user_data ) ;
#line 152
extern GTreeNode *g_tree_search_node(GTree *tree , GCompareFunc search_func , gconstpointer user_data ) ;
#line 156
extern gpointer g_tree_search(GTree *tree , GCompareFunc search_func , gconstpointer user_data ) ;
#line 160
extern GTreeNode *g_tree_lower_bound(GTree *tree , gconstpointer key ) ;
#line 163
extern GTreeNode *g_tree_upper_bound(GTree *tree , gconstpointer key ) ;
#line 166
extern gint g_tree_height(GTree *tree ) ;
#line 168
extern gint g_tree_nnodes(GTree *tree ) ;
#line 34 "/usr/include/glib-2.0/glib/guri.h"
extern GUri *g_uri_ref(GUri *uri ) ;
#line 36
extern void g_uri_unref(GUri *uri ) ;
#line 94
extern gboolean g_uri_split(gchar *uri_ref , GUriFlags flags , gchar **scheme , gchar **userinfo ,
                            gchar **host , gint *port , gchar **path , gchar **query ,
                            gchar **fragment , GError **error ) ;
#line 105
extern gboolean g_uri_split_with_user(gchar *uri_ref , GUriFlags flags , gchar **scheme ,
                                      gchar **user , gchar **password , gchar **auth_params ,
                                      gchar **host , gint *port , gchar **path , gchar **query ,
                                      gchar **fragment , GError **error ) ;
#line 118
extern gboolean g_uri_split_network(gchar *uri_string , GUriFlags flags , gchar **scheme ,
                                    gchar **host , gint *port , GError **error ) ;
#line 126
extern gboolean g_uri_is_valid(gchar *uri_string , GUriFlags flags , GError **error ) ;
#line 131
extern gchar *g_uri_join(GUriFlags flags , gchar *scheme , gchar *userinfo , gchar *host ,
                         gint port , gchar *path , gchar *query , gchar *fragment ) ;
#line 140
extern gchar *g_uri_join_with_user(GUriFlags flags , gchar *scheme , gchar *user ,
                                   gchar *password , gchar *auth_params , gchar *host ,
                                   gint port , gchar *path , gchar *query , gchar *fragment ) ;
#line 152
extern GUri *g_uri_parse(gchar *uri_string , GUriFlags flags , GError **error ) ;
#line 156
extern GUri *g_uri_parse_relative(GUri *base_uri , gchar *uri_ref , GUriFlags flags ,
                                  GError **error ) ;
#line 162
extern gchar *g_uri_resolve_relative(gchar *base_uri_string , gchar *uri_ref , GUriFlags flags ,
                                     GError **error ) ;
#line 168
extern GUri *g_uri_build(GUriFlags flags , gchar *scheme , gchar *userinfo , gchar *host ,
                         gint port , gchar *path , gchar *query , gchar *fragment ) ;
#line 177
extern GUri *g_uri_build_with_user(GUriFlags flags , gchar *scheme , gchar *user ,
                                   gchar *password , gchar *auth_params , gchar *host ,
                                   gint port , gchar *path , gchar *query , gchar *fragment ) ;
#line 215
extern char *g_uri_to_string(GUri *uri ) ;
#line 217
extern char *g_uri_to_string_partial(GUri *uri , GUriHideFlags flags ) ;
#line 221
extern gchar *g_uri_get_scheme(GUri *uri ) ;
#line 223
extern gchar *g_uri_get_userinfo(GUri *uri ) ;
#line 225
extern gchar *g_uri_get_user(GUri *uri ) ;
#line 227
extern gchar *g_uri_get_password(GUri *uri ) ;
#line 229
extern gchar *g_uri_get_auth_params(GUri *uri ) ;
#line 231
extern gchar *g_uri_get_host(GUri *uri ) ;
#line 233
extern gint g_uri_get_port(GUri *uri ) ;
#line 235
extern gchar *g_uri_get_path(GUri *uri ) ;
#line 237
extern gchar *g_uri_get_query(GUri *uri ) ;
#line 239
extern gchar *g_uri_get_fragment(GUri *uri ) ;
#line 241
extern GUriFlags g_uri_get_flags(GUri *uri ) ;
#line 265
extern GHashTable *g_uri_parse_params(gchar *params , gssize length , gchar *separators ,
                                      GUriParamsFlags flags , GError **error ) ;
#line 283
extern void g_uri_params_iter_init(GUriParamsIter *iter , gchar *params , gssize length ,
                                   gchar *separators , GUriParamsFlags flags ) ;
#line 290
extern gboolean g_uri_params_iter_next(GUriParamsIter *iter , gchar **attribute ,
                                       gchar **value , GError **error ) ;
#line 306
extern GQuark g_uri_error_quark(void) ;
#line 388
extern char *g_uri_unescape_string(char const   *escaped_string , char const   *illegal_characters ) ;
#line 391
extern char *g_uri_unescape_segment(char const   *escaped_string , char const   *escaped_string_end ,
                                    char const   *illegal_characters ) ;
#line 396
extern char *g_uri_parse_scheme(char const   *uri ) ;
#line 398
extern char const   *g_uri_peek_scheme(char const   *uri ) ;
#line 401
extern char *g_uri_escape_string(char const   *unescaped , char const   *reserved_chars_allowed ,
                                 gboolean allow_utf8 ) ;
#line 406
extern GBytes *g_uri_unescape_bytes(char const   *escaped_string , gssize length ,
                                    char const   *illegal_characters , GError **error ) ;
#line 412
extern char *g_uri_escape_bytes(guint8 *unescaped , gsize length , char const   *reserved_chars_allowed ) ;
#line 35 "/usr/include/glib-2.0/glib/guuid.h"
extern gboolean g_uuid_string_is_valid(gchar *str ) ;
#line 38
extern gchar *g_uuid_string_random(void) ;
#line 36 "/usr/include/glib-2.0/glib/gversion.h"
extern guint glib_major_version ;
#line 37
extern guint glib_minor_version ;
#line 38
extern guint glib_micro_version ;
#line 39
extern guint glib_interface_age ;
#line 40
extern guint glib_binary_age ;
#line 43
extern gchar *glib_check_version(guint required_major , guint required_minor , guint required_micro ) ;
#line 43 "/usr/include/glib-2.0/glib/deprecated/gallocator.h"
extern GMemChunk *g_mem_chunk_new(gchar *name , gint atom_size , gsize area_size ,
                                  gint type ) ;
#line 48
extern void g_mem_chunk_destroy(GMemChunk *mem_chunk ) ;
#line 50
extern gpointer g_mem_chunk_alloc(GMemChunk *mem_chunk ) ;
#line 52
extern gpointer g_mem_chunk_alloc0(GMemChunk *mem_chunk ) ;
#line 54
extern void g_mem_chunk_free(GMemChunk *mem_chunk , gpointer mem ) ;
#line 57
extern void g_mem_chunk_clean(GMemChunk *mem_chunk ) ;
#line 59
extern void g_mem_chunk_reset(GMemChunk *mem_chunk ) ;
#line 61
extern void g_mem_chunk_print(GMemChunk *mem_chunk ) ;
#line 63
extern void g_mem_chunk_info(void) ;
#line 65
extern void g_blow_chunks(void) ;
#line 69
extern GAllocator *g_allocator_new(gchar *name , guint n_preallocs ) ;
#line 72
extern void g_allocator_free(GAllocator *allocator ) ;
#line 74
extern void g_list_push_allocator(GAllocator *allocator ) ;
#line 76
extern void g_list_pop_allocator(void) ;
#line 78
extern void g_slist_push_allocator(GAllocator *allocator ) ;
#line 80
extern void g_slist_pop_allocator(void) ;
#line 82
extern void g_node_push_allocator(GAllocator *allocator ) ;
#line 84
extern void g_node_pop_allocator(void) ;
#line 47 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
extern GCache *g_cache_new(GCacheNewFunc value_new_func , GCacheDestroyFunc value_destroy_func ,
                           GCacheDupFunc key_dup_func , GCacheDestroyFunc key_destroy_func ,
                           GHashFunc hash_key_func , GHashFunc hash_value_func , GEqualFunc key_equal_func ) ;
#line 55
extern void g_cache_destroy(GCache *cache ) ;
#line 57
extern gpointer g_cache_insert(GCache *cache , gpointer key ) ;
#line 60
extern void g_cache_remove(GCache *cache , gconstpointer value ) ;
#line 63
extern void g_cache_key_foreach(GCache *cache , GHFunc func , gpointer user_data ) ;
#line 67
extern void g_cache_value_foreach(GCache *cache , GHFunc func , gpointer user_data ) ;
#line 58 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
extern GCompletion *g_completion_new(GCompletionFunc func ) ;
#line 60
extern void g_completion_add_items(GCompletion *cmp , GList *items ) ;
#line 63
extern void g_completion_remove_items(GCompletion *cmp , GList *items ) ;
#line 66
extern void g_completion_clear_items(GCompletion *cmp ) ;
#line 68
extern GList *g_completion_complete(GCompletion *cmp , gchar *prefix , gchar **new_prefix ) ;
#line 72
extern GList *g_completion_complete_utf8(GCompletion *cmp , gchar *prefix , gchar **new_prefix ) ;
#line 76
extern void g_completion_set_compare(GCompletion *cmp , GCompletionStrncmpFunc strncmp_func ) ;
#line 79
extern void g_completion_free(GCompletion *cmp ) ;
#line 68 "/usr/include/glib-2.0/glib/deprecated/grel.h"
extern GRelation *g_relation_new(gint fields ) ;
#line 70
extern void g_relation_destroy(GRelation *relation ) ;
#line 72
extern void g_relation_index(GRelation *relation , gint field , GHashFunc hash_func ,
                             GEqualFunc key_equal_func ) ;
#line 77
extern void g_relation_insert(GRelation *relation  , ...) ;
#line 80
extern gint g_relation_delete(GRelation *relation , gconstpointer key , gint field ) ;
#line 84
extern GTuples *g_relation_select(GRelation *relation , gconstpointer key , gint field ) ;
#line 88
extern gint g_relation_count(GRelation *relation , gconstpointer key , gint field ) ;
#line 92
extern gboolean g_relation_exists(GRelation *relation  , ...) ;
#line 95
extern void g_relation_print(GRelation *relation ) ;
#line 97
extern void g_tuples_destroy(GTuples *tuples ) ;
#line 99
extern gpointer g_tuples_index(GTuples *tuples , gint index_ , gint field ) ;
#line 94 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
extern GThreadFunctions g_thread_functions_for_glib_use ;
#line 95
extern gboolean g_thread_use_default_impl ;
#line 97
extern guint64 (*g_thread_gettime)(void) ;
#line 100
extern GThread *g_thread_create(GThreadFunc func , gpointer data , gboolean joinable ,
                                GError **error ) ;
#line 106
extern GThread *g_thread_create_full(GThreadFunc func , gpointer data , gulong stack_size ,
                                     gboolean joinable , gboolean bound , GThreadPriority priority ,
                                     GError **error ) ;
#line 115
extern void g_thread_set_priority(GThread *thread , GThreadPriority priority ) ;
#line 119
extern void g_thread_foreach(GFunc thread_func , gpointer user_data ) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/sched.h"
extern  __attribute__((__nothrow__)) int clone(int (*__fn)(void * ) , void *__child_stack ,
                                               int __flags , void *__arg  , ...) ;
#line 86
extern  __attribute__((__nothrow__)) int unshare(int __flags ) ;
#line 89
extern  __attribute__((__nothrow__)) int sched_getcpu(void) ;
#line 92
extern  __attribute__((__nothrow__)) int getcpu(unsigned int * , unsigned int * ) ;
#line 95
extern  __attribute__((__nothrow__)) int setns(int __fd , int __nstype ) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
extern  __attribute__((__nothrow__)) int __sched_cpucount(size_t __setsize , cpu_set_t *__setp ) ;
#line 119
extern  __attribute__((__nothrow__)) cpu_set_t *__sched_cpualloc(size_t __count ) ;
#line 120
extern  __attribute__((__nothrow__)) void __sched_cpufree(cpu_set_t *__set ) ;
#line 54 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int sched_setparam(__pid_t __pid , struct sched_param *__param ) ;
#line 58
extern  __attribute__((__nothrow__)) int sched_getparam(__pid_t __pid , struct sched_param *__param ) ;
#line 61
extern  __attribute__((__nothrow__)) int sched_setscheduler(__pid_t __pid , int __policy ,
                                                            struct sched_param *__param ) ;
#line 65
extern  __attribute__((__nothrow__)) int sched_getscheduler(__pid_t __pid ) ;
#line 68
extern  __attribute__((__nothrow__)) int sched_yield(void) ;
#line 71
extern  __attribute__((__nothrow__)) int sched_get_priority_max(int __algorithm ) ;
#line 74
extern  __attribute__((__nothrow__)) int sched_get_priority_min(int __algorithm ) ;
#line 78
extern  __attribute__((__nothrow__)) int sched_rr_get_interval(__pid_t __pid , struct timespec *__t ) ;
#line 130
extern  __attribute__((__nothrow__)) int sched_setaffinity(__pid_t __pid , size_t __cpusetsize ,
                                                           cpu_set_t *__cpuset ) ;
#line 134
extern  __attribute__((__nothrow__)) int sched_getaffinity(__pid_t __pid , size_t __cpusetsize ,
                                                           cpu_set_t *__cpuset ) ;
#line 202 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t *__newthread , pthread_attr_t *__attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void *__arg ) ;
#line 211
extern void pthread_exit(void *__retval ) ;
#line 219
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 224
extern  __attribute__((__nothrow__)) int pthread_tryjoin_np(pthread_t __th , void **__thread_return ) ;
#line 233
extern int pthread_timedjoin_np(pthread_t __th , void **__thread_return , struct timespec *__abstime ) ;
#line 243
extern int pthread_clockjoin_np(pthread_t __th , void **__thread_return , clockid_t __clockid ,
                                struct timespec *__abstime ) ;
#line 269
extern  __attribute__((__nothrow__)) int pthread_detach(pthread_t __th ) ;
#line 273
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void) ;
#line 276
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 )  __attribute__((__gnu_inline__)) ;
#line 285
extern  __attribute__((__nothrow__)) int pthread_attr_init(pthread_attr_t *__attr ) ;
#line 288
extern  __attribute__((__nothrow__)) int pthread_attr_destroy(pthread_attr_t *__attr ) ;
#line 292
extern  __attribute__((__nothrow__)) int pthread_attr_getdetachstate(pthread_attr_t *__attr ,
                                                                     int *__detachstate ) ;
#line 297
extern  __attribute__((__nothrow__)) int pthread_attr_setdetachstate(pthread_attr_t *__attr ,
                                                                     int __detachstate ) ;
#line 303
extern  __attribute__((__nothrow__)) int pthread_attr_getguardsize(pthread_attr_t *__attr ,
                                                                   size_t *__guardsize ) ;
#line 308
extern  __attribute__((__nothrow__)) int pthread_attr_setguardsize(pthread_attr_t *__attr ,
                                                                   size_t __guardsize ) ;
#line 314
extern  __attribute__((__nothrow__)) int pthread_attr_getschedparam(pthread_attr_t *__attr ,
                                                                    struct sched_param *__param ) ;
#line 319
extern  __attribute__((__nothrow__)) int pthread_attr_setschedparam(pthread_attr_t *__attr ,
                                                                    struct sched_param *__param ) ;
#line 324
extern  __attribute__((__nothrow__)) int pthread_attr_getschedpolicy(pthread_attr_t *__attr ,
                                                                     int *__policy ) ;
#line 329
extern  __attribute__((__nothrow__)) int pthread_attr_setschedpolicy(pthread_attr_t *__attr ,
                                                                     int __policy ) ;
#line 333
extern  __attribute__((__nothrow__)) int pthread_attr_getinheritsched(pthread_attr_t *__attr ,
                                                                      int *__inherit ) ;
#line 338
extern  __attribute__((__nothrow__)) int pthread_attr_setinheritsched(pthread_attr_t *__attr ,
                                                                      int __inherit ) ;
#line 344
extern  __attribute__((__nothrow__)) int pthread_attr_getscope(pthread_attr_t *__attr ,
                                                               int *__scope ) ;
#line 349
extern  __attribute__((__nothrow__)) int pthread_attr_setscope(pthread_attr_t *__attr ,
                                                               int __scope ) ;
#line 353
extern  __attribute__((__nothrow__)) int pthread_attr_getstackaddr(pthread_attr_t *__attr ,
                                                                   void **__stackaddr ) ;
#line 361
extern  __attribute__((__nothrow__)) int pthread_attr_setstackaddr(pthread_attr_t *__attr ,
                                                                   void *__stackaddr ) ;
#line 366
extern  __attribute__((__nothrow__)) int pthread_attr_getstacksize(pthread_attr_t *__attr ,
                                                                   size_t *__stacksize ) ;
#line 373
extern  __attribute__((__nothrow__)) int pthread_attr_setstacksize(pthread_attr_t *__attr ,
                                                                   size_t __stacksize ) ;
#line 379
extern  __attribute__((__nothrow__)) int pthread_attr_getstack(pthread_attr_t *__attr ,
                                                               void **__stackaddr ,
                                                               size_t *__stacksize ) ;
#line 387
extern  __attribute__((__nothrow__)) int pthread_attr_setstack(pthread_attr_t *__attr ,
                                                               void *__stackaddr ,
                                                               size_t __stacksize ) ;
#line 394
extern  __attribute__((__nothrow__)) int pthread_attr_setaffinity_np(pthread_attr_t *__attr ,
                                                                     size_t __cpusetsize ,
                                                                     cpu_set_t *__cpuset ) ;
#line 401
extern  __attribute__((__nothrow__)) int pthread_attr_getaffinity_np(pthread_attr_t *__attr ,
                                                                     size_t __cpusetsize ,
                                                                     cpu_set_t *__cpuset ) ;
#line 407
extern  __attribute__((__nothrow__)) int pthread_getattr_default_np(pthread_attr_t *__attr ) ;
#line 411
extern int pthread_attr_setsigmask_np(pthread_attr_t *__attr , __sigset_t *sigmask ) ;
#line 417
extern int pthread_attr_getsigmask_np(pthread_attr_t *__attr , __sigset_t *sigmask ) ;
#line 426
extern  __attribute__((__nothrow__)) int pthread_setattr_default_np(pthread_attr_t *__attr ) ;
#line 432
extern  __attribute__((__nothrow__)) int pthread_getattr_np(pthread_t __th , pthread_attr_t *__attr ) ;
#line 441
extern  __attribute__((__nothrow__)) int pthread_setschedparam(pthread_t __target_thread ,
                                                               int __policy , struct sched_param *__param ) ;
#line 446
extern  __attribute__((__nothrow__)) int pthread_getschedparam(pthread_t __target_thread ,
                                                               int *__policy , struct sched_param *__param ) ;
#line 452
extern  __attribute__((__nothrow__)) int pthread_setschedprio(pthread_t __target_thread ,
                                                              int __prio ) ;
#line 458
extern  __attribute__((__nothrow__)) int pthread_getname_np(pthread_t __target_thread ,
                                                            char *__buf , size_t __buflen ) ;
#line 463
extern  __attribute__((__nothrow__)) int pthread_setname_np(pthread_t __target_thread ,
                                                            char const   *__name ) ;
#line 470
extern  __attribute__((__nothrow__)) int pthread_getconcurrency(void) ;
#line 473
extern  __attribute__((__nothrow__)) int pthread_setconcurrency(int __level ) ;
#line 477
extern  __attribute__((__nothrow__)) int pthread_yield(void) ;
#line 489
extern  __attribute__((__nothrow__)) int pthread_setaffinity_np(pthread_t __th , size_t __cpusetsize ,
                                                                cpu_set_t *__cpuset ) ;
#line 494
extern  __attribute__((__nothrow__)) int pthread_getaffinity_np(pthread_t __th , size_t __cpusetsize ,
                                                                cpu_set_t *__cpuset ) ;
#line 509
extern int pthread_once(pthread_once_t *__once_control , void (*__init_routine)(void) ) ;
#line 521
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
#line 525
extern int pthread_setcanceltype(int __type , int *__oldtype ) ;
#line 528
extern int pthread_cancel(pthread_t __th ) ;
#line 533
extern void pthread_testcancel(void) ;
#line 697
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 709
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 732
extern void __pthread_register_cancel_defer(__pthread_unwind_buf_t *__buf ) ;
#line 745
extern void __pthread_unregister_cancel_restore(__pthread_unwind_buf_t *__buf ) ;
#line 750
extern void __pthread_unwind_next(__pthread_unwind_buf_t *__buf ) ;
#line 766
extern  __attribute__((__nothrow__)) int __sigsetjmp_cancel(struct __cancel_jmp_buf_tag __env[1] ,
                                                            int __savemask ) ;
#line 781
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t *__mutexattr ) ;
#line 786
extern  __attribute__((__nothrow__)) int pthread_mutex_destroy(pthread_mutex_t *__mutex ) ;
#line 790
extern  __attribute__((__nothrow__)) int pthread_mutex_trylock(pthread_mutex_t *__mutex ) ;
#line 794
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex ) ;
#line 800
extern  __attribute__((__nothrow__)) int pthread_mutex_timedlock(pthread_mutex_t *__mutex ,
                                                                 struct timespec *__abstime ) ;
#line 817
extern  __attribute__((__nothrow__)) int pthread_mutex_clocklock(pthread_mutex_t *__mutex ,
                                                                 clockid_t __clockid ,
                                                                 struct timespec *__abstime ) ;
#line 835
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex ) ;
#line 840
extern  __attribute__((__nothrow__)) int pthread_mutex_getprioceiling(pthread_mutex_t *__mutex ,
                                                                      int *__prioceiling ) ;
#line 847
extern  __attribute__((__nothrow__)) int pthread_mutex_setprioceiling(pthread_mutex_t *__mutex ,
                                                                      int __prioceiling ,
                                                                      int *__old_ceiling ) ;
#line 855
extern  __attribute__((__nothrow__)) int pthread_mutex_consistent(pthread_mutex_t *__mutex ) ;
#line 859
extern  __attribute__((__nothrow__)) int pthread_mutex_consistent_np(pthread_mutex_t * ) ;
#line 874
extern  __attribute__((__nothrow__)) int pthread_mutexattr_init(pthread_mutexattr_t *__attr ) ;
#line 878
extern  __attribute__((__nothrow__)) int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr ) ;
#line 882
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getpshared(pthread_mutexattr_t *__attr ,
                                                                      int *__pshared ) ;
#line 888
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr ,
                                                                      int __pshared ) ;
#line 894
extern  __attribute__((__nothrow__)) int pthread_mutexattr_gettype(pthread_mutexattr_t *__attr ,
                                                                   int *__kind ) ;
#line 901
extern  __attribute__((__nothrow__)) int pthread_mutexattr_settype(pthread_mutexattr_t *__attr ,
                                                                   int __kind ) ;
#line 906
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getprotocol(pthread_mutexattr_t *__attr ,
                                                                       int *__protocol ) ;
#line 913
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr ,
                                                                       int __protocol ) ;
#line 918
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getprioceiling(pthread_mutexattr_t *__attr ,
                                                                          int *__prioceiling ) ;
#line 924
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr ,
                                                                          int __prioceiling ) ;
#line 930
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getrobust(pthread_mutexattr_t *__attr ,
                                                                     int *__robustness ) ;
#line 935
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getrobust_np(pthread_mutexattr_t * ,
                                                                        int * ) ;
#line 946
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr ,
                                                                     int __robustness ) ;
#line 951
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setrobust_np(pthread_mutexattr_t * ,
                                                                        int  ) ;
#line 967
extern  __attribute__((__nothrow__)) int pthread_rwlock_init(pthread_rwlock_t *__rwlock ,
                                                             pthread_rwlockattr_t *__attr ) ;
#line 972
extern  __attribute__((__nothrow__)) int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock ) ;
#line 976
extern  __attribute__((__nothrow__)) int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock ) ;
#line 980
extern  __attribute__((__nothrow__)) int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock ) ;
#line 986
extern  __attribute__((__nothrow__)) int pthread_rwlock_timedrdlock(pthread_rwlock_t *__rwlock ,
                                                                    struct timespec *__abstime ) ;
#line 1004
extern  __attribute__((__nothrow__)) int pthread_rwlock_clockrdlock(pthread_rwlock_t *__rwlock ,
                                                                    clockid_t __clockid ,
                                                                    struct timespec *__abstime ) ;
#line 1023
extern  __attribute__((__nothrow__)) int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock ) ;
#line 1027
extern  __attribute__((__nothrow__)) int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock ) ;
#line 1033
extern  __attribute__((__nothrow__)) int pthread_rwlock_timedwrlock(pthread_rwlock_t *__rwlock ,
                                                                    struct timespec *__abstime ) ;
#line 1051
extern  __attribute__((__nothrow__)) int pthread_rwlock_clockwrlock(pthread_rwlock_t *__rwlock ,
                                                                    clockid_t __clockid ,
                                                                    struct timespec *__abstime ) ;
#line 1071
extern  __attribute__((__nothrow__)) int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock ) ;
#line 1078
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_init(pthread_rwlockattr_t *__attr ) ;
#line 1082
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr ) ;
#line 1086
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_getpshared(pthread_rwlockattr_t *__attr ,
                                                                       int *__pshared ) ;
#line 1092
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr ,
                                                                       int __pshared ) ;
#line 1097
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_getkind_np(pthread_rwlockattr_t *__attr ,
                                                                       int *__pref ) ;
#line 1103
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr ,
                                                                       int __pref ) ;
#line 1112
extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t *__cond ,
                                                           pthread_condattr_t *__cond_attr ) ;
#line 1117
extern  __attribute__((__nothrow__)) int pthread_cond_destroy(pthread_cond_t *__cond ) ;
#line 1121
extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t *__cond ) ;
#line 1125
extern  __attribute__((__nothrow__)) int pthread_cond_broadcast(pthread_cond_t *__cond ) ;
#line 1133
extern int pthread_cond_wait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ) ;
#line 1145
extern int pthread_cond_timedwait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ,
                                  struct timespec *__abstime ) ;
#line 1171
extern int pthread_cond_clockwait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ,
                                  __clockid_t __clock_id , struct timespec *__abstime ) ;
#line 1194
extern  __attribute__((__nothrow__)) int pthread_condattr_init(pthread_condattr_t *__attr ) ;
#line 1198
extern  __attribute__((__nothrow__)) int pthread_condattr_destroy(pthread_condattr_t *__attr ) ;
#line 1202
extern  __attribute__((__nothrow__)) int pthread_condattr_getpshared(pthread_condattr_t *__attr ,
                                                                     int *__pshared ) ;
#line 1208
extern  __attribute__((__nothrow__)) int pthread_condattr_setpshared(pthread_condattr_t *__attr ,
                                                                     int __pshared ) ;
#line 1213
extern  __attribute__((__nothrow__)) int pthread_condattr_getclock(pthread_condattr_t *__attr ,
                                                                   __clockid_t *__clock_id ) ;
#line 1219
extern  __attribute__((__nothrow__)) int pthread_condattr_setclock(pthread_condattr_t *__attr ,
                                                                   __clockid_t __clock_id ) ;
#line 1230
extern  __attribute__((__nothrow__)) int pthread_spin_init(pthread_spinlock_t *__lock ,
                                                           int __pshared ) ;
#line 1234
extern  __attribute__((__nothrow__)) int pthread_spin_destroy(pthread_spinlock_t *__lock ) ;
#line 1238
extern  __attribute__((__nothrow__)) int pthread_spin_lock(pthread_spinlock_t *__lock ) ;
#line 1242
extern  __attribute__((__nothrow__)) int pthread_spin_trylock(pthread_spinlock_t *__lock ) ;
#line 1246
extern  __attribute__((__nothrow__)) int pthread_spin_unlock(pthread_spinlock_t *__lock ) ;
#line 1254
extern  __attribute__((__nothrow__)) int pthread_barrier_init(pthread_barrier_t *__barrier ,
                                                              pthread_barrierattr_t *__attr ,
                                                              unsigned int __count ) ;
#line 1260
extern  __attribute__((__nothrow__)) int pthread_barrier_destroy(pthread_barrier_t *__barrier ) ;
#line 1264
extern  __attribute__((__nothrow__)) int pthread_barrier_wait(pthread_barrier_t *__barrier ) ;
#line 1269
extern  __attribute__((__nothrow__)) int pthread_barrierattr_init(pthread_barrierattr_t *__attr ) ;
#line 1273
extern  __attribute__((__nothrow__)) int pthread_barrierattr_destroy(pthread_barrierattr_t *__attr ) ;
#line 1277
extern  __attribute__((__nothrow__)) int pthread_barrierattr_getpshared(pthread_barrierattr_t *__attr ,
                                                                        int *__pshared ) ;
#line 1283
extern  __attribute__((__nothrow__)) int pthread_barrierattr_setpshared(pthread_barrierattr_t *__attr ,
                                                                        int __pshared ) ;
#line 1297
extern  __attribute__((__nothrow__)) int pthread_key_create(pthread_key_t *__key ,
                                                            void (*__destr_function)(void * ) ) ;
#line 1302
extern  __attribute__((__nothrow__)) int pthread_key_delete(pthread_key_t __key ) ;
#line 1305
extern  __attribute__((__nothrow__)) void *pthread_getspecific(pthread_key_t __key ) ;
#line 1308
extern  __attribute__((__nothrow__)) int pthread_setspecific(pthread_key_t __key ,
                                                             void const   *__pointer ) ;
#line 1315
extern  __attribute__((__nothrow__)) int pthread_getcpuclockid(pthread_t __thread_id ,
                                                               __clockid_t *__clock_id ) ;
#line 1332
extern  __attribute__((__nothrow__)) int pthread_atfork(void (*__prepare)(void) ,
                                                        void (*__parent)(void) , void (*__child)(void) ) ;
#line 1340
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 )  __attribute__((__gnu_inline__)) ;
#line 1340 "/usr/include/pthread.h"
__inline extern int pthread_equal(pthread_t __thread1 , pthread_t __thread2 ) 
{ 


  {
#line 1342
  return (__thread1 == __thread2);
}
}
#line 150 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
extern void g_static_mutex_init(GStaticMutex *mutex ) ;
#line 152
extern void g_static_mutex_free(GStaticMutex *mutex ) ;
#line 154
extern GMutex *g_static_mutex_get_mutex_impl(GStaticMutex *mutex ) ;
#line 176
extern void g_static_rec_mutex_init(GStaticRecMutex *mutex ) ;
#line 179
extern void g_static_rec_mutex_lock(GStaticRecMutex *mutex ) ;
#line 182
extern gboolean g_static_rec_mutex_trylock(GStaticRecMutex *mutex ) ;
#line 185
extern void g_static_rec_mutex_unlock(GStaticRecMutex *mutex ) ;
#line 188
extern void g_static_rec_mutex_lock_full(GStaticRecMutex *mutex , guint depth ) ;
#line 192
extern guint g_static_rec_mutex_unlock_full(GStaticRecMutex *mutex ) ;
#line 195
extern void g_static_rec_mutex_free(GStaticRecMutex *mutex ) ;
#line 213
extern void g_static_rw_lock_init(GStaticRWLock *lock ) ;
#line 216
extern void g_static_rw_lock_reader_lock(GStaticRWLock *lock ) ;
#line 219
extern gboolean g_static_rw_lock_reader_trylock(GStaticRWLock *lock ) ;
#line 222
extern void g_static_rw_lock_reader_unlock(GStaticRWLock *lock ) ;
#line 225
extern void g_static_rw_lock_writer_lock(GStaticRWLock *lock ) ;
#line 228
extern gboolean g_static_rw_lock_writer_trylock(GStaticRWLock *lock ) ;
#line 231
extern void g_static_rw_lock_writer_unlock(GStaticRWLock *lock ) ;
#line 234
extern void g_static_rw_lock_free(GStaticRWLock *lock ) ;
#line 237
extern GPrivate *g_private_new(GDestroyNotify notify ) ;
#line 248
extern void g_static_private_init(GStaticPrivate *private_key ) ;
#line 251
extern gpointer g_static_private_get(GStaticPrivate *private_key ) ;
#line 254
extern void g_static_private_set(GStaticPrivate *private_key , gpointer data , GDestroyNotify notify ) ;
#line 259
extern void g_static_private_free(GStaticPrivate *private_key ) ;
#line 262
extern gboolean g_once_init_enter_impl(gsize *location ) ;
#line 265
extern void g_thread_init(gpointer vtable ) ;
#line 267
extern void g_thread_init_with_errorcheck_mutexes(gpointer vtable ) ;
#line 270
extern gboolean g_thread_get_initialized(void) ;
#line 272
extern gboolean g_threads_got_initialized ;
#line 277
extern GMutex *g_mutex_new(void) ;
#line 279
extern void g_mutex_free(GMutex *mutex ) ;
#line 281
extern GCond *g_cond_new(void) ;
#line 283
extern void g_cond_free(GCond *cond ) ;
#line 285
extern gboolean g_cond_timed_wait(GCond *cond , GMutex *mutex , GTimeVal *timeval ) ;
#line 25 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void g_autoptr_cleanup_generic_gfree(void *p ) 
{ 
  void **pp ;

  {
  {
#line 27
  pp = (void **)p;
#line 28
  g_free(*pp);
  }
  return;
}
}
#line 32 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void g_autoptr_cleanup_gstring_free(GString *string ) 
{ 


  {
#line 34
  if (string) {
    {
#line 35
    g_string_free(string, ! 0);
    }
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GAsyncQueue(GAsyncQueue *_ptr ) 
{ 


  {
#line 45
  if (_ptr) {
    {
#line 45
    g_async_queue_unref((GAsyncQueue *)_ptr);
    }
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GAsyncQueue(GAsyncQueue **_ptr ) 
{ 


  {
  {
#line 45
  glib_autoptr_clear_GAsyncQueue(*_ptr);
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GAsyncQueue(GList **_l ) 
{ 


  {
  {
#line 45
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_async_queue_unref)));
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GAsyncQueue(GSList **_l ) 
{ 


  {
  {
#line 45
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_async_queue_unref)));
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GAsyncQueue(GQueue **_q ) 
{ 


  {
#line 45
  if (*_q) {
    {
#line 45
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_async_queue_unref)));
    }
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GBookmarkFile(GBookmarkFile *_ptr ) 
{ 


  {
#line 46
  if (_ptr) {
    {
#line 46
    g_bookmark_file_free((GBookmarkFile *)_ptr);
    }
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GBookmarkFile(GBookmarkFile **_ptr ) 
{ 


  {
  {
#line 46
  glib_autoptr_clear_GBookmarkFile(*_ptr);
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GBookmarkFile(GList **_l ) 
{ 


  {
  {
#line 46
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_bookmark_file_free)));
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GBookmarkFile(GSList **_l ) 
{ 


  {
  {
#line 46
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_bookmark_file_free)));
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GBookmarkFile(GQueue **_q ) 
{ 


  {
#line 46
  if (*_q) {
    {
#line 46
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_bookmark_file_free)));
    }
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GBytes(GBytes *_ptr ) 
{ 


  {
#line 47
  if (_ptr) {
    {
#line 47
    g_bytes_unref((GBytes *)_ptr);
    }
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GBytes(GBytes **_ptr ) 
{ 


  {
  {
#line 47
  glib_autoptr_clear_GBytes(*_ptr);
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GBytes(GList **_l ) 
{ 


  {
  {
#line 47
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_bytes_unref)));
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GBytes(GSList **_l ) 
{ 


  {
  {
#line 47
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_bytes_unref)));
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GBytes(GQueue **_q ) 
{ 


  {
#line 47
  if (*_q) {
    {
#line 47
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_bytes_unref)));
    }
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GChecksum(GChecksum *_ptr ) 
{ 


  {
#line 48
  if (_ptr) {
    {
#line 48
    g_checksum_free((GChecksum *)_ptr);
    }
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GChecksum(GChecksum **_ptr ) 
{ 


  {
  {
#line 48
  glib_autoptr_clear_GChecksum(*_ptr);
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GChecksum(GList **_l ) 
{ 


  {
  {
#line 48
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_checksum_free)));
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GChecksum(GSList **_l ) 
{ 


  {
  {
#line 48
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_checksum_free)));
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GChecksum(GQueue **_q ) 
{ 


  {
#line 48
  if (*_q) {
    {
#line 48
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_checksum_free)));
    }
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GDateTime(GDateTime *_ptr ) 
{ 


  {
#line 49
  if (_ptr) {
    {
#line 49
    g_date_time_unref((GDateTime *)_ptr);
    }
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDateTime(GDateTime **_ptr ) 
{ 


  {
  {
#line 49
  glib_autoptr_clear_GDateTime(*_ptr);
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GDateTime(GList **_l ) 
{ 


  {
  {
#line 49
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_date_time_unref)));
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GDateTime(GSList **_l ) 
{ 


  {
  {
#line 49
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_date_time_unref)));
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GDateTime(GQueue **_q ) 
{ 


  {
#line 49
  if (*_q) {
    {
#line 49
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_date_time_unref)));
    }
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GDate(GDate *_ptr ) 
{ 


  {
#line 50
  if (_ptr) {
    {
#line 50
    g_date_free((GDate *)_ptr);
    }
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDate(GDate **_ptr ) 
{ 


  {
  {
#line 50
  glib_autoptr_clear_GDate(*_ptr);
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GDate(GList **_l ) 
{ 


  {
  {
#line 50
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_date_free)));
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GDate(GSList **_l ) 
{ 


  {
  {
#line 50
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_date_free)));
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GDate(GQueue **_q ) 
{ 


  {
#line 50
  if (*_q) {
    {
#line 50
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_date_free)));
    }
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GDir(GDir *_ptr ) 
{ 


  {
#line 51
  if (_ptr) {
    {
#line 51
    g_dir_close((GDir *)_ptr);
    }
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDir(GDir **_ptr ) 
{ 


  {
  {
#line 51
  glib_autoptr_clear_GDir(*_ptr);
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GDir(GList **_l ) 
{ 


  {
  {
#line 51
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_dir_close)));
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GDir(GSList **_l ) 
{ 


  {
  {
#line 51
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_dir_close)));
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GDir(GQueue **_q ) 
{ 


  {
#line 51
  if (*_q) {
    {
#line 51
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_dir_close)));
    }
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GError(GError *_ptr ) 
{ 


  {
#line 52
  if (_ptr) {
    {
#line 52
    g_error_free((GError *)_ptr);
    }
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GError(GError **_ptr ) 
{ 


  {
  {
#line 52
  glib_autoptr_clear_GError(*_ptr);
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GError(GList **_l ) 
{ 


  {
  {
#line 52
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_error_free)));
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GError(GSList **_l ) 
{ 


  {
  {
#line 52
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_error_free)));
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GError(GQueue **_q ) 
{ 


  {
#line 52
  if (*_q) {
    {
#line 52
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_error_free)));
    }
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GHashTable(GHashTable *_ptr ) 
{ 


  {
#line 53
  if (_ptr) {
    {
#line 53
    g_hash_table_unref((GHashTable *)_ptr);
    }
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GHashTable(GHashTable **_ptr ) 
{ 


  {
  {
#line 53
  glib_autoptr_clear_GHashTable(*_ptr);
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GHashTable(GList **_l ) 
{ 


  {
  {
#line 53
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_hash_table_unref)));
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GHashTable(GSList **_l ) 
{ 


  {
  {
#line 53
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_hash_table_unref)));
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GHashTable(GQueue **_q ) 
{ 


  {
#line 53
  if (*_q) {
    {
#line 53
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_hash_table_unref)));
    }
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GHmac(GHmac *_ptr ) 
{ 


  {
#line 54
  if (_ptr) {
    {
#line 54
    g_hmac_unref((GHmac *)_ptr);
    }
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GHmac(GHmac **_ptr ) 
{ 


  {
  {
#line 54
  glib_autoptr_clear_GHmac(*_ptr);
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GHmac(GList **_l ) 
{ 


  {
  {
#line 54
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_hmac_unref)));
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GHmac(GSList **_l ) 
{ 


  {
  {
#line 54
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_hmac_unref)));
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GHmac(GQueue **_q ) 
{ 


  {
#line 54
  if (*_q) {
    {
#line 54
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_hmac_unref)));
    }
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GIOChannel(GIOChannel *_ptr ) 
{ 


  {
#line 55
  if (_ptr) {
    {
#line 55
    g_io_channel_unref((GIOChannel *)_ptr);
    }
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GIOChannel(GIOChannel **_ptr ) 
{ 


  {
  {
#line 55
  glib_autoptr_clear_GIOChannel(*_ptr);
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GIOChannel(GList **_l ) 
{ 


  {
  {
#line 55
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_io_channel_unref)));
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GIOChannel(GSList **_l ) 
{ 


  {
  {
#line 55
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_io_channel_unref)));
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GIOChannel(GQueue **_q ) 
{ 


  {
#line 55
  if (*_q) {
    {
#line 55
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_io_channel_unref)));
    }
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GKeyFile(GKeyFile *_ptr ) 
{ 


  {
#line 56
  if (_ptr) {
    {
#line 56
    g_key_file_unref((GKeyFile *)_ptr);
    }
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GKeyFile(GKeyFile **_ptr ) 
{ 


  {
  {
#line 56
  glib_autoptr_clear_GKeyFile(*_ptr);
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GKeyFile(GList **_l ) 
{ 


  {
  {
#line 56
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_key_file_unref)));
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GKeyFile(GSList **_l ) 
{ 


  {
  {
#line 56
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_key_file_unref)));
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GKeyFile(GQueue **_q ) 
{ 


  {
#line 56
  if (*_q) {
    {
#line 56
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_key_file_unref)));
    }
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GList(GList *_ptr ) 
{ 


  {
#line 57
  if (_ptr) {
    {
#line 57
    g_list_free((GList *)_ptr);
    }
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GList(GList **_ptr ) 
{ 


  {
  {
#line 57
  glib_autoptr_clear_GList(*_ptr);
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GList(GList **_l ) 
{ 


  {
  {
#line 57
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_list_free)));
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GList(GSList **_l ) 
{ 


  {
  {
#line 57
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_list_free)));
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GList(GQueue **_q ) 
{ 


  {
#line 57
  if (*_q) {
    {
#line 57
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_list_free)));
    }
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GArray(GArray *_ptr ) 
{ 


  {
#line 58
  if (_ptr) {
    {
#line 58
    g_array_unref((GArray *)_ptr);
    }
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GArray(GArray **_ptr ) 
{ 


  {
  {
#line 58
  glib_autoptr_clear_GArray(*_ptr);
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GArray(GList **_l ) 
{ 


  {
  {
#line 58
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_array_unref)));
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GArray(GSList **_l ) 
{ 


  {
  {
#line 58
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_array_unref)));
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GArray(GQueue **_q ) 
{ 


  {
#line 58
  if (*_q) {
    {
#line 58
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_array_unref)));
    }
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GPtrArray(GPtrArray *_ptr ) 
{ 


  {
#line 59
  if (_ptr) {
    {
#line 59
    g_ptr_array_unref((GPtrArray *)_ptr);
    }
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GPtrArray(GPtrArray **_ptr ) 
{ 


  {
  {
#line 59
  glib_autoptr_clear_GPtrArray(*_ptr);
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GPtrArray(GList **_l ) 
{ 


  {
  {
#line 59
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_ptr_array_unref)));
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GPtrArray(GSList **_l ) 
{ 


  {
  {
#line 59
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_ptr_array_unref)));
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GPtrArray(GQueue **_q ) 
{ 


  {
#line 59
  if (*_q) {
    {
#line 59
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_ptr_array_unref)));
    }
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GByteArray(GByteArray *_ptr ) 
{ 


  {
#line 60
  if (_ptr) {
    {
#line 60
    g_byte_array_unref((GByteArray *)_ptr);
    }
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GByteArray(GByteArray **_ptr ) 
{ 


  {
  {
#line 60
  glib_autoptr_clear_GByteArray(*_ptr);
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GByteArray(GList **_l ) 
{ 


  {
  {
#line 60
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_byte_array_unref)));
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GByteArray(GSList **_l ) 
{ 


  {
  {
#line 60
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_byte_array_unref)));
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GByteArray(GQueue **_q ) 
{ 


  {
#line 60
  if (*_q) {
    {
#line 60
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_byte_array_unref)));
    }
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMainContext(GMainContext *_ptr ) 
{ 


  {
#line 61
  if (_ptr) {
    {
#line 61
    g_main_context_unref((GMainContext *)_ptr);
    }
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMainContext(GMainContext **_ptr ) 
{ 


  {
  {
#line 61
  glib_autoptr_clear_GMainContext(*_ptr);
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMainContext(GList **_l ) 
{ 


  {
  {
#line 61
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_context_unref)));
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMainContext(GSList **_l ) 
{ 


  {
  {
#line 61
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_context_unref)));
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMainContext(GQueue **_q ) 
{ 


  {
#line 61
  if (*_q) {
    {
#line 61
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_main_context_unref)));
    }
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMainContextPusher(GMainContextPusher *_ptr ) 
{ 


  {
#line 62
  if (_ptr) {
    {
#line 62
    g_main_context_pusher_free((GMainContextPusher *)_ptr);
    }
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMainContextPusher(GMainContextPusher **_ptr ) 
{ 


  {
  {
#line 62
  glib_autoptr_clear_GMainContextPusher(*_ptr);
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMainContextPusher(GList **_l ) 
{ 


  {
  {
#line 62
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_context_pusher_free)));
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMainContextPusher(GSList **_l ) 
{ 


  {
  {
#line 62
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_context_pusher_free)));
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMainContextPusher(GQueue **_q ) 
{ 


  {
#line 62
  if (*_q) {
    {
#line 62
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_main_context_pusher_free)));
    }
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMainLoop(GMainLoop *_ptr ) 
{ 


  {
#line 63
  if (_ptr) {
    {
#line 63
    g_main_loop_unref((GMainLoop *)_ptr);
    }
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMainLoop(GMainLoop **_ptr ) 
{ 


  {
  {
#line 63
  glib_autoptr_clear_GMainLoop(*_ptr);
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMainLoop(GList **_l ) 
{ 


  {
  {
#line 63
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_loop_unref)));
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMainLoop(GSList **_l ) 
{ 


  {
  {
#line 63
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_loop_unref)));
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMainLoop(GQueue **_q ) 
{ 


  {
#line 63
  if (*_q) {
    {
#line 63
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_main_loop_unref)));
    }
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GSource(GSource *_ptr ) 
{ 


  {
#line 64
  if (_ptr) {
    {
#line 64
    g_source_unref((GSource *)_ptr);
    }
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSource(GSource **_ptr ) 
{ 


  {
  {
#line 64
  glib_autoptr_clear_GSource(*_ptr);
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GSource(GList **_l ) 
{ 


  {
  {
#line 64
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_source_unref)));
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GSource(GSList **_l ) 
{ 


  {
  {
#line 64
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_source_unref)));
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GSource(GQueue **_q ) 
{ 


  {
#line 64
  if (*_q) {
    {
#line 64
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_source_unref)));
    }
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMappedFile(GMappedFile *_ptr ) 
{ 


  {
#line 65
  if (_ptr) {
    {
#line 65
    g_mapped_file_unref((GMappedFile *)_ptr);
    }
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMappedFile(GMappedFile **_ptr ) 
{ 


  {
  {
#line 65
  glib_autoptr_clear_GMappedFile(*_ptr);
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMappedFile(GList **_l ) 
{ 


  {
  {
#line 65
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_mapped_file_unref)));
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMappedFile(GSList **_l ) 
{ 


  {
  {
#line 65
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_mapped_file_unref)));
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMappedFile(GQueue **_q ) 
{ 


  {
#line 65
  if (*_q) {
    {
#line 65
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_mapped_file_unref)));
    }
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMarkupParseContext(GMarkupParseContext *_ptr ) 
{ 


  {
#line 66
  if (_ptr) {
    {
#line 66
    g_markup_parse_context_unref((GMarkupParseContext *)_ptr);
    }
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMarkupParseContext(GMarkupParseContext **_ptr ) 
{ 


  {
  {
#line 66
  glib_autoptr_clear_GMarkupParseContext(*_ptr);
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMarkupParseContext(GList **_l ) 
{ 


  {
  {
#line 66
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_markup_parse_context_unref)));
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMarkupParseContext(GSList **_l ) 
{ 


  {
  {
#line 66
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_markup_parse_context_unref)));
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMarkupParseContext(GQueue **_q ) 
{ 


  {
#line 66
  if (*_q) {
    {
#line 66
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_markup_parse_context_unref)));
    }
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GNode(GNode *_ptr ) 
{ 


  {
#line 67
  if (_ptr) {
    {
#line 67
    g_node_destroy((GNode *)_ptr);
    }
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GNode(GNode **_ptr ) 
{ 


  {
  {
#line 67
  glib_autoptr_clear_GNode(*_ptr);
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GNode(GList **_l ) 
{ 


  {
  {
#line 67
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_node_destroy)));
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GNode(GSList **_l ) 
{ 


  {
  {
#line 67
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_node_destroy)));
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GNode(GQueue **_q ) 
{ 


  {
#line 67
  if (*_q) {
    {
#line 67
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_node_destroy)));
    }
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GOptionContext(GOptionContext *_ptr ) 
{ 


  {
#line 68
  if (_ptr) {
    {
#line 68
    g_option_context_free((GOptionContext *)_ptr);
    }
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GOptionContext(GOptionContext **_ptr ) 
{ 


  {
  {
#line 68
  glib_autoptr_clear_GOptionContext(*_ptr);
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GOptionContext(GList **_l ) 
{ 


  {
  {
#line 68
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_option_context_free)));
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GOptionContext(GSList **_l ) 
{ 


  {
  {
#line 68
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_option_context_free)));
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GOptionContext(GQueue **_q ) 
{ 


  {
#line 68
  if (*_q) {
    {
#line 68
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_option_context_free)));
    }
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GOptionGroup(GOptionGroup *_ptr ) 
{ 


  {
#line 69
  if (_ptr) {
    {
#line 69
    g_option_group_unref((GOptionGroup *)_ptr);
    }
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GOptionGroup(GOptionGroup **_ptr ) 
{ 


  {
  {
#line 69
  glib_autoptr_clear_GOptionGroup(*_ptr);
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GOptionGroup(GList **_l ) 
{ 


  {
  {
#line 69
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_option_group_unref)));
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GOptionGroup(GSList **_l ) 
{ 


  {
  {
#line 69
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_option_group_unref)));
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GOptionGroup(GQueue **_q ) 
{ 


  {
#line 69
  if (*_q) {
    {
#line 69
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_option_group_unref)));
    }
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GPatternSpec(GPatternSpec *_ptr ) 
{ 


  {
#line 70
  if (_ptr) {
    {
#line 70
    g_pattern_spec_free((GPatternSpec *)_ptr);
    }
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GPatternSpec(GPatternSpec **_ptr ) 
{ 


  {
  {
#line 70
  glib_autoptr_clear_GPatternSpec(*_ptr);
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GPatternSpec(GList **_l ) 
{ 


  {
  {
#line 70
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_pattern_spec_free)));
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GPatternSpec(GSList **_l ) 
{ 


  {
  {
#line 70
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_pattern_spec_free)));
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GPatternSpec(GQueue **_q ) 
{ 


  {
#line 70
  if (*_q) {
    {
#line 70
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_pattern_spec_free)));
    }
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GQueue(GQueue *_ptr ) 
{ 


  {
#line 71
  if (_ptr) {
    {
#line 71
    g_queue_free((GQueue *)_ptr);
    }
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GQueue(GQueue **_ptr ) 
{ 


  {
  {
#line 71
  glib_autoptr_clear_GQueue(*_ptr);
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GQueue(GList **_l ) 
{ 


  {
  {
#line 71
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_queue_free)));
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GQueue(GSList **_l ) 
{ 


  {
  {
#line 71
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_queue_free)));
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GQueue(GQueue **_q ) 
{ 


  {
#line 71
  if (*_q) {
    {
#line 71
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_queue_free)));
    }
  }
  return;
}
}
#line 72 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GQueue(GQueue *_ptr ) 
{ 


  {
  {
#line 72
  g_queue_clear(_ptr);
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRand(GRand *_ptr ) 
{ 


  {
#line 73
  if (_ptr) {
    {
#line 73
    g_rand_free((GRand *)_ptr);
    }
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRand(GRand **_ptr ) 
{ 


  {
  {
#line 73
  glib_autoptr_clear_GRand(*_ptr);
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRand(GList **_l ) 
{ 


  {
  {
#line 73
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rand_free)));
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRand(GSList **_l ) 
{ 


  {
  {
#line 73
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rand_free)));
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRand(GQueue **_q ) 
{ 


  {
#line 73
  if (*_q) {
    {
#line 73
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_rand_free)));
    }
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRegex(GRegex *_ptr ) 
{ 


  {
#line 74
  if (_ptr) {
    {
#line 74
    g_regex_unref((GRegex *)_ptr);
    }
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRegex(GRegex **_ptr ) 
{ 


  {
  {
#line 74
  glib_autoptr_clear_GRegex(*_ptr);
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRegex(GList **_l ) 
{ 


  {
  {
#line 74
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_regex_unref)));
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRegex(GSList **_l ) 
{ 


  {
  {
#line 74
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_regex_unref)));
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRegex(GQueue **_q ) 
{ 


  {
#line 74
  if (*_q) {
    {
#line 74
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_regex_unref)));
    }
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMatchInfo(GMatchInfo *_ptr ) 
{ 


  {
#line 75
  if (_ptr) {
    {
#line 75
    g_match_info_unref((GMatchInfo *)_ptr);
    }
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMatchInfo(GMatchInfo **_ptr ) 
{ 


  {
  {
#line 75
  glib_autoptr_clear_GMatchInfo(*_ptr);
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMatchInfo(GList **_l ) 
{ 


  {
  {
#line 75
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_match_info_unref)));
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMatchInfo(GSList **_l ) 
{ 


  {
  {
#line 75
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_match_info_unref)));
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMatchInfo(GQueue **_q ) 
{ 


  {
#line 75
  if (*_q) {
    {
#line 75
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_match_info_unref)));
    }
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GScanner(GScanner *_ptr ) 
{ 


  {
#line 76
  if (_ptr) {
    {
#line 76
    g_scanner_destroy((GScanner *)_ptr);
    }
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GScanner(GScanner **_ptr ) 
{ 


  {
  {
#line 76
  glib_autoptr_clear_GScanner(*_ptr);
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GScanner(GList **_l ) 
{ 


  {
  {
#line 76
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_scanner_destroy)));
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GScanner(GSList **_l ) 
{ 


  {
  {
#line 76
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_scanner_destroy)));
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GScanner(GQueue **_q ) 
{ 


  {
#line 76
  if (*_q) {
    {
#line 76
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_scanner_destroy)));
    }
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GSequence(GSequence *_ptr ) 
{ 


  {
#line 77
  if (_ptr) {
    {
#line 77
    g_sequence_free((GSequence *)_ptr);
    }
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSequence(GSequence **_ptr ) 
{ 


  {
  {
#line 77
  glib_autoptr_clear_GSequence(*_ptr);
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GSequence(GList **_l ) 
{ 


  {
  {
#line 77
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_sequence_free)));
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GSequence(GSList **_l ) 
{ 


  {
  {
#line 77
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_sequence_free)));
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GSequence(GQueue **_q ) 
{ 


  {
#line 77
  if (*_q) {
    {
#line 77
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_sequence_free)));
    }
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GSList(GSList *_ptr ) 
{ 


  {
#line 78
  if (_ptr) {
    {
#line 78
    g_slist_free((GSList *)_ptr);
    }
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSList(GSList **_ptr ) 
{ 


  {
  {
#line 78
  glib_autoptr_clear_GSList(*_ptr);
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GSList(GList **_l ) 
{ 


  {
  {
#line 78
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_slist_free)));
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GSList(GSList **_l ) 
{ 


  {
  {
#line 78
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_slist_free)));
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GSList(GQueue **_q ) 
{ 


  {
#line 78
  if (*_q) {
    {
#line 78
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_slist_free)));
    }
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GString(GString *_ptr ) 
{ 


  {
#line 79
  if (_ptr) {
    {
#line 79
    g_autoptr_cleanup_gstring_free((GString *)_ptr);
    }
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GString(GString **_ptr ) 
{ 


  {
  {
#line 79
  glib_autoptr_clear_GString(*_ptr);
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GString(GList **_l ) 
{ 


  {
  {
#line 79
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_autoptr_cleanup_gstring_free)));
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GString(GSList **_l ) 
{ 


  {
  {
#line 79
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_autoptr_cleanup_gstring_free)));
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GString(GQueue **_q ) 
{ 


  {
#line 79
  if (*_q) {
    {
#line 79
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_autoptr_cleanup_gstring_free)));
    }
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GStringChunk(GStringChunk *_ptr ) 
{ 


  {
#line 80
  if (_ptr) {
    {
#line 80
    g_string_chunk_free((GStringChunk *)_ptr);
    }
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GStringChunk(GStringChunk **_ptr ) 
{ 


  {
  {
#line 80
  glib_autoptr_clear_GStringChunk(*_ptr);
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GStringChunk(GList **_l ) 
{ 


  {
  {
#line 80
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_string_chunk_free)));
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GStringChunk(GSList **_l ) 
{ 


  {
  {
#line 80
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_string_chunk_free)));
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GStringChunk(GQueue **_q ) 
{ 


  {
#line 80
  if (*_q) {
    {
#line 80
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_string_chunk_free)));
    }
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GStrvBuilder(GStrvBuilder *_ptr ) 
{ 


  {
#line 81
  if (_ptr) {
    {
#line 81
    g_strv_builder_unref((GStrvBuilder *)_ptr);
    }
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GStrvBuilder(GStrvBuilder **_ptr ) 
{ 


  {
  {
#line 81
  glib_autoptr_clear_GStrvBuilder(*_ptr);
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GStrvBuilder(GList **_l ) 
{ 


  {
  {
#line 81
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_strv_builder_unref)));
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GStrvBuilder(GSList **_l ) 
{ 


  {
  {
#line 81
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_strv_builder_unref)));
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GStrvBuilder(GQueue **_q ) 
{ 


  {
#line 81
  if (*_q) {
    {
#line 81
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_strv_builder_unref)));
    }
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GThread(GThread *_ptr ) 
{ 


  {
#line 82
  if (_ptr) {
    {
#line 82
    g_thread_unref((GThread *)_ptr);
    }
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GThread(GThread **_ptr ) 
{ 


  {
  {
#line 82
  glib_autoptr_clear_GThread(*_ptr);
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GThread(GList **_l ) 
{ 


  {
  {
#line 82
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_thread_unref)));
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GThread(GSList **_l ) 
{ 


  {
  {
#line 82
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_thread_unref)));
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GThread(GQueue **_q ) 
{ 


  {
#line 82
  if (*_q) {
    {
#line 82
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_thread_unref)));
    }
  }
  return;
}
}
#line 83 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GMutex(GMutex *_ptr ) 
{ 


  {
  {
#line 83
  g_mutex_clear(_ptr);
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMutexLocker(GMutexLocker *_ptr ) 
{ 


  {
#line 84
  if (_ptr) {
    {
#line 84
    g_mutex_locker_free((GMutexLocker *)_ptr);
    }
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMutexLocker(GMutexLocker **_ptr ) 
{ 


  {
  {
#line 84
  glib_autoptr_clear_GMutexLocker(*_ptr);
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMutexLocker(GList **_l ) 
{ 


  {
  {
#line 84
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_mutex_locker_free)));
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMutexLocker(GSList **_l ) 
{ 


  {
  {
#line 84
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_mutex_locker_free)));
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMutexLocker(GQueue **_q ) 
{ 


  {
#line 84
  if (*_q) {
    {
#line 84
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_mutex_locker_free)));
    }
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRecMutexLocker(GRecMutexLocker *_ptr ) 
{ 


  {
#line 85
  if (_ptr) {
    {
#line 85
    g_rec_mutex_locker_free((GRecMutexLocker *)_ptr);
    }
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRecMutexLocker(GRecMutexLocker **_ptr ) 
{ 


  {
  {
#line 85
  glib_autoptr_clear_GRecMutexLocker(*_ptr);
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRecMutexLocker(GList **_l ) 
{ 


  {
  {
#line 85
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rec_mutex_locker_free)));
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRecMutexLocker(GSList **_l ) 
{ 


  {
  {
#line 85
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rec_mutex_locker_free)));
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRecMutexLocker(GQueue **_q ) 
{ 


  {
#line 85
  if (*_q) {
    {
#line 85
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_rec_mutex_locker_free)));
    }
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRWLockWriterLocker(GRWLockWriterLocker *_ptr ) 
{ 


  {
#line 86
  if (_ptr) {
    {
#line 86
    g_rw_lock_writer_locker_free((GRWLockWriterLocker *)_ptr);
    }
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRWLockWriterLocker(GRWLockWriterLocker **_ptr ) 
{ 


  {
  {
#line 86
  glib_autoptr_clear_GRWLockWriterLocker(*_ptr);
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRWLockWriterLocker(GList **_l ) 
{ 


  {
  {
#line 86
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rw_lock_writer_locker_free)));
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRWLockWriterLocker(GSList **_l ) 
{ 


  {
  {
#line 86
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rw_lock_writer_locker_free)));
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRWLockWriterLocker(GQueue **_q ) 
{ 


  {
#line 86
  if (*_q) {
    {
#line 86
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_rw_lock_writer_locker_free)));
    }
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRWLockReaderLocker(GRWLockReaderLocker *_ptr ) 
{ 


  {
#line 87
  if (_ptr) {
    {
#line 87
    g_rw_lock_reader_locker_free((GRWLockReaderLocker *)_ptr);
    }
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRWLockReaderLocker(GRWLockReaderLocker **_ptr ) 
{ 


  {
  {
#line 87
  glib_autoptr_clear_GRWLockReaderLocker(*_ptr);
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRWLockReaderLocker(GList **_l ) 
{ 


  {
  {
#line 87
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rw_lock_reader_locker_free)));
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRWLockReaderLocker(GSList **_l ) 
{ 


  {
  {
#line 87
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rw_lock_reader_locker_free)));
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRWLockReaderLocker(GQueue **_q ) 
{ 


  {
#line 87
  if (*_q) {
    {
#line 87
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_rw_lock_reader_locker_free)));
    }
  }
  return;
}
}
#line 88 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GCond(GCond *_ptr ) 
{ 


  {
  {
#line 88
  g_cond_clear(_ptr);
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GTimer(GTimer *_ptr ) 
{ 


  {
#line 89
  if (_ptr) {
    {
#line 89
    g_timer_destroy((GTimer *)_ptr);
    }
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTimer(GTimer **_ptr ) 
{ 


  {
  {
#line 89
  glib_autoptr_clear_GTimer(*_ptr);
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GTimer(GList **_l ) 
{ 


  {
  {
#line 89
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_timer_destroy)));
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GTimer(GSList **_l ) 
{ 


  {
  {
#line 89
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_timer_destroy)));
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GTimer(GQueue **_q ) 
{ 


  {
#line 89
  if (*_q) {
    {
#line 89
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_timer_destroy)));
    }
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GTimeZone(GTimeZone *_ptr ) 
{ 


  {
#line 90
  if (_ptr) {
    {
#line 90
    g_time_zone_unref((GTimeZone *)_ptr);
    }
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTimeZone(GTimeZone **_ptr ) 
{ 


  {
  {
#line 90
  glib_autoptr_clear_GTimeZone(*_ptr);
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GTimeZone(GList **_l ) 
{ 


  {
  {
#line 90
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_time_zone_unref)));
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GTimeZone(GSList **_l ) 
{ 


  {
  {
#line 90
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_time_zone_unref)));
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GTimeZone(GQueue **_q ) 
{ 


  {
#line 90
  if (*_q) {
    {
#line 90
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_time_zone_unref)));
    }
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GTree(GTree *_ptr ) 
{ 


  {
#line 91
  if (_ptr) {
    {
#line 91
    g_tree_unref((GTree *)_ptr);
    }
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTree(GTree **_ptr ) 
{ 


  {
  {
#line 91
  glib_autoptr_clear_GTree(*_ptr);
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GTree(GList **_l ) 
{ 


  {
  {
#line 91
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_tree_unref)));
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GTree(GSList **_l ) 
{ 


  {
  {
#line 91
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_tree_unref)));
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GTree(GQueue **_q ) 
{ 


  {
#line 91
  if (*_q) {
    {
#line 91
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_tree_unref)));
    }
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GVariant(GVariant *_ptr ) 
{ 


  {
#line 92
  if (_ptr) {
    {
#line 92
    g_variant_unref((GVariant *)_ptr);
    }
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVariant(GVariant **_ptr ) 
{ 


  {
  {
#line 92
  glib_autoptr_clear_GVariant(*_ptr);
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GVariant(GList **_l ) 
{ 


  {
  {
#line 92
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_unref)));
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GVariant(GSList **_l ) 
{ 


  {
  {
#line 92
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_unref)));
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GVariant(GQueue **_q ) 
{ 


  {
#line 92
  if (*_q) {
    {
#line 92
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_variant_unref)));
    }
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GVariantBuilder(GVariantBuilder *_ptr ) 
{ 


  {
#line 93
  if (_ptr) {
    {
#line 93
    g_variant_builder_unref((GVariantBuilder *)_ptr);
    }
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVariantBuilder(GVariantBuilder **_ptr ) 
{ 


  {
  {
#line 93
  glib_autoptr_clear_GVariantBuilder(*_ptr);
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GVariantBuilder(GList **_l ) 
{ 


  {
  {
#line 93
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_builder_unref)));
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GVariantBuilder(GSList **_l ) 
{ 


  {
  {
#line 93
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_builder_unref)));
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GVariantBuilder(GQueue **_q ) 
{ 


  {
#line 93
  if (*_q) {
    {
#line 93
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_variant_builder_unref)));
    }
  }
  return;
}
}
#line 94 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GVariantBuilder(GVariantBuilder *_ptr ) 
{ 


  {
  {
#line 94
  g_variant_builder_clear(_ptr);
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GVariantIter(GVariantIter *_ptr ) 
{ 


  {
#line 95
  if (_ptr) {
    {
#line 95
    g_variant_iter_free((GVariantIter *)_ptr);
    }
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVariantIter(GVariantIter **_ptr ) 
{ 


  {
  {
#line 95
  glib_autoptr_clear_GVariantIter(*_ptr);
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GVariantIter(GList **_l ) 
{ 


  {
  {
#line 95
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_iter_free)));
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GVariantIter(GSList **_l ) 
{ 


  {
  {
#line 95
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_iter_free)));
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GVariantIter(GQueue **_q ) 
{ 


  {
#line 95
  if (*_q) {
    {
#line 95
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_variant_iter_free)));
    }
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GVariantDict(GVariantDict *_ptr ) 
{ 


  {
#line 96
  if (_ptr) {
    {
#line 96
    g_variant_dict_unref((GVariantDict *)_ptr);
    }
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVariantDict(GVariantDict **_ptr ) 
{ 


  {
  {
#line 96
  glib_autoptr_clear_GVariantDict(*_ptr);
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GVariantDict(GList **_l ) 
{ 


  {
  {
#line 96
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_dict_unref)));
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GVariantDict(GSList **_l ) 
{ 


  {
  {
#line 96
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_dict_unref)));
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GVariantDict(GQueue **_q ) 
{ 


  {
#line 96
  if (*_q) {
    {
#line 96
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_variant_dict_unref)));
    }
  }
  return;
}
}
#line 97 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GVariantDict(GVariantDict *_ptr ) 
{ 


  {
  {
#line 97
  g_variant_dict_clear(_ptr);
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GVariantType(GVariantType *_ptr ) 
{ 


  {
#line 98
  if (_ptr) {
    {
#line 98
    g_variant_type_free((GVariantType *)_ptr);
    }
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVariantType(GVariantType **_ptr ) 
{ 


  {
  {
#line 98
  glib_autoptr_clear_GVariantType(*_ptr);
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GVariantType(GList **_l ) 
{ 


  {
  {
#line 98
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_type_free)));
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GVariantType(GSList **_l ) 
{ 


  {
  {
#line 98
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_type_free)));
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GVariantType(GQueue **_q ) 
{ 


  {
#line 98
  if (*_q) {
    {
#line 98
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_variant_type_free)));
    }
  }
  return;
}
}
#line 99 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GStrv(GStrv *_ptr ) 
{ 


  {
#line 99
  if (*_ptr != (void *)0) {
    {
#line 99
    g_strfreev(*_ptr);
    }
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRefString(GRefString *_ptr ) 
{ 


  {
#line 100
  if (_ptr) {
    {
#line 100
    g_ref_string_release((GRefString *)_ptr);
    }
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRefString(GRefString **_ptr ) 
{ 


  {
  {
#line 100
  glib_autoptr_clear_GRefString(*_ptr);
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRefString(GList **_l ) 
{ 


  {
  {
#line 100
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_ref_string_release)));
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRefString(GSList **_l ) 
{ 


  {
  {
#line 100
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_ref_string_release)));
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRefString(GQueue **_q ) 
{ 


  {
#line 100
  if (*_q) {
    {
#line 100
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_ref_string_release)));
    }
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GUri(GUri *_ptr ) 
{ 


  {
#line 101
  if (_ptr) {
    {
#line 101
    g_uri_unref((GUri *)_ptr);
    }
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GUri(GUri **_ptr ) 
{ 


  {
  {
#line 101
  glib_autoptr_clear_GUri(*_ptr);
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GUri(GList **_l ) 
{ 


  {
  {
#line 101
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_uri_unref)));
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GUri(GSList **_l ) 
{ 


  {
  {
#line 101
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_uri_unref)));
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GUri(GQueue **_q ) 
{ 


  {
#line 101
  if (*_q) {
    {
#line 101
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_uri_unref)));
    }
  }
  return;
}
}
#line 710 "/usr/include/glib-2.0/gobject/gtype.h"
extern void g_type_init(void) ;
#line 712
extern void g_type_init_with_debug_flags(GTypeDebugFlags debug_flags ) ;
#line 716
extern gchar *g_type_name(GType type ) ;
#line 718
extern GQuark g_type_qname(GType type ) ;
#line 720
extern GType g_type_from_name(gchar *name ) ;
#line 722
extern GType g_type_parent(GType type ) ;
#line 724
extern guint g_type_depth(GType type ) ;
#line 726
extern GType g_type_next_base(GType leaf_type , GType root_type ) ;
#line 729
extern gboolean g_type_is_a(GType type , GType is_a_type ) ;
#line 732
extern gpointer g_type_class_ref(GType type ) ;
#line 734
extern gpointer g_type_class_peek(GType type ) ;
#line 736
extern gpointer g_type_class_peek_static(GType type ) ;
#line 738
extern void g_type_class_unref(gpointer g_class ) ;
#line 740
extern gpointer g_type_class_peek_parent(gpointer g_class ) ;
#line 742
extern gpointer g_type_interface_peek(gpointer instance_class , GType iface_type ) ;
#line 745
extern gpointer g_type_interface_peek_parent(gpointer g_iface ) ;
#line 748
extern gpointer g_type_default_interface_ref(GType g_type ) ;
#line 750
extern gpointer g_type_default_interface_peek(GType g_type ) ;
#line 752
extern void g_type_default_interface_unref(gpointer g_iface ) ;
#line 756
extern GType *g_type_children(GType type , guint *n_children ) ;
#line 759
extern GType *g_type_interfaces(GType type , guint *n_interfaces ) ;
#line 764
extern void g_type_set_qdata(GType type , GQuark quark , gpointer data ) ;
#line 768
extern gpointer g_type_get_qdata(GType type , GQuark quark ) ;
#line 771
extern void g_type_query(GType type , GTypeQuery *query ) ;
#line 775
extern int g_type_get_instance_count(GType type ) ;
#line 1304
extern GType g_type_register_static(GType parent_type , gchar *type_name , GTypeInfo *info ,
                                    GTypeFlags flags ) ;
#line 1309
extern GType g_type_register_static_simple(GType parent_type , gchar *type_name ,
                                           guint class_size , GClassInitFunc class_init ,
                                           guint instance_size , GInstanceInitFunc instance_init ,
                                           GTypeFlags flags ) ;
#line 1318
extern GType g_type_register_dynamic(GType parent_type , gchar *type_name , GTypePlugin *plugin ,
                                     GTypeFlags flags ) ;
#line 1323
extern GType g_type_register_fundamental(GType type_id , gchar *type_name , GTypeInfo *info ,
                                         GTypeFundamentalInfo *finfo , GTypeFlags flags ) ;
#line 1329
extern void g_type_add_interface_static(GType instance_type , GType interface_type ,
                                        GInterfaceInfo *info ) ;
#line 1333
extern void g_type_add_interface_dynamic(GType instance_type , GType interface_type ,
                                         GTypePlugin *plugin ) ;
#line 1337
extern void g_type_interface_add_prerequisite(GType interface_type , GType prerequisite_type ) ;
#line 1340
extern GType *g_type_interface_prerequisites(GType interface_type , guint *n_prerequisites ) ;
#line 1343
extern GType g_type_interface_instantiatable_prerequisite(GType interface_type ) ;
#line 1346
extern void g_type_class_add_private(gpointer g_class , gsize private_size ) ;
#line 1349
extern gint g_type_add_instance_private(GType class_type , gsize private_size ) ;
#line 1352
extern gpointer g_type_instance_get_private(GTypeInstance *instance , GType private_type ) ;
#line 1355
extern void g_type_class_adjust_private_offset(gpointer g_class , gint *private_size_or_offset ) ;
#line 1359
extern void g_type_add_class_private(GType class_type , gsize private_size ) ;
#line 1362
extern gpointer g_type_class_get_private(GTypeClass *klass , GType private_type ) ;
#line 1365
extern gint g_type_class_get_instance_private_offset(gpointer g_class ) ;
#line 1368
extern void g_type_ensure(GType type ) ;
#line 1370
extern guint g_type_get_type_registration_serial(void) ;
#line 2385
extern GTypePlugin *g_type_get_plugin(GType type ) ;
#line 2387
extern GTypePlugin *g_type_interface_get_plugin(GType instance_type , GType interface_type ) ;
#line 2390
extern GType g_type_fundamental_next(void) ;
#line 2392
extern GType g_type_fundamental(GType type_id ) ;
#line 2394
extern GTypeInstance *g_type_create_instance(GType type ) ;
#line 2396
extern void g_type_free_instance(GTypeInstance *instance ) ;
#line 2399
extern void g_type_add_class_cache_func(gpointer cache_data , GTypeClassCacheFunc cache_func ) ;
#line 2402
extern void g_type_remove_class_cache_func(gpointer cache_data , GTypeClassCacheFunc cache_func ) ;
#line 2405
extern void g_type_class_unref_uncached(gpointer g_class ) ;
#line 2408
extern void g_type_add_interface_check(gpointer check_data , GTypeInterfaceCheckFunc check_func ) ;
#line 2411
extern void g_type_remove_interface_check(gpointer check_data , GTypeInterfaceCheckFunc check_func ) ;
#line 2415
extern GTypeValueTable *g_type_value_table_peek(GType type ) ;
#line 2420
extern gboolean g_type_check_instance(GTypeInstance *instance ) ;
#line 2422
extern GTypeInstance *g_type_check_instance_cast(GTypeInstance *instance , GType iface_type ) ;
#line 2425
extern gboolean g_type_check_instance_is_a(GTypeInstance *instance , GType iface_type ) ;
#line 2428
extern gboolean g_type_check_instance_is_fundamentally_a(GTypeInstance *instance ,
                                                         GType fundamental_type ) ;
#line 2431
extern GTypeClass *g_type_check_class_cast(GTypeClass *g_class , GType is_a_type ) ;
#line 2434
extern gboolean g_type_check_class_is_a(GTypeClass *g_class , GType is_a_type ) ;
#line 2437
extern gboolean g_type_check_is_value_type(GType type ) ;
#line 2439
extern gboolean g_type_check_value(GValue *value ) ;
#line 2441
extern gboolean g_type_check_value_holds(GValue *value , GType type ) ;
#line 2444
extern gboolean g_type_test_flags(GType type , guint flags ) ;
#line 2450
extern gchar *g_type_name_from_instance(GTypeInstance *instance ) ;
#line 2452
extern gchar *g_type_name_from_class(GTypeClass *g_class ) ;
#line 133 "/usr/include/glib-2.0/gobject/gvalue.h"
extern GValue *g_value_init(GValue *value , GType g_type ) ;
#line 136
extern void g_value_copy(GValue *src_value , GValue *dest_value ) ;
#line 139
extern GValue *g_value_reset(GValue *value ) ;
#line 141
extern void g_value_unset(GValue *value ) ;
#line 143
extern void g_value_set_instance(GValue *value , gpointer instance ) ;
#line 146
extern void g_value_init_from_instance(GValue *value , gpointer instance ) ;
#line 152
extern gboolean g_value_fits_pointer(GValue *value ) ;
#line 154
extern gpointer g_value_peek_pointer(GValue *value ) ;
#line 159
extern gboolean g_value_type_compatible(GType src_type , GType dest_type ) ;
#line 162
extern gboolean g_value_type_transformable(GType src_type , GType dest_type ) ;
#line 165
extern gboolean g_value_transform(GValue *src_value , GValue *dest_value ) ;
#line 168
extern void g_value_register_transform_func(GType src_type , GType dest_type , GValueTransform transform_func ) ;
#line 282 "/usr/include/glib-2.0/gobject/gparam.h"
extern GParamSpec *g_param_spec_ref(GParamSpec *pspec ) ;
#line 284
extern void g_param_spec_unref(GParamSpec *pspec ) ;
#line 286
extern void g_param_spec_sink(GParamSpec *pspec ) ;
#line 288
extern GParamSpec *g_param_spec_ref_sink(GParamSpec *pspec ) ;
#line 290
extern gpointer g_param_spec_get_qdata(GParamSpec *pspec , GQuark quark ) ;
#line 293
extern void g_param_spec_set_qdata(GParamSpec *pspec , GQuark quark , gpointer data ) ;
#line 297
extern void g_param_spec_set_qdata_full(GParamSpec *pspec , GQuark quark , gpointer data ,
                                        GDestroyNotify destroy ) ;
#line 302
extern gpointer g_param_spec_steal_qdata(GParamSpec *pspec , GQuark quark ) ;
#line 305
extern GParamSpec *g_param_spec_get_redirect_target(GParamSpec *pspec ) ;
#line 308
extern void g_param_value_set_default(GParamSpec *pspec , GValue *value ) ;
#line 311
extern gboolean g_param_value_defaults(GParamSpec *pspec , GValue *value ) ;
#line 314
extern gboolean g_param_value_validate(GParamSpec *pspec , GValue *value ) ;
#line 317
extern gboolean g_param_value_convert(GParamSpec *pspec , GValue *src_value , GValue *dest_value ,
                                      gboolean strict_validation ) ;
#line 322
extern gint g_param_values_cmp(GParamSpec *pspec , GValue *value1 , GValue *value2 ) ;
#line 326
extern gchar *g_param_spec_get_name(GParamSpec *pspec ) ;
#line 328
extern gchar *g_param_spec_get_nick(GParamSpec *pspec ) ;
#line 330
extern gchar *g_param_spec_get_blurb(GParamSpec *pspec ) ;
#line 332
extern void g_value_set_param(GValue *value , GParamSpec *param ) ;
#line 335
extern GParamSpec *g_value_get_param(GValue *value ) ;
#line 337
extern GParamSpec *g_value_dup_param(GValue *value ) ;
#line 341
extern void g_value_take_param(GValue *value , GParamSpec *param ) ;
#line 344
extern void g_value_set_param_take_ownership(GValue *value , GParamSpec *param ) ;
#line 347
extern GValue *g_param_spec_get_default_value(GParamSpec *pspec ) ;
#line 350
extern GQuark g_param_spec_get_name_quark(GParamSpec *pspec ) ;
#line 398
extern GType g_param_type_register_static(gchar *name , GParamSpecTypeInfo *pspec_info ) ;
#line 402
extern gboolean g_param_spec_is_valid_name(gchar *name ) ;
#line 405
GType _g_param_type_register_static_constant(gchar *name , GParamSpecTypeInfo *pspec_info ,
                                             GType opt_type ) ;
#line 412
extern gpointer g_param_spec_internal(GType param_type , gchar *name , gchar *nick ,
                                      gchar *blurb , GParamFlags flags ) ;
#line 418
extern GParamSpecPool *g_param_spec_pool_new(gboolean type_prefixing ) ;
#line 420
extern void g_param_spec_pool_insert(GParamSpecPool *pool , GParamSpec *pspec , GType owner_type ) ;
#line 424
extern void g_param_spec_pool_remove(GParamSpecPool *pool , GParamSpec *pspec ) ;
#line 427
extern GParamSpec *g_param_spec_pool_lookup(GParamSpecPool *pool , gchar *param_name ,
                                            GType owner_type , gboolean walk_ancestors ) ;
#line 432
extern GList *g_param_spec_pool_list_owned(GParamSpecPool *pool , GType owner_type ) ;
#line 435
extern GParamSpec **g_param_spec_pool_list(GParamSpecPool *pool , GType owner_type ,
                                           guint *n_pspecs_p ) ;
#line 229 "/usr/include/glib-2.0/gobject/gclosure.h"
extern GClosure *g_cclosure_new(GCallback callback_func , gpointer user_data , GClosureNotify destroy_data ) ;
#line 233
extern GClosure *g_cclosure_new_swap(GCallback callback_func , gpointer user_data ,
                                     GClosureNotify destroy_data ) ;
#line 237
extern GClosure *g_signal_type_cclosure_new(GType itype , guint struct_offset ) ;
#line 243
extern GClosure *g_closure_ref(GClosure *closure ) ;
#line 245
extern void g_closure_sink(GClosure *closure ) ;
#line 247
extern void g_closure_unref(GClosure *closure ) ;
#line 250
extern GClosure *g_closure_new_simple(guint sizeof_closure , gpointer data ) ;
#line 253
extern void g_closure_add_finalize_notifier(GClosure *closure , gpointer notify_data ,
                                            GClosureNotify notify_func ) ;
#line 257
extern void g_closure_remove_finalize_notifier(GClosure *closure , gpointer notify_data ,
                                               GClosureNotify notify_func ) ;
#line 261
extern void g_closure_add_invalidate_notifier(GClosure *closure , gpointer notify_data ,
                                              GClosureNotify notify_func ) ;
#line 265
extern void g_closure_remove_invalidate_notifier(GClosure *closure , gpointer notify_data ,
                                                 GClosureNotify notify_func ) ;
#line 269
extern void g_closure_add_marshal_guards(GClosure *closure , gpointer pre_marshal_data ,
                                         GClosureNotify pre_marshal_notify , gpointer post_marshal_data ,
                                         GClosureNotify post_marshal_notify ) ;
#line 275
extern void g_closure_set_marshal(GClosure *closure , GClosureMarshal marshal ) ;
#line 278
extern void g_closure_set_meta_marshal(GClosure *closure , gpointer marshal_data ,
                                       GClosureMarshal meta_marshal ) ;
#line 282
extern void g_closure_invalidate(GClosure *closure ) ;
#line 284
extern void g_closure_invoke(GClosure *closure , GValue *return_value , guint n_param_values ,
                             GValue *param_values , gpointer invocation_hint ) ;
#line 302
extern void g_cclosure_marshal_generic(GClosure *closure , GValue *return_gvalue ,
                                       guint n_param_values , GValue *param_values ,
                                       gpointer invocation_hint , gpointer marshal_data ) ;
#line 310
extern void g_cclosure_marshal_generic_va(GClosure *closure , GValue *return_value ,
                                          gpointer instance , va_list args_list ,
                                          gpointer marshal_data , int n_params , GType *param_types ) ;
#line 24 "/usr/include/glib-2.0/gobject/gmarshal.h"
extern void g_cclosure_marshal_VOID__VOID(GClosure *closure , GValue *return_value ,
                                          guint n_param_values , GValue *param_values ,
                                          gpointer invocation_hint , gpointer marshal_data ) ;
#line 31
extern void g_cclosure_marshal_VOID__VOIDv(GClosure *closure , GValue *return_value ,
                                           gpointer instance , va_list args , gpointer marshal_data ,
                                           int n_params , GType *param_types ) ;
#line 41
extern void g_cclosure_marshal_VOID__BOOLEAN(GClosure *closure , GValue *return_value ,
                                             guint n_param_values , GValue *param_values ,
                                             gpointer invocation_hint , gpointer marshal_data ) ;
#line 48
extern void g_cclosure_marshal_VOID__BOOLEANv(GClosure *closure , GValue *return_value ,
                                              gpointer instance , va_list args , gpointer marshal_data ,
                                              int n_params , GType *param_types ) ;
#line 58
extern void g_cclosure_marshal_VOID__CHAR(GClosure *closure , GValue *return_value ,
                                          guint n_param_values , GValue *param_values ,
                                          gpointer invocation_hint , gpointer marshal_data ) ;
#line 65
extern void g_cclosure_marshal_VOID__CHARv(GClosure *closure , GValue *return_value ,
                                           gpointer instance , va_list args , gpointer marshal_data ,
                                           int n_params , GType *param_types ) ;
#line 75
extern void g_cclosure_marshal_VOID__UCHAR(GClosure *closure , GValue *return_value ,
                                           guint n_param_values , GValue *param_values ,
                                           gpointer invocation_hint , gpointer marshal_data ) ;
#line 82
extern void g_cclosure_marshal_VOID__UCHARv(GClosure *closure , GValue *return_value ,
                                            gpointer instance , va_list args , gpointer marshal_data ,
                                            int n_params , GType *param_types ) ;
#line 92
extern void g_cclosure_marshal_VOID__INT(GClosure *closure , GValue *return_value ,
                                         guint n_param_values , GValue *param_values ,
                                         gpointer invocation_hint , gpointer marshal_data ) ;
#line 99
extern void g_cclosure_marshal_VOID__INTv(GClosure *closure , GValue *return_value ,
                                          gpointer instance , va_list args , gpointer marshal_data ,
                                          int n_params , GType *param_types ) ;
#line 109
extern void g_cclosure_marshal_VOID__UINT(GClosure *closure , GValue *return_value ,
                                          guint n_param_values , GValue *param_values ,
                                          gpointer invocation_hint , gpointer marshal_data ) ;
#line 116
extern void g_cclosure_marshal_VOID__UINTv(GClosure *closure , GValue *return_value ,
                                           gpointer instance , va_list args , gpointer marshal_data ,
                                           int n_params , GType *param_types ) ;
#line 126
extern void g_cclosure_marshal_VOID__LONG(GClosure *closure , GValue *return_value ,
                                          guint n_param_values , GValue *param_values ,
                                          gpointer invocation_hint , gpointer marshal_data ) ;
#line 133
extern void g_cclosure_marshal_VOID__LONGv(GClosure *closure , GValue *return_value ,
                                           gpointer instance , va_list args , gpointer marshal_data ,
                                           int n_params , GType *param_types ) ;
#line 143
extern void g_cclosure_marshal_VOID__ULONG(GClosure *closure , GValue *return_value ,
                                           guint n_param_values , GValue *param_values ,
                                           gpointer invocation_hint , gpointer marshal_data ) ;
#line 150
extern void g_cclosure_marshal_VOID__ULONGv(GClosure *closure , GValue *return_value ,
                                            gpointer instance , va_list args , gpointer marshal_data ,
                                            int n_params , GType *param_types ) ;
#line 160
extern void g_cclosure_marshal_VOID__ENUM(GClosure *closure , GValue *return_value ,
                                          guint n_param_values , GValue *param_values ,
                                          gpointer invocation_hint , gpointer marshal_data ) ;
#line 167
extern void g_cclosure_marshal_VOID__ENUMv(GClosure *closure , GValue *return_value ,
                                           gpointer instance , va_list args , gpointer marshal_data ,
                                           int n_params , GType *param_types ) ;
#line 177
extern void g_cclosure_marshal_VOID__FLAGS(GClosure *closure , GValue *return_value ,
                                           guint n_param_values , GValue *param_values ,
                                           gpointer invocation_hint , gpointer marshal_data ) ;
#line 184
extern void g_cclosure_marshal_VOID__FLAGSv(GClosure *closure , GValue *return_value ,
                                            gpointer instance , va_list args , gpointer marshal_data ,
                                            int n_params , GType *param_types ) ;
#line 194
extern void g_cclosure_marshal_VOID__FLOAT(GClosure *closure , GValue *return_value ,
                                           guint n_param_values , GValue *param_values ,
                                           gpointer invocation_hint , gpointer marshal_data ) ;
#line 201
extern void g_cclosure_marshal_VOID__FLOATv(GClosure *closure , GValue *return_value ,
                                            gpointer instance , va_list args , gpointer marshal_data ,
                                            int n_params , GType *param_types ) ;
#line 211
extern void g_cclosure_marshal_VOID__DOUBLE(GClosure *closure , GValue *return_value ,
                                            guint n_param_values , GValue *param_values ,
                                            gpointer invocation_hint , gpointer marshal_data ) ;
#line 218
extern void g_cclosure_marshal_VOID__DOUBLEv(GClosure *closure , GValue *return_value ,
                                             gpointer instance , va_list args , gpointer marshal_data ,
                                             int n_params , GType *param_types ) ;
#line 228
extern void g_cclosure_marshal_VOID__STRING(GClosure *closure , GValue *return_value ,
                                            guint n_param_values , GValue *param_values ,
                                            gpointer invocation_hint , gpointer marshal_data ) ;
#line 235
extern void g_cclosure_marshal_VOID__STRINGv(GClosure *closure , GValue *return_value ,
                                             gpointer instance , va_list args , gpointer marshal_data ,
                                             int n_params , GType *param_types ) ;
#line 245
extern void g_cclosure_marshal_VOID__PARAM(GClosure *closure , GValue *return_value ,
                                           guint n_param_values , GValue *param_values ,
                                           gpointer invocation_hint , gpointer marshal_data ) ;
#line 252
extern void g_cclosure_marshal_VOID__PARAMv(GClosure *closure , GValue *return_value ,
                                            gpointer instance , va_list args , gpointer marshal_data ,
                                            int n_params , GType *param_types ) ;
#line 262
extern void g_cclosure_marshal_VOID__BOXED(GClosure *closure , GValue *return_value ,
                                           guint n_param_values , GValue *param_values ,
                                           gpointer invocation_hint , gpointer marshal_data ) ;
#line 269
extern void g_cclosure_marshal_VOID__BOXEDv(GClosure *closure , GValue *return_value ,
                                            gpointer instance , va_list args , gpointer marshal_data ,
                                            int n_params , GType *param_types ) ;
#line 279
extern void g_cclosure_marshal_VOID__POINTER(GClosure *closure , GValue *return_value ,
                                             guint n_param_values , GValue *param_values ,
                                             gpointer invocation_hint , gpointer marshal_data ) ;
#line 286
extern void g_cclosure_marshal_VOID__POINTERv(GClosure *closure , GValue *return_value ,
                                              gpointer instance , va_list args , gpointer marshal_data ,
                                              int n_params , GType *param_types ) ;
#line 296
extern void g_cclosure_marshal_VOID__OBJECT(GClosure *closure , GValue *return_value ,
                                            guint n_param_values , GValue *param_values ,
                                            gpointer invocation_hint , gpointer marshal_data ) ;
#line 303
extern void g_cclosure_marshal_VOID__OBJECTv(GClosure *closure , GValue *return_value ,
                                             gpointer instance , va_list args , gpointer marshal_data ,
                                             int n_params , GType *param_types ) ;
#line 313
extern void g_cclosure_marshal_VOID__VARIANT(GClosure *closure , GValue *return_value ,
                                             guint n_param_values , GValue *param_values ,
                                             gpointer invocation_hint , gpointer marshal_data ) ;
#line 320
extern void g_cclosure_marshal_VOID__VARIANTv(GClosure *closure , GValue *return_value ,
                                              gpointer instance , va_list args , gpointer marshal_data ,
                                              int n_params , GType *param_types ) ;
#line 330
extern void g_cclosure_marshal_VOID__UINT_POINTER(GClosure *closure , GValue *return_value ,
                                                  guint n_param_values , GValue *param_values ,
                                                  gpointer invocation_hint , gpointer marshal_data ) ;
#line 337
extern void g_cclosure_marshal_VOID__UINT_POINTERv(GClosure *closure , GValue *return_value ,
                                                   gpointer instance , va_list args ,
                                                   gpointer marshal_data , int n_params ,
                                                   GType *param_types ) ;
#line 347
extern void g_cclosure_marshal_BOOLEAN__FLAGS(GClosure *closure , GValue *return_value ,
                                              guint n_param_values , GValue *param_values ,
                                              gpointer invocation_hint , gpointer marshal_data ) ;
#line 354
extern void g_cclosure_marshal_BOOLEAN__FLAGSv(GClosure *closure , GValue *return_value ,
                                               gpointer instance , va_list args ,
                                               gpointer marshal_data , int n_params ,
                                               GType *param_types ) ;
#line 382
extern void g_cclosure_marshal_STRING__OBJECT_POINTER(GClosure *closure , GValue *return_value ,
                                                      guint n_param_values , GValue *param_values ,
                                                      gpointer invocation_hint , gpointer marshal_data ) ;
#line 389
extern void g_cclosure_marshal_STRING__OBJECT_POINTERv(GClosure *closure , GValue *return_value ,
                                                       gpointer instance , va_list args ,
                                                       gpointer marshal_data , int n_params ,
                                                       GType *param_types ) ;
#line 399
extern void g_cclosure_marshal_BOOLEAN__BOXED_BOXED(GClosure *closure , GValue *return_value ,
                                                    guint n_param_values , GValue *param_values ,
                                                    gpointer invocation_hint , gpointer marshal_data ) ;
#line 406
extern void g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(GClosure *closure , GValue *return_value ,
                                                     gpointer instance , va_list args ,
                                                     gpointer marshal_data , int n_params ,
                                                     GType *param_types ) ;
#line 277 "/usr/include/glib-2.0/gobject/gsignal.h"
extern guint g_signal_newv(gchar *signal_name , GType itype , GSignalFlags signal_flags ,
                           GClosure *class_closure , GSignalAccumulator accumulator ,
                           gpointer accu_data , GSignalCMarshaller c_marshaller ,
                           GType return_type , guint n_params , GType *param_types ) ;
#line 288
extern guint g_signal_new_valist(gchar *signal_name , GType itype , GSignalFlags signal_flags ,
                                 GClosure *class_closure , GSignalAccumulator accumulator ,
                                 gpointer accu_data , GSignalCMarshaller c_marshaller ,
                                 GType return_type , guint n_params , va_list args ) ;
#line 299
extern guint g_signal_new(gchar *signal_name , GType itype , GSignalFlags signal_flags ,
                          guint class_offset , GSignalAccumulator accumulator , gpointer accu_data ,
                          GSignalCMarshaller c_marshaller , GType return_type , guint n_params 
                          , ...) ;
#line 310
extern guint g_signal_new_class_handler(gchar *signal_name , GType itype , GSignalFlags signal_flags ,
                                        GCallback class_handler , GSignalAccumulator accumulator ,
                                        gpointer accu_data , GSignalCMarshaller c_marshaller ,
                                        GType return_type , guint n_params  , ...) ;
#line 321
extern void g_signal_set_va_marshaller(guint signal_id , GType instance_type , GSignalCVaMarshaller va_marshaller ) ;
#line 326
extern void g_signal_emitv(GValue *instance_and_params , guint signal_id , GQuark detail ,
                           GValue *return_value ) ;
#line 331
extern void g_signal_emit_valist(gpointer instance , guint signal_id , GQuark detail ,
                                 va_list var_args ) ;
#line 336
extern void g_signal_emit(gpointer instance , guint signal_id , GQuark detail  , ...) ;
#line 341
extern void g_signal_emit_by_name(gpointer instance , gchar *detailed_signal  , ...) ;
#line 345
extern guint g_signal_lookup(gchar *name , GType itype ) ;
#line 348
extern gchar *g_signal_name(guint signal_id ) ;
#line 350
extern void g_signal_query(guint signal_id , GSignalQuery *query ) ;
#line 353
extern guint *g_signal_list_ids(GType itype , guint *n_ids ) ;
#line 356
extern gboolean g_signal_is_valid_name(gchar *name ) ;
#line 358
extern gboolean g_signal_parse_name(gchar *detailed_signal , GType itype , guint *signal_id_p ,
                                    GQuark *detail_p , gboolean force_detail_quark ) ;
#line 364
extern GSignalInvocationHint *g_signal_get_invocation_hint(gpointer instance ) ;
#line 369
extern void g_signal_stop_emission(gpointer instance , guint signal_id , GQuark detail ) ;
#line 373
extern void g_signal_stop_emission_by_name(gpointer instance , gchar *detailed_signal ) ;
#line 376
extern gulong g_signal_add_emission_hook(guint signal_id , GQuark detail , GSignalEmissionHook hook_func ,
                                         gpointer hook_data , GDestroyNotify data_destroy ) ;
#line 382
extern void g_signal_remove_emission_hook(guint signal_id , gulong hook_id ) ;
#line 388
extern gboolean g_signal_has_handler_pending(gpointer instance , guint signal_id ,
                                             GQuark detail , gboolean may_be_blocked ) ;
#line 393
extern gulong g_signal_connect_closure_by_id(gpointer instance , guint signal_id ,
                                             GQuark detail , GClosure *closure , gboolean after ) ;
#line 399
extern gulong g_signal_connect_closure(gpointer instance , gchar *detailed_signal ,
                                       GClosure *closure , gboolean after ) ;
#line 404
extern gulong g_signal_connect_data(gpointer instance , gchar *detailed_signal , GCallback c_handler ,
                                    gpointer data , GClosureNotify destroy_data ,
                                    GConnectFlags connect_flags ) ;
#line 411
extern void g_signal_handler_block(gpointer instance , gulong handler_id ) ;
#line 414
extern void g_signal_handler_unblock(gpointer instance , gulong handler_id ) ;
#line 417
extern void g_signal_handler_disconnect(gpointer instance , gulong handler_id ) ;
#line 420
extern gboolean g_signal_handler_is_connected(gpointer instance , gulong handler_id ) ;
#line 423
extern gulong g_signal_handler_find(gpointer instance , GSignalMatchType mask , guint signal_id ,
                                    GQuark detail , GClosure *closure , gpointer func ,
                                    gpointer data ) ;
#line 431
extern guint g_signal_handlers_block_matched(gpointer instance , GSignalMatchType mask ,
                                             guint signal_id , GQuark detail , GClosure *closure ,
                                             gpointer func , gpointer data ) ;
#line 439
extern guint g_signal_handlers_unblock_matched(gpointer instance , GSignalMatchType mask ,
                                               guint signal_id , GQuark detail , GClosure *closure ,
                                               gpointer func , gpointer data ) ;
#line 447
extern guint g_signal_handlers_disconnect_matched(gpointer instance , GSignalMatchType mask ,
                                                  guint signal_id , GQuark detail ,
                                                  GClosure *closure , gpointer func ,
                                                  gpointer data ) ;
#line 456
extern void g_clear_signal_handler(gulong *handler_id_ptr , gpointer instance ) ;
#line 475
extern void g_signal_override_class_closure(guint signal_id , GType instance_type ,
                                            GClosure *class_closure ) ;
#line 479
extern void g_signal_override_class_handler(gchar *signal_name , GType instance_type ,
                                            GCallback class_handler ) ;
#line 483
extern void g_signal_chain_from_overridden(GValue *instance_and_params , GValue *return_value ) ;
#line 486
extern void g_signal_chain_from_overridden_handler(gpointer instance  , ...) ;
#line 622
extern gboolean g_signal_accumulator_true_handled(GSignalInvocationHint *ihint , GValue *return_accu ,
                                                  GValue *handler_return , gpointer dummy ) ;
#line 628
extern gboolean g_signal_accumulator_first_wins(GSignalInvocationHint *ihint , GValue *return_accu ,
                                                GValue *handler_return , gpointer dummy ) ;
#line 635
extern void g_signal_handlers_destroy(gpointer instance ) ;
#line 636
void _g_signals_destroy(GType itype ) ;
#line 328 "/usr/include/glib-2.0/gobject/glib-types.h"
extern GType g_date_get_type(void) ;
#line 330
extern GType g_strv_get_type(void) ;
#line 332
extern GType g_gstring_get_type(void) ;
#line 334
extern GType g_hash_table_get_type(void) ;
#line 336
extern GType g_array_get_type(void) ;
#line 338
extern GType g_byte_array_get_type(void) ;
#line 340
extern GType g_ptr_array_get_type(void) ;
#line 342
extern GType g_bytes_get_type(void) ;
#line 344
extern GType g_variant_type_get_gtype(void) ;
#line 346
extern GType g_regex_get_type(void) ;
#line 348
extern GType g_match_info_get_type(void) ;
#line 350
extern GType g_error_get_type(void) ;
#line 352
extern GType g_date_time_get_type(void) ;
#line 354
extern GType g_time_zone_get_type(void) ;
#line 356
extern GType g_io_channel_get_type(void) ;
#line 358
extern GType g_io_condition_get_type(void) ;
#line 360
extern GType g_variant_builder_get_type(void) ;
#line 362
extern GType g_variant_dict_get_type(void) ;
#line 364
extern GType g_key_file_get_type(void) ;
#line 366
extern GType g_main_loop_get_type(void) ;
#line 368
extern GType g_main_context_get_type(void) ;
#line 370
extern GType g_source_get_type(void) ;
#line 372
extern GType g_pollfd_get_type(void) ;
#line 374
extern GType g_thread_get_type(void) ;
#line 376
extern GType g_checksum_get_type(void) ;
#line 378
extern GType g_markup_parse_context_get_type(void) ;
#line 380
extern GType g_mapped_file_get_type(void) ;
#line 382
extern GType g_option_group_get_type(void) ;
#line 384
extern GType g_uri_get_type(void) ;
#line 386
extern GType g_tree_get_type(void) ;
#line 388
extern GType g_pattern_spec_get_type(void) ;
#line 391
extern GType g_variant_get_gtype(void) ;
#line 70 "/usr/include/glib-2.0/gobject/gboxed.h"
extern gpointer g_boxed_copy(GType boxed_type , gconstpointer src_boxed ) ;
#line 73
extern void g_boxed_free(GType boxed_type , gpointer boxed ) ;
#line 76
extern void g_value_set_boxed(GValue *value , gconstpointer v_boxed ) ;
#line 79
extern void g_value_set_static_boxed(GValue *value , gconstpointer v_boxed ) ;
#line 82
extern void g_value_take_boxed(GValue *value , gconstpointer v_boxed ) ;
#line 85
extern void g_value_set_boxed_take_ownership(GValue *value , gconstpointer v_boxed ) ;
#line 88
extern gpointer g_value_get_boxed(GValue *value ) ;
#line 90
extern gpointer g_value_dup_boxed(GValue *value ) ;
#line 95
extern GType g_boxed_type_register_static(gchar *name , GBoxedCopyFunc boxed_copy ,
                                          GBoxedFreeFunc boxed_free ) ;
#line 116
extern GType g_closure_get_type(void) ;
#line 118
extern GType g_value_get_type(void) ;
#line 407 "/usr/include/glib-2.0/gobject/gobject.h"
extern GType g_initially_unowned_get_type(void) ;
#line 409
extern void g_object_class_install_property(GObjectClass *oclass , guint property_id ,
                                            GParamSpec *pspec ) ;
#line 413
extern GParamSpec *g_object_class_find_property(GObjectClass *oclass , gchar *property_name ) ;
#line 416
extern GParamSpec **g_object_class_list_properties(GObjectClass *oclass , guint *n_properties ) ;
#line 419
extern void g_object_class_override_property(GObjectClass *oclass , guint property_id ,
                                             gchar *name ) ;
#line 423
extern void g_object_class_install_properties(GObjectClass *oclass , guint n_pspecs ,
                                              GParamSpec **pspecs ) ;
#line 428
extern void g_object_interface_install_property(gpointer g_iface , GParamSpec *pspec ) ;
#line 431
extern GParamSpec *g_object_interface_find_property(gpointer g_iface , gchar *property_name ) ;
#line 434
extern GParamSpec **g_object_interface_list_properties(gpointer g_iface , guint *n_properties_p ) ;
#line 438
extern GType g_object_get_type(void) ;
#line 440
extern gpointer g_object_new(GType object_type , gchar *first_property_name  , ...) ;
#line 444
extern GObject *g_object_new_with_properties(GType object_type , guint n_properties ,
                                             char const   *names[] , GValue values[] ) ;
#line 452
extern gpointer g_object_newv(GType object_type , guint n_parameters , GParameter *parameters ) ;
#line 459
extern GObject *g_object_new_valist(GType object_type , gchar *first_property_name ,
                                    va_list var_args ) ;
#line 463
extern void g_object_set(gpointer object , gchar *first_property_name  , ...) ;
#line 467
extern void g_object_get(gpointer object , gchar *first_property_name  , ...) ;
#line 471
extern gpointer g_object_connect(gpointer object , gchar *signal_spec  , ...) ;
#line 475
extern void g_object_disconnect(gpointer object , gchar *signal_spec  , ...) ;
#line 479
extern void g_object_setv(GObject *object , guint n_properties , gchar *names[] ,
                          GValue values[] ) ;
#line 484
extern void g_object_set_valist(GObject *object , gchar *first_property_name , va_list var_args ) ;
#line 488
extern void g_object_getv(GObject *object , guint n_properties , gchar *names[] ,
                          GValue values[] ) ;
#line 493
extern void g_object_get_valist(GObject *object , gchar *first_property_name , va_list var_args ) ;
#line 497
extern void g_object_set_property(GObject *object , gchar *property_name , GValue *value ) ;
#line 501
extern void g_object_get_property(GObject *object , gchar *property_name , GValue *value ) ;
#line 505
extern void g_object_freeze_notify(GObject *object ) ;
#line 507
extern void g_object_notify(GObject *object , gchar *property_name ) ;
#line 510
extern void g_object_notify_by_pspec(GObject *object , GParamSpec *pspec ) ;
#line 513
extern void g_object_thaw_notify(GObject *object ) ;
#line 515
extern gboolean g_object_is_floating(gpointer object ) ;
#line 517
extern gpointer g_object_ref_sink(gpointer object ) ;
#line 519
extern gpointer g_object_take_ref(gpointer object ) ;
#line 521
extern gpointer g_object_ref(gpointer object ) ;
#line 523
extern void g_object_unref(gpointer object ) ;
#line 525
extern void g_object_weak_ref(GObject *object , GWeakNotify notify , gpointer data ) ;
#line 529
extern void g_object_weak_unref(GObject *object , GWeakNotify notify , gpointer data ) ;
#line 533
extern void g_object_add_weak_pointer(GObject *object , gpointer *weak_pointer_location ) ;
#line 536
extern void g_object_remove_weak_pointer(GObject *object , gpointer *weak_pointer_location ) ;
#line 564
extern void g_object_add_toggle_ref(GObject *object , GToggleNotify notify , gpointer data ) ;
#line 568
extern void g_object_remove_toggle_ref(GObject *object , GToggleNotify notify , gpointer data ) ;
#line 573
extern gpointer g_object_get_qdata(GObject *object , GQuark quark ) ;
#line 576
extern void g_object_set_qdata(GObject *object , GQuark quark , gpointer data ) ;
#line 580
extern void g_object_set_qdata_full(GObject *object , GQuark quark , gpointer data ,
                                    GDestroyNotify destroy ) ;
#line 585
extern gpointer g_object_steal_qdata(GObject *object , GQuark quark ) ;
#line 589
extern gpointer g_object_dup_qdata(GObject *object , GQuark quark , GDuplicateFunc dup_func ,
                                   gpointer user_data ) ;
#line 594
extern gboolean g_object_replace_qdata(GObject *object , GQuark quark , gpointer oldval ,
                                       gpointer newval , GDestroyNotify destroy ,
                                       GDestroyNotify *old_destroy ) ;
#line 602
extern gpointer g_object_get_data(GObject *object , gchar *key ) ;
#line 605
extern void g_object_set_data(GObject *object , gchar *key , gpointer data ) ;
#line 609
extern void g_object_set_data_full(GObject *object , gchar *key , gpointer data ,
                                   GDestroyNotify destroy ) ;
#line 614
extern gpointer g_object_steal_data(GObject *object , gchar *key ) ;
#line 618
extern gpointer g_object_dup_data(GObject *object , gchar *key , GDuplicateFunc dup_func ,
                                  gpointer user_data ) ;
#line 623
extern gboolean g_object_replace_data(GObject *object , gchar *key , gpointer oldval ,
                                      gpointer newval , GDestroyNotify destroy , GDestroyNotify *old_destroy ) ;
#line 632
extern void g_object_watch_closure(GObject *object , GClosure *closure ) ;
#line 635
extern GClosure *g_cclosure_new_object(GCallback callback_func , GObject *object ) ;
#line 638
extern GClosure *g_cclosure_new_object_swap(GCallback callback_func , GObject *object ) ;
#line 641
extern GClosure *g_closure_new_object(guint sizeof_closure , GObject *object ) ;
#line 644
extern void g_value_set_object(GValue *value , gpointer v_object ) ;
#line 647
extern gpointer g_value_get_object(GValue *value ) ;
#line 649
extern gpointer g_value_dup_object(GValue *value ) ;
#line 651
extern gulong g_signal_connect_object(gpointer instance , gchar *detailed_signal ,
                                      GCallback c_handler , gpointer gobject , GConnectFlags connect_flags ) ;
#line 659
extern void g_object_force_floating(GObject *object ) ;
#line 661
extern void g_object_run_dispose(GObject *object ) ;
#line 665
extern void g_value_take_object(GValue *value , gpointer v_object ) ;
#line 668
extern void g_value_set_object_take_ownership(GValue *value , gpointer v_object ) ;
#line 672
extern gsize g_object_compat_control(gsize what , gpointer data ) ;
#line 702
extern void g_clear_object(GObject **object_ptr ) ;
#line 742 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static gboolean g_set_object(GObject **object_ptr , GObject *new_object ) 
{ 
  GObject *old_object ;
  gpointer __cil_tmp4 ;

  {
#line 745
  old_object = *object_ptr;
#line 753
  if (old_object == new_object) {
#line 754
    return (0);
  }
#line 756
  if (new_object != (void *)0) {
    {
#line 757
    __cil_tmp4 = g_object_ref(new_object);
    }
  }
#line 759
  *object_ptr = new_object;
#line 761
  if (old_object != (void *)0) {
    {
#line 762
    g_object_unref(old_object);
    }
  }
#line 764
  return (! 0);
}
}
#line 808 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static void g_assert_finalize_object(GObject *object ) 
{ 
  gpointer weak_pointer ;
  long __cil_tmp3 ;
  long __cil_tmp4 ;

  {
#line 810
  weak_pointer = object;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 812
    __cil_tmp3 = __builtin_expect((long )0, (long )1);
    }
#line 812
    if (__cil_tmp3) {

    } else {
      {
#line 812
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          812, (char const   *)"g_assert_finalize_object\312\001@",
                          "\'G_IS_OBJECT (weak_pointer)\' should be TRUE");
      }
    }
#line 812
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 813
  g_object_add_weak_pointer(object, & weak_pointer);
#line 814
  g_object_unref(weak_pointer);
  }
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 815
    __cil_tmp4 = __builtin_expect((long )0, (long )1);
    }
#line 815
    if (__cil_tmp4) {

    } else {
      {
#line 815
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          815, (char const   *)"g_assert_finalize_object\312\001@",
                          "\'weak_pointer\' should be NULL");
      }
    }
#line 815
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 843 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static void g_clear_weak_pointer(gpointer *weak_pointer_location ) 
{ 
  GObject *object ;

  {
#line 845
  object = (GObject *)*weak_pointer_location;
#line 847
  if (object != (void *)0) {
    {
#line 849
    g_object_remove_weak_pointer(object, weak_pointer_location);
#line 850
    *weak_pointer_location = (void *)0;
    }
  }
  return;
}
}
#line 898 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static gboolean g_set_weak_pointer(gpointer *weak_pointer_location , GObject *new_object ) 
{ 
  GObject *old_object ;

  {
#line 901
  old_object = (GObject *)*weak_pointer_location;
#line 908
  if (old_object == new_object) {
#line 909
    return (0);
  }
#line 911
  if (old_object != (void *)0) {
    {
#line 912
    g_object_remove_weak_pointer(old_object, weak_pointer_location);
    }
  }
#line 914
  *weak_pointer_location = new_object;
#line 916
  if (new_object != (void *)0) {
    {
#line 917
    g_object_add_weak_pointer(new_object, weak_pointer_location);
    }
  }
#line 919
  return (! 0);
}
}
#line 934
extern void g_weak_ref_init(GWeakRef *weak_ref , gpointer object ) ;
#line 937
extern void g_weak_ref_clear(GWeakRef *weak_ref ) ;
#line 939
extern gpointer g_weak_ref_get(GWeakRef *weak_ref ) ;
#line 941
extern void g_weak_ref_set(GWeakRef *weak_ref , gpointer object ) ;
#line 106 "/usr/include/glib-2.0/gobject/gbinding.h"
extern GType g_binding_flags_get_type(void) ;
#line 108
extern GType g_binding_get_type(void) ;
#line 111
extern GBindingFlags g_binding_get_flags(GBinding *binding ) ;
#line 113
extern GObject *g_binding_get_source(GBinding *binding ) ;
#line 115
extern GObject *g_binding_dup_source(GBinding *binding ) ;
#line 117
extern GObject *g_binding_get_target(GBinding *binding ) ;
#line 119
extern GObject *g_binding_dup_target(GBinding *binding ) ;
#line 121
extern gchar *g_binding_get_source_property(GBinding *binding ) ;
#line 123
extern gchar *g_binding_get_target_property(GBinding *binding ) ;
#line 125
extern void g_binding_unbind(GBinding *binding ) ;
#line 128
extern GBinding *g_object_bind_property(gpointer source , gchar *source_property ,
                                        gpointer target , gchar *target_property ,
                                        GBindingFlags flags ) ;
#line 134
extern GBinding *g_object_bind_property_full(gpointer source , gchar *source_property ,
                                             gpointer target , gchar *target_property ,
                                             GBindingFlags flags , GBindingTransformFunc transform_to ,
                                             GBindingTransformFunc transform_from ,
                                             gpointer user_data , GDestroyNotify notify ) ;
#line 144
extern GBinding *g_object_bind_property_with_closures(gpointer source , gchar *source_property ,
                                                      gpointer target , gchar *target_property ,
                                                      GBindingFlags flags , GClosure *transform_to ,
                                                      GClosure *transform_from ) ;
#line 50 "/usr/include/glib-2.0/gobject/gbindinggroup.h"
extern GType g_binding_group_get_type(void) ;
#line 52
extern GBindingGroup *g_binding_group_new(void) ;
#line 54
extern gpointer g_binding_group_dup_source(GBindingGroup *self ) ;
#line 56
extern void g_binding_group_set_source(GBindingGroup *self , gpointer source ) ;
#line 59
extern void g_binding_group_bind(GBindingGroup *self , gchar *source_property , gpointer target ,
                                 gchar *target_property , GBindingFlags flags ) ;
#line 65
extern void g_binding_group_bind_full(GBindingGroup *self , gchar *source_property ,
                                      gpointer target , gchar *target_property , GBindingFlags flags ,
                                      GBindingTransformFunc transform_to , GBindingTransformFunc transform_from ,
                                      gpointer user_data , GDestroyNotify user_data_destroy ) ;
#line 75
extern void g_binding_group_bind_with_closures(GBindingGroup *self , gchar *source_property ,
                                               gpointer target , gchar *target_property ,
                                               GBindingFlags flags , GClosure *transform_to ,
                                               GClosure *transform_from ) ;
#line 219 "/usr/include/glib-2.0/gobject/genums.h"
extern GEnumValue *g_enum_get_value(GEnumClass *enum_class , gint value ) ;
#line 222
extern GEnumValue *g_enum_get_value_by_name(GEnumClass *enum_class , gchar *name ) ;
#line 225
extern GEnumValue *g_enum_get_value_by_nick(GEnumClass *enum_class , gchar *nick ) ;
#line 228
extern GFlagsValue *g_flags_get_first_value(GFlagsClass *flags_class , guint value ) ;
#line 231
extern GFlagsValue *g_flags_get_value_by_name(GFlagsClass *flags_class , gchar *name ) ;
#line 234
extern GFlagsValue *g_flags_get_value_by_nick(GFlagsClass *flags_class , gchar *nick ) ;
#line 237
extern gchar *g_enum_to_string(GType g_enum_type , gint value ) ;
#line 240
extern gchar *g_flags_to_string(GType flags_type , guint value ) ;
#line 243
extern void g_value_set_enum(GValue *value , gint v_enum ) ;
#line 246
extern gint g_value_get_enum(GValue *value ) ;
#line 248
extern void g_value_set_flags(GValue *value , guint v_flags ) ;
#line 251
extern guint g_value_get_flags(GValue *value ) ;
#line 260
extern GType g_enum_register_static(gchar *name , GEnumValue *const_static_values ) ;
#line 263
extern GType g_flags_register_static(gchar *name , GFlagsValue *const_static_values ) ;
#line 269
extern void g_enum_complete_type_info(GType g_enum_type , GTypeInfo *info , GEnumValue *const_values ) ;
#line 273
extern void g_flags_complete_type_info(GType g_flags_type , GTypeInfo *info , GFlagsValue *const_values ) ;
#line 12 "/usr/include/glib-2.0/gobject/glib-enumtypes.h"
extern GType g_unicode_type_get_type(void) ;
#line 14
extern GType g_unicode_break_type_get_type(void) ;
#line 16
extern GType g_unicode_script_get_type(void) ;
#line 18
extern GType g_normalize_mode_get_type(void) ;
#line 988 "/usr/include/glib-2.0/gobject/gparamspecs.h"
extern GParamSpec *g_param_spec_char(gchar *name , gchar *nick , gchar *blurb , gint8 minimum ,
                                     gint8 maximum , gint8 default_value , GParamFlags flags ) ;
#line 996
extern GParamSpec *g_param_spec_uchar(gchar *name , gchar *nick , gchar *blurb , guint8 minimum ,
                                      guint8 maximum , guint8 default_value , GParamFlags flags ) ;
#line 1004
extern GParamSpec *g_param_spec_boolean(gchar *name , gchar *nick , gchar *blurb ,
                                        gboolean default_value , GParamFlags flags ) ;
#line 1010
extern GParamSpec *g_param_spec_int(gchar *name , gchar *nick , gchar *blurb , gint minimum ,
                                    gint maximum , gint default_value , GParamFlags flags ) ;
#line 1018
extern GParamSpec *g_param_spec_uint(gchar *name , gchar *nick , gchar *blurb , guint minimum ,
                                     guint maximum , guint default_value , GParamFlags flags ) ;
#line 1026
extern GParamSpec *g_param_spec_long(gchar *name , gchar *nick , gchar *blurb , glong minimum ,
                                     glong maximum , glong default_value , GParamFlags flags ) ;
#line 1034
extern GParamSpec *g_param_spec_ulong(gchar *name , gchar *nick , gchar *blurb , gulong minimum ,
                                      gulong maximum , gulong default_value , GParamFlags flags ) ;
#line 1042
extern GParamSpec *g_param_spec_int64(gchar *name , gchar *nick , gchar *blurb , gint64 minimum ,
                                      gint64 maximum , gint64 default_value , GParamFlags flags ) ;
#line 1050
extern GParamSpec *g_param_spec_uint64(gchar *name , gchar *nick , gchar *blurb ,
                                       guint64 minimum , guint64 maximum , guint64 default_value ,
                                       GParamFlags flags ) ;
#line 1058
extern GParamSpec *g_param_spec_unichar(gchar *name , gchar *nick , gchar *blurb ,
                                        gunichar default_value , GParamFlags flags ) ;
#line 1064
extern GParamSpec *g_param_spec_enum(gchar *name , gchar *nick , gchar *blurb , GType enum_type ,
                                     gint default_value , GParamFlags flags ) ;
#line 1071
extern GParamSpec *g_param_spec_flags(gchar *name , gchar *nick , gchar *blurb , GType flags_type ,
                                      guint default_value , GParamFlags flags ) ;
#line 1078
extern GParamSpec *g_param_spec_float(gchar *name , gchar *nick , gchar *blurb , gfloat minimum ,
                                      gfloat maximum , gfloat default_value , GParamFlags flags ) ;
#line 1086
extern GParamSpec *g_param_spec_double(gchar *name , gchar *nick , gchar *blurb ,
                                       gdouble minimum , gdouble maximum , gdouble default_value ,
                                       GParamFlags flags ) ;
#line 1094
extern GParamSpec *g_param_spec_string(gchar *name , gchar *nick , gchar *blurb ,
                                       gchar *default_value , GParamFlags flags ) ;
#line 1100
extern GParamSpec *g_param_spec_param(gchar *name , gchar *nick , gchar *blurb , GType param_type ,
                                      GParamFlags flags ) ;
#line 1106
extern GParamSpec *g_param_spec_boxed(gchar *name , gchar *nick , gchar *blurb , GType boxed_type ,
                                      GParamFlags flags ) ;
#line 1112
extern GParamSpec *g_param_spec_pointer(gchar *name , gchar *nick , gchar *blurb ,
                                        GParamFlags flags ) ;
#line 1117
extern GParamSpec *g_param_spec_value_array(gchar *name , gchar *nick , gchar *blurb ,
                                            GParamSpec *element_spec , GParamFlags flags ) ;
#line 1123
extern GParamSpec *g_param_spec_object(gchar *name , gchar *nick , gchar *blurb ,
                                       GType object_type , GParamFlags flags ) ;
#line 1129
extern GParamSpec *g_param_spec_override(gchar *name , GParamSpec *overridden ) ;
#line 1132
extern GParamSpec *g_param_spec_gtype(gchar *name , gchar *nick , gchar *blurb , GType is_a_type ,
                                      GParamFlags flags ) ;
#line 1138
extern GParamSpec *g_param_spec_variant(gchar *name , gchar *nick , gchar *blurb ,
                                        GVariantType *type , GVariant *default_value ,
                                        GParamFlags flags ) ;
#line 1169
extern GType *g_param_spec_types ;
#line 50 "/usr/include/glib-2.0/gobject/gsignalgroup.h"
extern GType g_signal_group_get_type(void) ;
#line 52
extern GSignalGroup *g_signal_group_new(GType target_type ) ;
#line 54
extern void g_signal_group_set_target(GSignalGroup *self , gpointer target ) ;
#line 57
extern gpointer g_signal_group_dup_target(GSignalGroup *self ) ;
#line 59
extern void g_signal_group_block(GSignalGroup *self ) ;
#line 61
extern void g_signal_group_unblock(GSignalGroup *self ) ;
#line 63
extern void g_signal_group_connect_object(GSignalGroup *self , gchar *detailed_signal ,
                                          GCallback c_handler , gpointer object ,
                                          GConnectFlags flags ) ;
#line 69
extern void g_signal_group_connect_data(GSignalGroup *self , gchar *detailed_signal ,
                                        GCallback c_handler , gpointer data , GClosureNotify notify ,
                                        GConnectFlags flags ) ;
#line 76
extern void g_signal_group_connect(GSignalGroup *self , gchar *detailed_signal , GCallback c_handler ,
                                   gpointer data ) ;
#line 81
extern void g_signal_group_connect_after(GSignalGroup *self , gchar *detailed_signal ,
                                         GCallback c_handler , gpointer data ) ;
#line 86
extern void g_signal_group_connect_swapped(GSignalGroup *self , gchar *detailed_signal ,
                                           GCallback c_handler , gpointer data ) ;
#line 30 "/usr/include/glib-2.0/gobject/gsourceclosure.h"
extern void g_source_set_closure(GSource *source , GClosure *closure ) ;
#line 34
extern void g_source_set_dummy_callback(GSource *source ) ;
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
__inline static void glib_autoptr_clear_GTypeModule(GTypeModule *_ptr ) 
{ 


  {
#line 39
  if (_ptr) {
    {
#line 39
    g_object_unref((GTypeModule *)_ptr);
    }
  }
  return;
}
}
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
__inline static void glib_autoptr_cleanup_GTypeModule(GTypeModule **_ptr ) 
{ 


  {
  {
#line 39
  glib_autoptr_clear_GTypeModule(*_ptr);
  }
  return;
}
}
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
__inline static void glib_listautoptr_cleanup_GTypeModule(GList **_l ) 
{ 


  {
  {
#line 39
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_object_unref)));
  }
  return;
}
}
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
__inline static void glib_slistautoptr_cleanup_GTypeModule(GSList **_l ) 
{ 


  {
  {
#line 39
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_object_unref)));
  }
  return;
}
}
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
__inline static void glib_queueautoptr_cleanup_GTypeModule(GQueue **_q ) 
{ 


  {
#line 39
  if (*_q) {
    {
#line 39
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_object_unref)));
    }
  }
  return;
}
}
#line 270
extern GType g_type_module_get_type(void) ;
#line 272
extern gboolean g_type_module_use(GTypeModule *module ) ;
#line 274
extern void g_type_module_unuse(GTypeModule *module ) ;
#line 276
extern void g_type_module_set_name(GTypeModule *module , gchar *name ) ;
#line 279
extern GType g_type_module_register_type(GTypeModule *module , GType parent_type ,
                                         gchar *type_name , GTypeInfo *type_info ,
                                         GTypeFlags flags ) ;
#line 285
extern void g_type_module_add_interface(GTypeModule *module , GType instance_type ,
                                        GType interface_type , GInterfaceInfo *interface_info ) ;
#line 290
extern GType g_type_module_register_enum(GTypeModule *module , gchar *name , GEnumValue *const_static_values ) ;
#line 294
extern GType g_type_module_register_flags(GTypeModule *module , gchar *name , GFlagsValue *const_static_values ) ;
#line 116 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
extern GType g_type_plugin_get_type(void) ;
#line 118
extern void g_type_plugin_use(GTypePlugin *plugin ) ;
#line 120
extern void g_type_plugin_unuse(GTypePlugin *plugin ) ;
#line 122
extern void g_type_plugin_complete_type_info(GTypePlugin *plugin , GType g_type ,
                                             GTypeInfo *info , GTypeValueTable *value_table ) ;
#line 127
extern void g_type_plugin_complete_interface_info(GTypePlugin *plugin , GType instance_type ,
                                                  GType interface_type , GInterfaceInfo *info ) ;
#line 60 "/usr/include/glib-2.0/gobject/gvaluearray.h"
extern GType g_value_array_get_type(void) ;
#line 63
extern GValue *g_value_array_get_nth(GValueArray *value_array , guint index_ ) ;
#line 67
extern GValueArray *g_value_array_new(guint n_prealloced ) ;
#line 70
extern void g_value_array_free(GValueArray *value_array ) ;
#line 73
extern GValueArray *g_value_array_copy(GValueArray *value_array ) ;
#line 76
extern GValueArray *g_value_array_prepend(GValueArray *value_array , GValue *value ) ;
#line 80
extern GValueArray *g_value_array_append(GValueArray *value_array , GValue *value ) ;
#line 84
extern GValueArray *g_value_array_insert(GValueArray *value_array , guint index_ ,
                                         GValue *value ) ;
#line 89
extern GValueArray *g_value_array_remove(GValueArray *value_array , guint index_ ) ;
#line 93
extern GValueArray *g_value_array_sort(GValueArray *value_array , GCompareFunc compare_func ) ;
#line 97
extern GValueArray *g_value_array_sort_with_data(GValueArray *value_array , GCompareDataFunc compare_func ,
                                                 gpointer user_data ) ;
#line 192 "/usr/include/glib-2.0/gobject/gvaluetypes.h"
extern void g_value_set_char(GValue *value , gchar v_char ) ;
#line 195
extern gchar g_value_get_char(GValue *value ) ;
#line 197
extern void g_value_set_schar(GValue *value , gint8 v_char ) ;
#line 200
extern gint8 g_value_get_schar(GValue *value ) ;
#line 202
extern void g_value_set_uchar(GValue *value , guchar v_uchar ) ;
#line 205
extern guchar g_value_get_uchar(GValue *value ) ;
#line 207
extern void g_value_set_boolean(GValue *value , gboolean v_boolean ) ;
#line 210
extern gboolean g_value_get_boolean(GValue *value ) ;
#line 212
extern void g_value_set_int(GValue *value , gint v_int ) ;
#line 215
extern gint g_value_get_int(GValue *value ) ;
#line 217
extern void g_value_set_uint(GValue *value , guint v_uint ) ;
#line 220
extern guint g_value_get_uint(GValue *value ) ;
#line 222
extern void g_value_set_long(GValue *value , glong v_long ) ;
#line 225
extern glong g_value_get_long(GValue *value ) ;
#line 227
extern void g_value_set_ulong(GValue *value , gulong v_ulong ) ;
#line 230
extern gulong g_value_get_ulong(GValue *value ) ;
#line 232
extern void g_value_set_int64(GValue *value , gint64 v_int64 ) ;
#line 235
extern gint64 g_value_get_int64(GValue *value ) ;
#line 237
extern void g_value_set_uint64(GValue *value , guint64 v_uint64 ) ;
#line 240
extern guint64 g_value_get_uint64(GValue *value ) ;
#line 242
extern void g_value_set_float(GValue *value , gfloat v_float ) ;
#line 245
extern gfloat g_value_get_float(GValue *value ) ;
#line 247
extern void g_value_set_double(GValue *value , gdouble v_double ) ;
#line 250
extern gdouble g_value_get_double(GValue *value ) ;
#line 252
extern void g_value_set_string(GValue *value , gchar *v_string ) ;
#line 255
extern void g_value_set_static_string(GValue *value , gchar *v_string ) ;
#line 258
extern void g_value_set_interned_string(GValue *value , gchar *v_string ) ;
#line 261
extern gchar *g_value_get_string(GValue *value ) ;
#line 263
extern gchar *g_value_dup_string(GValue *value ) ;
#line 265
extern void g_value_set_pointer(GValue *value , gpointer v_pointer ) ;
#line 268
extern gpointer g_value_get_pointer(GValue *value ) ;
#line 270
extern GType g_gtype_get_type(void) ;
#line 272
extern void g_value_set_gtype(GValue *value , GType v_gtype ) ;
#line 275
extern GType g_value_get_gtype(GValue *value ) ;
#line 277
extern void g_value_set_variant(GValue *value , GVariant *variant ) ;
#line 280
extern void g_value_take_variant(GValue *value , GVariant *variant ) ;
#line 283
extern GVariant *g_value_get_variant(GValue *value ) ;
#line 285
extern GVariant *g_value_dup_variant(GValue *value ) ;
#line 290
extern GType g_pointer_type_register_static(gchar *name ) ;
#line 294
extern gchar *g_strdup_value_contents(GValue *value ) ;
#line 298
extern void g_value_take_string(GValue *value , gchar *v_string ) ;
#line 301
extern void g_value_set_string_take_ownership(GValue *value , gchar *v_string ) ;
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_clear_GClosure(GClosure *_ptr ) 
{ 


  {
#line 24
  if (_ptr) {
    {
#line 24
    g_closure_unref((GClosure *)_ptr);
    }
  }
  return;
}
}
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_cleanup_GClosure(GClosure **_ptr ) 
{ 


  {
  {
#line 24
  glib_autoptr_clear_GClosure(*_ptr);
  }
  return;
}
}
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GClosure(GList **_l ) 
{ 


  {
  {
#line 24
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_closure_unref)));
  }
  return;
}
}
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GClosure(GSList **_l ) 
{ 


  {
  {
#line 24
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_closure_unref)));
  }
  return;
}
}
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GClosure(GQueue **_q ) 
{ 


  {
#line 24
  if (*_q) {
    {
#line 24
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_closure_unref)));
    }
  }
  return;
}
}
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_clear_GEnumClass(GEnumClass *_ptr ) 
{ 


  {
#line 25
  if (_ptr) {
    {
#line 25
    g_type_class_unref((GEnumClass *)_ptr);
    }
  }
  return;
}
}
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_cleanup_GEnumClass(GEnumClass **_ptr ) 
{ 


  {
  {
#line 25
  glib_autoptr_clear_GEnumClass(*_ptr);
  }
  return;
}
}
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GEnumClass(GList **_l ) 
{ 


  {
  {
#line 25
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_type_class_unref)));
  }
  return;
}
}
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GEnumClass(GSList **_l ) 
{ 


  {
  {
#line 25
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_type_class_unref)));
  }
  return;
}
}
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GEnumClass(GQueue **_q ) 
{ 


  {
#line 25
  if (*_q) {
    {
#line 25
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_type_class_unref)));
    }
  }
  return;
}
}
#line 26 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_clear_GFlagsClass(GFlagsClass *_ptr ) 
{ 


  {
#line 26
  if (_ptr) {
    {
#line 26
    g_type_class_unref((GFlagsClass *)_ptr);
    }
  }
  return;
}
}
#line 26 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFlagsClass(GFlagsClass **_ptr ) 
{ 


  {
  {
#line 26
  glib_autoptr_clear_GFlagsClass(*_ptr);
  }
  return;
}
}
#line 27 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_clear_GObject(GObject *_ptr ) 
{ 


  {
#line 27
  if (_ptr) {
    {
#line 27
    g_object_unref((GObject *)_ptr);
    }
  }
  return;
}
}
#line 27 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_cleanup_GObject(GObject **_ptr ) 
{ 


  {
  {
#line 27
  glib_autoptr_clear_GObject(*_ptr);
  }
  return;
}
}
#line 28 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_clear_GInitiallyUnowned(GInitiallyUnowned *_ptr ) 
{ 


  {
#line 28
  if (_ptr) {
    {
#line 28
    g_object_unref((GInitiallyUnowned *)_ptr);
    }
  }
  return;
}
}
#line 28 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_cleanup_GInitiallyUnowned(GInitiallyUnowned **_ptr ) 
{ 


  {
  {
#line 28
  glib_autoptr_clear_GInitiallyUnowned(*_ptr);
  }
  return;
}
}
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_clear_GParamSpec(GParamSpec *_ptr ) 
{ 


  {
#line 29
  if (_ptr) {
    {
#line 29
    g_param_spec_unref((GParamSpec *)_ptr);
    }
  }
  return;
}
}
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_cleanup_GParamSpec(GParamSpec **_ptr ) 
{ 


  {
  {
#line 29
  glib_autoptr_clear_GParamSpec(*_ptr);
  }
  return;
}
}
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GParamSpec(GList **_l ) 
{ 


  {
  {
#line 29
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_param_spec_unref)));
  }
  return;
}
}
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GParamSpec(GSList **_l ) 
{ 


  {
  {
#line 29
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_param_spec_unref)));
  }
  return;
}
}
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GParamSpec(GQueue **_q ) 
{ 


  {
#line 29
  if (*_q) {
    {
#line 29
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_param_spec_unref)));
    }
  }
  return;
}
}
#line 30 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_clear_GTypeClass(GTypeClass *_ptr ) 
{ 


  {
#line 30
  if (_ptr) {
    {
#line 30
    g_type_class_unref((GTypeClass *)_ptr);
    }
  }
  return;
}
}
#line 30 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTypeClass(GTypeClass **_ptr ) 
{ 


  {
  {
#line 30
  glib_autoptr_clear_GTypeClass(*_ptr);
  }
  return;
}
}
#line 31 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_auto_cleanup_GValue(GValue *_ptr ) 
{ 


  {
  {
#line 31
  g_value_unset(_ptr);
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/gio/gaction.h"
extern GType g_action_get_type(void) ;
#line 63
extern gchar *g_action_get_name(GAction *action ) ;
#line 65
extern GVariantType *g_action_get_parameter_type(GAction *action ) ;
#line 67
extern GVariantType *g_action_get_state_type(GAction *action ) ;
#line 69
extern GVariant *g_action_get_state_hint(GAction *action ) ;
#line 72
extern gboolean g_action_get_enabled(GAction *action ) ;
#line 74
extern GVariant *g_action_get_state(GAction *action ) ;
#line 77
extern void g_action_change_state(GAction *action , GVariant *value ) ;
#line 80
extern void g_action_activate(GAction *action , GVariant *parameter ) ;
#line 84
extern gboolean g_action_name_is_valid(gchar *action_name ) ;
#line 87
extern gboolean g_action_parse_detailed_name(gchar *detailed_name , gchar **action_name ,
                                             GVariant **target_value , GError **error ) ;
#line 93
extern gchar *g_action_print_detailed_name(gchar *action_name , GVariant *target_value ) ;
#line 98 "/usr/include/glib-2.0/gio/gactiongroup.h"
extern GType g_action_group_get_type(void) ;
#line 101
extern gboolean g_action_group_has_action(GActionGroup *action_group , gchar *action_name ) ;
#line 104
extern gchar **g_action_group_list_actions(GActionGroup *action_group ) ;
#line 107
extern GVariantType *g_action_group_get_action_parameter_type(GActionGroup *action_group ,
                                                              gchar *action_name ) ;
#line 110
extern GVariantType *g_action_group_get_action_state_type(GActionGroup *action_group ,
                                                          gchar *action_name ) ;
#line 113
extern GVariant *g_action_group_get_action_state_hint(GActionGroup *action_group ,
                                                      gchar *action_name ) ;
#line 117
extern gboolean g_action_group_get_action_enabled(GActionGroup *action_group , gchar *action_name ) ;
#line 121
extern GVariant *g_action_group_get_action_state(GActionGroup *action_group , gchar *action_name ) ;
#line 124
extern void g_action_group_change_action_state(GActionGroup *action_group , gchar *action_name ,
                                               GVariant *value ) ;
#line 129
extern void g_action_group_activate_action(GActionGroup *action_group , gchar *action_name ,
                                           GVariant *parameter ) ;
#line 135
extern void g_action_group_action_added(GActionGroup *action_group , gchar *action_name ) ;
#line 138
extern void g_action_group_action_removed(GActionGroup *action_group , gchar *action_name ) ;
#line 141
extern void g_action_group_action_enabled_changed(GActionGroup *action_group , gchar *action_name ,
                                                  gboolean enabled ) ;
#line 146
extern void g_action_group_action_state_changed(GActionGroup *action_group , gchar *action_name ,
                                                GVariant *state ) ;
#line 151
extern gboolean g_action_group_query_action(GActionGroup *action_group , gchar *action_name ,
                                            gboolean *enabled , GVariantType **parameter_type ,
                                            GVariantType **state_type , GVariant **state_hint ,
                                            GVariant **state ) ;
#line 34 "/usr/include/glib-2.0/gio/gactiongroupexporter.h"
extern guint g_dbus_connection_export_action_group(GDBusConnection *connection , gchar *object_path ,
                                                   GActionGroup *action_group , GError **error ) ;
#line 40
extern void g_dbus_connection_unexport_action_group(GDBusConnection *connection ,
                                                    guint export_id ) ;
#line 76 "/usr/include/glib-2.0/gio/gactionmap.h"
extern GType g_action_map_get_type(void) ;
#line 79
extern GAction *g_action_map_lookup_action(GActionMap *action_map , gchar *action_name ) ;
#line 82
extern void g_action_map_add_action(GActionMap *action_map , GAction *action ) ;
#line 85
extern void g_action_map_remove_action(GActionMap *action_map , gchar *action_name ) ;
#line 88
extern void g_action_map_add_action_entries(GActionMap *action_map , GActionEntry *entries ,
                                            gint n_entries , gpointer user_data ) ;
#line 148 "/usr/include/glib-2.0/gio/gappinfo.h"
extern GType g_app_info_get_type(void) ;
#line 150
extern GAppInfo *g_app_info_create_from_commandline(char const   *commandline , char const   *application_name ,
                                                    GAppInfoCreateFlags flags , GError **error ) ;
#line 155
extern GAppInfo *g_app_info_dup(GAppInfo *appinfo ) ;
#line 157
extern gboolean g_app_info_equal(GAppInfo *appinfo1 , GAppInfo *appinfo2 ) ;
#line 160
extern char const   *g_app_info_get_id(GAppInfo *appinfo ) ;
#line 162
extern char const   *g_app_info_get_name(GAppInfo *appinfo ) ;
#line 164
extern char const   *g_app_info_get_display_name(GAppInfo *appinfo ) ;
#line 166
extern char const   *g_app_info_get_description(GAppInfo *appinfo ) ;
#line 168
extern char const   *g_app_info_get_executable(GAppInfo *appinfo ) ;
#line 170
extern char const   *g_app_info_get_commandline(GAppInfo *appinfo ) ;
#line 172
extern GIcon *g_app_info_get_icon(GAppInfo *appinfo ) ;
#line 174
extern gboolean g_app_info_launch(GAppInfo *appinfo , GList *files , GAppLaunchContext *context ,
                                  GError **error ) ;
#line 179
extern gboolean g_app_info_supports_uris(GAppInfo *appinfo ) ;
#line 181
extern gboolean g_app_info_supports_files(GAppInfo *appinfo ) ;
#line 183
extern gboolean g_app_info_launch_uris(GAppInfo *appinfo , GList *uris , GAppLaunchContext *context ,
                                       GError **error ) ;
#line 188
extern void g_app_info_launch_uris_async(GAppInfo *appinfo , GList *uris , GAppLaunchContext *context ,
                                         GCancellable *cancellable , GAsyncReadyCallback callback ,
                                         gpointer user_data ) ;
#line 195
extern gboolean g_app_info_launch_uris_finish(GAppInfo *appinfo , GAsyncResult *result ,
                                              GError **error ) ;
#line 200
extern gboolean g_app_info_should_show(GAppInfo *appinfo ) ;
#line 203
extern gboolean g_app_info_set_as_default_for_type(GAppInfo *appinfo , char const   *content_type ,
                                                   GError **error ) ;
#line 207
extern gboolean g_app_info_set_as_default_for_extension(GAppInfo *appinfo , char const   *extension ,
                                                        GError **error ) ;
#line 211
extern gboolean g_app_info_add_supports_type(GAppInfo *appinfo , char const   *content_type ,
                                             GError **error ) ;
#line 215
extern gboolean g_app_info_can_remove_supports_type(GAppInfo *appinfo ) ;
#line 217
extern gboolean g_app_info_remove_supports_type(GAppInfo *appinfo , char const   *content_type ,
                                                GError **error ) ;
#line 221
extern char const   **g_app_info_get_supported_types(GAppInfo *appinfo ) ;
#line 224
extern gboolean g_app_info_can_delete(GAppInfo *appinfo ) ;
#line 226
extern gboolean g_app_info_delete(GAppInfo *appinfo ) ;
#line 229
extern gboolean g_app_info_set_as_last_used_for_type(GAppInfo *appinfo , char const   *content_type ,
                                                     GError **error ) ;
#line 234
extern GList *g_app_info_get_all(void) ;
#line 236
extern GList *g_app_info_get_all_for_type(char const   *content_type ) ;
#line 238
extern GList *g_app_info_get_recommended_for_type(gchar *content_type ) ;
#line 240
extern GList *g_app_info_get_fallback_for_type(gchar *content_type ) ;
#line 243
extern void g_app_info_reset_type_associations(char const   *content_type ) ;
#line 245
extern GAppInfo *g_app_info_get_default_for_type(char const   *content_type , gboolean must_support_uris ) ;
#line 248
extern GAppInfo *g_app_info_get_default_for_uri_scheme(char const   *uri_scheme ) ;
#line 251
extern gboolean g_app_info_launch_default_for_uri(char const   *uri , GAppLaunchContext *context ,
                                                  GError **error ) ;
#line 256
extern void g_app_info_launch_default_for_uri_async(char const   *uri , GAppLaunchContext *context ,
                                                    GCancellable *cancellable , GAsyncReadyCallback callback ,
                                                    gpointer user_data ) ;
#line 262
extern gboolean g_app_info_launch_default_for_uri_finish(GAsyncResult *result , GError **error ) ;
#line 307
extern GType g_app_launch_context_get_type(void) ;
#line 309
extern GAppLaunchContext *g_app_launch_context_new(void) ;
#line 312
extern void g_app_launch_context_setenv(GAppLaunchContext *context , char const   *variable ,
                                        char const   *value ) ;
#line 316
extern void g_app_launch_context_unsetenv(GAppLaunchContext *context , char const   *variable ) ;
#line 319
extern char **g_app_launch_context_get_environment(GAppLaunchContext *context ) ;
#line 322
extern char *g_app_launch_context_get_display(GAppLaunchContext *context , GAppInfo *info ,
                                              GList *files ) ;
#line 326
extern char *g_app_launch_context_get_startup_notify_id(GAppLaunchContext *context ,
                                                        GAppInfo *info , GList *files ) ;
#line 330
extern void g_app_launch_context_launch_failed(GAppLaunchContext *context , char const   *startup_notify_id ) ;
#line 342
extern GType g_app_info_monitor_get_type(void) ;
#line 345
extern GAppInfoMonitor *g_app_info_monitor_get(void) ;
#line 122 "/usr/include/glib-2.0/gio/gapplication.h"
extern GType g_application_get_type(void) ;
#line 125
extern gboolean g_application_id_is_valid(gchar *application_id ) ;
#line 128
extern GApplication *g_application_new(gchar *application_id , GApplicationFlags flags ) ;
#line 132
extern gchar *g_application_get_application_id(GApplication *application ) ;
#line 134
extern void g_application_set_application_id(GApplication *application , gchar *application_id ) ;
#line 138
extern GDBusConnection *g_application_get_dbus_connection(GApplication *application ) ;
#line 140
extern gchar *g_application_get_dbus_object_path(GApplication *application ) ;
#line 143
extern guint g_application_get_inactivity_timeout(GApplication *application ) ;
#line 145
extern void g_application_set_inactivity_timeout(GApplication *application , guint inactivity_timeout ) ;
#line 149
extern GApplicationFlags g_application_get_flags(GApplication *application ) ;
#line 151
extern void g_application_set_flags(GApplication *application , GApplicationFlags flags ) ;
#line 155
extern gchar *g_application_get_resource_base_path(GApplication *application ) ;
#line 157
extern void g_application_set_resource_base_path(GApplication *application , gchar *resource_path ) ;
#line 161
extern void g_application_set_action_group(GApplication *application , GActionGroup *action_group ) ;
#line 165
extern void g_application_add_main_option_entries(GApplication *application , GOptionEntry *entries ) ;
#line 169
extern void g_application_add_main_option(GApplication *application , char const   *long_name ,
                                          char short_name , GOptionFlags flags , GOptionArg arg ,
                                          char const   *description , char const   *arg_description ) ;
#line 177
extern void g_application_add_option_group(GApplication *application , GOptionGroup *group ) ;
#line 180
extern void g_application_set_option_context_parameter_string(GApplication *application ,
                                                              gchar *parameter_string ) ;
#line 183
extern void g_application_set_option_context_summary(GApplication *application , gchar *summary ) ;
#line 186
extern void g_application_set_option_context_description(GApplication *application ,
                                                         gchar *description ) ;
#line 189
extern gboolean g_application_get_is_registered(GApplication *application ) ;
#line 191
extern gboolean g_application_get_is_remote(GApplication *application ) ;
#line 194
extern gboolean g_application_register(GApplication *application , GCancellable *cancellable ,
                                       GError **error ) ;
#line 199
extern void g_application_hold(GApplication *application ) ;
#line 201
extern void g_application_release(GApplication *application ) ;
#line 204
extern void g_application_activate(GApplication *application ) ;
#line 207
extern void g_application_open(GApplication *application , GFile **files , gint n_files ,
                               gchar *hint ) ;
#line 213
extern int g_application_run(GApplication *application , int argc , char **argv ) ;
#line 218
extern void g_application_quit(GApplication *application ) ;
#line 221
extern GApplication *g_application_get_default(void) ;
#line 223
extern void g_application_set_default(GApplication *application ) ;
#line 226
extern void g_application_mark_busy(GApplication *application ) ;
#line 228
extern void g_application_unmark_busy(GApplication *application ) ;
#line 230
extern gboolean g_application_get_is_busy(GApplication *application ) ;
#line 233
extern void g_application_send_notification(GApplication *application , gchar *id ,
                                            GNotification *notification ) ;
#line 237
extern void g_application_withdraw_notification(GApplication *application , gchar *id ) ;
#line 241
extern void g_application_bind_busy_property(GApplication *application , gpointer object ,
                                             gchar *property ) ;
#line 246
extern void g_application_unbind_busy_property(GApplication *application , gpointer object ,
                                               gchar *property ) ;
#line 73 "/usr/include/glib-2.0/gio/gapplicationcommandline.h"
extern GType g_application_command_line_get_type(void) ;
#line 76
extern gchar **g_application_command_line_get_arguments(GApplicationCommandLine *cmdline ,
                                                        int *argc ) ;
#line 80
extern GVariantDict *g_application_command_line_get_options_dict(GApplicationCommandLine *cmdline ) ;
#line 83
extern GInputStream *g_application_command_line_get_stdin(GApplicationCommandLine *cmdline ) ;
#line 86
extern gchar * const  *g_application_command_line_get_environ(GApplicationCommandLine *cmdline ) ;
#line 89
extern gchar *g_application_command_line_getenv(GApplicationCommandLine *cmdline ,
                                                gchar *name ) ;
#line 93
extern gchar *g_application_command_line_get_cwd(GApplicationCommandLine *cmdline ) ;
#line 96
extern gboolean g_application_command_line_get_is_remote(GApplicationCommandLine *cmdline ) ;
#line 99
extern void g_application_command_line_print(GApplicationCommandLine *cmdline , gchar *format 
                                             , ...) ;
#line 103
extern void g_application_command_line_printerr(GApplicationCommandLine *cmdline ,
                                                gchar *format  , ...) ;
#line 108
extern int g_application_command_line_get_exit_status(GApplicationCommandLine *cmdline ) ;
#line 110
extern void g_application_command_line_set_exit_status(GApplicationCommandLine *cmdline ,
                                                       int exit_status ) ;
#line 114
extern GVariant *g_application_command_line_get_platform_data(GApplicationCommandLine *cmdline ) ;
#line 117
extern GFile *g_application_command_line_create_file_for_arg(GApplicationCommandLine *cmdline ,
                                                             gchar *arg ) ;
#line 70 "/usr/include/glib-2.0/gio/ginitable.h"
extern GType g_initable_get_type(void) ;
#line 73
extern gboolean g_initable_init(GInitable *initable , GCancellable *cancellable ,
                                GError **error ) ;
#line 78
extern gpointer g_initable_new(GType object_type , GCancellable *cancellable , GError **error ,
                               gchar *first_property_name  , ...) ;
#line 87
extern gpointer g_initable_newv(GType object_type , guint n_parameters , GParameter *parameters ,
                                GCancellable *cancellable , GError **error ) ;
#line 96
extern GObject *g_initable_new_valist(GType object_type , gchar *first_property_name ,
                                      va_list var_args , GCancellable *cancellable ,
                                      GError **error ) ;
#line 76 "/usr/include/glib-2.0/gio/gasyncinitable.h"
extern GType g_async_initable_get_type(void) ;
#line 80
extern void g_async_initable_init_async(GAsyncInitable *initable , int io_priority ,
                                        GCancellable *cancellable , GAsyncReadyCallback callback ,
                                        gpointer user_data ) ;
#line 86
extern gboolean g_async_initable_init_finish(GAsyncInitable *initable , GAsyncResult *res ,
                                             GError **error ) ;
#line 91
extern void g_async_initable_new_async(GType object_type , int io_priority , GCancellable *cancellable ,
                                       GAsyncReadyCallback callback , gpointer user_data ,
                                       gchar *first_property_name  , ...) ;
#line 102
extern void g_async_initable_newv_async(GType object_type , guint n_parameters , GParameter *parameters ,
                                        int io_priority , GCancellable *cancellable ,
                                        GAsyncReadyCallback callback , gpointer user_data ) ;
#line 113
extern void g_async_initable_new_valist_async(GType object_type , gchar *first_property_name ,
                                              va_list var_args , int io_priority ,
                                              GCancellable *cancellable , GAsyncReadyCallback callback ,
                                              gpointer user_data ) ;
#line 121
extern GObject *g_async_initable_new_finish(GAsyncInitable *initable , GAsyncResult *res ,
                                            GError **error ) ;
#line 69 "/usr/include/glib-2.0/gio/gasyncresult.h"
extern GType g_async_result_get_type(void) ;
#line 72
extern gpointer g_async_result_get_user_data(GAsyncResult *res ) ;
#line 74
extern GObject *g_async_result_get_source_object(GAsyncResult *res ) ;
#line 77
extern gboolean g_async_result_legacy_propagate_error(GAsyncResult *res , GError **error ) ;
#line 80
extern gboolean g_async_result_is_tagged(GAsyncResult *res , gpointer source_tag ) ;
#line 113 "/usr/include/glib-2.0/gio/ginputstream.h"
extern GType g_input_stream_get_type(void) ;
#line 116
extern gssize g_input_stream_read(GInputStream *stream , void *buffer , gsize count ,
                                  GCancellable *cancellable , GError **error ) ;
#line 122
extern gboolean g_input_stream_read_all(GInputStream *stream , void *buffer , gsize count ,
                                        gsize *bytes_read , GCancellable *cancellable ,
                                        GError **error ) ;
#line 129
extern GBytes *g_input_stream_read_bytes(GInputStream *stream , gsize count , GCancellable *cancellable ,
                                         GError **error ) ;
#line 134
extern gssize g_input_stream_skip(GInputStream *stream , gsize count , GCancellable *cancellable ,
                                  GError **error ) ;
#line 139
extern gboolean g_input_stream_close(GInputStream *stream , GCancellable *cancellable ,
                                     GError **error ) ;
#line 143
extern void g_input_stream_read_async(GInputStream *stream , void *buffer , gsize count ,
                                      int io_priority , GCancellable *cancellable ,
                                      GAsyncReadyCallback callback , gpointer user_data ) ;
#line 151
extern gssize g_input_stream_read_finish(GInputStream *stream , GAsyncResult *result ,
                                         GError **error ) ;
#line 156
extern void g_input_stream_read_all_async(GInputStream *stream , void *buffer , gsize count ,
                                          int io_priority , GCancellable *cancellable ,
                                          GAsyncReadyCallback callback , gpointer user_data ) ;
#line 164
extern gboolean g_input_stream_read_all_finish(GInputStream *stream , GAsyncResult *result ,
                                               gsize *bytes_read , GError **error ) ;
#line 170
extern void g_input_stream_read_bytes_async(GInputStream *stream , gsize count , int io_priority ,
                                            GCancellable *cancellable , GAsyncReadyCallback callback ,
                                            gpointer user_data ) ;
#line 177
extern GBytes *g_input_stream_read_bytes_finish(GInputStream *stream , GAsyncResult *result ,
                                                GError **error ) ;
#line 181
extern void g_input_stream_skip_async(GInputStream *stream , gsize count , int io_priority ,
                                      GCancellable *cancellable , GAsyncReadyCallback callback ,
                                      gpointer user_data ) ;
#line 188
extern gssize g_input_stream_skip_finish(GInputStream *stream , GAsyncResult *result ,
                                         GError **error ) ;
#line 192
extern void g_input_stream_close_async(GInputStream *stream , int io_priority , GCancellable *cancellable ,
                                       GAsyncReadyCallback callback , gpointer user_data ) ;
#line 198
extern gboolean g_input_stream_close_finish(GInputStream *stream , GAsyncResult *result ,
                                            GError **error ) ;
#line 205
extern gboolean g_input_stream_is_closed(GInputStream *stream ) ;
#line 207
extern gboolean g_input_stream_has_pending(GInputStream *stream ) ;
#line 209
extern gboolean g_input_stream_set_pending(GInputStream *stream , GError **error ) ;
#line 212
extern void g_input_stream_clear_pending(GInputStream *stream ) ;
#line 67 "/usr/include/glib-2.0/gio/gfilterinputstream.h"
extern GType g_filter_input_stream_get_type(void) ;
#line 69
extern GInputStream *g_filter_input_stream_get_base_stream(GFilterInputStream *stream ) ;
#line 71
extern gboolean g_filter_input_stream_get_close_base_stream(GFilterInputStream *stream ) ;
#line 73
extern void g_filter_input_stream_set_close_base_stream(GFilterInputStream *stream ,
                                                        gboolean close_base ) ;
#line 86 "/usr/include/glib-2.0/gio/gbufferedinputstream.h"
extern GType g_buffered_input_stream_get_type(void) ;
#line 88
extern GInputStream *g_buffered_input_stream_new(GInputStream *base_stream ) ;
#line 90
extern GInputStream *g_buffered_input_stream_new_sized(GInputStream *base_stream ,
                                                       gsize size ) ;
#line 94
extern gsize g_buffered_input_stream_get_buffer_size(GBufferedInputStream *stream ) ;
#line 96
extern void g_buffered_input_stream_set_buffer_size(GBufferedInputStream *stream ,
                                                    gsize size ) ;
#line 99
extern gsize g_buffered_input_stream_get_available(GBufferedInputStream *stream ) ;
#line 101
extern gsize g_buffered_input_stream_peek(GBufferedInputStream *stream , void *buffer ,
                                          gsize offset , gsize count ) ;
#line 106
extern void const   *g_buffered_input_stream_peek_buffer(GBufferedInputStream *stream ,
                                                         gsize *count ) ;
#line 110
extern gssize g_buffered_input_stream_fill(GBufferedInputStream *stream , gssize count ,
                                           GCancellable *cancellable , GError **error ) ;
#line 115
extern void g_buffered_input_stream_fill_async(GBufferedInputStream *stream , gssize count ,
                                               int io_priority , GCancellable *cancellable ,
                                               GAsyncReadyCallback callback , gpointer user_data ) ;
#line 122
extern gssize g_buffered_input_stream_fill_finish(GBufferedInputStream *stream , GAsyncResult *result ,
                                                  GError **error ) ;
#line 127
extern int g_buffered_input_stream_read_byte(GBufferedInputStream *stream , GCancellable *cancellable ,
                                             GError **error ) ;
#line 152 "/usr/include/glib-2.0/gio/goutputstream.h"
extern GType g_output_stream_get_type(void) ;
#line 155
extern gssize g_output_stream_write(GOutputStream *stream , void const   *buffer ,
                                    gsize count , GCancellable *cancellable , GError **error ) ;
#line 161
extern gboolean g_output_stream_write_all(GOutputStream *stream , void const   *buffer ,
                                          gsize count , gsize *bytes_written , GCancellable *cancellable ,
                                          GError **error ) ;
#line 169
extern gboolean g_output_stream_writev(GOutputStream *stream , GOutputVector *vectors ,
                                       gsize n_vectors , gsize *bytes_written , GCancellable *cancellable ,
                                       GError **error ) ;
#line 176
extern gboolean g_output_stream_writev_all(GOutputStream *stream , GOutputVector *vectors ,
                                           gsize n_vectors , gsize *bytes_written ,
                                           GCancellable *cancellable , GError **error ) ;
#line 184
extern gboolean g_output_stream_printf(GOutputStream *stream , gsize *bytes_written ,
                                       GCancellable *cancellable , GError **error ,
                                       gchar *format  , ...) ;
#line 191
extern gboolean g_output_stream_vprintf(GOutputStream *stream , gsize *bytes_written ,
                                        GCancellable *cancellable , GError **error ,
                                        gchar *format , va_list args ) ;
#line 198
extern gssize g_output_stream_write_bytes(GOutputStream *stream , GBytes *bytes ,
                                          GCancellable *cancellable , GError **error ) ;
#line 203
extern gssize g_output_stream_splice(GOutputStream *stream , GInputStream *source ,
                                     GOutputStreamSpliceFlags flags , GCancellable *cancellable ,
                                     GError **error ) ;
#line 209
extern gboolean g_output_stream_flush(GOutputStream *stream , GCancellable *cancellable ,
                                      GError **error ) ;
#line 213
extern gboolean g_output_stream_close(GOutputStream *stream , GCancellable *cancellable ,
                                      GError **error ) ;
#line 217
extern void g_output_stream_write_async(GOutputStream *stream , void const   *buffer ,
                                        gsize count , int io_priority , GCancellable *cancellable ,
                                        GAsyncReadyCallback callback , gpointer user_data ) ;
#line 225
extern gssize g_output_stream_write_finish(GOutputStream *stream , GAsyncResult *result ,
                                           GError **error ) ;
#line 230
extern void g_output_stream_write_all_async(GOutputStream *stream , void const   *buffer ,
                                            gsize count , int io_priority , GCancellable *cancellable ,
                                            GAsyncReadyCallback callback , gpointer user_data ) ;
#line 239
extern gboolean g_output_stream_write_all_finish(GOutputStream *stream , GAsyncResult *result ,
                                                 gsize *bytes_written , GError **error ) ;
#line 245
extern void g_output_stream_writev_async(GOutputStream *stream , GOutputVector *vectors ,
                                         gsize n_vectors , int io_priority , GCancellable *cancellable ,
                                         GAsyncReadyCallback callback , gpointer user_data ) ;
#line 253
extern gboolean g_output_stream_writev_finish(GOutputStream *stream , GAsyncResult *result ,
                                              gsize *bytes_written , GError **error ) ;
#line 259
extern void g_output_stream_writev_all_async(GOutputStream *stream , GOutputVector *vectors ,
                                             gsize n_vectors , int io_priority , GCancellable *cancellable ,
                                             GAsyncReadyCallback callback , gpointer user_data ) ;
#line 268
extern gboolean g_output_stream_writev_all_finish(GOutputStream *stream , GAsyncResult *result ,
                                                  gsize *bytes_written , GError **error ) ;
#line 274
extern void g_output_stream_write_bytes_async(GOutputStream *stream , GBytes *bytes ,
                                              int io_priority , GCancellable *cancellable ,
                                              GAsyncReadyCallback callback , gpointer user_data ) ;
#line 281
extern gssize g_output_stream_write_bytes_finish(GOutputStream *stream , GAsyncResult *result ,
                                                 GError **error ) ;
#line 285
extern void g_output_stream_splice_async(GOutputStream *stream , GInputStream *source ,
                                         GOutputStreamSpliceFlags flags , int io_priority ,
                                         GCancellable *cancellable , GAsyncReadyCallback callback ,
                                         gpointer user_data ) ;
#line 293
extern gssize g_output_stream_splice_finish(GOutputStream *stream , GAsyncResult *result ,
                                            GError **error ) ;
#line 297
extern void g_output_stream_flush_async(GOutputStream *stream , int io_priority ,
                                        GCancellable *cancellable , GAsyncReadyCallback callback ,
                                        gpointer user_data ) ;
#line 303
extern gboolean g_output_stream_flush_finish(GOutputStream *stream , GAsyncResult *result ,
                                             GError **error ) ;
#line 307
extern void g_output_stream_close_async(GOutputStream *stream , int io_priority ,
                                        GCancellable *cancellable , GAsyncReadyCallback callback ,
                                        gpointer user_data ) ;
#line 313
extern gboolean g_output_stream_close_finish(GOutputStream *stream , GAsyncResult *result ,
                                             GError **error ) ;
#line 318
extern gboolean g_output_stream_is_closed(GOutputStream *stream ) ;
#line 320
extern gboolean g_output_stream_is_closing(GOutputStream *stream ) ;
#line 322
extern gboolean g_output_stream_has_pending(GOutputStream *stream ) ;
#line 324
extern gboolean g_output_stream_set_pending(GOutputStream *stream , GError **error ) ;
#line 327
extern void g_output_stream_clear_pending(GOutputStream *stream ) ;
#line 67 "/usr/include/glib-2.0/gio/gfilteroutputstream.h"
extern GType g_filter_output_stream_get_type(void) ;
#line 69
extern GOutputStream *g_filter_output_stream_get_base_stream(GFilterOutputStream *stream ) ;
#line 71
extern gboolean g_filter_output_stream_get_close_base_stream(GFilterOutputStream *stream ) ;
#line 73
extern void g_filter_output_stream_set_close_base_stream(GFilterOutputStream *stream ,
                                                         gboolean close_base ) ;
#line 67 "/usr/include/glib-2.0/gio/gbufferedoutputstream.h"
extern GType g_buffered_output_stream_get_type(void) ;
#line 69
extern GOutputStream *g_buffered_output_stream_new(GOutputStream *base_stream ) ;
#line 71
extern GOutputStream *g_buffered_output_stream_new_sized(GOutputStream *base_stream ,
                                                         gsize size ) ;
#line 74
extern gsize g_buffered_output_stream_get_buffer_size(GBufferedOutputStream *stream ) ;
#line 76
extern void g_buffered_output_stream_set_buffer_size(GBufferedOutputStream *stream ,
                                                     gsize size ) ;
#line 79
extern gboolean g_buffered_output_stream_get_auto_grow(GBufferedOutputStream *stream ) ;
#line 81
extern void g_buffered_output_stream_set_auto_grow(GBufferedOutputStream *stream ,
                                                   gboolean auto_grow ) ;
#line 42 "/usr/include/glib-2.0/gio/gbytesicon.h"
extern GType g_bytes_icon_get_type(void) ;
#line 45
extern GIcon *g_bytes_icon_new(GBytes *bytes ) ;
#line 48
extern GBytes *g_bytes_icon_get_bytes(GBytesIcon *icon ) ;
#line 71 "/usr/include/glib-2.0/gio/gcancellable.h"
extern GType g_cancellable_get_type(void) ;
#line 74
extern GCancellable *g_cancellable_new(void) ;
#line 78
extern gboolean g_cancellable_is_cancelled(GCancellable *cancellable ) ;
#line 80
extern gboolean g_cancellable_set_error_if_cancelled(GCancellable *cancellable , GError **error ) ;
#line 84
extern int g_cancellable_get_fd(GCancellable *cancellable ) ;
#line 86
extern gboolean g_cancellable_make_pollfd(GCancellable *cancellable , GPollFD *pollfd ) ;
#line 89
extern void g_cancellable_release_fd(GCancellable *cancellable ) ;
#line 92
extern GSource *g_cancellable_source_new(GCancellable *cancellable ) ;
#line 95
extern GCancellable *g_cancellable_get_current(void) ;
#line 97
extern void g_cancellable_push_current(GCancellable *cancellable ) ;
#line 99
extern void g_cancellable_pop_current(GCancellable *cancellable ) ;
#line 101
extern void g_cancellable_reset(GCancellable *cancellable ) ;
#line 103
extern gulong g_cancellable_connect(GCancellable *cancellable , GCallback callback ,
                                    gpointer data , GDestroyNotify data_destroy_func ) ;
#line 108
extern void g_cancellable_disconnect(GCancellable *cancellable , gulong handler_id ) ;
#line 114
extern void g_cancellable_cancel(GCancellable *cancellable ) ;
#line 77 "/usr/include/glib-2.0/gio/gconverter.h"
extern GType g_converter_get_type(void) ;
#line 80
extern GConverterResult g_converter_convert(GConverter *converter , void const   *inbuf ,
                                            gsize inbuf_size , void *outbuf , gsize outbuf_size ,
                                            GConverterFlags flags , gsize *bytes_read ,
                                            gsize *bytes_written , GError **error ) ;
#line 90
extern void g_converter_reset(GConverter *converter ) ;
#line 47 "/usr/include/glib-2.0/gio/gcharsetconverter.h"
extern GType g_charset_converter_get_type(void) ;
#line 50
extern GCharsetConverter *g_charset_converter_new(gchar *to_charset , gchar *from_charset ,
                                                  GError **error ) ;
#line 54
extern void g_charset_converter_set_use_fallback(GCharsetConverter *converter , gboolean use_fallback ) ;
#line 57
extern gboolean g_charset_converter_get_use_fallback(GCharsetConverter *converter ) ;
#line 59
extern guint g_charset_converter_get_num_fallbacks(GCharsetConverter *converter ) ;
#line 33 "/usr/include/glib-2.0/gio/gcontenttype.h"
extern gboolean g_content_type_equals(gchar *type1 , gchar *type2 ) ;
#line 36
extern gboolean g_content_type_is_a(gchar *type , gchar *supertype ) ;
#line 39
extern gboolean g_content_type_is_mime_type(gchar *type , gchar *mime_type ) ;
#line 42
extern gboolean g_content_type_is_unknown(gchar *type ) ;
#line 44
extern gchar *g_content_type_get_description(gchar *type ) ;
#line 46
extern gchar *g_content_type_get_mime_type(gchar *type ) ;
#line 48
extern GIcon *g_content_type_get_icon(gchar *type ) ;
#line 50
extern GIcon *g_content_type_get_symbolic_icon(gchar *type ) ;
#line 52
extern gchar *g_content_type_get_generic_icon_name(gchar *type ) ;
#line 55
extern gboolean g_content_type_can_be_executable(gchar *type ) ;
#line 58
extern gchar *g_content_type_from_mime_type(gchar *mime_type ) ;
#line 61
extern gchar *g_content_type_guess(gchar *filename , guchar *data , gsize data_size ,
                                   gboolean *result_uncertain ) ;
#line 67
extern gchar **g_content_type_guess_for_tree(GFile *root ) ;
#line 70
extern GList *g_content_types_get_registered(void) ;
#line 75
extern gchar * const  *g_content_type_get_mime_dirs(void) ;
#line 77
extern void g_content_type_set_mime_dirs(gchar * const  *dirs ) ;
#line 71 "/usr/include/glib-2.0/gio/gconverterinputstream.h"
extern GType g_converter_input_stream_get_type(void) ;
#line 73
extern GInputStream *g_converter_input_stream_new(GInputStream *base_stream , GConverter *converter ) ;
#line 76
extern GConverter *g_converter_input_stream_get_converter(GConverterInputStream *converter_stream ) ;
#line 71 "/usr/include/glib-2.0/gio/gconverteroutputstream.h"
extern GType g_converter_output_stream_get_type(void) ;
#line 73
extern GOutputStream *g_converter_output_stream_new(GOutputStream *base_stream , GConverter *converter ) ;
#line 76
extern GConverter *g_converter_output_stream_get_converter(GConverterOutputStream *converter_stream ) ;
#line 48 "/usr/include/glib-2.0/gio/gcredentials.h"
extern GType g_credentials_get_type(void) ;
#line 51
extern GCredentials *g_credentials_new(void) ;
#line 54
extern gchar *g_credentials_to_string(GCredentials *credentials ) ;
#line 57
extern gpointer g_credentials_get_native(GCredentials *credentials , GCredentialsType native_type ) ;
#line 61
extern void g_credentials_set_native(GCredentials *credentials , GCredentialsType native_type ,
                                     gpointer native ) ;
#line 66
extern gboolean g_credentials_is_same_user(GCredentials *credentials , GCredentials *other_credentials ,
                                           GError **error ) ;
#line 72
extern pid_t g_credentials_get_unix_pid(GCredentials *credentials , GError **error ) ;
#line 75
extern uid_t g_credentials_get_unix_user(GCredentials *credentials , GError **error ) ;
#line 78
extern gboolean g_credentials_set_unix_user(GCredentials *credentials , uid_t uid ,
                                            GError **error ) ;
#line 103 "/usr/include/glib-2.0/gio/gdatagrambased.h"
extern GType g_datagram_based_get_type(void) ;
#line 107
extern gint g_datagram_based_receive_messages(GDatagramBased *datagram_based , GInputMessage *messages ,
                                              guint num_messages , gint flags , gint64 timeout ,
                                              GCancellable *cancellable , GError **error ) ;
#line 117
extern gint g_datagram_based_send_messages(GDatagramBased *datagram_based , GOutputMessage *messages ,
                                           guint num_messages , gint flags , gint64 timeout ,
                                           GCancellable *cancellable , GError **error ) ;
#line 127
extern GSource *g_datagram_based_create_source(GDatagramBased *datagram_based , GIOCondition condition ,
                                               GCancellable *cancellable ) ;
#line 132
extern GIOCondition g_datagram_based_condition_check(GDatagramBased *datagram_based ,
                                                     GIOCondition condition ) ;
#line 136
extern gboolean g_datagram_based_condition_wait(GDatagramBased *datagram_based , GIOCondition condition ,
                                                gint64 timeout , GCancellable *cancellable ,
                                                GError **error ) ;
#line 70 "/usr/include/glib-2.0/gio/gdatainputstream.h"
extern GType g_data_input_stream_get_type(void) ;
#line 72
extern GDataInputStream *g_data_input_stream_new(GInputStream *base_stream ) ;
#line 75
extern void g_data_input_stream_set_byte_order(GDataInputStream *stream , GDataStreamByteOrder order ) ;
#line 78
extern GDataStreamByteOrder g_data_input_stream_get_byte_order(GDataInputStream *stream ) ;
#line 80
extern void g_data_input_stream_set_newline_type(GDataInputStream *stream , GDataStreamNewlineType type ) ;
#line 83
extern GDataStreamNewlineType g_data_input_stream_get_newline_type(GDataInputStream *stream ) ;
#line 85
extern guchar g_data_input_stream_read_byte(GDataInputStream *stream , GCancellable *cancellable ,
                                            GError **error ) ;
#line 89
extern gint16 g_data_input_stream_read_int16(GDataInputStream *stream , GCancellable *cancellable ,
                                             GError **error ) ;
#line 93
extern guint16 g_data_input_stream_read_uint16(GDataInputStream *stream , GCancellable *cancellable ,
                                               GError **error ) ;
#line 97
extern gint32 g_data_input_stream_read_int32(GDataInputStream *stream , GCancellable *cancellable ,
                                             GError **error ) ;
#line 101
extern guint32 g_data_input_stream_read_uint32(GDataInputStream *stream , GCancellable *cancellable ,
                                               GError **error ) ;
#line 105
extern gint64 g_data_input_stream_read_int64(GDataInputStream *stream , GCancellable *cancellable ,
                                             GError **error ) ;
#line 109
extern guint64 g_data_input_stream_read_uint64(GDataInputStream *stream , GCancellable *cancellable ,
                                               GError **error ) ;
#line 113
extern char *g_data_input_stream_read_line(GDataInputStream *stream , gsize *length ,
                                           GCancellable *cancellable , GError **error ) ;
#line 118
extern char *g_data_input_stream_read_line_utf8(GDataInputStream *stream , gsize *length ,
                                                GCancellable *cancellable , GError **error ) ;
#line 123
extern void g_data_input_stream_read_line_async(GDataInputStream *stream , gint io_priority ,
                                                GCancellable *cancellable , GAsyncReadyCallback callback ,
                                                gpointer user_data ) ;
#line 129
extern char *g_data_input_stream_read_line_finish(GDataInputStream *stream , GAsyncResult *result ,
                                                  gsize *length , GError **error ) ;
#line 134
extern char *g_data_input_stream_read_line_finish_utf8(GDataInputStream *stream ,
                                                       GAsyncResult *result , gsize *length ,
                                                       GError **error ) ;
#line 139
extern char *g_data_input_stream_read_until(GDataInputStream *stream , gchar *stop_chars ,
                                            gsize *length , GCancellable *cancellable ,
                                            GError **error ) ;
#line 145
extern void g_data_input_stream_read_until_async(GDataInputStream *stream , gchar *stop_chars ,
                                                 gint io_priority , GCancellable *cancellable ,
                                                 GAsyncReadyCallback callback , gpointer user_data ) ;
#line 152
extern char *g_data_input_stream_read_until_finish(GDataInputStream *stream , GAsyncResult *result ,
                                                   gsize *length , GError **error ) ;
#line 158
extern char *g_data_input_stream_read_upto(GDataInputStream *stream , gchar *stop_chars ,
                                           gssize stop_chars_len , gsize *length ,
                                           GCancellable *cancellable , GError **error ) ;
#line 165
extern void g_data_input_stream_read_upto_async(GDataInputStream *stream , gchar *stop_chars ,
                                                gssize stop_chars_len , gint io_priority ,
                                                GCancellable *cancellable , GAsyncReadyCallback callback ,
                                                gpointer user_data ) ;
#line 173
extern char *g_data_input_stream_read_upto_finish(GDataInputStream *stream , GAsyncResult *result ,
                                                  gsize *length , GError **error ) ;
#line 72 "/usr/include/glib-2.0/gio/gdataoutputstream.h"
extern GType g_data_output_stream_get_type(void) ;
#line 74
extern GDataOutputStream *g_data_output_stream_new(GOutputStream *base_stream ) ;
#line 77
extern void g_data_output_stream_set_byte_order(GDataOutputStream *stream , GDataStreamByteOrder order ) ;
#line 80
extern GDataStreamByteOrder g_data_output_stream_get_byte_order(GDataOutputStream *stream ) ;
#line 83
extern gboolean g_data_output_stream_put_byte(GDataOutputStream *stream , guchar data ,
                                              GCancellable *cancellable , GError **error ) ;
#line 88
extern gboolean g_data_output_stream_put_int16(GDataOutputStream *stream , gint16 data ,
                                               GCancellable *cancellable , GError **error ) ;
#line 93
extern gboolean g_data_output_stream_put_uint16(GDataOutputStream *stream , guint16 data ,
                                                GCancellable *cancellable , GError **error ) ;
#line 98
extern gboolean g_data_output_stream_put_int32(GDataOutputStream *stream , gint32 data ,
                                               GCancellable *cancellable , GError **error ) ;
#line 103
extern gboolean g_data_output_stream_put_uint32(GDataOutputStream *stream , guint32 data ,
                                                GCancellable *cancellable , GError **error ) ;
#line 108
extern gboolean g_data_output_stream_put_int64(GDataOutputStream *stream , gint64 data ,
                                               GCancellable *cancellable , GError **error ) ;
#line 113
extern gboolean g_data_output_stream_put_uint64(GDataOutputStream *stream , guint64 data ,
                                                GCancellable *cancellable , GError **error ) ;
#line 118
extern gboolean g_data_output_stream_put_string(GDataOutputStream *stream , char const   *str ,
                                                GCancellable *cancellable , GError **error ) ;
#line 45 "/usr/include/glib-2.0/gio/gdbusactiongroup.h"
extern GType g_dbus_action_group_get_type(void) ;
#line 48
extern GDBusActionGroup *g_dbus_action_group_get(GDBusConnection *connection , gchar *bus_name ,
                                                 gchar *object_path ) ;
#line 33 "/usr/include/glib-2.0/gio/gdbusaddress.h"
extern gchar *g_dbus_address_escape_value(gchar *string ) ;
#line 36
extern gboolean g_dbus_is_address(gchar *string ) ;
#line 38
extern gboolean g_dbus_is_supported_address(gchar *string , GError **error ) ;
#line 42
extern void g_dbus_address_get_stream(gchar *address , GCancellable *cancellable ,
                                      GAsyncReadyCallback callback , gpointer user_data ) ;
#line 48
extern GIOStream *g_dbus_address_get_stream_finish(GAsyncResult *res , gchar **out_guid ,
                                                   GError **error ) ;
#line 53
extern GIOStream *g_dbus_address_get_stream_sync(gchar *address , gchar **out_guid ,
                                                 GCancellable *cancellable , GError **error ) ;
#line 59
extern gchar *g_dbus_address_get_for_bus_sync(GBusType bus_type , GCancellable *cancellable ,
                                              GError **error ) ;
#line 37 "/usr/include/glib-2.0/gio/gdbusauthobserver.h"
extern GType g_dbus_auth_observer_get_type(void) ;
#line 39
extern GDBusAuthObserver *g_dbus_auth_observer_new(void) ;
#line 41
extern gboolean g_dbus_auth_observer_authorize_authenticated_peer(GDBusAuthObserver *observer ,
                                                                  GIOStream *stream ,
                                                                  GCredentials *credentials ) ;
#line 46
extern gboolean g_dbus_auth_observer_allow_mechanism(GDBusAuthObserver *observer ,
                                                     gchar *mechanism ) ;
#line 37 "/usr/include/glib-2.0/gio/gdbusconnection.h"
extern GType g_dbus_connection_get_type(void) ;
#line 42
extern void g_bus_get(GBusType bus_type , GCancellable *cancellable , GAsyncReadyCallback callback ,
                      gpointer user_data ) ;
#line 47
extern GDBusConnection *g_bus_get_finish(GAsyncResult *res , GError **error ) ;
#line 50
extern GDBusConnection *g_bus_get_sync(GBusType bus_type , GCancellable *cancellable ,
                                       GError **error ) ;
#line 57
extern void g_dbus_connection_new(GIOStream *stream , gchar *guid , GDBusConnectionFlags flags ,
                                  GDBusAuthObserver *observer , GCancellable *cancellable ,
                                  GAsyncReadyCallback callback , gpointer user_data ) ;
#line 65
extern GDBusConnection *g_dbus_connection_new_finish(GAsyncResult *res , GError **error ) ;
#line 68
extern GDBusConnection *g_dbus_connection_new_sync(GIOStream *stream , gchar *guid ,
                                                   GDBusConnectionFlags flags , GDBusAuthObserver *observer ,
                                                   GCancellable *cancellable , GError **error ) ;
#line 76
extern void g_dbus_connection_new_for_address(gchar *address , GDBusConnectionFlags flags ,
                                              GDBusAuthObserver *observer , GCancellable *cancellable ,
                                              GAsyncReadyCallback callback , gpointer user_data ) ;
#line 83
extern GDBusConnection *g_dbus_connection_new_for_address_finish(GAsyncResult *res ,
                                                                 GError **error ) ;
#line 86
extern GDBusConnection *g_dbus_connection_new_for_address_sync(gchar *address , GDBusConnectionFlags flags ,
                                                               GDBusAuthObserver *observer ,
                                                               GCancellable *cancellable ,
                                                               GError **error ) ;
#line 95
extern void g_dbus_connection_start_message_processing(GDBusConnection *connection ) ;
#line 97
extern gboolean g_dbus_connection_is_closed(GDBusConnection *connection ) ;
#line 99
extern GIOStream *g_dbus_connection_get_stream(GDBusConnection *connection ) ;
#line 101
extern gchar *g_dbus_connection_get_guid(GDBusConnection *connection ) ;
#line 103
extern gchar *g_dbus_connection_get_unique_name(GDBusConnection *connection ) ;
#line 105
extern GCredentials *g_dbus_connection_get_peer_credentials(GDBusConnection *connection ) ;
#line 108
extern guint32 g_dbus_connection_get_last_serial(GDBusConnection *connection ) ;
#line 111
extern gboolean g_dbus_connection_get_exit_on_close(GDBusConnection *connection ) ;
#line 113
extern void g_dbus_connection_set_exit_on_close(GDBusConnection *connection , gboolean exit_on_close ) ;
#line 116
extern GDBusCapabilityFlags g_dbus_connection_get_capabilities(GDBusConnection *connection ) ;
#line 118
extern GDBusConnectionFlags g_dbus_connection_get_flags(GDBusConnection *connection ) ;
#line 123
extern void g_dbus_connection_close(GDBusConnection *connection , GCancellable *cancellable ,
                                    GAsyncReadyCallback callback , gpointer user_data ) ;
#line 128
extern gboolean g_dbus_connection_close_finish(GDBusConnection *connection , GAsyncResult *res ,
                                               GError **error ) ;
#line 132
extern gboolean g_dbus_connection_close_sync(GDBusConnection *connection , GCancellable *cancellable ,
                                             GError **error ) ;
#line 139
extern void g_dbus_connection_flush(GDBusConnection *connection , GCancellable *cancellable ,
                                    GAsyncReadyCallback callback , gpointer user_data ) ;
#line 144
extern gboolean g_dbus_connection_flush_finish(GDBusConnection *connection , GAsyncResult *res ,
                                               GError **error ) ;
#line 148
extern gboolean g_dbus_connection_flush_sync(GDBusConnection *connection , GCancellable *cancellable ,
                                             GError **error ) ;
#line 155
extern gboolean g_dbus_connection_send_message(GDBusConnection *connection , GDBusMessage *message ,
                                               GDBusSendMessageFlags flags , guint32 *out_serial ,
                                               GError **error ) ;
#line 161
extern void g_dbus_connection_send_message_with_reply(GDBusConnection *connection ,
                                                      GDBusMessage *message , GDBusSendMessageFlags flags ,
                                                      gint timeout_msec , guint32 *out_serial ,
                                                      GCancellable *cancellable ,
                                                      GAsyncReadyCallback callback ,
                                                      gpointer user_data ) ;
#line 170
extern GDBusMessage *g_dbus_connection_send_message_with_reply_finish(GDBusConnection *connection ,
                                                                      GAsyncResult *res ,
                                                                      GError **error ) ;
#line 174
extern GDBusMessage *g_dbus_connection_send_message_with_reply_sync(GDBusConnection *connection ,
                                                                    GDBusMessage *message ,
                                                                    GDBusSendMessageFlags flags ,
                                                                    gint timeout_msec ,
                                                                    guint32 *out_serial ,
                                                                    GCancellable *cancellable ,
                                                                    GError **error ) ;
#line 185
extern gboolean g_dbus_connection_emit_signal(GDBusConnection *connection , gchar *destination_bus_name ,
                                              gchar *object_path , gchar *interface_name ,
                                              gchar *signal_name , GVariant *parameters ,
                                              GError **error ) ;
#line 193
extern void g_dbus_connection_call(GDBusConnection *connection , gchar *bus_name ,
                                   gchar *object_path , gchar *interface_name , gchar *method_name ,
                                   GVariant *parameters , GVariantType *reply_type ,
                                   GDBusCallFlags flags , gint timeout_msec , GCancellable *cancellable ,
                                   GAsyncReadyCallback callback , gpointer user_data ) ;
#line 206
extern GVariant *g_dbus_connection_call_finish(GDBusConnection *connection , GAsyncResult *res ,
                                               GError **error ) ;
#line 210
extern GVariant *g_dbus_connection_call_sync(GDBusConnection *connection , gchar *bus_name ,
                                             gchar *object_path , gchar *interface_name ,
                                             gchar *method_name , GVariant *parameters ,
                                             GVariantType *reply_type , GDBusCallFlags flags ,
                                             gint timeout_msec , GCancellable *cancellable ,
                                             GError **error ) ;
#line 222
extern void g_dbus_connection_call_with_unix_fd_list(GDBusConnection *connection ,
                                                     gchar *bus_name , gchar *object_path ,
                                                     gchar *interface_name , gchar *method_name ,
                                                     GVariant *parameters , GVariantType *reply_type ,
                                                     GDBusCallFlags flags , gint timeout_msec ,
                                                     GUnixFDList *fd_list , GCancellable *cancellable ,
                                                     GAsyncReadyCallback callback ,
                                                     gpointer user_data ) ;
#line 236
extern GVariant *g_dbus_connection_call_with_unix_fd_list_finish(GDBusConnection *connection ,
                                                                 GUnixFDList **out_fd_list ,
                                                                 GAsyncResult *res ,
                                                                 GError **error ) ;
#line 241
extern GVariant *g_dbus_connection_call_with_unix_fd_list_sync(GDBusConnection *connection ,
                                                               gchar *bus_name , gchar *object_path ,
                                                               gchar *interface_name ,
                                                               gchar *method_name ,
                                                               GVariant *parameters ,
                                                               GVariantType *reply_type ,
                                                               GDBusCallFlags flags ,
                                                               gint timeout_msec ,
                                                               GUnixFDList *fd_list ,
                                                               GUnixFDList **out_fd_list ,
                                                               GCancellable *cancellable ,
                                                               GError **error ) ;
#line 399
extern guint g_dbus_connection_register_object(GDBusConnection *connection , gchar *object_path ,
                                               GDBusInterfaceInfo *interface_info ,
                                               GDBusInterfaceVTable *vtable , gpointer user_data ,
                                               GDestroyNotify user_data_free_func ,
                                               GError **error ) ;
#line 407
extern guint g_dbus_connection_register_object_with_closures(GDBusConnection *connection ,
                                                             gchar *object_path ,
                                                             GDBusInterfaceInfo *interface_info ,
                                                             GClosure *method_call_closure ,
                                                             GClosure *get_property_closure ,
                                                             GClosure *set_property_closure ,
                                                             GError **error ) ;
#line 415
extern gboolean g_dbus_connection_unregister_object(GDBusConnection *connection ,
                                                    guint registration_id ) ;
#line 537
extern guint g_dbus_connection_register_subtree(GDBusConnection *connection , gchar *object_path ,
                                                GDBusSubtreeVTable *vtable , GDBusSubtreeFlags flags ,
                                                gpointer user_data , GDestroyNotify user_data_free_func ,
                                                GError **error ) ;
#line 545
extern gboolean g_dbus_connection_unregister_subtree(GDBusConnection *connection ,
                                                     guint registration_id ) ;
#line 574
extern guint g_dbus_connection_signal_subscribe(GDBusConnection *connection , gchar *sender ,
                                                gchar *interface_name , gchar *member ,
                                                gchar *object_path , gchar *arg0 ,
                                                GDBusSignalFlags flags , GDBusSignalCallback callback ,
                                                gpointer user_data , GDestroyNotify user_data_free_func ) ;
#line 585
extern void g_dbus_connection_signal_unsubscribe(GDBusConnection *connection , guint subscription_id ) ;
#line 670
extern guint g_dbus_connection_add_filter(GDBusConnection *connection , GDBusMessageFilterFunction filter_function ,
                                          gpointer user_data , GDestroyNotify user_data_free_func ) ;
#line 676
extern void g_dbus_connection_remove_filter(GDBusConnection *connection , guint filter_id ) ;
#line 49 "/usr/include/glib-2.0/gio/gdbuserror.h"
extern GQuark g_dbus_error_quark(void) ;
#line 53
extern gboolean g_dbus_error_is_remote_error(GError *error ) ;
#line 55
extern gchar *g_dbus_error_get_remote_error(GError *error ) ;
#line 57
extern gboolean g_dbus_error_strip_remote_error(GError *error ) ;
#line 75
extern gboolean g_dbus_error_register_error(GQuark error_domain , gint error_code ,
                                            gchar *dbus_error_name ) ;
#line 79
extern gboolean g_dbus_error_unregister_error(GQuark error_domain , gint error_code ,
                                              gchar *dbus_error_name ) ;
#line 83
extern void g_dbus_error_register_error_domain(gchar *error_domain_quark_name , gsize *quark_volatile ,
                                               GDBusErrorEntry *entries , guint num_entries ) ;
#line 90
extern GError *g_dbus_error_new_for_dbus_error(gchar *dbus_error_name , gchar *dbus_error_message ) ;
#line 93
extern void g_dbus_error_set_dbus_error(GError **error , gchar *dbus_error_name ,
                                        gchar *dbus_error_message , gchar *format 
                                        , ...) ;
#line 99
extern void g_dbus_error_set_dbus_error_valist(GError **error , gchar *dbus_error_name ,
                                               gchar *dbus_error_message , gchar *format ,
                                               va_list var_args ) ;
#line 105
extern gchar *g_dbus_error_encode_gerror(GError *error ) ;
#line 68 "/usr/include/glib-2.0/gio/gdbusinterface.h"
extern GType g_dbus_interface_get_type(void) ;
#line 70
extern GDBusInterfaceInfo *g_dbus_interface_get_info(GDBusInterface *interface_ ) ;
#line 72
extern GDBusObject *g_dbus_interface_get_object(GDBusInterface *interface_ ) ;
#line 74
extern void g_dbus_interface_set_object(GDBusInterface *interface_ , GDBusObject *object ) ;
#line 77
extern GDBusObject *g_dbus_interface_dup_object(GDBusInterface *interface_ ) ;
#line 89 "/usr/include/glib-2.0/gio/gdbusinterfaceskeleton.h"
extern GType g_dbus_interface_skeleton_get_type(void) ;
#line 91
extern GDBusInterfaceSkeletonFlags g_dbus_interface_skeleton_get_flags(GDBusInterfaceSkeleton *interface_ ) ;
#line 93
extern void g_dbus_interface_skeleton_set_flags(GDBusInterfaceSkeleton *interface_ ,
                                                GDBusInterfaceSkeletonFlags flags ) ;
#line 96
extern GDBusInterfaceInfo *g_dbus_interface_skeleton_get_info(GDBusInterfaceSkeleton *interface_ ) ;
#line 98
extern GDBusInterfaceVTable *g_dbus_interface_skeleton_get_vtable(GDBusInterfaceSkeleton *interface_ ) ;
#line 100
extern GVariant *g_dbus_interface_skeleton_get_properties(GDBusInterfaceSkeleton *interface_ ) ;
#line 102
extern void g_dbus_interface_skeleton_flush(GDBusInterfaceSkeleton *interface_ ) ;
#line 105
extern gboolean g_dbus_interface_skeleton_export(GDBusInterfaceSkeleton *interface_ ,
                                                 GDBusConnection *connection , gchar *object_path ,
                                                 GError **error ) ;
#line 110
extern void g_dbus_interface_skeleton_unexport(GDBusInterfaceSkeleton *interface_ ) ;
#line 112
extern void g_dbus_interface_skeleton_unexport_from_connection(GDBusInterfaceSkeleton *interface_ ,
                                                               GDBusConnection *connection ) ;
#line 116
extern GDBusConnection *g_dbus_interface_skeleton_get_connection(GDBusInterfaceSkeleton *interface_ ) ;
#line 118
extern GList *g_dbus_interface_skeleton_get_connections(GDBusInterfaceSkeleton *interface_ ) ;
#line 120
extern gboolean g_dbus_interface_skeleton_has_connection(GDBusInterfaceSkeleton *interface_ ,
                                                         GDBusConnection *connection ) ;
#line 123
extern gchar *g_dbus_interface_skeleton_get_object_path(GDBusInterfaceSkeleton *interface_ ) ;
#line 183 "/usr/include/glib-2.0/gio/gdbusintrospection.h"
extern gchar *g_dbus_annotation_info_lookup(GDBusAnnotationInfo **annotations , gchar *name ) ;
#line 186
extern GDBusMethodInfo *g_dbus_interface_info_lookup_method(GDBusInterfaceInfo *info ,
                                                            gchar *name ) ;
#line 189
extern GDBusSignalInfo *g_dbus_interface_info_lookup_signal(GDBusInterfaceInfo *info ,
                                                            gchar *name ) ;
#line 192
extern GDBusPropertyInfo *g_dbus_interface_info_lookup_property(GDBusInterfaceInfo *info ,
                                                                gchar *name ) ;
#line 195
extern void g_dbus_interface_info_cache_build(GDBusInterfaceInfo *info ) ;
#line 197
extern void g_dbus_interface_info_cache_release(GDBusInterfaceInfo *info ) ;
#line 200
extern void g_dbus_interface_info_generate_xml(GDBusInterfaceInfo *info , guint indent ,
                                               GString *string_builder ) ;
#line 205
extern GDBusNodeInfo *g_dbus_node_info_new_for_xml(gchar *xml_data , GError **error ) ;
#line 208
extern GDBusInterfaceInfo *g_dbus_node_info_lookup_interface(GDBusNodeInfo *info ,
                                                             gchar *name ) ;
#line 211
extern void g_dbus_node_info_generate_xml(GDBusNodeInfo *info , guint indent , GString *string_builder ) ;
#line 216
extern GDBusNodeInfo *g_dbus_node_info_ref(GDBusNodeInfo *info ) ;
#line 218
extern GDBusInterfaceInfo *g_dbus_interface_info_ref(GDBusInterfaceInfo *info ) ;
#line 220
extern GDBusMethodInfo *g_dbus_method_info_ref(GDBusMethodInfo *info ) ;
#line 222
extern GDBusSignalInfo *g_dbus_signal_info_ref(GDBusSignalInfo *info ) ;
#line 224
extern GDBusPropertyInfo *g_dbus_property_info_ref(GDBusPropertyInfo *info ) ;
#line 226
extern GDBusArgInfo *g_dbus_arg_info_ref(GDBusArgInfo *info ) ;
#line 228
extern GDBusAnnotationInfo *g_dbus_annotation_info_ref(GDBusAnnotationInfo *info ) ;
#line 231
extern void g_dbus_node_info_unref(GDBusNodeInfo *info ) ;
#line 233
extern void g_dbus_interface_info_unref(GDBusInterfaceInfo *info ) ;
#line 235
extern void g_dbus_method_info_unref(GDBusMethodInfo *info ) ;
#line 237
extern void g_dbus_signal_info_unref(GDBusSignalInfo *info ) ;
#line 239
extern void g_dbus_property_info_unref(GDBusPropertyInfo *info ) ;
#line 241
extern void g_dbus_arg_info_unref(GDBusArgInfo *info ) ;
#line 243
extern void g_dbus_annotation_info_unref(GDBusAnnotationInfo *info ) ;
#line 309
extern GType g_dbus_node_info_get_type(void) ;
#line 311
extern GType g_dbus_interface_info_get_type(void) ;
#line 313
extern GType g_dbus_method_info_get_type(void) ;
#line 315
extern GType g_dbus_signal_info_get_type(void) ;
#line 317
extern GType g_dbus_property_info_get_type(void) ;
#line 319
extern GType g_dbus_arg_info_get_type(void) ;
#line 321
extern GType g_dbus_annotation_info_get_type(void) ;
#line 36 "/usr/include/glib-2.0/gio/gdbusmenumodel.h"
extern GType g_dbus_menu_model_get_type(void) ;
#line 39
extern GDBusMenuModel *g_dbus_menu_model_get(GDBusConnection *connection , gchar *bus_name ,
                                             gchar *object_path ) ;
#line 37 "/usr/include/glib-2.0/gio/gdbusmessage.h"
extern GType g_dbus_message_get_type(void) ;
#line 39
extern GDBusMessage *g_dbus_message_new(void) ;
#line 41
extern GDBusMessage *g_dbus_message_new_signal(gchar *path , gchar *interface_ , gchar *signal ) ;
#line 45
extern GDBusMessage *g_dbus_message_new_method_call(gchar *name , gchar *path , gchar *interface_ ,
                                                    gchar *method ) ;
#line 50
extern GDBusMessage *g_dbus_message_new_method_reply(GDBusMessage *method_call_message ) ;
#line 52
extern GDBusMessage *g_dbus_message_new_method_error(GDBusMessage *method_call_message ,
                                                     gchar *error_name , gchar *error_message_format 
                                                     , ...) ;
#line 57
extern GDBusMessage *g_dbus_message_new_method_error_valist(GDBusMessage *method_call_message ,
                                                            gchar *error_name , gchar *error_message_format ,
                                                            va_list var_args ) ;
#line 62
extern GDBusMessage *g_dbus_message_new_method_error_literal(GDBusMessage *method_call_message ,
                                                             gchar *error_name , gchar *error_message ) ;
#line 66
extern gchar *g_dbus_message_print(GDBusMessage *message , guint indent ) ;
#line 69
extern gboolean g_dbus_message_get_locked(GDBusMessage *message ) ;
#line 71
extern void g_dbus_message_lock(GDBusMessage *message ) ;
#line 73
extern GDBusMessage *g_dbus_message_copy(GDBusMessage *message , GError **error ) ;
#line 76
extern GDBusMessageByteOrder g_dbus_message_get_byte_order(GDBusMessage *message ) ;
#line 78
extern void g_dbus_message_set_byte_order(GDBusMessage *message , GDBusMessageByteOrder byte_order ) ;
#line 82
extern GDBusMessageType g_dbus_message_get_message_type(GDBusMessage *message ) ;
#line 84
extern void g_dbus_message_set_message_type(GDBusMessage *message , GDBusMessageType type ) ;
#line 87
extern GDBusMessageFlags g_dbus_message_get_flags(GDBusMessage *message ) ;
#line 89
extern void g_dbus_message_set_flags(GDBusMessage *message , GDBusMessageFlags flags ) ;
#line 92
extern guint32 g_dbus_message_get_serial(GDBusMessage *message ) ;
#line 94
extern void g_dbus_message_set_serial(GDBusMessage *message , guint32 serial ) ;
#line 97
extern GVariant *g_dbus_message_get_header(GDBusMessage *message , GDBusMessageHeaderField header_field ) ;
#line 100
extern void g_dbus_message_set_header(GDBusMessage *message , GDBusMessageHeaderField header_field ,
                                      GVariant *value ) ;
#line 104
extern guchar *g_dbus_message_get_header_fields(GDBusMessage *message ) ;
#line 106
extern GVariant *g_dbus_message_get_body(GDBusMessage *message ) ;
#line 108
extern void g_dbus_message_set_body(GDBusMessage *message , GVariant *body ) ;
#line 111
extern GUnixFDList *g_dbus_message_get_unix_fd_list(GDBusMessage *message ) ;
#line 113
extern void g_dbus_message_set_unix_fd_list(GDBusMessage *message , GUnixFDList *fd_list ) ;
#line 117
extern guint32 g_dbus_message_get_reply_serial(GDBusMessage *message ) ;
#line 119
extern void g_dbus_message_set_reply_serial(GDBusMessage *message , guint32 value ) ;
#line 123
extern gchar *g_dbus_message_get_interface(GDBusMessage *message ) ;
#line 125
extern void g_dbus_message_set_interface(GDBusMessage *message , gchar *value ) ;
#line 129
extern gchar *g_dbus_message_get_member(GDBusMessage *message ) ;
#line 131
extern void g_dbus_message_set_member(GDBusMessage *message , gchar *value ) ;
#line 135
extern gchar *g_dbus_message_get_path(GDBusMessage *message ) ;
#line 137
extern void g_dbus_message_set_path(GDBusMessage *message , gchar *value ) ;
#line 141
extern gchar *g_dbus_message_get_sender(GDBusMessage *message ) ;
#line 143
extern void g_dbus_message_set_sender(GDBusMessage *message , gchar *value ) ;
#line 147
extern gchar *g_dbus_message_get_destination(GDBusMessage *message ) ;
#line 149
extern void g_dbus_message_set_destination(GDBusMessage *message , gchar *value ) ;
#line 153
extern gchar *g_dbus_message_get_error_name(GDBusMessage *message ) ;
#line 155
extern void g_dbus_message_set_error_name(GDBusMessage *message , gchar *value ) ;
#line 159
extern gchar *g_dbus_message_get_signature(GDBusMessage *message ) ;
#line 161
extern void g_dbus_message_set_signature(GDBusMessage *message , gchar *value ) ;
#line 165
extern guint32 g_dbus_message_get_num_unix_fds(GDBusMessage *message ) ;
#line 167
extern void g_dbus_message_set_num_unix_fds(GDBusMessage *message , guint32 value ) ;
#line 171
extern gchar *g_dbus_message_get_arg0(GDBusMessage *message ) ;
#line 175
extern GDBusMessage *g_dbus_message_new_from_blob(guchar *blob , gsize blob_len ,
                                                  GDBusCapabilityFlags capabilities ,
                                                  GError **error ) ;
#line 181
extern gssize g_dbus_message_bytes_needed(guchar *blob , gsize blob_len , GError **error ) ;
#line 186
extern guchar *g_dbus_message_to_blob(GDBusMessage *message , gsize *out_size , GDBusCapabilityFlags capabilities ,
                                      GError **error ) ;
#line 192
extern gboolean g_dbus_message_to_gerror(GDBusMessage *message , GError **error ) ;
#line 72 "/usr/include/glib-2.0/gio/gdbusmethodinvocation.h"
extern GType g_dbus_method_invocation_get_type(void) ;
#line 74
extern gchar *g_dbus_method_invocation_get_sender(GDBusMethodInvocation *invocation ) ;
#line 76
extern gchar *g_dbus_method_invocation_get_object_path(GDBusMethodInvocation *invocation ) ;
#line 78
extern gchar *g_dbus_method_invocation_get_interface_name(GDBusMethodInvocation *invocation ) ;
#line 80
extern gchar *g_dbus_method_invocation_get_method_name(GDBusMethodInvocation *invocation ) ;
#line 82
extern GDBusMethodInfo *g_dbus_method_invocation_get_method_info(GDBusMethodInvocation *invocation ) ;
#line 84
extern GDBusPropertyInfo *g_dbus_method_invocation_get_property_info(GDBusMethodInvocation *invocation ) ;
#line 86
extern GDBusConnection *g_dbus_method_invocation_get_connection(GDBusMethodInvocation *invocation ) ;
#line 88
extern GDBusMessage *g_dbus_method_invocation_get_message(GDBusMethodInvocation *invocation ) ;
#line 90
extern GVariant *g_dbus_method_invocation_get_parameters(GDBusMethodInvocation *invocation ) ;
#line 92
extern gpointer g_dbus_method_invocation_get_user_data(GDBusMethodInvocation *invocation ) ;
#line 95
extern void g_dbus_method_invocation_return_value(GDBusMethodInvocation *invocation ,
                                                  GVariant *parameters ) ;
#line 98
extern void g_dbus_method_invocation_return_value_with_unix_fd_list(GDBusMethodInvocation *invocation ,
                                                                    GVariant *parameters ,
                                                                    GUnixFDList *fd_list ) ;
#line 102
extern void g_dbus_method_invocation_return_error(GDBusMethodInvocation *invocation ,
                                                  GQuark domain , gint code , gchar *format 
                                                  , ...) ;
#line 108
extern void g_dbus_method_invocation_return_error_valist(GDBusMethodInvocation *invocation ,
                                                         GQuark domain , gint code ,
                                                         gchar *format , va_list var_args ) ;
#line 115
extern void g_dbus_method_invocation_return_error_literal(GDBusMethodInvocation *invocation ,
                                                          GQuark domain , gint code ,
                                                          gchar *message ) ;
#line 120
extern void g_dbus_method_invocation_return_gerror(GDBusMethodInvocation *invocation ,
                                                   GError *error ) ;
#line 123
extern void g_dbus_method_invocation_take_error(GDBusMethodInvocation *invocation ,
                                                GError *error ) ;
#line 126
extern void g_dbus_method_invocation_return_dbus_error(GDBusMethodInvocation *invocation ,
                                                       gchar *error_name , gchar *error_message ) ;
#line 76 "/usr/include/glib-2.0/gio/gdbusnameowning.h"
extern guint g_bus_own_name(GBusType bus_type , gchar *name , GBusNameOwnerFlags flags ,
                            GBusAcquiredCallback bus_acquired_handler , GBusNameAcquiredCallback name_acquired_handler ,
                            GBusNameLostCallback name_lost_handler , gpointer user_data ,
                            GDestroyNotify user_data_free_func ) ;
#line 86
extern guint g_bus_own_name_on_connection(GDBusConnection *connection , gchar *name ,
                                          GBusNameOwnerFlags flags , GBusNameAcquiredCallback name_acquired_handler ,
                                          GBusNameLostCallback name_lost_handler ,
                                          gpointer user_data , GDestroyNotify user_data_free_func ) ;
#line 95
extern guint g_bus_own_name_with_closures(GBusType bus_type , gchar *name , GBusNameOwnerFlags flags ,
                                          GClosure *bus_acquired_closure , GClosure *name_acquired_closure ,
                                          GClosure *name_lost_closure ) ;
#line 103
extern guint g_bus_own_name_on_connection_with_closures(GDBusConnection *connection ,
                                                        gchar *name , GBusNameOwnerFlags flags ,
                                                        GClosure *name_acquired_closure ,
                                                        GClosure *name_lost_closure ) ;
#line 111
extern void g_bus_unown_name(guint owner_id ) ;
#line 69 "/usr/include/glib-2.0/gio/gdbusnamewatching.h"
extern guint g_bus_watch_name(GBusType bus_type , gchar *name , GBusNameWatcherFlags flags ,
                              GBusNameAppearedCallback name_appeared_handler , GBusNameVanishedCallback name_vanished_handler ,
                              gpointer user_data , GDestroyNotify user_data_free_func ) ;
#line 77
extern guint g_bus_watch_name_on_connection(GDBusConnection *connection , gchar *name ,
                                            GBusNameWatcherFlags flags , GBusNameAppearedCallback name_appeared_handler ,
                                            GBusNameVanishedCallback name_vanished_handler ,
                                            gpointer user_data , GDestroyNotify user_data_free_func ) ;
#line 85
extern guint g_bus_watch_name_with_closures(GBusType bus_type , gchar *name , GBusNameWatcherFlags flags ,
                                            GClosure *name_appeared_closure , GClosure *name_vanished_closure ) ;
#line 91
extern guint g_bus_watch_name_on_connection_with_closures(GDBusConnection *connection ,
                                                          gchar *name , GBusNameWatcherFlags flags ,
                                                          GClosure *name_appeared_closure ,
                                                          GClosure *name_vanished_closure ) ;
#line 98
extern void g_bus_unwatch_name(guint watcher_id ) ;
#line 67 "/usr/include/glib-2.0/gio/gdbusobject.h"
extern GType g_dbus_object_get_type(void) ;
#line 69
extern gchar *g_dbus_object_get_object_path(GDBusObject *object ) ;
#line 71
extern GList *g_dbus_object_get_interfaces(GDBusObject *object ) ;
#line 73
extern GDBusInterface *g_dbus_object_get_interface(GDBusObject *object , gchar *interface_name ) ;
#line 79 "/usr/include/glib-2.0/gio/gdbusobjectmanager.h"
extern GType g_dbus_object_manager_get_type(void) ;
#line 81
extern gchar *g_dbus_object_manager_get_object_path(GDBusObjectManager *manager ) ;
#line 83
extern GList *g_dbus_object_manager_get_objects(GDBusObjectManager *manager ) ;
#line 85
extern GDBusObject *g_dbus_object_manager_get_object(GDBusObjectManager *manager ,
                                                     gchar *object_path ) ;
#line 88
extern GDBusInterface *g_dbus_object_manager_get_interface(GDBusObjectManager *manager ,
                                                           gchar *object_path , gchar *interface_name ) ;
#line 86 "/usr/include/glib-2.0/gio/gdbusobjectmanagerclient.h"
extern GType g_dbus_object_manager_client_get_type(void) ;
#line 88
extern void g_dbus_object_manager_client_new(GDBusConnection *connection , GDBusObjectManagerClientFlags flags ,
                                             gchar *name , gchar *object_path , GDBusProxyTypeFunc get_proxy_type_func ,
                                             gpointer get_proxy_type_user_data , GDestroyNotify get_proxy_type_destroy_notify ,
                                             GCancellable *cancellable , GAsyncReadyCallback callback ,
                                             gpointer user_data ) ;
#line 99
extern GDBusObjectManager *g_dbus_object_manager_client_new_finish(GAsyncResult *res ,
                                                                   GError **error ) ;
#line 102
extern GDBusObjectManager *g_dbus_object_manager_client_new_sync(GDBusConnection *connection ,
                                                                 GDBusObjectManagerClientFlags flags ,
                                                                 gchar *name , gchar *object_path ,
                                                                 GDBusProxyTypeFunc get_proxy_type_func ,
                                                                 gpointer get_proxy_type_user_data ,
                                                                 GDestroyNotify get_proxy_type_destroy_notify ,
                                                                 GCancellable *cancellable ,
                                                                 GError **error ) ;
#line 112
extern void g_dbus_object_manager_client_new_for_bus(GBusType bus_type , GDBusObjectManagerClientFlags flags ,
                                                     gchar *name , gchar *object_path ,
                                                     GDBusProxyTypeFunc get_proxy_type_func ,
                                                     gpointer get_proxy_type_user_data ,
                                                     GDestroyNotify get_proxy_type_destroy_notify ,
                                                     GCancellable *cancellable , GAsyncReadyCallback callback ,
                                                     gpointer user_data ) ;
#line 123
extern GDBusObjectManager *g_dbus_object_manager_client_new_for_bus_finish(GAsyncResult *res ,
                                                                           GError **error ) ;
#line 126
extern GDBusObjectManager *g_dbus_object_manager_client_new_for_bus_sync(GBusType bus_type ,
                                                                         GDBusObjectManagerClientFlags flags ,
                                                                         gchar *name ,
                                                                         gchar *object_path ,
                                                                         GDBusProxyTypeFunc get_proxy_type_func ,
                                                                         gpointer get_proxy_type_user_data ,
                                                                         GDestroyNotify get_proxy_type_destroy_notify ,
                                                                         GCancellable *cancellable ,
                                                                         GError **error ) ;
#line 136
extern GDBusConnection *g_dbus_object_manager_client_get_connection(GDBusObjectManagerClient *manager ) ;
#line 138
extern GDBusObjectManagerClientFlags g_dbus_object_manager_client_get_flags(GDBusObjectManagerClient *manager ) ;
#line 140
extern gchar *g_dbus_object_manager_client_get_name(GDBusObjectManagerClient *manager ) ;
#line 142
extern gchar *g_dbus_object_manager_client_get_name_owner(GDBusObjectManagerClient *manager ) ;
#line 70 "/usr/include/glib-2.0/gio/gdbusobjectmanagerserver.h"
extern GType g_dbus_object_manager_server_get_type(void) ;
#line 72
extern GDBusObjectManagerServer *g_dbus_object_manager_server_new(gchar *object_path ) ;
#line 74
extern GDBusConnection *g_dbus_object_manager_server_get_connection(GDBusObjectManagerServer *manager ) ;
#line 76
extern void g_dbus_object_manager_server_set_connection(GDBusObjectManagerServer *manager ,
                                                        GDBusConnection *connection ) ;
#line 79
extern void g_dbus_object_manager_server_export(GDBusObjectManagerServer *manager ,
                                                GDBusObjectSkeleton *object ) ;
#line 82
extern void g_dbus_object_manager_server_export_uniquely(GDBusObjectManagerServer *manager ,
                                                         GDBusObjectSkeleton *object ) ;
#line 85
extern gboolean g_dbus_object_manager_server_is_exported(GDBusObjectManagerServer *manager ,
                                                         GDBusObjectSkeleton *object ) ;
#line 88
extern gboolean g_dbus_object_manager_server_unexport(GDBusObjectManagerServer *manager ,
                                                      gchar *object_path ) ;
#line 70 "/usr/include/glib-2.0/gio/gdbusobjectproxy.h"
extern GType g_dbus_object_proxy_get_type(void) ;
#line 72
extern GDBusObjectProxy *g_dbus_object_proxy_new(GDBusConnection *connection , gchar *object_path ) ;
#line 75
extern GDBusConnection *g_dbus_object_proxy_get_connection(GDBusObjectProxy *proxy ) ;
#line 76 "/usr/include/glib-2.0/gio/gdbusobjectskeleton.h"
extern GType g_dbus_object_skeleton_get_type(void) ;
#line 78
extern GDBusObjectSkeleton *g_dbus_object_skeleton_new(gchar *object_path ) ;
#line 80
extern void g_dbus_object_skeleton_flush(GDBusObjectSkeleton *object ) ;
#line 82
extern void g_dbus_object_skeleton_add_interface(GDBusObjectSkeleton *object , GDBusInterfaceSkeleton *interface_ ) ;
#line 85
extern void g_dbus_object_skeleton_remove_interface(GDBusObjectSkeleton *object ,
                                                    GDBusInterfaceSkeleton *interface_ ) ;
#line 88
extern void g_dbus_object_skeleton_remove_interface_by_name(GDBusObjectSkeleton *object ,
                                                            gchar *interface_name ) ;
#line 91
extern void g_dbus_object_skeleton_set_object_path(GDBusObjectSkeleton *object , gchar *object_path ) ;
#line 88 "/usr/include/glib-2.0/gio/gdbusproxy.h"
extern GType g_dbus_proxy_get_type(void) ;
#line 90
extern void g_dbus_proxy_new(GDBusConnection *connection , GDBusProxyFlags flags ,
                             GDBusInterfaceInfo *info , gchar *name , gchar *object_path ,
                             gchar *interface_name , GCancellable *cancellable , GAsyncReadyCallback callback ,
                             gpointer user_data ) ;
#line 100
extern GDBusProxy *g_dbus_proxy_new_finish(GAsyncResult *res , GError **error ) ;
#line 103
extern GDBusProxy *g_dbus_proxy_new_sync(GDBusConnection *connection , GDBusProxyFlags flags ,
                                         GDBusInterfaceInfo *info , gchar *name ,
                                         gchar *object_path , gchar *interface_name ,
                                         GCancellable *cancellable , GError **error ) ;
#line 112
extern void g_dbus_proxy_new_for_bus(GBusType bus_type , GDBusProxyFlags flags , GDBusInterfaceInfo *info ,
                                     gchar *name , gchar *object_path , gchar *interface_name ,
                                     GCancellable *cancellable , GAsyncReadyCallback callback ,
                                     gpointer user_data ) ;
#line 122
extern GDBusProxy *g_dbus_proxy_new_for_bus_finish(GAsyncResult *res , GError **error ) ;
#line 125
extern GDBusProxy *g_dbus_proxy_new_for_bus_sync(GBusType bus_type , GDBusProxyFlags flags ,
                                                 GDBusInterfaceInfo *info , gchar *name ,
                                                 gchar *object_path , gchar *interface_name ,
                                                 GCancellable *cancellable , GError **error ) ;
#line 134
extern GDBusConnection *g_dbus_proxy_get_connection(GDBusProxy *proxy ) ;
#line 136
extern GDBusProxyFlags g_dbus_proxy_get_flags(GDBusProxy *proxy ) ;
#line 138
extern gchar *g_dbus_proxy_get_name(GDBusProxy *proxy ) ;
#line 140
extern gchar *g_dbus_proxy_get_name_owner(GDBusProxy *proxy ) ;
#line 142
extern gchar *g_dbus_proxy_get_object_path(GDBusProxy *proxy ) ;
#line 144
extern gchar *g_dbus_proxy_get_interface_name(GDBusProxy *proxy ) ;
#line 146
extern gint g_dbus_proxy_get_default_timeout(GDBusProxy *proxy ) ;
#line 148
extern void g_dbus_proxy_set_default_timeout(GDBusProxy *proxy , gint timeout_msec ) ;
#line 151
extern GDBusInterfaceInfo *g_dbus_proxy_get_interface_info(GDBusProxy *proxy ) ;
#line 153
extern void g_dbus_proxy_set_interface_info(GDBusProxy *proxy , GDBusInterfaceInfo *info ) ;
#line 156
extern GVariant *g_dbus_proxy_get_cached_property(GDBusProxy *proxy , gchar *property_name ) ;
#line 159
extern void g_dbus_proxy_set_cached_property(GDBusProxy *proxy , gchar *property_name ,
                                             GVariant *value ) ;
#line 163
extern gchar **g_dbus_proxy_get_cached_property_names(GDBusProxy *proxy ) ;
#line 165
extern void g_dbus_proxy_call(GDBusProxy *proxy , gchar *method_name , GVariant *parameters ,
                              GDBusCallFlags flags , gint timeout_msec , GCancellable *cancellable ,
                              GAsyncReadyCallback callback , gpointer user_data ) ;
#line 174
extern GVariant *g_dbus_proxy_call_finish(GDBusProxy *proxy , GAsyncResult *res ,
                                          GError **error ) ;
#line 178
extern GVariant *g_dbus_proxy_call_sync(GDBusProxy *proxy , gchar *method_name , GVariant *parameters ,
                                        GDBusCallFlags flags , gint timeout_msec ,
                                        GCancellable *cancellable , GError **error ) ;
#line 187
extern void g_dbus_proxy_call_with_unix_fd_list(GDBusProxy *proxy , gchar *method_name ,
                                                GVariant *parameters , GDBusCallFlags flags ,
                                                gint timeout_msec , GUnixFDList *fd_list ,
                                                GCancellable *cancellable , GAsyncReadyCallback callback ,
                                                gpointer user_data ) ;
#line 197
extern GVariant *g_dbus_proxy_call_with_unix_fd_list_finish(GDBusProxy *proxy , GUnixFDList **out_fd_list ,
                                                            GAsyncResult *res , GError **error ) ;
#line 202
extern GVariant *g_dbus_proxy_call_with_unix_fd_list_sync(GDBusProxy *proxy , gchar *method_name ,
                                                          GVariant *parameters , GDBusCallFlags flags ,
                                                          gint timeout_msec , GUnixFDList *fd_list ,
                                                          GUnixFDList **out_fd_list ,
                                                          GCancellable *cancellable ,
                                                          GError **error ) ;
#line 37 "/usr/include/glib-2.0/gio/gdbusserver.h"
extern GType g_dbus_server_get_type(void) ;
#line 39
extern GDBusServer *g_dbus_server_new_sync(gchar *address , GDBusServerFlags flags ,
                                           gchar *guid , GDBusAuthObserver *observer ,
                                           GCancellable *cancellable , GError **error ) ;
#line 46
extern gchar *g_dbus_server_get_client_address(GDBusServer *server ) ;
#line 48
extern gchar *g_dbus_server_get_guid(GDBusServer *server ) ;
#line 50
extern GDBusServerFlags g_dbus_server_get_flags(GDBusServer *server ) ;
#line 52
extern void g_dbus_server_start(GDBusServer *server ) ;
#line 54
extern void g_dbus_server_stop(GDBusServer *server ) ;
#line 56
extern gboolean g_dbus_server_is_active(GDBusServer *server ) ;
#line 33 "/usr/include/glib-2.0/gio/gdbusutils.h"
extern gboolean g_dbus_is_guid(gchar *string ) ;
#line 35
extern gchar *g_dbus_generate_guid(void) ;
#line 38
extern gboolean g_dbus_is_name(gchar *string ) ;
#line 40
extern gboolean g_dbus_is_unique_name(gchar *string ) ;
#line 42
extern gboolean g_dbus_is_member_name(gchar *string ) ;
#line 44
extern gboolean g_dbus_is_interface_name(gchar *string ) ;
#line 46
extern gboolean g_dbus_is_error_name(gchar *string ) ;
#line 49
extern void g_dbus_gvariant_to_gvalue(GVariant *value , GValue *out_gvalue ) ;
#line 52
extern GVariant *g_dbus_gvalue_to_gvariant(GValue *gvalue , GVariantType *type ) ;
#line 55
extern gchar *g_dbus_escape_object_path_bytestring(guint8 *bytes ) ;
#line 57
extern gchar *g_dbus_escape_object_path(gchar *s ) ;
#line 59
extern guint8 *g_dbus_unescape_object_path(gchar *s ) ;
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
extern GType g_debug_controller_get_type(void) ;
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
__inline static void glib_autoptr_clear_GDebugController(GDebugController *_ptr ) 
{ 


  {
#line 52
  if (_ptr) {
    {
#line 52
    glib_autoptr_clear_GObject((GObject *)_ptr);
    }
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
__inline static void glib_autoptr_cleanup_GDebugController(GDebugController **_ptr ) 
{ 


  {
  {
#line 52
  glib_autoptr_clear_GDebugController(*_ptr);
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
__inline static void glib_listautoptr_cleanup_GDebugController(GList **_l ) 
{ 


  {
  {
#line 52
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& glib_autoptr_clear_GObject)));
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
__inline static void glib_slistautoptr_cleanup_GDebugController(GSList **_l ) 
{ 


  {
  {
#line 52
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& glib_autoptr_clear_GObject)));
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
__inline static void glib_queueautoptr_cleanup_GDebugController(GQueue **_q ) 
{ 


  {
#line 52
  if (*_q) {
    {
#line 52
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& glib_autoptr_clear_GObject)));
    }
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
__inline static GDebugController *g_debug_controller(gpointer ptr ) 
{ 
  GType __cil_tmp2 ;
  GTypeInstance *__cil_tmp3 ;

  {
  {
#line 52
  __cil_tmp2 = g_debug_controller_get_type();
#line 52
  __cil_tmp3 = g_type_check_instance_cast((GTypeInstance *)ptr, __cil_tmp2);
  }
#line 52
  return ((GDebugController *)((void *)__cil_tmp3));
}
}
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
__inline static gboolean g_IS_debug_controller(gpointer ptr ) 
{ 


  {
#line 52
  return (0);
}
}
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
__inline static GDebugControllerInterface *g_debug_controller_GET_IFACE(gpointer ptr ) 
{ 
  GType __cil_tmp2 ;
  gpointer __cil_tmp3 ;

  {
  {
#line 52
  __cil_tmp2 = g_debug_controller_get_type();
#line 52
  __cil_tmp3 = g_type_interface_peek(((GTypeInstance *)ptr)->g_class, __cil_tmp2);
  }
#line 52
  return ((GDebugControllerInterface *)__cil_tmp3);
}
}
#line 72
extern gboolean g_debug_controller_get_debug_enabled(GDebugController *self ) ;
#line 74
extern void g_debug_controller_set_debug_enabled(GDebugController *self , gboolean debug_enabled ) ;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
extern GType g_debug_controller_dbus_get_type(void) ;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
__inline static void glib_autoptr_clear_GDebugControllerDBus(GDebugControllerDBus *_ptr ) 
{ 


  {
#line 38
  if (_ptr) {
    {
#line 38
    glib_autoptr_clear_GObject((GObject *)_ptr);
    }
  }
  return;
}
}
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
__inline static void glib_autoptr_cleanup_GDebugControllerDBus(GDebugControllerDBus **_ptr ) 
{ 


  {
  {
#line 38
  glib_autoptr_clear_GDebugControllerDBus(*_ptr);
  }
  return;
}
}
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
__inline static void glib_autoptr_clear_GDebugControllerDBusClass(GDebugControllerDBusClass *_ptr ) 
{ 


  {
#line 38
  if (_ptr) {
    {
#line 38
    g_type_class_unref((GDebugControllerDBusClass *)_ptr);
    }
  }
  return;
}
}
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
__inline static void glib_autoptr_cleanup_GDebugControllerDBusClass(GDebugControllerDBusClass **_ptr ) 
{ 


  {
  {
#line 38
  glib_autoptr_clear_GDebugControllerDBusClass(*_ptr);
  }
  return;
}
}
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
__inline static GDebugControllerDBus *G_DEBUG_CONTROLLER_DBUS(gpointer ptr ) 
{ 
  GType __cil_tmp2 ;
  GTypeInstance *__cil_tmp3 ;

  {
  {
#line 38
  __cil_tmp2 = g_debug_controller_dbus_get_type();
#line 38
  __cil_tmp3 = g_type_check_instance_cast((GTypeInstance *)ptr, __cil_tmp2);
  }
#line 38
  return ((GDebugControllerDBus *)((void *)__cil_tmp3));
}
}
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
__inline static GDebugControllerDBusClass *G_DEBUG_CONTROLLER_DBUS_CLASS(gpointer ptr ) 
{ 
  GType __cil_tmp2 ;
  GTypeClass *__cil_tmp3 ;

  {
  {
#line 38
  __cil_tmp2 = g_debug_controller_dbus_get_type();
#line 38
  __cil_tmp3 = g_type_check_class_cast((GTypeClass *)ptr, __cil_tmp2);
  }
#line 38
  return ((GDebugControllerDBusClass *)((void *)__cil_tmp3));
}
}
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
__inline static GDebugControllerDBusClass *G_DEBUG_CONTROLLER_DBUS_GET_CLASS(gpointer ptr ) 
{ 


  {
#line 38
  return ((GDebugControllerDBusClass *)((GTypeInstance *)ptr)->g_class);
}
}
#line 60
extern GDebugControllerDBus *g_debug_controller_dbus_new(GDBusConnection *connection ,
                                                         GCancellable *cancellable ,
                                                         GError **error ) ;
#line 65
extern void g_debug_controller_dbus_stop(GDebugControllerDBus *self ) ;
#line 172 "/usr/include/glib-2.0/gio/gdrive.h"
extern GType g_drive_get_type(void) ;
#line 175
extern char *g_drive_get_name(GDrive *drive ) ;
#line 177
extern GIcon *g_drive_get_icon(GDrive *drive ) ;
#line 179
extern GIcon *g_drive_get_symbolic_icon(GDrive *drive ) ;
#line 181
extern gboolean g_drive_has_volumes(GDrive *drive ) ;
#line 183
extern GList *g_drive_get_volumes(GDrive *drive ) ;
#line 185
extern gboolean g_drive_is_removable(GDrive *drive ) ;
#line 187
extern gboolean g_drive_is_media_removable(GDrive *drive ) ;
#line 189
extern gboolean g_drive_has_media(GDrive *drive ) ;
#line 191
extern gboolean g_drive_is_media_check_automatic(GDrive *drive ) ;
#line 193
extern gboolean g_drive_can_poll_for_media(GDrive *drive ) ;
#line 195
extern gboolean g_drive_can_eject(GDrive *drive ) ;
#line 197
extern void g_drive_eject(GDrive *drive , GMountUnmountFlags flags , GCancellable *cancellable ,
                          GAsyncReadyCallback callback , gpointer user_data ) ;
#line 204
extern gboolean g_drive_eject_finish(GDrive *drive , GAsyncResult *result , GError **error ) ;
#line 208
extern void g_drive_poll_for_media(GDrive *drive , GCancellable *cancellable , GAsyncReadyCallback callback ,
                                   gpointer user_data ) ;
#line 213
extern gboolean g_drive_poll_for_media_finish(GDrive *drive , GAsyncResult *result ,
                                              GError **error ) ;
#line 217
extern char *g_drive_get_identifier(GDrive *drive , char const   *kind ) ;
#line 220
extern char **g_drive_enumerate_identifiers(GDrive *drive ) ;
#line 223
extern GDriveStartStopType g_drive_get_start_stop_type(GDrive *drive ) ;
#line 226
extern gboolean g_drive_can_start(GDrive *drive ) ;
#line 228
extern gboolean g_drive_can_start_degraded(GDrive *drive ) ;
#line 230
extern void g_drive_start(GDrive *drive , GDriveStartFlags flags , GMountOperation *mount_operation ,
                          GCancellable *cancellable , GAsyncReadyCallback callback ,
                          gpointer user_data ) ;
#line 237
extern gboolean g_drive_start_finish(GDrive *drive , GAsyncResult *result , GError **error ) ;
#line 242
extern gboolean g_drive_can_stop(GDrive *drive ) ;
#line 244
extern void g_drive_stop(GDrive *drive , GMountUnmountFlags flags , GMountOperation *mount_operation ,
                         GCancellable *cancellable , GAsyncReadyCallback callback ,
                         gpointer user_data ) ;
#line 251
extern gboolean g_drive_stop_finish(GDrive *drive , GAsyncResult *result , GError **error ) ;
#line 256
extern void g_drive_eject_with_operation(GDrive *drive , GMountUnmountFlags flags ,
                                         GMountOperation *mount_operation , GCancellable *cancellable ,
                                         GAsyncReadyCallback callback , gpointer user_data ) ;
#line 263
extern gboolean g_drive_eject_with_operation_finish(GDrive *drive , GAsyncResult *result ,
                                                    GError **error ) ;
#line 268
extern gchar *g_drive_get_sort_key(GDrive *drive ) ;
#line 109 "/usr/include/glib-2.0/gio/gdtlsconnection.h"
extern GType g_dtls_connection_get_type(void) ;
#line 112
extern void g_dtls_connection_set_database(GDtlsConnection *conn , GTlsDatabase *database ) ;
#line 115
extern GTlsDatabase *g_dtls_connection_get_database(GDtlsConnection *conn ) ;
#line 118
extern void g_dtls_connection_set_certificate(GDtlsConnection *conn , GTlsCertificate *certificate ) ;
#line 121
extern GTlsCertificate *g_dtls_connection_get_certificate(GDtlsConnection *conn ) ;
#line 124
extern void g_dtls_connection_set_interaction(GDtlsConnection *conn , GTlsInteraction *interaction ) ;
#line 127
extern GTlsInteraction *g_dtls_connection_get_interaction(GDtlsConnection *conn ) ;
#line 130
extern GTlsCertificate *g_dtls_connection_get_peer_certificate(GDtlsConnection *conn ) ;
#line 132
extern GTlsCertificateFlags g_dtls_connection_get_peer_certificate_errors(GDtlsConnection *conn ) ;
#line 135
extern void g_dtls_connection_set_require_close_notify(GDtlsConnection *conn , gboolean require_close_notify ) ;
#line 138
extern gboolean g_dtls_connection_get_require_close_notify(GDtlsConnection *conn ) ;
#line 142
extern void g_dtls_connection_set_rehandshake_mode(GDtlsConnection *conn , GTlsRehandshakeMode mode ) ;
#line 145
extern GTlsRehandshakeMode g_dtls_connection_get_rehandshake_mode(GDtlsConnection *conn ) ;
#line 149
extern gboolean g_dtls_connection_handshake(GDtlsConnection *conn , GCancellable *cancellable ,
                                            GError **error ) ;
#line 154
extern void g_dtls_connection_handshake_async(GDtlsConnection *conn , int io_priority ,
                                              GCancellable *cancellable , GAsyncReadyCallback callback ,
                                              gpointer user_data ) ;
#line 160
extern gboolean g_dtls_connection_handshake_finish(GDtlsConnection *conn , GAsyncResult *result ,
                                                   GError **error ) ;
#line 165
extern gboolean g_dtls_connection_shutdown(GDtlsConnection *conn , gboolean shutdown_read ,
                                           gboolean shutdown_write , GCancellable *cancellable ,
                                           GError **error ) ;
#line 172
extern void g_dtls_connection_shutdown_async(GDtlsConnection *conn , gboolean shutdown_read ,
                                             gboolean shutdown_write , int io_priority ,
                                             GCancellable *cancellable , GAsyncReadyCallback callback ,
                                             gpointer user_data ) ;
#line 180
extern gboolean g_dtls_connection_shutdown_finish(GDtlsConnection *conn , GAsyncResult *result ,
                                                  GError **error ) ;
#line 185
extern gboolean g_dtls_connection_close(GDtlsConnection *conn , GCancellable *cancellable ,
                                        GError **error ) ;
#line 190
extern void g_dtls_connection_close_async(GDtlsConnection *conn , int io_priority ,
                                          GCancellable *cancellable , GAsyncReadyCallback callback ,
                                          gpointer user_data ) ;
#line 196
extern gboolean g_dtls_connection_close_finish(GDtlsConnection *conn , GAsyncResult *result ,
                                               GError **error ) ;
#line 202
extern gboolean g_dtls_connection_emit_accept_certificate(GDtlsConnection *conn ,
                                                          GTlsCertificate *peer_cert ,
                                                          GTlsCertificateFlags errors ) ;
#line 206
extern void g_dtls_connection_set_advertised_protocols(GDtlsConnection *conn , gchar * const  *protocols ) ;
#line 210
extern gchar *g_dtls_connection_get_negotiated_protocol(GDtlsConnection *conn ) ;
#line 214
extern gboolean g_dtls_connection_get_channel_binding_data(GDtlsConnection *conn ,
                                                           GTlsChannelBindingType type ,
                                                           GByteArray *data , GError **error ) ;
#line 221
extern GTlsProtocolVersion g_dtls_connection_get_protocol_version(GDtlsConnection *conn ) ;
#line 224
extern gchar *g_dtls_connection_get_ciphersuite_name(GDtlsConnection *conn ) ;
#line 52 "/usr/include/glib-2.0/gio/gdtlsclientconnection.h"
extern GType g_dtls_client_connection_get_type(void) ;
#line 55
extern GDatagramBased *g_dtls_client_connection_new(GDatagramBased *base_socket ,
                                                    GSocketConnectable *server_identity ,
                                                    GError **error ) ;
#line 60
extern GTlsCertificateFlags g_dtls_client_connection_get_validation_flags(GDtlsClientConnection *conn ) ;
#line 62
extern void g_dtls_client_connection_set_validation_flags(GDtlsClientConnection *conn ,
                                                          GTlsCertificateFlags flags ) ;
#line 65
extern GSocketConnectable *g_dtls_client_connection_get_server_identity(GDtlsClientConnection *conn ) ;
#line 67
extern void g_dtls_client_connection_set_server_identity(GDtlsClientConnection *conn ,
                                                         GSocketConnectable *identity ) ;
#line 70
extern GList *g_dtls_client_connection_get_accepted_cas(GDtlsClientConnection *conn ) ;
#line 60 "/usr/include/glib-2.0/gio/gdtlsserverconnection.h"
extern GType g_dtls_server_connection_get_type(void) ;
#line 63
extern GDatagramBased *g_dtls_server_connection_new(GDatagramBased *base_socket ,
                                                    GTlsCertificate *certificate ,
                                                    GError **error ) ;
#line 82 "/usr/include/glib-2.0/gio/gicon.h"
extern GType g_icon_get_type(void) ;
#line 85
extern guint g_icon_hash(gconstpointer icon ) ;
#line 87
extern gboolean g_icon_equal(GIcon *icon1 , GIcon *icon2 ) ;
#line 90
extern gchar *g_icon_to_string(GIcon *icon ) ;
#line 92
extern GIcon *g_icon_new_for_string(gchar *str , GError **error ) ;
#line 96
extern GVariant *g_icon_serialize(GIcon *icon ) ;
#line 98
extern GIcon *g_icon_deserialize(GVariant *value ) ;
#line 47 "/usr/include/glib-2.0/gio/gemblem.h"
extern GType g_emblem_get_type(void) ;
#line 50
extern GEmblem *g_emblem_new(GIcon *icon ) ;
#line 52
extern GEmblem *g_emblem_new_with_origin(GIcon *icon , GEmblemOrigin origin ) ;
#line 55
extern GIcon *g_emblem_get_icon(GEmblem *emblem ) ;
#line 57
extern GEmblemOrigin g_emblem_get_origin(GEmblem *emblem ) ;
#line 64 "/usr/include/glib-2.0/gio/gemblemedicon.h"
extern GType g_emblemed_icon_get_type(void) ;
#line 67
extern GIcon *g_emblemed_icon_new(GIcon *icon , GEmblem *emblem ) ;
#line 70
extern GIcon *g_emblemed_icon_get_icon(GEmblemedIcon *emblemed ) ;
#line 72
extern GList *g_emblemed_icon_get_emblems(GEmblemedIcon *emblemed ) ;
#line 74
extern void g_emblemed_icon_add_emblem(GEmblemedIcon *emblemed , GEmblem *emblem ) ;
#line 77
extern void g_emblemed_icon_clear_emblems(GEmblemedIcon *emblemed ) ;
#line 605 "/usr/include/glib-2.0/gio/gfile.h"
extern GType g_file_get_type(void) ;
#line 608
extern GFile *g_file_new_for_path(char const   *path ) ;
#line 610
extern GFile *g_file_new_for_uri(char const   *uri ) ;
#line 612
extern GFile *g_file_new_for_commandline_arg(char const   *arg ) ;
#line 614
extern GFile *g_file_new_for_commandline_arg_and_cwd(gchar *arg , gchar *cwd ) ;
#line 617
extern GFile *g_file_new_tmp(char const   *tmpl , GFileIOStream **iostream , GError **error ) ;
#line 621
extern GFile *g_file_parse_name(char const   *parse_name ) ;
#line 623
extern GFile *g_file_new_build_filename(gchar *first_element  , ...) ;
#line 626
extern GFile *g_file_dup(GFile *file ) ;
#line 628
extern guint g_file_hash(gconstpointer file ) ;
#line 630
extern gboolean g_file_equal(GFile *file1 , GFile *file2 ) ;
#line 633
extern char *g_file_get_basename(GFile *file ) ;
#line 635
extern char *g_file_get_path(GFile *file ) ;
#line 637
extern char const   *g_file_peek_path(GFile *file ) ;
#line 639
extern char *g_file_get_uri(GFile *file ) ;
#line 641
extern char *g_file_get_parse_name(GFile *file ) ;
#line 643
extern GFile *g_file_get_parent(GFile *file ) ;
#line 645
extern gboolean g_file_has_parent(GFile *file , GFile *parent ) ;
#line 648
extern GFile *g_file_get_child(GFile *file , char const   *name ) ;
#line 651
extern GFile *g_file_get_child_for_display_name(GFile *file , char const   *display_name ,
                                                GError **error ) ;
#line 655
extern gboolean g_file_has_prefix(GFile *file , GFile *prefix ) ;
#line 658
extern char *g_file_get_relative_path(GFile *parent , GFile *descendant ) ;
#line 661
extern GFile *g_file_resolve_relative_path(GFile *file , char const   *relative_path ) ;
#line 664
extern gboolean g_file_is_native(GFile *file ) ;
#line 666
extern gboolean g_file_has_uri_scheme(GFile *file , char const   *uri_scheme ) ;
#line 669
extern char *g_file_get_uri_scheme(GFile *file ) ;
#line 671
extern GFileInputStream *g_file_read(GFile *file , GCancellable *cancellable , GError **error ) ;
#line 675
extern void g_file_read_async(GFile *file , int io_priority , GCancellable *cancellable ,
                              GAsyncReadyCallback callback , gpointer user_data ) ;
#line 681
extern GFileInputStream *g_file_read_finish(GFile *file , GAsyncResult *res , GError **error ) ;
#line 685
extern GFileOutputStream *g_file_append_to(GFile *file , GFileCreateFlags flags ,
                                           GCancellable *cancellable , GError **error ) ;
#line 690
extern GFileOutputStream *g_file_create(GFile *file , GFileCreateFlags flags , GCancellable *cancellable ,
                                        GError **error ) ;
#line 695
extern GFileOutputStream *g_file_replace(GFile *file , char const   *etag , gboolean make_backup ,
                                         GFileCreateFlags flags , GCancellable *cancellable ,
                                         GError **error ) ;
#line 702
extern void g_file_append_to_async(GFile *file , GFileCreateFlags flags , int io_priority ,
                                   GCancellable *cancellable , GAsyncReadyCallback callback ,
                                   gpointer user_data ) ;
#line 709
extern GFileOutputStream *g_file_append_to_finish(GFile *file , GAsyncResult *res ,
                                                  GError **error ) ;
#line 713
extern void g_file_create_async(GFile *file , GFileCreateFlags flags , int io_priority ,
                                GCancellable *cancellable , GAsyncReadyCallback callback ,
                                gpointer user_data ) ;
#line 720
extern GFileOutputStream *g_file_create_finish(GFile *file , GAsyncResult *res , GError **error ) ;
#line 724
extern void g_file_replace_async(GFile *file , char const   *etag , gboolean make_backup ,
                                 GFileCreateFlags flags , int io_priority , GCancellable *cancellable ,
                                 GAsyncReadyCallback callback , gpointer user_data ) ;
#line 733
extern GFileOutputStream *g_file_replace_finish(GFile *file , GAsyncResult *res ,
                                                GError **error ) ;
#line 737
extern GFileIOStream *g_file_open_readwrite(GFile *file , GCancellable *cancellable ,
                                            GError **error ) ;
#line 741
extern void g_file_open_readwrite_async(GFile *file , int io_priority , GCancellable *cancellable ,
                                        GAsyncReadyCallback callback , gpointer user_data ) ;
#line 747
extern GFileIOStream *g_file_open_readwrite_finish(GFile *file , GAsyncResult *res ,
                                                   GError **error ) ;
#line 751
extern GFileIOStream *g_file_create_readwrite(GFile *file , GFileCreateFlags flags ,
                                              GCancellable *cancellable , GError **error ) ;
#line 756
extern void g_file_create_readwrite_async(GFile *file , GFileCreateFlags flags , int io_priority ,
                                          GCancellable *cancellable , GAsyncReadyCallback callback ,
                                          gpointer user_data ) ;
#line 763
extern GFileIOStream *g_file_create_readwrite_finish(GFile *file , GAsyncResult *res ,
                                                     GError **error ) ;
#line 767
extern GFileIOStream *g_file_replace_readwrite(GFile *file , char const   *etag ,
                                               gboolean make_backup , GFileCreateFlags flags ,
                                               GCancellable *cancellable , GError **error ) ;
#line 774
extern void g_file_replace_readwrite_async(GFile *file , char const   *etag , gboolean make_backup ,
                                           GFileCreateFlags flags , int io_priority ,
                                           GCancellable *cancellable , GAsyncReadyCallback callback ,
                                           gpointer user_data ) ;
#line 783
extern GFileIOStream *g_file_replace_readwrite_finish(GFile *file , GAsyncResult *res ,
                                                      GError **error ) ;
#line 787
extern gboolean g_file_query_exists(GFile *file , GCancellable *cancellable ) ;
#line 790
extern GFileType g_file_query_file_type(GFile *file , GFileQueryInfoFlags flags ,
                                        GCancellable *cancellable ) ;
#line 794
extern GFileInfo *g_file_query_info(GFile *file , char const   *attributes , GFileQueryInfoFlags flags ,
                                    GCancellable *cancellable , GError **error ) ;
#line 800
extern void g_file_query_info_async(GFile *file , char const   *attributes , GFileQueryInfoFlags flags ,
                                    int io_priority , GCancellable *cancellable ,
                                    GAsyncReadyCallback callback , gpointer user_data ) ;
#line 808
extern GFileInfo *g_file_query_info_finish(GFile *file , GAsyncResult *res , GError **error ) ;
#line 812
extern GFileInfo *g_file_query_filesystem_info(GFile *file , char const   *attributes ,
                                               GCancellable *cancellable , GError **error ) ;
#line 817
extern void g_file_query_filesystem_info_async(GFile *file , char const   *attributes ,
                                               int io_priority , GCancellable *cancellable ,
                                               GAsyncReadyCallback callback , gpointer user_data ) ;
#line 824
extern GFileInfo *g_file_query_filesystem_info_finish(GFile *file , GAsyncResult *res ,
                                                      GError **error ) ;
#line 828
extern GMount *g_file_find_enclosing_mount(GFile *file , GCancellable *cancellable ,
                                           GError **error ) ;
#line 832
extern void g_file_find_enclosing_mount_async(GFile *file , int io_priority , GCancellable *cancellable ,
                                              GAsyncReadyCallback callback , gpointer user_data ) ;
#line 838
extern GMount *g_file_find_enclosing_mount_finish(GFile *file , GAsyncResult *res ,
                                                  GError **error ) ;
#line 842
extern GFileEnumerator *g_file_enumerate_children(GFile *file , char const   *attributes ,
                                                  GFileQueryInfoFlags flags , GCancellable *cancellable ,
                                                  GError **error ) ;
#line 848
extern void g_file_enumerate_children_async(GFile *file , char const   *attributes ,
                                            GFileQueryInfoFlags flags , int io_priority ,
                                            GCancellable *cancellable , GAsyncReadyCallback callback ,
                                            gpointer user_data ) ;
#line 856
extern GFileEnumerator *g_file_enumerate_children_finish(GFile *file , GAsyncResult *res ,
                                                         GError **error ) ;
#line 860
extern GFile *g_file_set_display_name(GFile *file , char const   *display_name , GCancellable *cancellable ,
                                      GError **error ) ;
#line 865
extern void g_file_set_display_name_async(GFile *file , char const   *display_name ,
                                          int io_priority , GCancellable *cancellable ,
                                          GAsyncReadyCallback callback , gpointer user_data ) ;
#line 872
extern GFile *g_file_set_display_name_finish(GFile *file , GAsyncResult *res , GError **error ) ;
#line 876
extern gboolean g_file_delete(GFile *file , GCancellable *cancellable , GError **error ) ;
#line 881
extern void g_file_delete_async(GFile *file , int io_priority , GCancellable *cancellable ,
                                GAsyncReadyCallback callback , gpointer user_data ) ;
#line 888
extern gboolean g_file_delete_finish(GFile *file , GAsyncResult *result , GError **error ) ;
#line 893
extern gboolean g_file_trash(GFile *file , GCancellable *cancellable , GError **error ) ;
#line 898
extern void g_file_trash_async(GFile *file , int io_priority , GCancellable *cancellable ,
                               GAsyncReadyCallback callback , gpointer user_data ) ;
#line 905
extern gboolean g_file_trash_finish(GFile *file , GAsyncResult *result , GError **error ) ;
#line 910
extern gboolean g_file_copy(GFile *source , GFile *destination , GFileCopyFlags flags ,
                            GCancellable *cancellable , GFileProgressCallback progress_callback ,
                            gpointer progress_callback_data , GError **error ) ;
#line 918
extern void g_file_copy_async(GFile *source , GFile *destination , GFileCopyFlags flags ,
                              int io_priority , GCancellable *cancellable , GFileProgressCallback progress_callback ,
                              gpointer progress_callback_data , GAsyncReadyCallback callback ,
                              gpointer user_data ) ;
#line 928
extern gboolean g_file_copy_finish(GFile *file , GAsyncResult *res , GError **error ) ;
#line 932
extern gboolean g_file_move(GFile *source , GFile *destination , GFileCopyFlags flags ,
                            GCancellable *cancellable , GFileProgressCallback progress_callback ,
                            gpointer progress_callback_data , GError **error ) ;
#line 940
extern void g_file_move_async(GFile *source , GFile *destination , GFileCopyFlags flags ,
                              int io_priority , GCancellable *cancellable , GFileProgressCallback progress_callback ,
                              gpointer progress_callback_data , GAsyncReadyCallback callback ,
                              gpointer user_data ) ;
#line 950
extern gboolean g_file_move_finish(GFile *file , GAsyncResult *result , GError **error ) ;
#line 954
extern gboolean g_file_make_directory(GFile *file , GCancellable *cancellable , GError **error ) ;
#line 958
extern void g_file_make_directory_async(GFile *file , int io_priority , GCancellable *cancellable ,
                                        GAsyncReadyCallback callback , gpointer user_data ) ;
#line 964
extern gboolean g_file_make_directory_finish(GFile *file , GAsyncResult *result ,
                                             GError **error ) ;
#line 969
extern gboolean g_file_make_directory_with_parents(GFile *file , GCancellable *cancellable ,
                                                   GError **error ) ;
#line 973
extern gboolean g_file_make_symbolic_link(GFile *file , char const   *symlink_value ,
                                          GCancellable *cancellable , GError **error ) ;
#line 978
extern GFileAttributeInfoList *g_file_query_settable_attributes(GFile *file , GCancellable *cancellable ,
                                                                GError **error ) ;
#line 982
extern GFileAttributeInfoList *g_file_query_writable_namespaces(GFile *file , GCancellable *cancellable ,
                                                                GError **error ) ;
#line 986
extern gboolean g_file_set_attribute(GFile *file , char const   *attribute , GFileAttributeType type ,
                                     gpointer value_p , GFileQueryInfoFlags flags ,
                                     GCancellable *cancellable , GError **error ) ;
#line 994
extern gboolean g_file_set_attributes_from_info(GFile *file , GFileInfo *info , GFileQueryInfoFlags flags ,
                                                GCancellable *cancellable , GError **error ) ;
#line 1000
extern void g_file_set_attributes_async(GFile *file , GFileInfo *info , GFileQueryInfoFlags flags ,
                                        int io_priority , GCancellable *cancellable ,
                                        GAsyncReadyCallback callback , gpointer user_data ) ;
#line 1008
extern gboolean g_file_set_attributes_finish(GFile *file , GAsyncResult *result ,
                                             GFileInfo **info , GError **error ) ;
#line 1013
extern gboolean g_file_set_attribute_string(GFile *file , char const   *attribute ,
                                            char const   *value , GFileQueryInfoFlags flags ,
                                            GCancellable *cancellable , GError **error ) ;
#line 1020
extern gboolean g_file_set_attribute_byte_string(GFile *file , char const   *attribute ,
                                                 char const   *value , GFileQueryInfoFlags flags ,
                                                 GCancellable *cancellable , GError **error ) ;
#line 1027
extern gboolean g_file_set_attribute_uint32(GFile *file , char const   *attribute ,
                                            guint32 value , GFileQueryInfoFlags flags ,
                                            GCancellable *cancellable , GError **error ) ;
#line 1034
extern gboolean g_file_set_attribute_int32(GFile *file , char const   *attribute ,
                                           gint32 value , GFileQueryInfoFlags flags ,
                                           GCancellable *cancellable , GError **error ) ;
#line 1041
extern gboolean g_file_set_attribute_uint64(GFile *file , char const   *attribute ,
                                            guint64 value , GFileQueryInfoFlags flags ,
                                            GCancellable *cancellable , GError **error ) ;
#line 1048
extern gboolean g_file_set_attribute_int64(GFile *file , char const   *attribute ,
                                           gint64 value , GFileQueryInfoFlags flags ,
                                           GCancellable *cancellable , GError **error ) ;
#line 1055
extern void g_file_mount_enclosing_volume(GFile *location , GMountMountFlags flags ,
                                          GMountOperation *mount_operation , GCancellable *cancellable ,
                                          GAsyncReadyCallback callback , gpointer user_data ) ;
#line 1062
extern gboolean g_file_mount_enclosing_volume_finish(GFile *location , GAsyncResult *result ,
                                                     GError **error ) ;
#line 1066
extern void g_file_mount_mountable(GFile *file , GMountMountFlags flags , GMountOperation *mount_operation ,
                                   GCancellable *cancellable , GAsyncReadyCallback callback ,
                                   gpointer user_data ) ;
#line 1073
extern GFile *g_file_mount_mountable_finish(GFile *file , GAsyncResult *result , GError **error ) ;
#line 1077
extern void g_file_unmount_mountable(GFile *file , GMountUnmountFlags flags , GCancellable *cancellable ,
                                     GAsyncReadyCallback callback , gpointer user_data ) ;
#line 1084
extern gboolean g_file_unmount_mountable_finish(GFile *file , GAsyncResult *result ,
                                                GError **error ) ;
#line 1088
extern void g_file_unmount_mountable_with_operation(GFile *file , GMountUnmountFlags flags ,
                                                    GMountOperation *mount_operation ,
                                                    GCancellable *cancellable , GAsyncReadyCallback callback ,
                                                    gpointer user_data ) ;
#line 1095
extern gboolean g_file_unmount_mountable_with_operation_finish(GFile *file , GAsyncResult *result ,
                                                               GError **error ) ;
#line 1099
extern void g_file_eject_mountable(GFile *file , GMountUnmountFlags flags , GCancellable *cancellable ,
                                   GAsyncReadyCallback callback , gpointer user_data ) ;
#line 1106
extern gboolean g_file_eject_mountable_finish(GFile *file , GAsyncResult *result ,
                                              GError **error ) ;
#line 1110
extern void g_file_eject_mountable_with_operation(GFile *file , GMountUnmountFlags flags ,
                                                  GMountOperation *mount_operation ,
                                                  GCancellable *cancellable , GAsyncReadyCallback callback ,
                                                  gpointer user_data ) ;
#line 1117
extern gboolean g_file_eject_mountable_with_operation_finish(GFile *file , GAsyncResult *result ,
                                                             GError **error ) ;
#line 1122
extern char *g_file_build_attribute_list_for_copy(GFile *file , GFileCopyFlags flags ,
                                                  GCancellable *cancellable , GError **error ) ;
#line 1128
extern gboolean g_file_copy_attributes(GFile *source , GFile *destination , GFileCopyFlags flags ,
                                       GCancellable *cancellable , GError **error ) ;
#line 1136
extern GFileMonitor *g_file_monitor_directory(GFile *file , GFileMonitorFlags flags ,
                                              GCancellable *cancellable , GError **error ) ;
#line 1141
extern GFileMonitor *g_file_monitor_file(GFile *file , GFileMonitorFlags flags , GCancellable *cancellable ,
                                         GError **error ) ;
#line 1146
extern GFileMonitor *g_file_monitor(GFile *file , GFileMonitorFlags flags , GCancellable *cancellable ,
                                    GError **error ) ;
#line 1152
extern gboolean g_file_measure_disk_usage(GFile *file , GFileMeasureFlags flags ,
                                          GCancellable *cancellable , GFileMeasureProgressCallback progress_callback ,
                                          gpointer progress_data , guint64 *disk_usage ,
                                          guint64 *num_dirs , guint64 *num_files ,
                                          GError **error ) ;
#line 1163
extern void g_file_measure_disk_usage_async(GFile *file , GFileMeasureFlags flags ,
                                            gint io_priority , GCancellable *cancellable ,
                                            GFileMeasureProgressCallback progress_callback ,
                                            gpointer progress_data , GAsyncReadyCallback callback ,
                                            gpointer user_data ) ;
#line 1173
extern gboolean g_file_measure_disk_usage_finish(GFile *file , GAsyncResult *result ,
                                                 guint64 *disk_usage , guint64 *num_dirs ,
                                                 guint64 *num_files , GError **error ) ;
#line 1181
extern void g_file_start_mountable(GFile *file , GDriveStartFlags flags , GMountOperation *start_operation ,
                                   GCancellable *cancellable , GAsyncReadyCallback callback ,
                                   gpointer user_data ) ;
#line 1188
extern gboolean g_file_start_mountable_finish(GFile *file , GAsyncResult *result ,
                                              GError **error ) ;
#line 1192
extern void g_file_stop_mountable(GFile *file , GMountUnmountFlags flags , GMountOperation *mount_operation ,
                                  GCancellable *cancellable , GAsyncReadyCallback callback ,
                                  gpointer user_data ) ;
#line 1199
extern gboolean g_file_stop_mountable_finish(GFile *file , GAsyncResult *result ,
                                             GError **error ) ;
#line 1204
extern void g_file_poll_mountable(GFile *file , GCancellable *cancellable , GAsyncReadyCallback callback ,
                                  gpointer user_data ) ;
#line 1209
extern gboolean g_file_poll_mountable_finish(GFile *file , GAsyncResult *result ,
                                             GError **error ) ;
#line 1216
extern GAppInfo *g_file_query_default_handler(GFile *file , GCancellable *cancellable ,
                                              GError **error ) ;
#line 1220
extern void g_file_query_default_handler_async(GFile *file , int io_priority , GCancellable *cancellable ,
                                               GAsyncReadyCallback callback , gpointer user_data ) ;
#line 1226
extern GAppInfo *g_file_query_default_handler_finish(GFile *file , GAsyncResult *result ,
                                                     GError **error ) ;
#line 1231
extern gboolean g_file_load_contents(GFile *file , GCancellable *cancellable , char **contents ,
                                     gsize *length , char **etag_out , GError **error ) ;
#line 1238
extern void g_file_load_contents_async(GFile *file , GCancellable *cancellable , GAsyncReadyCallback callback ,
                                       gpointer user_data ) ;
#line 1243
extern gboolean g_file_load_contents_finish(GFile *file , GAsyncResult *res , char **contents ,
                                            gsize *length , char **etag_out , GError **error ) ;
#line 1250
extern void g_file_load_partial_contents_async(GFile *file , GCancellable *cancellable ,
                                               GFileReadMoreCallback read_more_callback ,
                                               GAsyncReadyCallback callback , gpointer user_data ) ;
#line 1256
extern gboolean g_file_load_partial_contents_finish(GFile *file , GAsyncResult *res ,
                                                    char **contents , gsize *length ,
                                                    char **etag_out , GError **error ) ;
#line 1263
extern gboolean g_file_replace_contents(GFile *file , char const   *contents , gsize length ,
                                        char const   *etag , gboolean make_backup ,
                                        GFileCreateFlags flags , char **new_etag ,
                                        GCancellable *cancellable , GError **error ) ;
#line 1273
extern void g_file_replace_contents_async(GFile *file , char const   *contents , gsize length ,
                                          char const   *etag , gboolean make_backup ,
                                          GFileCreateFlags flags , GCancellable *cancellable ,
                                          GAsyncReadyCallback callback , gpointer user_data ) ;
#line 1283
extern void g_file_replace_contents_bytes_async(GFile *file , GBytes *contents , char const   *etag ,
                                                gboolean make_backup , GFileCreateFlags flags ,
                                                GCancellable *cancellable , GAsyncReadyCallback callback ,
                                                gpointer user_data ) ;
#line 1292
extern gboolean g_file_replace_contents_finish(GFile *file , GAsyncResult *res , char **new_etag ,
                                               GError **error ) ;
#line 1298
extern gboolean g_file_supports_thread_contexts(GFile *file ) ;
#line 1301
extern GBytes *g_file_load_bytes(GFile *file , GCancellable *cancellable , gchar **etag_out ,
                                 GError **error ) ;
#line 1306
extern void g_file_load_bytes_async(GFile *file , GCancellable *cancellable , GAsyncReadyCallback callback ,
                                    gpointer user_data ) ;
#line 1311
extern GBytes *g_file_load_bytes_finish(GFile *file , GAsyncResult *result , gchar **etag_out ,
                                        GError **error ) ;
#line 63 "/usr/include/glib-2.0/gio/gfileattribute.h"
extern GType g_file_attribute_info_list_get_type(void) ;
#line 66
extern GFileAttributeInfoList *g_file_attribute_info_list_new(void) ;
#line 68
extern GFileAttributeInfoList *g_file_attribute_info_list_ref(GFileAttributeInfoList *list ) ;
#line 70
extern void g_file_attribute_info_list_unref(GFileAttributeInfoList *list ) ;
#line 72
extern GFileAttributeInfoList *g_file_attribute_info_list_dup(GFileAttributeInfoList *list ) ;
#line 74
extern GFileAttributeInfo *g_file_attribute_info_list_lookup(GFileAttributeInfoList *list ,
                                                             char const   *name ) ;
#line 77
extern void g_file_attribute_info_list_add(GFileAttributeInfoList *list , char const   *name ,
                                           GFileAttributeType type , GFileAttributeInfoFlags flags ) ;
#line 98 "/usr/include/glib-2.0/gio/gfileenumerator.h"
extern GType g_file_enumerator_get_type(void) ;
#line 101
extern GFileInfo *g_file_enumerator_next_file(GFileEnumerator *enumerator , GCancellable *cancellable ,
                                              GError **error ) ;
#line 105
extern gboolean g_file_enumerator_close(GFileEnumerator *enumerator , GCancellable *cancellable ,
                                        GError **error ) ;
#line 109
extern void g_file_enumerator_next_files_async(GFileEnumerator *enumerator , int num_files ,
                                               int io_priority , GCancellable *cancellable ,
                                               GAsyncReadyCallback callback , gpointer user_data ) ;
#line 116
extern GList *g_file_enumerator_next_files_finish(GFileEnumerator *enumerator , GAsyncResult *result ,
                                                  GError **error ) ;
#line 120
extern void g_file_enumerator_close_async(GFileEnumerator *enumerator , int io_priority ,
                                          GCancellable *cancellable , GAsyncReadyCallback callback ,
                                          gpointer user_data ) ;
#line 126
extern gboolean g_file_enumerator_close_finish(GFileEnumerator *enumerator , GAsyncResult *result ,
                                               GError **error ) ;
#line 130
extern gboolean g_file_enumerator_is_closed(GFileEnumerator *enumerator ) ;
#line 132
extern gboolean g_file_enumerator_has_pending(GFileEnumerator *enumerator ) ;
#line 134
extern void g_file_enumerator_set_pending(GFileEnumerator *enumerator , gboolean pending ) ;
#line 137
extern GFile *g_file_enumerator_get_container(GFileEnumerator *enumerator ) ;
#line 139
extern GFile *g_file_enumerator_get_child(GFileEnumerator *enumerator , GFileInfo *info ) ;
#line 143
extern gboolean g_file_enumerator_iterate(GFileEnumerator *direnum , GFileInfo **out_info ,
                                          GFile **out_child , GCancellable *cancellable ,
                                          GError **error ) ;
#line 47 "/usr/include/glib-2.0/gio/gfileicon.h"
extern GType g_file_icon_get_type(void) ;
#line 50
extern GIcon *g_file_icon_new(GFile *file ) ;
#line 53
extern GFile *g_file_icon_get_file(GFileIcon *icon ) ;
#line 1070 "/usr/include/glib-2.0/gio/gfileinfo.h"
extern GType g_file_info_get_type(void) ;
#line 1073
extern GFileInfo *g_file_info_new(void) ;
#line 1075
extern GFileInfo *g_file_info_dup(GFileInfo *other ) ;
#line 1077
extern void g_file_info_copy_into(GFileInfo *src_info , GFileInfo *dest_info ) ;
#line 1080
extern gboolean g_file_info_has_attribute(GFileInfo *info , char const   *attribute ) ;
#line 1083
extern gboolean g_file_info_has_namespace(GFileInfo *info , char const   *name_space ) ;
#line 1086
extern char **g_file_info_list_attributes(GFileInfo *info , char const   *name_space ) ;
#line 1089
extern gboolean g_file_info_get_attribute_data(GFileInfo *info , char const   *attribute ,
                                               GFileAttributeType *type , gpointer *value_pp ,
                                               GFileAttributeStatus *status ) ;
#line 1095
extern GFileAttributeType g_file_info_get_attribute_type(GFileInfo *info , char const   *attribute ) ;
#line 1098
extern void g_file_info_remove_attribute(GFileInfo *info , char const   *attribute ) ;
#line 1101
extern GFileAttributeStatus g_file_info_get_attribute_status(GFileInfo *info , char const   *attribute ) ;
#line 1104
extern gboolean g_file_info_set_attribute_status(GFileInfo *info , char const   *attribute ,
                                                 GFileAttributeStatus status ) ;
#line 1108
extern char *g_file_info_get_attribute_as_string(GFileInfo *info , char const   *attribute ) ;
#line 1111
extern char const   *g_file_info_get_attribute_string(GFileInfo *info , char const   *attribute ) ;
#line 1114
extern char const   *g_file_info_get_attribute_byte_string(GFileInfo *info , char const   *attribute ) ;
#line 1117
extern gboolean g_file_info_get_attribute_boolean(GFileInfo *info , char const   *attribute ) ;
#line 1120
extern guint32 g_file_info_get_attribute_uint32(GFileInfo *info , char const   *attribute ) ;
#line 1123
extern gint32 g_file_info_get_attribute_int32(GFileInfo *info , char const   *attribute ) ;
#line 1126
extern guint64 g_file_info_get_attribute_uint64(GFileInfo *info , char const   *attribute ) ;
#line 1129
extern gint64 g_file_info_get_attribute_int64(GFileInfo *info , char const   *attribute ) ;
#line 1132
extern GObject *g_file_info_get_attribute_object(GFileInfo *info , char const   *attribute ) ;
#line 1135
extern char **g_file_info_get_attribute_stringv(GFileInfo *info , char const   *attribute ) ;
#line 1139
extern void g_file_info_set_attribute(GFileInfo *info , char const   *attribute ,
                                      GFileAttributeType type , gpointer value_p ) ;
#line 1144
extern void g_file_info_set_attribute_string(GFileInfo *info , char const   *attribute ,
                                             char const   *attr_value ) ;
#line 1148
extern void g_file_info_set_attribute_byte_string(GFileInfo *info , char const   *attribute ,
                                                  char const   *attr_value ) ;
#line 1152
extern void g_file_info_set_attribute_boolean(GFileInfo *info , char const   *attribute ,
                                              gboolean attr_value ) ;
#line 1156
extern void g_file_info_set_attribute_uint32(GFileInfo *info , char const   *attribute ,
                                             guint32 attr_value ) ;
#line 1160
extern void g_file_info_set_attribute_int32(GFileInfo *info , char const   *attribute ,
                                            gint32 attr_value ) ;
#line 1164
extern void g_file_info_set_attribute_uint64(GFileInfo *info , char const   *attribute ,
                                             guint64 attr_value ) ;
#line 1168
extern void g_file_info_set_attribute_int64(GFileInfo *info , char const   *attribute ,
                                            gint64 attr_value ) ;
#line 1172
extern void g_file_info_set_attribute_object(GFileInfo *info , char const   *attribute ,
                                             GObject *attr_value ) ;
#line 1176
extern void g_file_info_set_attribute_stringv(GFileInfo *info , char const   *attribute ,
                                              char **attr_value ) ;
#line 1181
extern void g_file_info_clear_status(GFileInfo *info ) ;
#line 1185
extern GDateTime *g_file_info_get_deletion_date(GFileInfo *info ) ;
#line 1187
extern GFileType g_file_info_get_file_type(GFileInfo *info ) ;
#line 1189
extern gboolean g_file_info_get_is_hidden(GFileInfo *info ) ;
#line 1191
extern gboolean g_file_info_get_is_backup(GFileInfo *info ) ;
#line 1193
extern gboolean g_file_info_get_is_symlink(GFileInfo *info ) ;
#line 1195
extern char const   *g_file_info_get_name(GFileInfo *info ) ;
#line 1197
extern char const   *g_file_info_get_display_name(GFileInfo *info ) ;
#line 1199
extern char const   *g_file_info_get_edit_name(GFileInfo *info ) ;
#line 1201
extern GIcon *g_file_info_get_icon(GFileInfo *info ) ;
#line 1203
extern GIcon *g_file_info_get_symbolic_icon(GFileInfo *info ) ;
#line 1205
extern char const   *g_file_info_get_content_type(GFileInfo *info ) ;
#line 1207
extern goffset g_file_info_get_size(GFileInfo *info ) ;
#line 1210
extern void g_file_info_get_modification_time(GFileInfo *info , GTimeVal *result ) ;
#line 1214
extern GDateTime *g_file_info_get_modification_date_time(GFileInfo *info ) ;
#line 1216
extern GDateTime *g_file_info_get_access_date_time(GFileInfo *info ) ;
#line 1218
extern GDateTime *g_file_info_get_creation_date_time(GFileInfo *info ) ;
#line 1220
extern char const   *g_file_info_get_symlink_target(GFileInfo *info ) ;
#line 1222
extern char const   *g_file_info_get_etag(GFileInfo *info ) ;
#line 1224
extern gint32 g_file_info_get_sort_order(GFileInfo *info ) ;
#line 1227
extern void g_file_info_set_attribute_mask(GFileInfo *info , GFileAttributeMatcher *mask ) ;
#line 1230
extern void g_file_info_unset_attribute_mask(GFileInfo *info ) ;
#line 1234
extern void g_file_info_set_file_type(GFileInfo *info , GFileType type ) ;
#line 1237
extern void g_file_info_set_is_hidden(GFileInfo *info , gboolean is_hidden ) ;
#line 1240
extern void g_file_info_set_is_symlink(GFileInfo *info , gboolean is_symlink ) ;
#line 1243
extern void g_file_info_set_name(GFileInfo *info , char const   *name ) ;
#line 1246
extern void g_file_info_set_display_name(GFileInfo *info , char const   *display_name ) ;
#line 1249
extern void g_file_info_set_edit_name(GFileInfo *info , char const   *edit_name ) ;
#line 1252
extern void g_file_info_set_icon(GFileInfo *info , GIcon *icon ) ;
#line 1255
extern void g_file_info_set_symbolic_icon(GFileInfo *info , GIcon *icon ) ;
#line 1258
extern void g_file_info_set_content_type(GFileInfo *info , char const   *content_type ) ;
#line 1261
extern void g_file_info_set_size(GFileInfo *info , goffset size ) ;
#line 1265
extern void g_file_info_set_modification_time(GFileInfo *info , GTimeVal *mtime ) ;
#line 1269
extern void g_file_info_set_modification_date_time(GFileInfo *info , GDateTime *mtime ) ;
#line 1272
extern void g_file_info_set_access_date_time(GFileInfo *info , GDateTime *atime ) ;
#line 1275
extern void g_file_info_set_creation_date_time(GFileInfo *info , GDateTime *creation_time ) ;
#line 1278
extern void g_file_info_set_symlink_target(GFileInfo *info , char const   *symlink_target ) ;
#line 1281
extern void g_file_info_set_sort_order(GFileInfo *info , gint32 sort_order ) ;
#line 1286
extern GType g_file_attribute_matcher_get_type(void) ;
#line 1289
extern GFileAttributeMatcher *g_file_attribute_matcher_new(char const   *attributes ) ;
#line 1291
extern GFileAttributeMatcher *g_file_attribute_matcher_ref(GFileAttributeMatcher *matcher ) ;
#line 1293
extern void g_file_attribute_matcher_unref(GFileAttributeMatcher *matcher ) ;
#line 1295
extern GFileAttributeMatcher *g_file_attribute_matcher_subtract(GFileAttributeMatcher *matcher ,
                                                                GFileAttributeMatcher *subtract ) ;
#line 1298
extern gboolean g_file_attribute_matcher_matches(GFileAttributeMatcher *matcher ,
                                                 char const   *attribute ) ;
#line 1301
extern gboolean g_file_attribute_matcher_matches_only(GFileAttributeMatcher *matcher ,
                                                      char const   *attribute ) ;
#line 1304
extern gboolean g_file_attribute_matcher_enumerate_namespace(GFileAttributeMatcher *matcher ,
                                                             char const   *ns ) ;
#line 1307
extern char const   *g_file_attribute_matcher_enumerate_next(GFileAttributeMatcher *matcher ) ;
#line 1309
extern char *g_file_attribute_matcher_to_string(GFileAttributeMatcher *matcher ) ;
#line 93 "/usr/include/glib-2.0/gio/gfileinputstream.h"
extern GType g_file_input_stream_get_type(void) ;
#line 96
extern GFileInfo *g_file_input_stream_query_info(GFileInputStream *stream , char const   *attributes ,
                                                 GCancellable *cancellable , GError **error ) ;
#line 101
extern void g_file_input_stream_query_info_async(GFileInputStream *stream , char const   *attributes ,
                                                 int io_priority , GCancellable *cancellable ,
                                                 GAsyncReadyCallback callback , gpointer user_data ) ;
#line 108
extern GFileInfo *g_file_input_stream_query_info_finish(GFileInputStream *stream ,
                                                        GAsyncResult *result , GError **error ) ;
#line 42 "/usr/include/glib-2.0/gio/gioerror.h"
extern GQuark g_io_error_quark(void) ;
#line 44
extern GIOErrorEnum g_io_error_from_errno(gint err_no ) ;
#line 87 "/usr/include/glib-2.0/gio/giostream.h"
extern GType g_io_stream_get_type(void) ;
#line 90
extern GInputStream *g_io_stream_get_input_stream(GIOStream *stream ) ;
#line 92
extern GOutputStream *g_io_stream_get_output_stream(GIOStream *stream ) ;
#line 95
extern void g_io_stream_splice_async(GIOStream *stream1 , GIOStream *stream2 , GIOStreamSpliceFlags flags ,
                                     int io_priority , GCancellable *cancellable ,
                                     GAsyncReadyCallback callback , gpointer user_data ) ;
#line 104
extern gboolean g_io_stream_splice_finish(GAsyncResult *result , GError **error ) ;
#line 108
extern gboolean g_io_stream_close(GIOStream *stream , GCancellable *cancellable ,
                                  GError **error ) ;
#line 113
extern void g_io_stream_close_async(GIOStream *stream , int io_priority , GCancellable *cancellable ,
                                    GAsyncReadyCallback callback , gpointer user_data ) ;
#line 119
extern gboolean g_io_stream_close_finish(GIOStream *stream , GAsyncResult *result ,
                                         GError **error ) ;
#line 124
extern gboolean g_io_stream_is_closed(GIOStream *stream ) ;
#line 126
extern gboolean g_io_stream_has_pending(GIOStream *stream ) ;
#line 128
extern gboolean g_io_stream_set_pending(GIOStream *stream , GError **error ) ;
#line 131
extern void g_io_stream_clear_pending(GIOStream *stream ) ;
#line 98 "/usr/include/glib-2.0/gio/gfileiostream.h"
extern GType g_file_io_stream_get_type(void) ;
#line 101
extern GFileInfo *g_file_io_stream_query_info(GFileIOStream *stream , char const   *attributes ,
                                              GCancellable *cancellable , GError **error ) ;
#line 106
extern void g_file_io_stream_query_info_async(GFileIOStream *stream , char const   *attributes ,
                                              int io_priority , GCancellable *cancellable ,
                                              GAsyncReadyCallback callback , gpointer user_data ) ;
#line 113
extern GFileInfo *g_file_io_stream_query_info_finish(GFileIOStream *stream , GAsyncResult *result ,
                                                     GError **error ) ;
#line 117
extern char *g_file_io_stream_get_etag(GFileIOStream *stream ) ;
#line 78 "/usr/include/glib-2.0/gio/gfilemonitor.h"
extern GType g_file_monitor_get_type(void) ;
#line 81
extern gboolean g_file_monitor_cancel(GFileMonitor *monitor ) ;
#line 83
extern gboolean g_file_monitor_is_cancelled(GFileMonitor *monitor ) ;
#line 85
extern void g_file_monitor_set_rate_limit(GFileMonitor *monitor , gint limit_msecs ) ;
#line 91
extern void g_file_monitor_emit_event(GFileMonitor *monitor , GFile *child , GFile *other_file ,
                                      GFileMonitorEvent event_type ) ;
#line 62 "/usr/include/glib-2.0/gio/gfilenamecompleter.h"
extern GType g_filename_completer_get_type(void) ;
#line 65
extern GFilenameCompleter *g_filename_completer_new(void) ;
#line 68
extern char *g_filename_completer_get_completion_suffix(GFilenameCompleter *completer ,
                                                        char const   *initial_text ) ;
#line 71
extern char **g_filename_completer_get_completions(GFilenameCompleter *completer ,
                                                   char const   *initial_text ) ;
#line 74
extern void g_filename_completer_set_dirs_only(GFilenameCompleter *completer , gboolean dirs_only ) ;
#line 98 "/usr/include/glib-2.0/gio/gfileoutputstream.h"
extern GType g_file_output_stream_get_type(void) ;
#line 102
extern GFileInfo *g_file_output_stream_query_info(GFileOutputStream *stream , char const   *attributes ,
                                                  GCancellable *cancellable , GError **error ) ;
#line 107
extern void g_file_output_stream_query_info_async(GFileOutputStream *stream , char const   *attributes ,
                                                  int io_priority , GCancellable *cancellable ,
                                                  GAsyncReadyCallback callback , gpointer user_data ) ;
#line 114
extern GFileInfo *g_file_output_stream_query_info_finish(GFileOutputStream *stream ,
                                                         GAsyncResult *result , GError **error ) ;
#line 118
extern char *g_file_output_stream_get_etag(GFileOutputStream *stream ) ;
#line 60 "/usr/include/glib-2.0/gio/ginetaddress.h"
extern GType g_inet_address_get_type(void) ;
#line 63
extern GInetAddress *g_inet_address_new_from_string(gchar *string ) ;
#line 66
extern GInetAddress *g_inet_address_new_from_bytes(guint8 *bytes , GSocketFamily family ) ;
#line 70
extern GInetAddress *g_inet_address_new_loopback(GSocketFamily family ) ;
#line 73
extern GInetAddress *g_inet_address_new_any(GSocketFamily family ) ;
#line 76
extern gboolean g_inet_address_equal(GInetAddress *address , GInetAddress *other_address ) ;
#line 80
extern gchar *g_inet_address_to_string(GInetAddress *address ) ;
#line 83
extern guint8 *g_inet_address_to_bytes(GInetAddress *address ) ;
#line 86
extern gsize g_inet_address_get_native_size(GInetAddress *address ) ;
#line 89
extern GSocketFamily g_inet_address_get_family(GInetAddress *address ) ;
#line 92
extern gboolean g_inet_address_get_is_any(GInetAddress *address ) ;
#line 95
extern gboolean g_inet_address_get_is_loopback(GInetAddress *address ) ;
#line 98
extern gboolean g_inet_address_get_is_link_local(GInetAddress *address ) ;
#line 101
extern gboolean g_inet_address_get_is_site_local(GInetAddress *address ) ;
#line 104
extern gboolean g_inet_address_get_is_multicast(GInetAddress *address ) ;
#line 107
extern gboolean g_inet_address_get_is_mc_global(GInetAddress *address ) ;
#line 110
extern gboolean g_inet_address_get_is_mc_link_local(GInetAddress *address ) ;
#line 113
extern gboolean g_inet_address_get_is_mc_node_local(GInetAddress *address ) ;
#line 116
extern gboolean g_inet_address_get_is_mc_org_local(GInetAddress *address ) ;
#line 119
extern gboolean g_inet_address_get_is_mc_site_local(GInetAddress *address ) ;
#line 55 "/usr/include/glib-2.0/gio/ginetaddressmask.h"
extern GType g_inet_address_mask_get_type(void) ;
#line 58
extern GInetAddressMask *g_inet_address_mask_new(GInetAddress *addr , guint length ,
                                                 GError **error ) ;
#line 63
extern GInetAddressMask *g_inet_address_mask_new_from_string(gchar *mask_string ,
                                                             GError **error ) ;
#line 66
extern gchar *g_inet_address_mask_to_string(GInetAddressMask *mask ) ;
#line 69
extern GSocketFamily g_inet_address_mask_get_family(GInetAddressMask *mask ) ;
#line 71
extern GInetAddress *g_inet_address_mask_get_address(GInetAddressMask *mask ) ;
#line 73
extern guint g_inet_address_mask_get_length(GInetAddressMask *mask ) ;
#line 76
extern gboolean g_inet_address_mask_matches(GInetAddressMask *mask , GInetAddress *address ) ;
#line 79
extern gboolean g_inet_address_mask_equal(GInetAddressMask *mask , GInetAddressMask *mask2 ) ;
#line 62 "/usr/include/glib-2.0/gio/gsocketaddress.h"
extern GType g_socket_address_get_type(void) ;
#line 65
extern GSocketFamily g_socket_address_get_family(GSocketAddress *address ) ;
#line 68
extern GSocketAddress *g_socket_address_new_from_native(gpointer native , gsize len ) ;
#line 72
extern gboolean g_socket_address_to_native(GSocketAddress *address , gpointer dest ,
                                           gsize destlen , GError **error ) ;
#line 78
extern gssize g_socket_address_get_native_size(GSocketAddress *address ) ;
#line 57 "/usr/include/glib-2.0/gio/ginetsocketaddress.h"
extern GType g_inet_socket_address_get_type(void) ;
#line 60
extern GSocketAddress *g_inet_socket_address_new(GInetAddress *address , guint16 port ) ;
#line 63
extern GSocketAddress *g_inet_socket_address_new_from_string(char const   *address ,
                                                             guint port ) ;
#line 67
extern GInetAddress *g_inet_socket_address_get_address(GInetSocketAddress *address ) ;
#line 69
extern guint16 g_inet_socket_address_get_port(GInetSocketAddress *address ) ;
#line 72
extern guint32 g_inet_socket_address_get_flowinfo(GInetSocketAddress *address ) ;
#line 74
extern guint32 g_inet_socket_address_get_scope_id(GInetSocketAddress *address ) ;
#line 12 "/usr/include/glib-2.0/gio/gioenumtypes.h"
extern GType g_app_info_create_flags_get_type(void) ;
#line 14
extern GType g_converter_flags_get_type(void) ;
#line 16
extern GType g_converter_result_get_type(void) ;
#line 18
extern GType g_data_stream_byte_order_get_type(void) ;
#line 20
extern GType g_data_stream_newline_type_get_type(void) ;
#line 22
extern GType g_file_attribute_type_get_type(void) ;
#line 24
extern GType g_file_attribute_info_flags_get_type(void) ;
#line 26
extern GType g_file_attribute_status_get_type(void) ;
#line 28
extern GType g_file_query_info_flags_get_type(void) ;
#line 30
extern GType g_file_create_flags_get_type(void) ;
#line 32
extern GType g_file_measure_flags_get_type(void) ;
#line 34
extern GType g_mount_mount_flags_get_type(void) ;
#line 36
extern GType g_mount_unmount_flags_get_type(void) ;
#line 38
extern GType g_drive_start_flags_get_type(void) ;
#line 40
extern GType g_drive_start_stop_type_get_type(void) ;
#line 42
extern GType g_file_copy_flags_get_type(void) ;
#line 44
extern GType g_file_monitor_flags_get_type(void) ;
#line 46
extern GType g_file_type_get_type(void) ;
#line 48
extern GType g_filesystem_preview_type_get_type(void) ;
#line 50
extern GType g_file_monitor_event_get_type(void) ;
#line 52
extern GType g_io_error_enum_get_type(void) ;
#line 54
extern GType g_ask_password_flags_get_type(void) ;
#line 56
extern GType g_password_save_get_type(void) ;
#line 58
extern GType g_mount_operation_result_get_type(void) ;
#line 60
extern GType g_output_stream_splice_flags_get_type(void) ;
#line 62
extern GType g_io_stream_splice_flags_get_type(void) ;
#line 64
extern GType g_emblem_origin_get_type(void) ;
#line 66
extern GType g_resolver_error_get_type(void) ;
#line 68
extern GType g_resolver_record_type_get_type(void) ;
#line 70
extern GType g_resource_error_get_type(void) ;
#line 72
extern GType g_resource_flags_get_type(void) ;
#line 74
extern GType g_resource_lookup_flags_get_type(void) ;
#line 76
extern GType g_socket_family_get_type(void) ;
#line 78
extern GType g_socket_type_get_type(void) ;
#line 80
extern GType g_socket_msg_flags_get_type(void) ;
#line 82
extern GType g_socket_protocol_get_type(void) ;
#line 84
extern GType g_zlib_compressor_format_get_type(void) ;
#line 86
extern GType g_unix_socket_address_type_get_type(void) ;
#line 88
extern GType g_bus_type_get_type(void) ;
#line 90
extern GType g_bus_name_owner_flags_get_type(void) ;
#line 92
extern GType g_bus_name_watcher_flags_get_type(void) ;
#line 94
extern GType g_dbus_proxy_flags_get_type(void) ;
#line 96
extern GType g_dbus_error_get_type(void) ;
#line 98
extern GType g_dbus_connection_flags_get_type(void) ;
#line 100
extern GType g_dbus_capability_flags_get_type(void) ;
#line 102
extern GType g_dbus_call_flags_get_type(void) ;
#line 104
extern GType g_dbus_message_type_get_type(void) ;
#line 106
extern GType g_dbus_message_flags_get_type(void) ;
#line 108
extern GType g_dbus_message_header_field_get_type(void) ;
#line 110
extern GType g_dbus_property_info_flags_get_type(void) ;
#line 112
extern GType g_dbus_subtree_flags_get_type(void) ;
#line 114
extern GType g_dbus_server_flags_get_type(void) ;
#line 116
extern GType g_dbus_signal_flags_get_type(void) ;
#line 118
extern GType g_dbus_send_message_flags_get_type(void) ;
#line 120
extern GType g_credentials_type_get_type(void) ;
#line 122
extern GType g_dbus_message_byte_order_get_type(void) ;
#line 124
extern GType g_application_flags_get_type(void) ;
#line 126
extern GType g_tls_error_get_type(void) ;
#line 128
extern GType g_tls_certificate_flags_get_type(void) ;
#line 130
extern GType g_tls_authentication_mode_get_type(void) ;
#line 132
extern GType g_tls_channel_binding_type_get_type(void) ;
#line 134
extern GType g_tls_channel_binding_error_get_type(void) ;
#line 136
extern GType g_tls_rehandshake_mode_get_type(void) ;
#line 138
extern GType g_tls_password_flags_get_type(void) ;
#line 140
extern GType g_tls_interaction_result_get_type(void) ;
#line 142
extern GType g_dbus_interface_skeleton_flags_get_type(void) ;
#line 144
extern GType g_dbus_object_manager_client_flags_get_type(void) ;
#line 146
extern GType g_tls_database_verify_flags_get_type(void) ;
#line 148
extern GType g_tls_database_lookup_flags_get_type(void) ;
#line 150
extern GType g_tls_certificate_request_flags_get_type(void) ;
#line 152
extern GType g_tls_protocol_version_get_type(void) ;
#line 154
extern GType g_io_module_scope_flags_get_type(void) ;
#line 156
extern GType g_socket_client_event_get_type(void) ;
#line 158
extern GType g_socket_listener_event_get_type(void) ;
#line 160
extern GType g_test_dbus_flags_get_type(void) ;
#line 162
extern GType g_subprocess_flags_get_type(void) ;
#line 164
extern GType g_notification_priority_get_type(void) ;
#line 166
extern GType g_network_connectivity_get_type(void) ;
#line 168
extern GType g_pollable_return_get_type(void) ;
#line 170
extern GType g_memory_monitor_warning_level_get_type(void) ;
#line 174
extern GType g_resolver_name_lookup_flags_get_type(void) ;
#line 178
extern GType g_settings_bind_flags_get_type(void) ;
#line 71 "/usr/include/glib-2.0/gmodule.h"
extern GQuark g_module_error_quark(void) ;
#line 91
extern gboolean g_module_supported(void) ;
#line 95
extern GModule *g_module_open(gchar *file_name , GModuleFlags flags ) ;
#line 99
extern GModule *g_module_open_full(gchar *file_name , GModuleFlags flags , GError **error ) ;
#line 105
extern gboolean g_module_close(GModule *module ) ;
#line 109
extern void g_module_make_resident(GModule *module ) ;
#line 113
extern gchar *g_module_error(void) ;
#line 117
extern gboolean g_module_symbol(GModule *module , gchar *symbol_name , gpointer *symbol ) ;
#line 123
extern gchar *g_module_name(GModule *module ) ;
#line 137
extern gchar *g_module_build_path(gchar *directory , gchar *module_name ) ;
#line 36 "/usr/include/glib-2.0/gio/giomodule.h"
extern GIOModuleScope *g_io_module_scope_new(GIOModuleScopeFlags flags ) ;
#line 38
extern void g_io_module_scope_free(GIOModuleScope *scope ) ;
#line 40
extern void g_io_module_scope_block(GIOModuleScope *scope , gchar *basename ) ;
#line 58
extern GType g_io_module_get_type(void) ;
#line 60
extern GIOModule *g_io_module_new(gchar *filename ) ;
#line 63
extern void g_io_modules_scan_all_in_directory(char const   *dirname ) ;
#line 65
extern GList *g_io_modules_load_all_in_directory(gchar *dirname ) ;
#line 68
extern void g_io_modules_scan_all_in_directory_with_scope(gchar *dirname , GIOModuleScope *scope ) ;
#line 71
extern GList *g_io_modules_load_all_in_directory_with_scope(gchar *dirname , GIOModuleScope *scope ) ;
#line 75
extern GIOExtensionPoint *g_io_extension_point_register(char const   *name ) ;
#line 77
extern GIOExtensionPoint *g_io_extension_point_lookup(char const   *name ) ;
#line 79
extern void g_io_extension_point_set_required_type(GIOExtensionPoint *extension_point ,
                                                   GType type ) ;
#line 82
extern GType g_io_extension_point_get_required_type(GIOExtensionPoint *extension_point ) ;
#line 84
extern GList *g_io_extension_point_get_extensions(GIOExtensionPoint *extension_point ) ;
#line 86
extern GIOExtension *g_io_extension_point_get_extension_by_name(GIOExtensionPoint *extension_point ,
                                                                char const   *name ) ;
#line 89
extern GIOExtension *g_io_extension_point_implement(char const   *extension_point_name ,
                                                    GType type , char const   *extension_name ,
                                                    gint priority ) ;
#line 95
extern GType g_io_extension_get_type(GIOExtension *extension ) ;
#line 97
extern char const   *g_io_extension_get_name(GIOExtension *extension ) ;
#line 99
extern gint g_io_extension_get_priority(GIOExtension *extension ) ;
#line 101
extern GTypeClass *g_io_extension_ref_class(GIOExtension *extension ) ;
#line 125
extern void g_io_module_load(GIOModule *module ) ;
#line 145
extern void g_io_module_unload(GIOModule *module ) ;
#line 189
extern char **g_io_module_query(void) ;
#line 34 "/usr/include/glib-2.0/gio/gioscheduler.h"
extern void g_io_scheduler_push_job(GIOSchedulerJobFunc job_func , gpointer user_data ,
                                    GDestroyNotify notify , gint io_priority , GCancellable *cancellable ) ;
#line 40
extern void g_io_scheduler_cancel_all_jobs(void) ;
#line 42
extern gboolean g_io_scheduler_job_send_to_mainloop(GIOSchedulerJob *job , GSourceFunc func ,
                                                    gpointer user_data , GDestroyNotify notify ) ;
#line 47
extern void g_io_scheduler_job_send_to_mainloop_async(GIOSchedulerJob *job , GSourceFunc func ,
                                                      gpointer user_data , GDestroyNotify notify ) ;
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
extern GType g_list_model_get_type(void) ;
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
__inline static void glib_autoptr_clear_GListModel(GListModel *_ptr ) 
{ 


  {
#line 36
  if (_ptr) {
    {
#line 36
    glib_autoptr_clear_GObject((GObject *)_ptr);
    }
  }
  return;
}
}
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
__inline static void glib_autoptr_cleanup_GListModel(GListModel **_ptr ) 
{ 


  {
  {
#line 36
  glib_autoptr_clear_GListModel(*_ptr);
  }
  return;
}
}
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
__inline static GListModel *G_LIST_MODEL(gpointer ptr ) 
{ 
  GType __cil_tmp2 ;
  GTypeInstance *__cil_tmp3 ;

  {
  {
#line 36
  __cil_tmp2 = g_list_model_get_type();
#line 36
  __cil_tmp3 = g_type_check_instance_cast((GTypeInstance *)ptr, __cil_tmp2);
  }
#line 36
  return ((GListModel *)((void *)__cil_tmp3));
}
}
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
__inline static GListModelInterface *G_LIST_MODEL_GET_IFACE(gpointer ptr ) 
{ 
  GType __cil_tmp2 ;
  gpointer __cil_tmp3 ;

  {
  {
#line 36
  __cil_tmp2 = g_list_model_get_type();
#line 36
  __cil_tmp3 = g_type_interface_peek(((GTypeInstance *)ptr)->g_class, __cil_tmp2);
  }
#line 36
  return ((GListModelInterface *)__cil_tmp3);
}
}
#line 51
extern GType g_list_model_get_item_type(GListModel *list ) ;
#line 54
extern guint g_list_model_get_n_items(GListModel *list ) ;
#line 57
extern gpointer g_list_model_get_item(GListModel *list , guint position ) ;
#line 61
extern GObject *g_list_model_get_object(GListModel *list , guint position ) ;
#line 65
extern void g_list_model_items_changed(GListModel *list , guint position , guint removed ,
                                       guint added ) ;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
extern GType g_list_store_get_type(void) ;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
__inline static void glib_autoptr_clear_GListStore(GListStore *_ptr ) 
{ 


  {
#line 36
  if (_ptr) {
    {
#line 36
    glib_autoptr_clear_GObject((GObject *)_ptr);
    }
  }
  return;
}
}
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
__inline static void glib_autoptr_cleanup_GListStore(GListStore **_ptr ) 
{ 


  {
  {
#line 36
  glib_autoptr_clear_GListStore(*_ptr);
  }
  return;
}
}
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
__inline static void glib_autoptr_clear_GListStoreClass(GListStoreClass *_ptr ) 
{ 


  {
#line 36
  if (_ptr) {
    {
#line 36
    g_type_class_unref((GListStoreClass *)_ptr);
    }
  }
  return;
}
}
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
__inline static void glib_autoptr_cleanup_GListStoreClass(GListStoreClass **_ptr ) 
{ 


  {
  {
#line 36
  glib_autoptr_clear_GListStoreClass(*_ptr);
  }
  return;
}
}
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
__inline static GListStore *G_LIST_STORE(gpointer ptr ) 
{ 
  GType __cil_tmp2 ;
  GTypeInstance *__cil_tmp3 ;

  {
  {
#line 36
  __cil_tmp2 = g_list_store_get_type();
#line 36
  __cil_tmp3 = g_type_check_instance_cast((GTypeInstance *)ptr, __cil_tmp2);
  }
#line 36
  return ((GListStore *)((void *)__cil_tmp3));
}
}
#line 39
extern GListStore *g_list_store_new(GType item_type ) ;
#line 42
extern void g_list_store_insert(GListStore *store , guint position , gpointer item ) ;
#line 47
extern guint g_list_store_insert_sorted(GListStore *store , gpointer item , GCompareDataFunc compare_func ,
                                        gpointer user_data ) ;
#line 53
extern void g_list_store_sort(GListStore *store , GCompareDataFunc compare_func ,
                              gpointer user_data ) ;
#line 58
extern void g_list_store_append(GListStore *store , gpointer item ) ;
#line 62
extern void g_list_store_remove(GListStore *store , guint position ) ;
#line 66
extern void g_list_store_remove_all(GListStore *store ) ;
#line 69
extern void g_list_store_splice(GListStore *store , guint position , guint n_removals ,
                                gpointer *additions , guint n_additions ) ;
#line 76
extern gboolean g_list_store_find(GListStore *store , gpointer item , guint *position ) ;
#line 81
extern gboolean g_list_store_find_with_equal_func(GListStore *store , gpointer item ,
                                                  GEqualFunc equal_func , guint *position ) ;
#line 77 "/usr/include/glib-2.0/gio/gloadableicon.h"
extern GType g_loadable_icon_get_type(void) ;
#line 80
extern GInputStream *g_loadable_icon_load(GLoadableIcon *icon , int size , char **type ,
                                          GCancellable *cancellable , GError **error ) ;
#line 86
extern void g_loadable_icon_load_async(GLoadableIcon *icon , int size , GCancellable *cancellable ,
                                       GAsyncReadyCallback callback , gpointer user_data ) ;
#line 92
extern GInputStream *g_loadable_icon_load_finish(GLoadableIcon *icon , GAsyncResult *res ,
                                                 char **type , GError **error ) ;
#line 69 "/usr/include/glib-2.0/gio/gmemoryinputstream.h"
extern GType g_memory_input_stream_get_type(void) ;
#line 71
extern GInputStream *g_memory_input_stream_new(void) ;
#line 73
extern GInputStream *g_memory_input_stream_new_from_data(void const   *data , gssize len ,
                                                         GDestroyNotify destroy ) ;
#line 77
extern GInputStream *g_memory_input_stream_new_from_bytes(GBytes *bytes ) ;
#line 80
extern void g_memory_input_stream_add_data(GMemoryInputStream *stream , void const   *data ,
                                           gssize len , GDestroyNotify destroy ) ;
#line 85
extern void g_memory_input_stream_add_bytes(GMemoryInputStream *stream , GBytes *bytes ) ;
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
extern GType g_memory_monitor_get_type(void) ;
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
__inline static void glib_autoptr_clear_GMemoryMonitor(GMemoryMonitor *_ptr ) 
{ 


  {
#line 42
  if (_ptr) {
    {
#line 42
    glib_autoptr_clear_GObject((GObject *)_ptr);
    }
  }
  return;
}
}
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
__inline static void glib_autoptr_cleanup_GMemoryMonitor(GMemoryMonitor **_ptr ) 
{ 


  {
  {
#line 42
  glib_autoptr_clear_GMemoryMonitor(*_ptr);
  }
  return;
}
}
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
__inline static GMemoryMonitor *g_memory_monitor(gpointer ptr ) 
{ 
  GType __cil_tmp2 ;
  GTypeInstance *__cil_tmp3 ;

  {
  {
#line 42
  __cil_tmp2 = g_memory_monitor_get_type();
#line 42
  __cil_tmp3 = g_type_check_instance_cast((GTypeInstance *)ptr, __cil_tmp2);
  }
#line 42
  return ((GMemoryMonitor *)((void *)__cil_tmp3));
}
}
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
__inline static GMemoryMonitorInterface *g_memory_monitor_GET_IFACE(gpointer ptr ) 
{ 
  GType __cil_tmp2 ;
  gpointer __cil_tmp3 ;

  {
  {
#line 42
  __cil_tmp2 = g_memory_monitor_get_type();
#line 42
  __cil_tmp3 = g_type_interface_peek(((GTypeInstance *)ptr)->g_class, __cil_tmp2);
  }
#line 42
  return ((GMemoryMonitorInterface *)__cil_tmp3);
}
}
#line 58
extern GMemoryMonitor *g_memory_monitor_dup_default(void) ;
#line 84 "/usr/include/glib-2.0/gio/gmemoryoutputstream.h"
extern GType g_memory_output_stream_get_type(void) ;
#line 87
extern GOutputStream *g_memory_output_stream_new(gpointer data , gsize size , GReallocFunc realloc_function ,
                                                 GDestroyNotify destroy_function ) ;
#line 92
extern GOutputStream *g_memory_output_stream_new_resizable(void) ;
#line 94
extern gpointer g_memory_output_stream_get_data(GMemoryOutputStream *ostream ) ;
#line 96
extern gsize g_memory_output_stream_get_size(GMemoryOutputStream *ostream ) ;
#line 98
extern gsize g_memory_output_stream_get_data_size(GMemoryOutputStream *ostream ) ;
#line 100
extern gpointer g_memory_output_stream_steal_data(GMemoryOutputStream *ostream ) ;
#line 103
extern GBytes *g_memory_output_stream_steal_as_bytes(GMemoryOutputStream *ostream ) ;
#line 184 "/usr/include/glib-2.0/gio/gmenumodel.h"
extern GType g_menu_model_get_type(void) ;
#line 187
extern gboolean g_menu_model_is_mutable(GMenuModel *model ) ;
#line 189
extern gint g_menu_model_get_n_items(GMenuModel *model ) ;
#line 192
extern GMenuAttributeIter *g_menu_model_iterate_item_attributes(GMenuModel *model ,
                                                                gint item_index ) ;
#line 195
extern GVariant *g_menu_model_get_item_attribute_value(GMenuModel *model , gint item_index ,
                                                       gchar *attribute , GVariantType *expected_type ) ;
#line 200
extern gboolean g_menu_model_get_item_attribute(GMenuModel *model , gint item_index ,
                                                gchar *attribute , gchar *format_string 
                                                , ...) ;
#line 206
extern GMenuLinkIter *g_menu_model_iterate_item_links(GMenuModel *model , gint item_index ) ;
#line 209
extern GMenuModel *g_menu_model_get_item_link(GMenuModel *model , gint item_index ,
                                              gchar *link ) ;
#line 214
extern void g_menu_model_items_changed(GMenuModel *model , gint position , gint removed ,
                                       gint added ) ;
#line 248
extern GType g_menu_attribute_iter_get_type(void) ;
#line 251
extern gboolean g_menu_attribute_iter_get_next(GMenuAttributeIter *iter , gchar **out_name ,
                                               GVariant **value ) ;
#line 255
extern gboolean g_menu_attribute_iter_next(GMenuAttributeIter *iter ) ;
#line 257
extern gchar *g_menu_attribute_iter_get_name(GMenuAttributeIter *iter ) ;
#line 259
extern GVariant *g_menu_attribute_iter_get_value(GMenuAttributeIter *iter ) ;
#line 290
extern GType g_menu_link_iter_get_type(void) ;
#line 293
extern gboolean g_menu_link_iter_get_next(GMenuLinkIter *iter , gchar **out_link ,
                                          GMenuModel **value ) ;
#line 297
extern gboolean g_menu_link_iter_next(GMenuLinkIter *iter ) ;
#line 299
extern gchar *g_menu_link_iter_get_name(GMenuLinkIter *iter ) ;
#line 301
extern GMenuModel *g_menu_link_iter_get_value(GMenuLinkIter *iter ) ;
#line 43 "/usr/include/glib-2.0/gio/gmenu.h"
extern GType g_menu_get_type(void) ;
#line 45
extern GMenu *g_menu_new(void) ;
#line 48
extern void g_menu_freeze(GMenu *menu ) ;
#line 51
extern void g_menu_insert_item(GMenu *menu , gint position , GMenuItem *item ) ;
#line 55
extern void g_menu_prepend_item(GMenu *menu , GMenuItem *item ) ;
#line 58
extern void g_menu_append_item(GMenu *menu , GMenuItem *item ) ;
#line 61
extern void g_menu_remove(GMenu *menu , gint position ) ;
#line 65
extern void g_menu_remove_all(GMenu *menu ) ;
#line 68
extern void g_menu_insert(GMenu *menu , gint position , gchar *label , gchar *detailed_action ) ;
#line 73
extern void g_menu_prepend(GMenu *menu , gchar *label , gchar *detailed_action ) ;
#line 77
extern void g_menu_append(GMenu *menu , gchar *label , gchar *detailed_action ) ;
#line 82
extern void g_menu_insert_section(GMenu *menu , gint position , gchar *label , GMenuModel *section ) ;
#line 87
extern void g_menu_prepend_section(GMenu *menu , gchar *label , GMenuModel *section ) ;
#line 91
extern void g_menu_append_section(GMenu *menu , gchar *label , GMenuModel *section ) ;
#line 96
extern void g_menu_insert_submenu(GMenu *menu , gint position , gchar *label , GMenuModel *submenu ) ;
#line 101
extern void g_menu_prepend_submenu(GMenu *menu , gchar *label , GMenuModel *submenu ) ;
#line 105
extern void g_menu_append_submenu(GMenu *menu , gchar *label , GMenuModel *submenu ) ;
#line 111
extern GType g_menu_item_get_type(void) ;
#line 113
extern GMenuItem *g_menu_item_new(gchar *label , gchar *detailed_action ) ;
#line 117
extern GMenuItem *g_menu_item_new_from_model(GMenuModel *model , gint item_index ) ;
#line 121
extern GMenuItem *g_menu_item_new_submenu(gchar *label , GMenuModel *submenu ) ;
#line 125
extern GMenuItem *g_menu_item_new_section(gchar *label , GMenuModel *section ) ;
#line 129
extern GVariant *g_menu_item_get_attribute_value(GMenuItem *menu_item , gchar *attribute ,
                                                 GVariantType *expected_type ) ;
#line 133
extern gboolean g_menu_item_get_attribute(GMenuItem *menu_item , gchar *attribute ,
                                          gchar *format_string  , ...) ;
#line 138
extern GMenuModel *g_menu_item_get_link(GMenuItem *menu_item , gchar *link ) ;
#line 142
extern void g_menu_item_set_attribute_value(GMenuItem *menu_item , gchar *attribute ,
                                            GVariant *value ) ;
#line 146
extern void g_menu_item_set_attribute(GMenuItem *menu_item , gchar *attribute , gchar *format_string 
                                      , ...) ;
#line 151
extern void g_menu_item_set_link(GMenuItem *menu_item , gchar *link , GMenuModel *model ) ;
#line 155
extern void g_menu_item_set_label(GMenuItem *menu_item , gchar *label ) ;
#line 158
extern void g_menu_item_set_submenu(GMenuItem *menu_item , GMenuModel *submenu ) ;
#line 161
extern void g_menu_item_set_section(GMenuItem *menu_item , GMenuModel *section ) ;
#line 164
extern void g_menu_item_set_action_and_target_value(GMenuItem *menu_item , gchar *action ,
                                                    GVariant *target_value ) ;
#line 168
extern void g_menu_item_set_action_and_target(GMenuItem *menu_item , gchar *action ,
                                              gchar *format_string  , ...) ;
#line 173
extern void g_menu_item_set_detailed_action(GMenuItem *menu_item , gchar *detailed_action ) ;
#line 177
extern void g_menu_item_set_icon(GMenuItem *menu_item , GIcon *icon ) ;
#line 29 "/usr/include/glib-2.0/gio/gmenuexporter.h"
extern guint g_dbus_connection_export_menu_model(GDBusConnection *connection , gchar *object_path ,
                                                 GMenuModel *menu , GError **error ) ;
#line 35
extern void g_dbus_connection_unexport_menu_model(GDBusConnection *connection , guint export_id ) ;
#line 165 "/usr/include/glib-2.0/gio/gmount.h"
extern GType g_mount_get_type(void) ;
#line 168
extern GFile *g_mount_get_root(GMount *mount ) ;
#line 170
extern GFile *g_mount_get_default_location(GMount *mount ) ;
#line 172
extern char *g_mount_get_name(GMount *mount ) ;
#line 174
extern GIcon *g_mount_get_icon(GMount *mount ) ;
#line 176
extern GIcon *g_mount_get_symbolic_icon(GMount *mount ) ;
#line 178
extern char *g_mount_get_uuid(GMount *mount ) ;
#line 180
extern GVolume *g_mount_get_volume(GMount *mount ) ;
#line 182
extern GDrive *g_mount_get_drive(GMount *mount ) ;
#line 184
extern gboolean g_mount_can_unmount(GMount *mount ) ;
#line 186
extern gboolean g_mount_can_eject(GMount *mount ) ;
#line 189
extern void g_mount_unmount(GMount *mount , GMountUnmountFlags flags , GCancellable *cancellable ,
                            GAsyncReadyCallback callback , gpointer user_data ) ;
#line 196
extern gboolean g_mount_unmount_finish(GMount *mount , GAsyncResult *result , GError **error ) ;
#line 201
extern void g_mount_eject(GMount *mount , GMountUnmountFlags flags , GCancellable *cancellable ,
                          GAsyncReadyCallback callback , gpointer user_data ) ;
#line 208
extern gboolean g_mount_eject_finish(GMount *mount , GAsyncResult *result , GError **error ) ;
#line 213
extern void g_mount_remount(GMount *mount , GMountMountFlags flags , GMountOperation *mount_operation ,
                            GCancellable *cancellable , GAsyncReadyCallback callback ,
                            gpointer user_data ) ;
#line 220
extern gboolean g_mount_remount_finish(GMount *mount , GAsyncResult *result , GError **error ) ;
#line 225
extern void g_mount_guess_content_type(GMount *mount , gboolean force_rescan , GCancellable *cancellable ,
                                       GAsyncReadyCallback callback , gpointer user_data ) ;
#line 231
extern gchar **g_mount_guess_content_type_finish(GMount *mount , GAsyncResult *result ,
                                                 GError **error ) ;
#line 235
extern gchar **g_mount_guess_content_type_sync(GMount *mount , gboolean force_rescan ,
                                               GCancellable *cancellable , GError **error ) ;
#line 241
extern gboolean g_mount_is_shadowed(GMount *mount ) ;
#line 243
extern void g_mount_shadow(GMount *mount ) ;
#line 245
extern void g_mount_unshadow(GMount *mount ) ;
#line 248
extern void g_mount_unmount_with_operation(GMount *mount , GMountUnmountFlags flags ,
                                           GMountOperation *mount_operation , GCancellable *cancellable ,
                                           GAsyncReadyCallback callback , gpointer user_data ) ;
#line 255
extern gboolean g_mount_unmount_with_operation_finish(GMount *mount , GAsyncResult *result ,
                                                      GError **error ) ;
#line 260
extern void g_mount_eject_with_operation(GMount *mount , GMountUnmountFlags flags ,
                                         GMountOperation *mount_operation , GCancellable *cancellable ,
                                         GAsyncReadyCallback callback , gpointer user_data ) ;
#line 267
extern gboolean g_mount_eject_with_operation_finish(GMount *mount , GAsyncResult *result ,
                                                    GError **error ) ;
#line 272
extern gchar *g_mount_get_sort_key(GMount *mount ) ;
#line 122 "/usr/include/glib-2.0/gio/gmountoperation.h"
extern GType g_mount_operation_get_type(void) ;
#line 124
extern GMountOperation *g_mount_operation_new(void) ;
#line 127
extern char const   *g_mount_operation_get_username(GMountOperation *op ) ;
#line 129
extern void g_mount_operation_set_username(GMountOperation *op , char const   *username ) ;
#line 132
extern char const   *g_mount_operation_get_password(GMountOperation *op ) ;
#line 134
extern void g_mount_operation_set_password(GMountOperation *op , char const   *password ) ;
#line 137
extern gboolean g_mount_operation_get_anonymous(GMountOperation *op ) ;
#line 139
extern void g_mount_operation_set_anonymous(GMountOperation *op , gboolean anonymous ) ;
#line 142
extern char const   *g_mount_operation_get_domain(GMountOperation *op ) ;
#line 144
extern void g_mount_operation_set_domain(GMountOperation *op , char const   *domain ) ;
#line 147
extern GPasswordSave g_mount_operation_get_password_save(GMountOperation *op ) ;
#line 149
extern void g_mount_operation_set_password_save(GMountOperation *op , GPasswordSave save ) ;
#line 152
extern int g_mount_operation_get_choice(GMountOperation *op ) ;
#line 154
extern void g_mount_operation_set_choice(GMountOperation *op , int choice ) ;
#line 157
extern void g_mount_operation_reply(GMountOperation *op , GMountOperationResult result ) ;
#line 160
extern gboolean g_mount_operation_get_is_tcrypt_hidden_volume(GMountOperation *op ) ;
#line 162
extern void g_mount_operation_set_is_tcrypt_hidden_volume(GMountOperation *op , gboolean hidden_volume ) ;
#line 165
extern gboolean g_mount_operation_get_is_tcrypt_system_volume(GMountOperation *op ) ;
#line 167
extern void g_mount_operation_set_is_tcrypt_system_volume(GMountOperation *op , gboolean system_volume ) ;
#line 170
extern guint g_mount_operation_get_pim(GMountOperation *op ) ;
#line 172
extern void g_mount_operation_set_pim(GMountOperation *op , guint pim ) ;
#line 57 "/usr/include/glib-2.0/gio/gnativesocketaddress.h"
extern GType g_native_socket_address_get_type(void) ;
#line 60
extern GSocketAddress *g_native_socket_address_new(gpointer native , gsize len ) ;
#line 132 "/usr/include/glib-2.0/gio/gvolumemonitor.h"
extern GType g_volume_monitor_get_type(void) ;
#line 135
extern GVolumeMonitor *g_volume_monitor_get(void) ;
#line 137
extern GList *g_volume_monitor_get_connected_drives(GVolumeMonitor *volume_monitor ) ;
#line 139
extern GList *g_volume_monitor_get_volumes(GVolumeMonitor *volume_monitor ) ;
#line 141
extern GList *g_volume_monitor_get_mounts(GVolumeMonitor *volume_monitor ) ;
#line 143
extern GVolume *g_volume_monitor_get_volume_for_uuid(GVolumeMonitor *volume_monitor ,
                                                     char const   *uuid ) ;
#line 146
extern GMount *g_volume_monitor_get_mount_for_uuid(GVolumeMonitor *volume_monitor ,
                                                   char const   *uuid ) ;
#line 150
extern GVolume *g_volume_monitor_adopt_orphan_mount(GMount *mount ) ;
#line 57 "/usr/include/glib-2.0/gio/gnativevolumemonitor.h"
extern GType g_native_volume_monitor_get_type(void) ;
#line 55 "/usr/include/glib-2.0/gio/gnetworkaddress.h"
extern GType g_network_address_get_type(void) ;
#line 58
extern GSocketConnectable *g_network_address_new(gchar *hostname , guint16 port ) ;
#line 61
extern GSocketConnectable *g_network_address_new_loopback(guint16 port ) ;
#line 63
extern GSocketConnectable *g_network_address_parse(gchar *host_and_port , guint16 default_port ,
                                                   GError **error ) ;
#line 67
extern GSocketConnectable *g_network_address_parse_uri(gchar *uri , guint16 default_port ,
                                                       GError **error ) ;
#line 71
extern gchar *g_network_address_get_hostname(GNetworkAddress *addr ) ;
#line 73
extern guint16 g_network_address_get_port(GNetworkAddress *addr ) ;
#line 75
extern gchar *g_network_address_get_scheme(GNetworkAddress *addr ) ;
#line 68 "/usr/include/glib-2.0/gio/gnetworkmonitor.h"
extern GType g_network_monitor_get_type(void) ;
#line 70
extern GNetworkMonitor *g_network_monitor_get_default(void) ;
#line 73
extern gboolean g_network_monitor_get_network_available(GNetworkMonitor *monitor ) ;
#line 76
extern gboolean g_network_monitor_get_network_metered(GNetworkMonitor *monitor ) ;
#line 79
extern GNetworkConnectivity g_network_monitor_get_connectivity(GNetworkMonitor *monitor ) ;
#line 82
extern gboolean g_network_monitor_can_reach(GNetworkMonitor *monitor , GSocketConnectable *connectable ,
                                            GCancellable *cancellable , GError **error ) ;
#line 87
extern void g_network_monitor_can_reach_async(GNetworkMonitor *monitor , GSocketConnectable *connectable ,
                                              GCancellable *cancellable , GAsyncReadyCallback callback ,
                                              gpointer user_data ) ;
#line 93
extern gboolean g_network_monitor_can_reach_finish(GNetworkMonitor *monitor , GAsyncResult *result ,
                                                   GError **error ) ;
#line 55 "/usr/include/glib-2.0/gio/gnetworkservice.h"
extern GType g_network_service_get_type(void) ;
#line 58
extern GSocketConnectable *g_network_service_new(gchar *service , gchar *protocol ,
                                                 gchar *domain ) ;
#line 63
extern gchar *g_network_service_get_service(GNetworkService *srv ) ;
#line 65
extern gchar *g_network_service_get_protocol(GNetworkService *srv ) ;
#line 67
extern gchar *g_network_service_get_domain(GNetworkService *srv ) ;
#line 69
extern gchar *g_network_service_get_scheme(GNetworkService *srv ) ;
#line 71
extern void g_network_service_set_scheme(GNetworkService *srv , gchar *scheme ) ;
#line 37 "/usr/include/glib-2.0/gio/gnotification.h"
extern GType g_notification_get_type(void) ;
#line 40
extern GNotification *g_notification_new(gchar *title ) ;
#line 43
extern void g_notification_set_title(GNotification *notification , gchar *title ) ;
#line 47
extern void g_notification_set_body(GNotification *notification , gchar *body ) ;
#line 51
extern void g_notification_set_icon(GNotification *notification , GIcon *icon ) ;
#line 55
extern void g_notification_set_urgent(GNotification *notification , gboolean urgent ) ;
#line 59
extern void g_notification_set_priority(GNotification *notification , GNotificationPriority priority ) ;
#line 63
extern void g_notification_set_category(GNotification *notification , gchar *category ) ;
#line 67
extern void g_notification_add_button(GNotification *notification , gchar *label ,
                                      gchar *detailed_action ) ;
#line 72
extern void g_notification_add_button_with_target(GNotification *notification , gchar *label ,
                                                  gchar *action , gchar *target_format 
                                                  , ...) ;
#line 79
extern void g_notification_add_button_with_target_value(GNotification *notification ,
                                                        gchar *label , gchar *action ,
                                                        GVariant *target ) ;
#line 85
extern void g_notification_set_default_action(GNotification *notification , gchar *detailed_action ) ;
#line 89
extern void g_notification_set_default_action_and_target(GNotification *notification ,
                                                         gchar *action , gchar *target_format 
                                                         , ...) ;
#line 95
extern void g_notification_set_default_action_and_target_value(GNotification *notification ,
                                                               gchar *action , GVariant *target ) ;
#line 83 "/usr/include/glib-2.0/gio/gpermission.h"
extern GType g_permission_get_type(void) ;
#line 85
extern gboolean g_permission_acquire(GPermission *permission , GCancellable *cancellable ,
                                     GError **error ) ;
#line 89
extern void g_permission_acquire_async(GPermission *permission , GCancellable *cancellable ,
                                       GAsyncReadyCallback callback , gpointer user_data ) ;
#line 94
extern gboolean g_permission_acquire_finish(GPermission *permission , GAsyncResult *result ,
                                            GError **error ) ;
#line 99
extern gboolean g_permission_release(GPermission *permission , GCancellable *cancellable ,
                                     GError **error ) ;
#line 103
extern void g_permission_release_async(GPermission *permission , GCancellable *cancellable ,
                                       GAsyncReadyCallback callback , gpointer user_data ) ;
#line 108
extern gboolean g_permission_release_finish(GPermission *permission , GAsyncResult *result ,
                                            GError **error ) ;
#line 113
extern gboolean g_permission_get_allowed(GPermission *permission ) ;
#line 115
extern gboolean g_permission_get_can_acquire(GPermission *permission ) ;
#line 117
extern gboolean g_permission_get_can_release(GPermission *permission ) ;
#line 120
extern void g_permission_impl_update(GPermission *permission , gboolean allowed ,
                                     gboolean can_acquire , gboolean can_release ) ;
#line 83 "/usr/include/glib-2.0/gio/gpollableinputstream.h"
extern GType g_pollable_input_stream_get_type(void) ;
#line 86
extern gboolean g_pollable_input_stream_can_poll(GPollableInputStream *stream ) ;
#line 89
extern gboolean g_pollable_input_stream_is_readable(GPollableInputStream *stream ) ;
#line 91
extern GSource *g_pollable_input_stream_create_source(GPollableInputStream *stream ,
                                                      GCancellable *cancellable ) ;
#line 95
extern gssize g_pollable_input_stream_read_nonblocking(GPollableInputStream *stream ,
                                                       void *buffer , gsize count ,
                                                       GCancellable *cancellable ,
                                                       GError **error ) ;
#line 96 "/usr/include/glib-2.0/gio/gpollableoutputstream.h"
extern GType g_pollable_output_stream_get_type(void) ;
#line 99
extern gboolean g_pollable_output_stream_can_poll(GPollableOutputStream *stream ) ;
#line 102
extern gboolean g_pollable_output_stream_is_writable(GPollableOutputStream *stream ) ;
#line 104
extern GSource *g_pollable_output_stream_create_source(GPollableOutputStream *stream ,
                                                       GCancellable *cancellable ) ;
#line 108
extern gssize g_pollable_output_stream_write_nonblocking(GPollableOutputStream *stream ,
                                                         void const   *buffer , gsize count ,
                                                         GCancellable *cancellable ,
                                                         GError **error ) ;
#line 115
extern GPollableReturn g_pollable_output_stream_writev_nonblocking(GPollableOutputStream *stream ,
                                                                   GOutputVector *vectors ,
                                                                   gsize n_vectors ,
                                                                   gsize *bytes_written ,
                                                                   GCancellable *cancellable ,
                                                                   GError **error ) ;
#line 31 "/usr/include/glib-2.0/gio/gpollableutils.h"
extern GSource *g_pollable_source_new(GObject *pollable_stream ) ;
#line 34
extern GSource *g_pollable_source_new_full(gpointer pollable_stream , GSource *child_source ,
                                           GCancellable *cancellable ) ;
#line 39
extern gssize g_pollable_stream_read(GInputStream *stream , void *buffer , gsize count ,
                                     gboolean blocking , GCancellable *cancellable ,
                                     GError **error ) ;
#line 47
extern gssize g_pollable_stream_write(GOutputStream *stream , void const   *buffer ,
                                      gsize count , gboolean blocking , GCancellable *cancellable ,
                                      GError **error ) ;
#line 54
extern gboolean g_pollable_stream_write_all(GOutputStream *stream , void const   *buffer ,
                                            gsize count , gboolean blocking , gsize *bytes_written ,
                                            GCancellable *cancellable , GError **error ) ;
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
extern GType g_power_profile_monitor_get_type(void) ;
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
__inline static void glib_autoptr_clear_GPowerProfileMonitor(GPowerProfileMonitor *_ptr ) 
{ 


  {
#line 43
  if (_ptr) {
    {
#line 43
    glib_autoptr_clear_GObject((GObject *)_ptr);
    }
  }
  return;
}
}
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
__inline static void glib_autoptr_cleanup_GPowerProfileMonitor(GPowerProfileMonitor **_ptr ) 
{ 


  {
  {
#line 43
  glib_autoptr_clear_GPowerProfileMonitor(*_ptr);
  }
  return;
}
}
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
__inline static GPowerProfileMonitor *g_power_profile_monitor(gpointer ptr ) 
{ 
  GType __cil_tmp2 ;
  GTypeInstance *__cil_tmp3 ;

  {
  {
#line 43
  __cil_tmp2 = g_power_profile_monitor_get_type();
#line 43
  __cil_tmp3 = g_type_check_instance_cast((GTypeInstance *)ptr, __cil_tmp2);
  }
#line 43
  return ((GPowerProfileMonitor *)((void *)__cil_tmp3));
}
}
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
__inline static GPowerProfileMonitorInterface *g_power_profile_monitor_GET_IFACE(gpointer ptr ) 
{ 
  GType __cil_tmp2 ;
  gpointer __cil_tmp3 ;

  {
  {
#line 43
  __cil_tmp2 = g_power_profile_monitor_get_type();
#line 43
  __cil_tmp3 = g_type_interface_peek(((GTypeInstance *)ptr)->g_class, __cil_tmp2);
  }
#line 43
  return ((GPowerProfileMonitorInterface *)__cil_tmp3);
}
}
#line 56
extern GPowerProfileMonitor *g_power_profile_monitor_dup_default(void) ;
#line 59
extern gboolean g_power_profile_monitor_get_power_saver_enabled(GPowerProfileMonitor *monitor ) ;
#line 38 "/usr/include/glib-2.0/gio/gpropertyaction.h"
extern GType g_property_action_get_type(void) ;
#line 41
extern GPropertyAction *g_property_action_new(gchar *name , gpointer object , gchar *property_name ) ;
#line 98 "/usr/include/glib-2.0/gio/gproxy.h"
extern GType g_proxy_get_type(void) ;
#line 101
extern GProxy *g_proxy_get_default_for_protocol(gchar *protocol ) ;
#line 104
extern GIOStream *g_proxy_connect(GProxy *proxy , GIOStream *connection , GProxyAddress *proxy_address ,
                                  GCancellable *cancellable , GError **error ) ;
#line 111
extern void g_proxy_connect_async(GProxy *proxy , GIOStream *connection , GProxyAddress *proxy_address ,
                                  GCancellable *cancellable , GAsyncReadyCallback callback ,
                                  gpointer user_data ) ;
#line 119
extern GIOStream *g_proxy_connect_finish(GProxy *proxy , GAsyncResult *result , GError **error ) ;
#line 124
extern gboolean g_proxy_supports_hostname(GProxy *proxy ) ;
#line 57 "/usr/include/glib-2.0/gio/gproxyaddress.h"
extern GType g_proxy_address_get_type(void) ;
#line 60
extern GSocketAddress *g_proxy_address_new(GInetAddress *inetaddr , guint16 port ,
                                           gchar *protocol , gchar *dest_hostname ,
                                           guint16 dest_port , gchar *username , gchar *password ) ;
#line 69
extern gchar *g_proxy_address_get_protocol(GProxyAddress *proxy ) ;
#line 71
extern gchar *g_proxy_address_get_destination_protocol(GProxyAddress *proxy ) ;
#line 73
extern gchar *g_proxy_address_get_destination_hostname(GProxyAddress *proxy ) ;
#line 75
extern guint16 g_proxy_address_get_destination_port(GProxyAddress *proxy ) ;
#line 77
extern gchar *g_proxy_address_get_username(GProxyAddress *proxy ) ;
#line 79
extern gchar *g_proxy_address_get_password(GProxyAddress *proxy ) ;
#line 82
extern gchar *g_proxy_address_get_uri(GProxyAddress *proxy ) ;
#line 81 "/usr/include/glib-2.0/gio/gsocketaddressenumerator.h"
extern GType g_socket_address_enumerator_get_type(void) ;
#line 84
extern GSocketAddress *g_socket_address_enumerator_next(GSocketAddressEnumerator *enumerator ,
                                                        GCancellable *cancellable ,
                                                        GError **error ) ;
#line 89
extern void g_socket_address_enumerator_next_async(GSocketAddressEnumerator *enumerator ,
                                                   GCancellable *cancellable , GAsyncReadyCallback callback ,
                                                   gpointer user_data ) ;
#line 94
extern GSocketAddress *g_socket_address_enumerator_next_finish(GSocketAddressEnumerator *enumerator ,
                                                               GAsyncResult *result ,
                                                               GError **error ) ;
#line 77 "/usr/include/glib-2.0/gio/gproxyaddressenumerator.h"
extern GType g_proxy_address_enumerator_get_type(void) ;
#line 70 "/usr/include/glib-2.0/gio/gproxyresolver.h"
extern GType g_proxy_resolver_get_type(void) ;
#line 72
extern GProxyResolver *g_proxy_resolver_get_default(void) ;
#line 75
extern gboolean g_proxy_resolver_is_supported(GProxyResolver *resolver ) ;
#line 77
extern gchar **g_proxy_resolver_lookup(GProxyResolver *resolver , gchar *uri , GCancellable *cancellable ,
                                       GError **error ) ;
#line 82
extern void g_proxy_resolver_lookup_async(GProxyResolver *resolver , gchar *uri ,
                                          GCancellable *cancellable , GAsyncReadyCallback callback ,
                                          gpointer user_data ) ;
#line 88
extern gchar **g_proxy_resolver_lookup_finish(GProxyResolver *resolver , GAsyncResult *result ,
                                              GError **error ) ;
#line 59 "/usr/include/glib-2.0/gio/gremoteactiongroup.h"
extern GType g_remote_action_group_get_type(void) ;
#line 62
extern void g_remote_action_group_activate_action_full(GRemoteActionGroup *remote ,
                                                       gchar *action_name , GVariant *parameter ,
                                                       GVariant *platform_data ) ;
#line 68
extern void g_remote_action_group_change_action_state_full(GRemoteActionGroup *remote ,
                                                           gchar *action_name , GVariant *value ,
                                                           GVariant *platform_data ) ;
#line 185 "/usr/include/glib-2.0/gio/gresolver.h"
extern GType g_resolver_get_type(void) ;
#line 187
extern GResolver *g_resolver_get_default(void) ;
#line 189
extern void g_resolver_set_default(GResolver *resolver ) ;
#line 191
extern GList *g_resolver_lookup_by_name(GResolver *resolver , gchar *hostname , GCancellable *cancellable ,
                                        GError **error ) ;
#line 196
extern void g_resolver_lookup_by_name_async(GResolver *resolver , gchar *hostname ,
                                            GCancellable *cancellable , GAsyncReadyCallback callback ,
                                            gpointer user_data ) ;
#line 202
extern GList *g_resolver_lookup_by_name_finish(GResolver *resolver , GAsyncResult *result ,
                                               GError **error ) ;
#line 206
extern void g_resolver_lookup_by_name_with_flags_async(GResolver *resolver , gchar *hostname ,
                                                       GResolverNameLookupFlags flags ,
                                                       GCancellable *cancellable ,
                                                       GAsyncReadyCallback callback ,
                                                       gpointer user_data ) ;
#line 213
extern GList *g_resolver_lookup_by_name_with_flags_finish(GResolver *resolver , GAsyncResult *result ,
                                                          GError **error ) ;
#line 217
extern GList *g_resolver_lookup_by_name_with_flags(GResolver *resolver , gchar *hostname ,
                                                   GResolverNameLookupFlags flags ,
                                                   GCancellable *cancellable , GError **error ) ;
#line 223
extern void g_resolver_free_addresses(GList *addresses ) ;
#line 225
extern gchar *g_resolver_lookup_by_address(GResolver *resolver , GInetAddress *address ,
                                           GCancellable *cancellable , GError **error ) ;
#line 230
extern void g_resolver_lookup_by_address_async(GResolver *resolver , GInetAddress *address ,
                                               GCancellable *cancellable , GAsyncReadyCallback callback ,
                                               gpointer user_data ) ;
#line 236
extern gchar *g_resolver_lookup_by_address_finish(GResolver *resolver , GAsyncResult *result ,
                                                  GError **error ) ;
#line 240
extern GList *g_resolver_lookup_service(GResolver *resolver , gchar *service , gchar *protocol ,
                                        gchar *domain , GCancellable *cancellable ,
                                        GError **error ) ;
#line 247
extern void g_resolver_lookup_service_async(GResolver *resolver , gchar *service ,
                                            gchar *protocol , gchar *domain , GCancellable *cancellable ,
                                            GAsyncReadyCallback callback , gpointer user_data ) ;
#line 255
extern GList *g_resolver_lookup_service_finish(GResolver *resolver , GAsyncResult *result ,
                                               GError **error ) ;
#line 259
extern GList *g_resolver_lookup_records(GResolver *resolver , gchar *rrname , GResolverRecordType record_type ,
                                        GCancellable *cancellable , GError **error ) ;
#line 265
extern void g_resolver_lookup_records_async(GResolver *resolver , gchar *rrname ,
                                            GResolverRecordType record_type , GCancellable *cancellable ,
                                            GAsyncReadyCallback callback , gpointer user_data ) ;
#line 272
extern GList *g_resolver_lookup_records_finish(GResolver *resolver , GAsyncResult *result ,
                                               GError **error ) ;
#line 276
extern void g_resolver_free_targets(GList *targets ) ;
#line 288
extern GQuark g_resolver_error_quark(void) ;
#line 49 "/usr/include/glib-2.0/gio/gresource.h"
extern GQuark g_resource_error_quark(void) ;
#line 63
extern GType g_resource_get_type(void) ;
#line 65
extern GResource *g_resource_new_from_data(GBytes *data , GError **error ) ;
#line 68
extern GResource *g_resource_ref(GResource *resource ) ;
#line 70
extern void g_resource_unref(GResource *resource ) ;
#line 72
extern GResource *g_resource_load(gchar *filename , GError **error ) ;
#line 75
extern GInputStream *g_resource_open_stream(GResource *resource , char const   *path ,
                                            GResourceLookupFlags lookup_flags , GError **error ) ;
#line 80
extern GBytes *g_resource_lookup_data(GResource *resource , char const   *path , GResourceLookupFlags lookup_flags ,
                                      GError **error ) ;
#line 85
extern char **g_resource_enumerate_children(GResource *resource , char const   *path ,
                                            GResourceLookupFlags lookup_flags , GError **error ) ;
#line 90
extern gboolean g_resource_get_info(GResource *resource , char const   *path , GResourceLookupFlags lookup_flags ,
                                    gsize *size , guint32 *flags , GError **error ) ;
#line 98
extern void g_resources_register(GResource *resource ) ;
#line 100
extern void g_resources_unregister(GResource *resource ) ;
#line 102
extern GInputStream *g_resources_open_stream(char const   *path , GResourceLookupFlags lookup_flags ,
                                             GError **error ) ;
#line 106
extern GBytes *g_resources_lookup_data(char const   *path , GResourceLookupFlags lookup_flags ,
                                       GError **error ) ;
#line 110
extern char **g_resources_enumerate_children(char const   *path , GResourceLookupFlags lookup_flags ,
                                             GError **error ) ;
#line 114
extern gboolean g_resources_get_info(char const   *path , GResourceLookupFlags lookup_flags ,
                                     gsize *size , guint32 *flags , GError **error ) ;
#line 122
extern void g_static_resource_init(GStaticResource *static_resource ) ;
#line 124
extern void g_static_resource_fini(GStaticResource *static_resource ) ;
#line 126
extern GResource *g_static_resource_get_resource(GStaticResource *static_resource ) ;
#line 80 "/usr/include/glib-2.0/gio/gseekable.h"
extern GType g_seekable_get_type(void) ;
#line 83
extern goffset g_seekable_tell(GSeekable *seekable ) ;
#line 85
extern gboolean g_seekable_can_seek(GSeekable *seekable ) ;
#line 87
extern gboolean g_seekable_seek(GSeekable *seekable , goffset offset , GSeekType type ,
                                GCancellable *cancellable , GError **error ) ;
#line 93
extern gboolean g_seekable_can_truncate(GSeekable *seekable ) ;
#line 95
extern gboolean g_seekable_truncate(GSeekable *seekable , goffset offset , GCancellable *cancellable ,
                                    GError **error ) ;
#line 32 "/usr/include/glib-2.0/gio/gsettingsschema.h"
extern GType g_settings_schema_source_get_type(void) ;
#line 35
extern GSettingsSchemaSource *g_settings_schema_source_get_default(void) ;
#line 37
extern GSettingsSchemaSource *g_settings_schema_source_ref(GSettingsSchemaSource *source ) ;
#line 39
extern void g_settings_schema_source_unref(GSettingsSchemaSource *source ) ;
#line 42
extern GSettingsSchemaSource *g_settings_schema_source_new_from_directory(gchar *directory ,
                                                                          GSettingsSchemaSource *parent ,
                                                                          gboolean trusted ,
                                                                          GError **error ) ;
#line 48
extern GSettingsSchema *g_settings_schema_source_lookup(GSettingsSchemaSource *source ,
                                                        gchar *schema_id , gboolean recursive ) ;
#line 53
extern void g_settings_schema_source_list_schemas(GSettingsSchemaSource *source ,
                                                  gboolean recursive , gchar ***non_relocatable ,
                                                  gchar ***relocatable ) ;
#line 60
extern GType g_settings_schema_get_type(void) ;
#line 63
extern GSettingsSchema *g_settings_schema_ref(GSettingsSchema *schema ) ;
#line 65
extern void g_settings_schema_unref(GSettingsSchema *schema ) ;
#line 68
extern gchar *g_settings_schema_get_id(GSettingsSchema *schema ) ;
#line 70
extern gchar *g_settings_schema_get_path(GSettingsSchema *schema ) ;
#line 72
extern GSettingsSchemaKey *g_settings_schema_get_key(GSettingsSchema *schema , gchar *name ) ;
#line 75
extern gboolean g_settings_schema_has_key(GSettingsSchema *schema , gchar *name ) ;
#line 78
extern gchar **g_settings_schema_list_keys(GSettingsSchema *schema ) ;
#line 82
extern gchar **g_settings_schema_list_children(GSettingsSchema *schema ) ;
#line 86
extern GType g_settings_schema_key_get_type(void) ;
#line 89
extern GSettingsSchemaKey *g_settings_schema_key_ref(GSettingsSchemaKey *key ) ;
#line 91
extern void g_settings_schema_key_unref(GSettingsSchemaKey *key ) ;
#line 94
extern GVariantType *g_settings_schema_key_get_value_type(GSettingsSchemaKey *key ) ;
#line 96
extern GVariant *g_settings_schema_key_get_default_value(GSettingsSchemaKey *key ) ;
#line 98
extern GVariant *g_settings_schema_key_get_range(GSettingsSchemaKey *key ) ;
#line 100
extern gboolean g_settings_schema_key_range_check(GSettingsSchemaKey *key , GVariant *value ) ;
#line 104
extern gchar *g_settings_schema_key_get_name(GSettingsSchemaKey *key ) ;
#line 106
extern gchar *g_settings_schema_key_get_summary(GSettingsSchemaKey *key ) ;
#line 108
extern gchar *g_settings_schema_key_get_description(GSettingsSchemaKey *key ) ;
#line 71 "/usr/include/glib-2.0/gio/gsettings.h"
extern GType g_settings_get_type(void) ;
#line 74
extern gchar * const  *g_settings_list_schemas(void) ;
#line 76
extern gchar * const  *g_settings_list_relocatable_schemas(void) ;
#line 78
extern GSettings *g_settings_new(gchar *schema_id ) ;
#line 80
extern GSettings *g_settings_new_with_path(gchar *schema_id , gchar *path ) ;
#line 83
extern GSettings *g_settings_new_with_backend(gchar *schema_id , GSettingsBackend *backend ) ;
#line 86
extern GSettings *g_settings_new_with_backend_and_path(gchar *schema_id , GSettingsBackend *backend ,
                                                       gchar *path ) ;
#line 90
extern GSettings *g_settings_new_full(GSettingsSchema *schema , GSettingsBackend *backend ,
                                      gchar *path ) ;
#line 94
extern gchar **g_settings_list_children(GSettings *settings ) ;
#line 96
extern gchar **g_settings_list_keys(GSettings *settings ) ;
#line 98
extern GVariant *g_settings_get_range(GSettings *settings , gchar *key ) ;
#line 101
extern gboolean g_settings_range_check(GSettings *settings , gchar *key , GVariant *value ) ;
#line 106
extern gboolean g_settings_set_value(GSettings *settings , gchar *key , GVariant *value ) ;
#line 110
extern GVariant *g_settings_get_value(GSettings *settings , gchar *key ) ;
#line 114
extern GVariant *g_settings_get_user_value(GSettings *settings , gchar *key ) ;
#line 117
extern GVariant *g_settings_get_default_value(GSettings *settings , gchar *key ) ;
#line 121
extern gboolean g_settings_set(GSettings *settings , gchar *key , gchar *format  , ...) ;
#line 126
extern void g_settings_get(GSettings *settings , gchar *key , gchar *format  , ...) ;
#line 131
extern void g_settings_reset(GSettings *settings , gchar *key ) ;
#line 135
extern gint g_settings_get_int(GSettings *settings , gchar *key ) ;
#line 138
extern gboolean g_settings_set_int(GSettings *settings , gchar *key , gint value ) ;
#line 142
extern gint64 g_settings_get_int64(GSettings *settings , gchar *key ) ;
#line 145
extern gboolean g_settings_set_int64(GSettings *settings , gchar *key , gint64 value ) ;
#line 149
extern guint g_settings_get_uint(GSettings *settings , gchar *key ) ;
#line 152
extern gboolean g_settings_set_uint(GSettings *settings , gchar *key , guint value ) ;
#line 156
extern guint64 g_settings_get_uint64(GSettings *settings , gchar *key ) ;
#line 159
extern gboolean g_settings_set_uint64(GSettings *settings , gchar *key , guint64 value ) ;
#line 163
extern gchar *g_settings_get_string(GSettings *settings , gchar *key ) ;
#line 166
extern gboolean g_settings_set_string(GSettings *settings , gchar *key , gchar *value ) ;
#line 170
extern gboolean g_settings_get_boolean(GSettings *settings , gchar *key ) ;
#line 173
extern gboolean g_settings_set_boolean(GSettings *settings , gchar *key , gboolean value ) ;
#line 177
extern gdouble g_settings_get_double(GSettings *settings , gchar *key ) ;
#line 180
extern gboolean g_settings_set_double(GSettings *settings , gchar *key , gdouble value ) ;
#line 184
extern gchar **g_settings_get_strv(GSettings *settings , gchar *key ) ;
#line 187
extern gboolean g_settings_set_strv(GSettings *settings , gchar *key , gchar * const  *value ) ;
#line 191
extern gint g_settings_get_enum(GSettings *settings , gchar *key ) ;
#line 194
extern gboolean g_settings_set_enum(GSettings *settings , gchar *key , gint value ) ;
#line 198
extern guint g_settings_get_flags(GSettings *settings , gchar *key ) ;
#line 201
extern gboolean g_settings_set_flags(GSettings *settings , gchar *key , guint value ) ;
#line 205
extern GSettings *g_settings_get_child(GSettings *settings , gchar *name ) ;
#line 209
extern gboolean g_settings_is_writable(GSettings *settings , gchar *name ) ;
#line 213
extern void g_settings_delay(GSettings *settings ) ;
#line 215
extern void g_settings_apply(GSettings *settings ) ;
#line 217
extern void g_settings_revert(GSettings *settings ) ;
#line 219
extern gboolean g_settings_get_has_unapplied(GSettings *settings ) ;
#line 221
extern void g_settings_sync(void) ;
#line 308
extern void g_settings_bind(GSettings *settings , gchar *key , gpointer object , gchar *property ,
                            GSettingsBindFlags flags ) ;
#line 314
extern void g_settings_bind_with_mapping(GSettings *settings , gchar *key , gpointer object ,
                                         gchar *property , GSettingsBindFlags flags ,
                                         GSettingsBindGetMapping get_mapping , GSettingsBindSetMapping set_mapping ,
                                         gpointer user_data , GDestroyNotify destroy ) ;
#line 324
extern void g_settings_bind_writable(GSettings *settings , gchar *key , gpointer object ,
                                     gchar *property , gboolean inverted ) ;
#line 330
extern void g_settings_unbind(gpointer object , gchar *property ) ;
#line 334
extern GAction *g_settings_create_action(GSettings *settings , gchar *key ) ;
#line 338
extern gpointer g_settings_get_mapped(GSettings *settings , gchar *key , GSettingsGetMapping mapping ,
                                      gpointer user_data ) ;
#line 38 "/usr/include/glib-2.0/gio/gsimpleaction.h"
extern GType g_simple_action_get_type(void) ;
#line 41
extern GSimpleAction *g_simple_action_new(gchar *name , GVariantType *parameter_type ) ;
#line 45
extern GSimpleAction *g_simple_action_new_stateful(gchar *name , GVariantType *parameter_type ,
                                                   GVariant *state ) ;
#line 50
extern void g_simple_action_set_enabled(GSimpleAction *simple , gboolean enabled ) ;
#line 54
extern void g_simple_action_set_state(GSimpleAction *simple , GVariant *value ) ;
#line 58
extern void g_simple_action_set_state_hint(GSimpleAction *simple , GVariant *state_hint ) ;
#line 72 "/usr/include/glib-2.0/gio/gsimpleactiongroup.h"
extern GType g_simple_action_group_get_type(void) ;
#line 75
extern GSimpleActionGroup *g_simple_action_group_new(void) ;
#line 78
extern GAction *g_simple_action_group_lookup(GSimpleActionGroup *simple , gchar *action_name ) ;
#line 82
extern void g_simple_action_group_insert(GSimpleActionGroup *simple , GAction *action ) ;
#line 86
extern void g_simple_action_group_remove(GSimpleActionGroup *simple , gchar *action_name ) ;
#line 90
extern void g_simple_action_group_add_entries(GSimpleActionGroup *simple , GActionEntry *entries ,
                                              gint n_entries , gpointer user_data ) ;
#line 48 "/usr/include/glib-2.0/gio/gsimpleasyncresult.h"
extern GType g_simple_async_result_get_type(void) ;
#line 51
extern GSimpleAsyncResult *g_simple_async_result_new(GObject *source_object , GAsyncReadyCallback callback ,
                                                     gpointer user_data , gpointer source_tag ) ;
#line 56
extern GSimpleAsyncResult *g_simple_async_result_new_error(GObject *source_object ,
                                                           GAsyncReadyCallback callback ,
                                                           gpointer user_data , GQuark domain ,
                                                           gint code , char const   *format 
                                                           , ...) ;
#line 64
extern GSimpleAsyncResult *g_simple_async_result_new_from_error(GObject *source_object ,
                                                                GAsyncReadyCallback callback ,
                                                                gpointer user_data ,
                                                                GError *error ) ;
#line 69
extern GSimpleAsyncResult *g_simple_async_result_new_take_error(GObject *source_object ,
                                                                GAsyncReadyCallback callback ,
                                                                gpointer user_data ,
                                                                GError *error ) ;
#line 75
extern void g_simple_async_result_set_op_res_gpointer(GSimpleAsyncResult *simple ,
                                                      gpointer op_res , GDestroyNotify destroy_op_res ) ;
#line 79
extern gpointer g_simple_async_result_get_op_res_gpointer(GSimpleAsyncResult *simple ) ;
#line 82
extern void g_simple_async_result_set_op_res_gssize(GSimpleAsyncResult *simple , gssize op_res ) ;
#line 85
extern gssize g_simple_async_result_get_op_res_gssize(GSimpleAsyncResult *simple ) ;
#line 88
extern void g_simple_async_result_set_op_res_gboolean(GSimpleAsyncResult *simple ,
                                                      gboolean op_res ) ;
#line 91
extern gboolean g_simple_async_result_get_op_res_gboolean(GSimpleAsyncResult *simple ) ;
#line 96
extern void g_simple_async_result_set_check_cancellable(GSimpleAsyncResult *simple ,
                                                        GCancellable *check_cancellable ) ;
#line 99
extern gpointer g_simple_async_result_get_source_tag(GSimpleAsyncResult *simple ) ;
#line 101
extern void g_simple_async_result_set_handle_cancellation(GSimpleAsyncResult *simple ,
                                                          gboolean handle_cancellation ) ;
#line 104
extern void g_simple_async_result_complete(GSimpleAsyncResult *simple ) ;
#line 106
extern void g_simple_async_result_complete_in_idle(GSimpleAsyncResult *simple ) ;
#line 108
extern void g_simple_async_result_run_in_thread(GSimpleAsyncResult *simple , GSimpleAsyncThreadFunc func ,
                                                int io_priority , GCancellable *cancellable ) ;
#line 113
extern void g_simple_async_result_set_from_error(GSimpleAsyncResult *simple , GError *error ) ;
#line 116
extern void g_simple_async_result_take_error(GSimpleAsyncResult *simple , GError *error ) ;
#line 119
extern gboolean g_simple_async_result_propagate_error(GSimpleAsyncResult *simple ,
                                                      GError **dest ) ;
#line 122
extern void g_simple_async_result_set_error(GSimpleAsyncResult *simple , GQuark domain ,
                                            gint code , char const   *format  , ...) ;
#line 128
extern void g_simple_async_result_set_error_va(GSimpleAsyncResult *simple , GQuark domain ,
                                               gint code , char const   *format ,
                                               va_list args ) ;
#line 135
extern gboolean g_simple_async_result_is_valid(GAsyncResult *result , GObject *source ,
                                               gpointer source_tag ) ;
#line 140
extern void g_simple_async_report_error_in_idle(GObject *object , GAsyncReadyCallback callback ,
                                                gpointer user_data , GQuark domain ,
                                                gint code , char const   *format 
                                                , ...) ;
#line 148
extern void g_simple_async_report_gerror_in_idle(GObject *object , GAsyncReadyCallback callback ,
                                                 gpointer user_data , GError *error ) ;
#line 153
extern void g_simple_async_report_take_gerror_in_idle(GObject *object , GAsyncReadyCallback callback ,
                                                      gpointer user_data , GError *error ) ;
#line 37 "/usr/include/glib-2.0/gio/gsimpleiostream.h"
extern GType g_simple_io_stream_get_type(void) ;
#line 40
extern GIOStream *g_simple_io_stream_new(GInputStream *input_stream , GOutputStream *output_stream ) ;
#line 39 "/usr/include/glib-2.0/gio/gsimplepermission.h"
extern GType g_simple_permission_get_type(void) ;
#line 41
extern GPermission *g_simple_permission_new(gboolean allowed ) ;
#line 68 "/usr/include/glib-2.0/gio/gsimpleproxyresolver.h"
extern GType g_simple_proxy_resolver_get_type(void) ;
#line 71
extern GProxyResolver *g_simple_proxy_resolver_new(gchar *default_proxy , gchar **ignore_hosts ) ;
#line 75
extern void g_simple_proxy_resolver_set_default_proxy(GSimpleProxyResolver *resolver ,
                                                      gchar *default_proxy ) ;
#line 79
extern void g_simple_proxy_resolver_set_ignore_hosts(GSimpleProxyResolver *resolver ,
                                                     gchar **ignore_hosts ) ;
#line 83
extern void g_simple_proxy_resolver_set_uri_proxy(GSimpleProxyResolver *resolver ,
                                                  gchar *uri_scheme , gchar *proxy ) ;
#line 75 "/usr/include/glib-2.0/gio/gsocket.h"
extern GType g_socket_get_type(void) ;
#line 77
extern GSocket *g_socket_new(GSocketFamily family , GSocketType type , GSocketProtocol protocol ,
                             GError **error ) ;
#line 82
extern GSocket *g_socket_new_from_fd(gint fd , GError **error ) ;
#line 85
extern int g_socket_get_fd(GSocket *socket ) ;
#line 87
extern GSocketFamily g_socket_get_family(GSocket *socket ) ;
#line 89
extern GSocketType g_socket_get_socket_type(GSocket *socket ) ;
#line 91
extern GSocketProtocol g_socket_get_protocol(GSocket *socket ) ;
#line 93
extern GSocketAddress *g_socket_get_local_address(GSocket *socket , GError **error ) ;
#line 96
extern GSocketAddress *g_socket_get_remote_address(GSocket *socket , GError **error ) ;
#line 99
extern void g_socket_set_blocking(GSocket *socket , gboolean blocking ) ;
#line 102
extern gboolean g_socket_get_blocking(GSocket *socket ) ;
#line 104
extern void g_socket_set_keepalive(GSocket *socket , gboolean keepalive ) ;
#line 107
extern gboolean g_socket_get_keepalive(GSocket *socket ) ;
#line 109
extern gint g_socket_get_listen_backlog(GSocket *socket ) ;
#line 111
extern void g_socket_set_listen_backlog(GSocket *socket , gint backlog ) ;
#line 114
extern guint g_socket_get_timeout(GSocket *socket ) ;
#line 116
extern void g_socket_set_timeout(GSocket *socket , guint timeout ) ;
#line 120
extern guint g_socket_get_ttl(GSocket *socket ) ;
#line 122
extern void g_socket_set_ttl(GSocket *socket , guint ttl ) ;
#line 126
extern gboolean g_socket_get_broadcast(GSocket *socket ) ;
#line 128
extern void g_socket_set_broadcast(GSocket *socket , gboolean broadcast ) ;
#line 132
extern gboolean g_socket_get_multicast_loopback(GSocket *socket ) ;
#line 134
extern void g_socket_set_multicast_loopback(GSocket *socket , gboolean loopback ) ;
#line 137
extern guint g_socket_get_multicast_ttl(GSocket *socket ) ;
#line 139
extern void g_socket_set_multicast_ttl(GSocket *socket , guint ttl ) ;
#line 142
extern gboolean g_socket_is_connected(GSocket *socket ) ;
#line 144
extern gboolean g_socket_bind(GSocket *socket , GSocketAddress *address , gboolean allow_reuse ,
                              GError **error ) ;
#line 149
extern gboolean g_socket_join_multicast_group(GSocket *socket , GInetAddress *group ,
                                              gboolean source_specific , gchar *iface ,
                                              GError **error ) ;
#line 155
extern gboolean g_socket_leave_multicast_group(GSocket *socket , GInetAddress *group ,
                                               gboolean source_specific , gchar *iface ,
                                               GError **error ) ;
#line 161
extern gboolean g_socket_join_multicast_group_ssm(GSocket *socket , GInetAddress *group ,
                                                  GInetAddress *source_specific ,
                                                  gchar *iface , GError **error ) ;
#line 167
extern gboolean g_socket_leave_multicast_group_ssm(GSocket *socket , GInetAddress *group ,
                                                   GInetAddress *source_specific ,
                                                   gchar *iface , GError **error ) ;
#line 173
extern gboolean g_socket_connect(GSocket *socket , GSocketAddress *address , GCancellable *cancellable ,
                                 GError **error ) ;
#line 178
extern gboolean g_socket_check_connect_result(GSocket *socket , GError **error ) ;
#line 182
extern gssize g_socket_get_available_bytes(GSocket *socket ) ;
#line 185
extern GIOCondition g_socket_condition_check(GSocket *socket , GIOCondition condition ) ;
#line 188
extern gboolean g_socket_condition_wait(GSocket *socket , GIOCondition condition ,
                                        GCancellable *cancellable , GError **error ) ;
#line 193
extern gboolean g_socket_condition_timed_wait(GSocket *socket , GIOCondition condition ,
                                              gint64 timeout_us , GCancellable *cancellable ,
                                              GError **error ) ;
#line 199
extern GSocket *g_socket_accept(GSocket *socket , GCancellable *cancellable , GError **error ) ;
#line 203
extern gboolean g_socket_listen(GSocket *socket , GError **error ) ;
#line 206
extern gssize g_socket_receive(GSocket *socket , gchar *buffer , gsize size , GCancellable *cancellable ,
                               GError **error ) ;
#line 212
extern gssize g_socket_receive_from(GSocket *socket , GSocketAddress **address , gchar *buffer ,
                                    gsize size , GCancellable *cancellable , GError **error ) ;
#line 219
extern gssize g_socket_send(GSocket *socket , gchar *buffer , gsize size , GCancellable *cancellable ,
                            GError **error ) ;
#line 225
extern gssize g_socket_send_to(GSocket *socket , GSocketAddress *address , gchar *buffer ,
                               gsize size , GCancellable *cancellable , GError **error ) ;
#line 232
extern gssize g_socket_receive_message(GSocket *socket , GSocketAddress **address ,
                                       GInputVector *vectors , gint num_vectors ,
                                       GSocketControlMessage ***messages , gint *num_messages ,
                                       gint *flags , GCancellable *cancellable , GError **error ) ;
#line 242
extern gssize g_socket_send_message(GSocket *socket , GSocketAddress *address , GOutputVector *vectors ,
                                    gint num_vectors , GSocketControlMessage **messages ,
                                    gint num_messages , gint flags , GCancellable *cancellable ,
                                    GError **error ) ;
#line 253
extern gint g_socket_receive_messages(GSocket *socket , GInputMessage *messages ,
                                      guint num_messages , gint flags , GCancellable *cancellable ,
                                      GError **error ) ;
#line 260
extern gint g_socket_send_messages(GSocket *socket , GOutputMessage *messages , guint num_messages ,
                                   gint flags , GCancellable *cancellable , GError **error ) ;
#line 268
extern gboolean g_socket_close(GSocket *socket , GError **error ) ;
#line 271
extern gboolean g_socket_shutdown(GSocket *socket , gboolean shutdown_read , gboolean shutdown_write ,
                                  GError **error ) ;
#line 276
extern gboolean g_socket_is_closed(GSocket *socket ) ;
#line 278
extern GSource *g_socket_create_source(GSocket *socket , GIOCondition condition ,
                                       GCancellable *cancellable ) ;
#line 282
extern gboolean g_socket_speaks_ipv4(GSocket *socket ) ;
#line 284
extern GCredentials *g_socket_get_credentials(GSocket *socket , GError **error ) ;
#line 288
extern gssize g_socket_receive_with_blocking(GSocket *socket , gchar *buffer , gsize size ,
                                             gboolean blocking , GCancellable *cancellable ,
                                             GError **error ) ;
#line 295
extern gssize g_socket_send_with_blocking(GSocket *socket , gchar *buffer , gsize size ,
                                          gboolean blocking , GCancellable *cancellable ,
                                          GError **error ) ;
#line 302
extern GPollableReturn g_socket_send_message_with_timeout(GSocket *socket , GSocketAddress *address ,
                                                          GOutputVector *vectors ,
                                                          gint num_vectors , GSocketControlMessage **messages ,
                                                          gint num_messages , gint flags ,
                                                          gint64 timeout_us , gsize *bytes_written ,
                                                          GCancellable *cancellable ,
                                                          GError **error ) ;
#line 314
extern gboolean g_socket_get_option(GSocket *socket , gint level , gint optname ,
                                    gint *value , GError **error ) ;
#line 320
extern gboolean g_socket_set_option(GSocket *socket , gint level , gint optname ,
                                    gint value , GError **error ) ;
#line 72 "/usr/include/glib-2.0/gio/gsocketclient.h"
extern GType g_socket_client_get_type(void) ;
#line 75
extern GSocketClient *g_socket_client_new(void) ;
#line 78
extern GSocketFamily g_socket_client_get_family(GSocketClient *client ) ;
#line 80
extern void g_socket_client_set_family(GSocketClient *client , GSocketFamily family ) ;
#line 83
extern GSocketType g_socket_client_get_socket_type(GSocketClient *client ) ;
#line 85
extern void g_socket_client_set_socket_type(GSocketClient *client , GSocketType type ) ;
#line 88
extern GSocketProtocol g_socket_client_get_protocol(GSocketClient *client ) ;
#line 90
extern void g_socket_client_set_protocol(GSocketClient *client , GSocketProtocol protocol ) ;
#line 93
extern GSocketAddress *g_socket_client_get_local_address(GSocketClient *client ) ;
#line 95
extern void g_socket_client_set_local_address(GSocketClient *client , GSocketAddress *address ) ;
#line 98
extern guint g_socket_client_get_timeout(GSocketClient *client ) ;
#line 100
extern void g_socket_client_set_timeout(GSocketClient *client , guint timeout ) ;
#line 103
extern gboolean g_socket_client_get_enable_proxy(GSocketClient *client ) ;
#line 105
extern void g_socket_client_set_enable_proxy(GSocketClient *client , gboolean enable ) ;
#line 109
extern gboolean g_socket_client_get_tls(GSocketClient *client ) ;
#line 111
extern void g_socket_client_set_tls(GSocketClient *client , gboolean tls ) ;
#line 114
extern GTlsCertificateFlags g_socket_client_get_tls_validation_flags(GSocketClient *client ) ;
#line 116
extern void g_socket_client_set_tls_validation_flags(GSocketClient *client , GTlsCertificateFlags flags ) ;
#line 119
extern GProxyResolver *g_socket_client_get_proxy_resolver(GSocketClient *client ) ;
#line 121
extern void g_socket_client_set_proxy_resolver(GSocketClient *client , GProxyResolver *proxy_resolver ) ;
#line 125
extern GSocketConnection *g_socket_client_connect(GSocketClient *client , GSocketConnectable *connectable ,
                                                  GCancellable *cancellable , GError **error ) ;
#line 130
extern GSocketConnection *g_socket_client_connect_to_host(GSocketClient *client ,
                                                          gchar *host_and_port , guint16 default_port ,
                                                          GCancellable *cancellable ,
                                                          GError **error ) ;
#line 136
extern GSocketConnection *g_socket_client_connect_to_service(GSocketClient *client ,
                                                             gchar *domain , gchar *service ,
                                                             GCancellable *cancellable ,
                                                             GError **error ) ;
#line 142
extern GSocketConnection *g_socket_client_connect_to_uri(GSocketClient *client , gchar *uri ,
                                                         guint16 default_port , GCancellable *cancellable ,
                                                         GError **error ) ;
#line 148
extern void g_socket_client_connect_async(GSocketClient *client , GSocketConnectable *connectable ,
                                          GCancellable *cancellable , GAsyncReadyCallback callback ,
                                          gpointer user_data ) ;
#line 154
extern GSocketConnection *g_socket_client_connect_finish(GSocketClient *client , GAsyncResult *result ,
                                                         GError **error ) ;
#line 158
extern void g_socket_client_connect_to_host_async(GSocketClient *client , gchar *host_and_port ,
                                                  guint16 default_port , GCancellable *cancellable ,
                                                  GAsyncReadyCallback callback , gpointer user_data ) ;
#line 165
extern GSocketConnection *g_socket_client_connect_to_host_finish(GSocketClient *client ,
                                                                 GAsyncResult *result ,
                                                                 GError **error ) ;
#line 170
extern void g_socket_client_connect_to_service_async(GSocketClient *client , gchar *domain ,
                                                     gchar *service , GCancellable *cancellable ,
                                                     GAsyncReadyCallback callback ,
                                                     gpointer user_data ) ;
#line 177
extern GSocketConnection *g_socket_client_connect_to_service_finish(GSocketClient *client ,
                                                                    GAsyncResult *result ,
                                                                    GError **error ) ;
#line 181
extern void g_socket_client_connect_to_uri_async(GSocketClient *client , gchar *uri ,
                                                 guint16 default_port , GCancellable *cancellable ,
                                                 GAsyncReadyCallback callback , gpointer user_data ) ;
#line 188
extern GSocketConnection *g_socket_client_connect_to_uri_finish(GSocketClient *client ,
                                                                GAsyncResult *result ,
                                                                GError **error ) ;
#line 192
extern void g_socket_client_add_application_proxy(GSocketClient *client , gchar *protocol ) ;
#line 67 "/usr/include/glib-2.0/gio/gsocketconnectable.h"
extern GType g_socket_connectable_get_type(void) ;
#line 70
extern GSocketAddressEnumerator *g_socket_connectable_enumerate(GSocketConnectable *connectable ) ;
#line 73
extern GSocketAddressEnumerator *g_socket_connectable_proxy_enumerate(GSocketConnectable *connectable ) ;
#line 76
extern gchar *g_socket_connectable_to_string(GSocketConnectable *connectable ) ;
#line 72 "/usr/include/glib-2.0/gio/gsocketconnection.h"
extern GType g_socket_connection_get_type(void) ;
#line 75
extern gboolean g_socket_connection_is_connected(GSocketConnection *connection ) ;
#line 77
extern gboolean g_socket_connection_connect(GSocketConnection *connection , GSocketAddress *address ,
                                            GCancellable *cancellable , GError **error ) ;
#line 82
extern void g_socket_connection_connect_async(GSocketConnection *connection , GSocketAddress *address ,
                                              GCancellable *cancellable , GAsyncReadyCallback callback ,
                                              gpointer user_data ) ;
#line 88
extern gboolean g_socket_connection_connect_finish(GSocketConnection *connection ,
                                                   GAsyncResult *result , GError **error ) ;
#line 93
extern GSocket *g_socket_connection_get_socket(GSocketConnection *connection ) ;
#line 95
extern GSocketAddress *g_socket_connection_get_local_address(GSocketConnection *connection ,
                                                             GError **error ) ;
#line 98
extern GSocketAddress *g_socket_connection_get_remote_address(GSocketConnection *connection ,
                                                              GError **error ) ;
#line 102
extern void g_socket_connection_factory_register_type(GType g_type , GSocketFamily family ,
                                                      GSocketType type , gint protocol ) ;
#line 107
extern GType g_socket_connection_factory_lookup_type(GSocketFamily family , GSocketType type ,
                                                     gint protocol_id ) ;
#line 111
extern GSocketConnection *g_socket_connection_factory_create_connection(GSocket *socket ) ;
#line 92 "/usr/include/glib-2.0/gio/gsocketcontrolmessage.h"
extern GType g_socket_control_message_get_type(void) ;
#line 94
extern gsize g_socket_control_message_get_size(GSocketControlMessage *message ) ;
#line 96
extern int g_socket_control_message_get_level(GSocketControlMessage *message ) ;
#line 98
extern int g_socket_control_message_get_msg_type(GSocketControlMessage *message ) ;
#line 100
extern void g_socket_control_message_serialize(GSocketControlMessage *message , gpointer data ) ;
#line 103
extern GSocketControlMessage *g_socket_control_message_deserialize(int level , int type ,
                                                                   gsize size , gpointer data ) ;
#line 83 "/usr/include/glib-2.0/gio/gsocketlistener.h"
extern GType g_socket_listener_get_type(void) ;
#line 86
extern GSocketListener *g_socket_listener_new(void) ;
#line 89
extern void g_socket_listener_set_backlog(GSocketListener *listener , int listen_backlog ) ;
#line 93
extern gboolean g_socket_listener_add_socket(GSocketListener *listener , GSocket *socket ,
                                             GObject *source_object , GError **error ) ;
#line 98
extern gboolean g_socket_listener_add_address(GSocketListener *listener , GSocketAddress *address ,
                                              GSocketType type , GSocketProtocol protocol ,
                                              GObject *source_object , GSocketAddress **effective_address ,
                                              GError **error ) ;
#line 106
extern gboolean g_socket_listener_add_inet_port(GSocketListener *listener , guint16 port ,
                                                GObject *source_object , GError **error ) ;
#line 111
extern guint16 g_socket_listener_add_any_inet_port(GSocketListener *listener , GObject *source_object ,
                                                   GError **error ) ;
#line 116
extern GSocket *g_socket_listener_accept_socket(GSocketListener *listener , GObject **source_object ,
                                                GCancellable *cancellable , GError **error ) ;
#line 121
extern void g_socket_listener_accept_socket_async(GSocketListener *listener , GCancellable *cancellable ,
                                                  GAsyncReadyCallback callback , gpointer user_data ) ;
#line 126
extern GSocket *g_socket_listener_accept_socket_finish(GSocketListener *listener ,
                                                       GAsyncResult *result , GObject **source_object ,
                                                       GError **error ) ;
#line 133
extern GSocketConnection *g_socket_listener_accept(GSocketListener *listener , GObject **source_object ,
                                                   GCancellable *cancellable , GError **error ) ;
#line 139
extern void g_socket_listener_accept_async(GSocketListener *listener , GCancellable *cancellable ,
                                           GAsyncReadyCallback callback , gpointer user_data ) ;
#line 145
extern GSocketConnection *g_socket_listener_accept_finish(GSocketListener *listener ,
                                                          GAsyncResult *result , GObject **source_object ,
                                                          GError **error ) ;
#line 151
extern void g_socket_listener_close(GSocketListener *listener ) ;
#line 79 "/usr/include/glib-2.0/gio/gsocketservice.h"
extern GType g_socket_service_get_type(void) ;
#line 82
extern GSocketService *g_socket_service_new(void) ;
#line 84
extern void g_socket_service_start(GSocketService *service ) ;
#line 86
extern void g_socket_service_stop(GSocketService *service ) ;
#line 88
extern gboolean g_socket_service_is_active(GSocketService *service ) ;
#line 31 "/usr/include/glib-2.0/gio/gsrvtarget.h"
extern GType g_srv_target_get_type(void) ;
#line 35
extern GSrvTarget *g_srv_target_new(gchar *hostname , guint16 port , guint16 priority ,
                                    guint16 weight ) ;
#line 40
extern GSrvTarget *g_srv_target_copy(GSrvTarget *target ) ;
#line 42
extern void g_srv_target_free(GSrvTarget *target ) ;
#line 45
extern gchar *g_srv_target_get_hostname(GSrvTarget *target ) ;
#line 47
extern guint16 g_srv_target_get_port(GSrvTarget *target ) ;
#line 49
extern guint16 g_srv_target_get_priority(GSrvTarget *target ) ;
#line 51
extern guint16 g_srv_target_get_weight(GSrvTarget *target ) ;
#line 54
extern GList *g_srv_target_list_sort(GList *targets ) ;
#line 37 "/usr/include/glib-2.0/gio/gsubprocess.h"
extern GType g_subprocess_get_type(void) ;
#line 42
extern GSubprocess *g_subprocess_new(GSubprocessFlags flags , GError **error , gchar *argv0 
                                     , ...) ;
#line 47
extern GSubprocess *g_subprocess_newv(gchar * const  *argv , GSubprocessFlags flags ,
                                      GError **error ) ;
#line 52
extern GOutputStream *g_subprocess_get_stdin_pipe(GSubprocess *subprocess ) ;
#line 55
extern GInputStream *g_subprocess_get_stdout_pipe(GSubprocess *subprocess ) ;
#line 58
extern GInputStream *g_subprocess_get_stderr_pipe(GSubprocess *subprocess ) ;
#line 61
extern gchar *g_subprocess_get_identifier(GSubprocess *subprocess ) ;
#line 65
extern void g_subprocess_send_signal(GSubprocess *subprocess , gint signal_num ) ;
#line 70
extern void g_subprocess_force_exit(GSubprocess *subprocess ) ;
#line 73
extern gboolean g_subprocess_wait(GSubprocess *subprocess , GCancellable *cancellable ,
                                  GError **error ) ;
#line 78
extern void g_subprocess_wait_async(GSubprocess *subprocess , GCancellable *cancellable ,
                                    GAsyncReadyCallback callback , gpointer user_data ) ;
#line 84
extern gboolean g_subprocess_wait_finish(GSubprocess *subprocess , GAsyncResult *result ,
                                         GError **error ) ;
#line 89
extern gboolean g_subprocess_wait_check(GSubprocess *subprocess , GCancellable *cancellable ,
                                        GError **error ) ;
#line 94
extern void g_subprocess_wait_check_async(GSubprocess *subprocess , GCancellable *cancellable ,
                                          GAsyncReadyCallback callback , gpointer user_data ) ;
#line 100
extern gboolean g_subprocess_wait_check_finish(GSubprocess *subprocess , GAsyncResult *result ,
                                               GError **error ) ;
#line 106
extern gint g_subprocess_get_status(GSubprocess *subprocess ) ;
#line 109
extern gboolean g_subprocess_get_successful(GSubprocess *subprocess ) ;
#line 112
extern gboolean g_subprocess_get_if_exited(GSubprocess *subprocess ) ;
#line 115
extern gint g_subprocess_get_exit_status(GSubprocess *subprocess ) ;
#line 118
extern gboolean g_subprocess_get_if_signaled(GSubprocess *subprocess ) ;
#line 121
extern gint g_subprocess_get_term_sig(GSubprocess *subprocess ) ;
#line 124
extern gboolean g_subprocess_communicate(GSubprocess *subprocess , GBytes *stdin_buf ,
                                         GCancellable *cancellable , GBytes **stdout_buf ,
                                         GBytes **stderr_buf , GError **error ) ;
#line 131
extern void g_subprocess_communicate_async(GSubprocess *subprocess , GBytes *stdin_buf ,
                                           GCancellable *cancellable , GAsyncReadyCallback callback ,
                                           gpointer user_data ) ;
#line 138
extern gboolean g_subprocess_communicate_finish(GSubprocess *subprocess , GAsyncResult *result ,
                                                GBytes **stdout_buf , GBytes **stderr_buf ,
                                                GError **error ) ;
#line 145
extern gboolean g_subprocess_communicate_utf8(GSubprocess *subprocess , char const   *stdin_buf ,
                                              GCancellable *cancellable , char **stdout_buf ,
                                              char **stderr_buf , GError **error ) ;
#line 152
extern void g_subprocess_communicate_utf8_async(GSubprocess *subprocess , char const   *stdin_buf ,
                                                GCancellable *cancellable , GAsyncReadyCallback callback ,
                                                gpointer user_data ) ;
#line 159
extern gboolean g_subprocess_communicate_utf8_finish(GSubprocess *subprocess , GAsyncResult *result ,
                                                     char **stdout_buf , char **stderr_buf ,
                                                     GError **error ) ;
#line 39 "/usr/include/glib-2.0/gio/gsubprocesslauncher.h"
extern GType g_subprocess_launcher_get_type(void) ;
#line 42
extern GSubprocessLauncher *g_subprocess_launcher_new(GSubprocessFlags flags ) ;
#line 45
extern GSubprocess *g_subprocess_launcher_spawn(GSubprocessLauncher *self , GError **error ,
                                                gchar *argv0  , ...) ;
#line 51
extern GSubprocess *g_subprocess_launcher_spawnv(GSubprocessLauncher *self , gchar * const  *argv ,
                                                 GError **error ) ;
#line 56
extern void g_subprocess_launcher_set_environ(GSubprocessLauncher *self , gchar **env ) ;
#line 60
extern void g_subprocess_launcher_setenv(GSubprocessLauncher *self , gchar *variable ,
                                         gchar *value , gboolean overwrite ) ;
#line 66
extern void g_subprocess_launcher_unsetenv(GSubprocessLauncher *self , gchar *variable ) ;
#line 70
extern gchar *g_subprocess_launcher_getenv(GSubprocessLauncher *self , gchar *variable ) ;
#line 74
extern void g_subprocess_launcher_set_cwd(GSubprocessLauncher *self , gchar *cwd ) ;
#line 77
extern void g_subprocess_launcher_set_flags(GSubprocessLauncher *self , GSubprocessFlags flags ) ;
#line 83
extern void g_subprocess_launcher_set_stdin_file_path(GSubprocessLauncher *self ,
                                                      gchar *path ) ;
#line 86
extern void g_subprocess_launcher_take_stdin_fd(GSubprocessLauncher *self , gint fd ) ;
#line 89
extern void g_subprocess_launcher_set_stdout_file_path(GSubprocessLauncher *self ,
                                                       gchar *path ) ;
#line 92
extern void g_subprocess_launcher_take_stdout_fd(GSubprocessLauncher *self , gint fd ) ;
#line 95
extern void g_subprocess_launcher_set_stderr_file_path(GSubprocessLauncher *self ,
                                                       gchar *path ) ;
#line 98
extern void g_subprocess_launcher_take_stderr_fd(GSubprocessLauncher *self , gint fd ) ;
#line 102
extern void g_subprocess_launcher_take_fd(GSubprocessLauncher *self , gint source_fd ,
                                          gint target_fd ) ;
#line 107
extern void g_subprocess_launcher_close(GSubprocessLauncher *self ) ;
#line 111
extern void g_subprocess_launcher_set_child_setup(GSubprocessLauncher *self , GSpawnChildSetupFunc child_setup ,
                                                  gpointer user_data , GDestroyNotify destroy_notify ) ;
#line 40 "/usr/include/glib-2.0/gio/gtask.h"
extern GType g_task_get_type(void) ;
#line 43
extern GTask *g_task_new(gpointer source_object , GCancellable *cancellable , GAsyncReadyCallback callback ,
                         gpointer callback_data ) ;
#line 49
extern void g_task_report_error(gpointer source_object , GAsyncReadyCallback callback ,
                                gpointer callback_data , gpointer source_tag , GError *error ) ;
#line 55
extern void g_task_report_new_error(gpointer source_object , GAsyncReadyCallback callback ,
                                    gpointer callback_data , gpointer source_tag ,
                                    GQuark domain , gint code , char const   *format 
                                    , ...) ;
#line 65
extern void g_task_set_task_data(GTask *task , gpointer task_data , GDestroyNotify task_data_destroy ) ;
#line 69
extern void g_task_set_priority(GTask *task , gint priority ) ;
#line 72
extern void g_task_set_check_cancellable(GTask *task , gboolean check_cancellable ) ;
#line 75
extern void g_task_set_source_tag(GTask *task , gpointer source_tag ) ;
#line 78
extern void g_task_set_name(GTask *task , gchar *name ) ;
#line 92
extern gpointer g_task_get_source_object(GTask *task ) ;
#line 94
extern gpointer g_task_get_task_data(GTask *task ) ;
#line 96
extern gint g_task_get_priority(GTask *task ) ;
#line 98
extern GMainContext *g_task_get_context(GTask *task ) ;
#line 100
extern GCancellable *g_task_get_cancellable(GTask *task ) ;
#line 102
extern gboolean g_task_get_check_cancellable(GTask *task ) ;
#line 104
extern gpointer g_task_get_source_tag(GTask *task ) ;
#line 106
extern gchar *g_task_get_name(GTask *task ) ;
#line 109
extern gboolean g_task_is_valid(gpointer result , gpointer source_object ) ;
#line 118
extern void g_task_run_in_thread(GTask *task , GTaskThreadFunc task_func ) ;
#line 121
extern void g_task_run_in_thread_sync(GTask *task , GTaskThreadFunc task_func ) ;
#line 124
extern gboolean g_task_set_return_on_cancel(GTask *task , gboolean return_on_cancel ) ;
#line 127
extern gboolean g_task_get_return_on_cancel(GTask *task ) ;
#line 130
extern void g_task_attach_source(GTask *task , GSource *source , GSourceFunc callback ) ;
#line 136
extern void g_task_return_pointer(GTask *task , gpointer result , GDestroyNotify result_destroy ) ;
#line 140
extern void g_task_return_boolean(GTask *task , gboolean result ) ;
#line 143
extern void g_task_return_int(GTask *task , gssize result ) ;
#line 147
extern void g_task_return_error(GTask *task , GError *error ) ;
#line 150
extern void g_task_return_new_error(GTask *task , GQuark domain , gint code , char const   *format 
                                    , ...) ;
#line 156
extern void g_task_return_value(GTask *task , GValue *result ) ;
#line 160
extern gboolean g_task_return_error_if_cancelled(GTask *task ) ;
#line 163
extern gpointer g_task_propagate_pointer(GTask *task , GError **error ) ;
#line 166
extern gboolean g_task_propagate_boolean(GTask *task , GError **error ) ;
#line 169
extern gssize g_task_propagate_int(GTask *task , GError **error ) ;
#line 172
extern gboolean g_task_propagate_value(GTask *task , GValue *value , GError **error ) ;
#line 176
extern gboolean g_task_had_error(GTask *task ) ;
#line 178
extern gboolean g_task_get_completed(GTask *task ) ;
#line 59 "/usr/include/glib-2.0/gio/gtcpconnection.h"
extern GType g_tcp_connection_get_type(void) ;
#line 62
extern void g_tcp_connection_set_graceful_disconnect(GTcpConnection *connection ,
                                                     gboolean graceful_disconnect ) ;
#line 65
extern gboolean g_tcp_connection_get_graceful_disconnect(GTcpConnection *connection ) ;
#line 59 "/usr/include/glib-2.0/gio/gtcpwrapperconnection.h"
extern GType g_tcp_wrapper_connection_get_type(void) ;
#line 62
extern GSocketConnection *g_tcp_wrapper_connection_new(GIOStream *base_io_stream ,
                                                       GSocket *socket ) ;
#line 65
extern GIOStream *g_tcp_wrapper_connection_get_base_io_stream(GTcpWrapperConnection *conn ) ;
#line 43 "/usr/include/glib-2.0/gio/gtestdbus.h"
extern GType g_test_dbus_get_type(void) ;
#line 46
extern GTestDBus *g_test_dbus_new(GTestDBusFlags flags ) ;
#line 49
extern GTestDBusFlags g_test_dbus_get_flags(GTestDBus *self ) ;
#line 52
extern gchar *g_test_dbus_get_bus_address(GTestDBus *self ) ;
#line 55
extern void g_test_dbus_add_service_dir(GTestDBus *self , gchar *path ) ;
#line 59
extern void g_test_dbus_up(GTestDBus *self ) ;
#line 62
extern void g_test_dbus_stop(GTestDBus *self ) ;
#line 65
extern void g_test_dbus_down(GTestDBus *self ) ;
#line 68
extern void g_test_dbus_unset(void) ;
#line 47 "/usr/include/glib-2.0/gio/gthemedicon.h"
extern GType g_themed_icon_get_type(void) ;
#line 50
extern GIcon *g_themed_icon_new(char const   *iconname ) ;
#line 52
extern GIcon *g_themed_icon_new_with_default_fallbacks(char const   *iconname ) ;
#line 54
extern GIcon *g_themed_icon_new_from_names(char **iconnames , int len ) ;
#line 57
extern void g_themed_icon_prepend_name(GThemedIcon *icon , char const   *iconname ) ;
#line 60
extern void g_themed_icon_append_name(GThemedIcon *icon , char const   *iconname ) ;
#line 64
extern gchar * const  *g_themed_icon_get_names(GThemedIcon *icon ) ;
#line 75 "/usr/include/glib-2.0/gio/gthreadedsocketservice.h"
extern GType g_threaded_socket_service_get_type(void) ;
#line 77
extern GSocketService *g_threaded_socket_service_new(int max_threads ) ;
#line 81 "/usr/include/glib-2.0/gio/gtlsbackend.h"
extern GType g_tls_backend_get_type(void) ;
#line 84
extern GTlsBackend *g_tls_backend_get_default(void) ;
#line 87
extern GTlsDatabase *g_tls_backend_get_default_database(GTlsBackend *backend ) ;
#line 89
extern void g_tls_backend_set_default_database(GTlsBackend *backend , GTlsDatabase *database ) ;
#line 93
extern gboolean g_tls_backend_supports_tls(GTlsBackend *backend ) ;
#line 95
extern gboolean g_tls_backend_supports_dtls(GTlsBackend *backend ) ;
#line 98
extern GType g_tls_backend_get_certificate_type(GTlsBackend *backend ) ;
#line 100
extern GType g_tls_backend_get_client_connection_type(GTlsBackend *backend ) ;
#line 102
extern GType g_tls_backend_get_server_connection_type(GTlsBackend *backend ) ;
#line 104
extern GType g_tls_backend_get_file_database_type(GTlsBackend *backend ) ;
#line 107
extern GType g_tls_backend_get_dtls_client_connection_type(GTlsBackend *backend ) ;
#line 109
extern GType g_tls_backend_get_dtls_server_connection_type(GTlsBackend *backend ) ;
#line 60 "/usr/include/glib-2.0/gio/gtlscertificate.h"
extern GType g_tls_certificate_get_type(void) ;
#line 63
extern GTlsCertificate *g_tls_certificate_new_from_pem(gchar *data , gssize length ,
                                                       GError **error ) ;
#line 67
extern GTlsCertificate *g_tls_certificate_new_from_pkcs12(guint8 *data , gsize length ,
                                                          gchar *password , GError **error ) ;
#line 72
extern GTlsCertificate *g_tls_certificate_new_from_file_with_password(gchar *file ,
                                                                      gchar *password ,
                                                                      GError **error ) ;
#line 76
extern GTlsCertificate *g_tls_certificate_new_from_file(gchar *file , GError **error ) ;
#line 79
extern GTlsCertificate *g_tls_certificate_new_from_files(gchar *cert_file , gchar *key_file ,
                                                         GError **error ) ;
#line 83
extern GTlsCertificate *g_tls_certificate_new_from_pkcs11_uris(gchar *pkcs11_uri ,
                                                               gchar *private_key_pkcs11_uri ,
                                                               GError **error ) ;
#line 88
extern GList *g_tls_certificate_list_new_from_file(gchar *file , GError **error ) ;
#line 92
extern GTlsCertificate *g_tls_certificate_get_issuer(GTlsCertificate *cert ) ;
#line 95
extern GTlsCertificateFlags g_tls_certificate_verify(GTlsCertificate *cert , GSocketConnectable *identity ,
                                                     GTlsCertificate *trusted_ca ) ;
#line 100
extern gboolean g_tls_certificate_is_same(GTlsCertificate *cert_one , GTlsCertificate *cert_two ) ;
#line 104
extern GDateTime *g_tls_certificate_get_not_valid_before(GTlsCertificate *cert ) ;
#line 107
extern GDateTime *g_tls_certificate_get_not_valid_after(GTlsCertificate *cert ) ;
#line 110
extern gchar *g_tls_certificate_get_subject_name(GTlsCertificate *cert ) ;
#line 113
extern gchar *g_tls_certificate_get_issuer_name(GTlsCertificate *cert ) ;
#line 116
extern GPtrArray *g_tls_certificate_get_dns_names(GTlsCertificate *cert ) ;
#line 119
extern GPtrArray *g_tls_certificate_get_ip_addresses(GTlsCertificate *cert ) ;
#line 98 "/usr/include/glib-2.0/gio/gtlsconnection.h"
extern GType g_tls_connection_get_type(void) ;
#line 101
extern void g_tls_connection_set_use_system_certdb(GTlsConnection *conn , gboolean use_system_certdb ) ;
#line 104
extern gboolean g_tls_connection_get_use_system_certdb(GTlsConnection *conn ) ;
#line 107
extern void g_tls_connection_set_database(GTlsConnection *conn , GTlsDatabase *database ) ;
#line 110
extern GTlsDatabase *g_tls_connection_get_database(GTlsConnection *conn ) ;
#line 113
extern void g_tls_connection_set_certificate(GTlsConnection *conn , GTlsCertificate *certificate ) ;
#line 116
extern GTlsCertificate *g_tls_connection_get_certificate(GTlsConnection *conn ) ;
#line 119
extern void g_tls_connection_set_interaction(GTlsConnection *conn , GTlsInteraction *interaction ) ;
#line 122
extern GTlsInteraction *g_tls_connection_get_interaction(GTlsConnection *conn ) ;
#line 125
extern GTlsCertificate *g_tls_connection_get_peer_certificate(GTlsConnection *conn ) ;
#line 127
extern GTlsCertificateFlags g_tls_connection_get_peer_certificate_errors(GTlsConnection *conn ) ;
#line 130
extern void g_tls_connection_set_require_close_notify(GTlsConnection *conn , gboolean require_close_notify ) ;
#line 133
extern gboolean g_tls_connection_get_require_close_notify(GTlsConnection *conn ) ;
#line 137
extern void g_tls_connection_set_rehandshake_mode(GTlsConnection *conn , GTlsRehandshakeMode mode ) ;
#line 140
extern GTlsRehandshakeMode g_tls_connection_get_rehandshake_mode(GTlsConnection *conn ) ;
#line 144
extern void g_tls_connection_set_advertised_protocols(GTlsConnection *conn , gchar * const  *protocols ) ;
#line 148
extern gchar *g_tls_connection_get_negotiated_protocol(GTlsConnection *conn ) ;
#line 152
extern gboolean g_tls_connection_get_channel_binding_data(GTlsConnection *conn , GTlsChannelBindingType type ,
                                                          GByteArray *data , GError **error ) ;
#line 159
extern gboolean g_tls_connection_handshake(GTlsConnection *conn , GCancellable *cancellable ,
                                           GError **error ) ;
#line 164
extern void g_tls_connection_handshake_async(GTlsConnection *conn , int io_priority ,
                                             GCancellable *cancellable , GAsyncReadyCallback callback ,
                                             gpointer user_data ) ;
#line 170
extern gboolean g_tls_connection_handshake_finish(GTlsConnection *conn , GAsyncResult *result ,
                                                  GError **error ) ;
#line 175
extern GTlsProtocolVersion g_tls_connection_get_protocol_version(GTlsConnection *conn ) ;
#line 178
extern gchar *g_tls_connection_get_ciphersuite_name(GTlsConnection *conn ) ;
#line 189
extern GQuark g_tls_error_quark(void) ;
#line 202
extern GQuark g_tls_channel_binding_error_quark(void) ;
#line 206
extern gboolean g_tls_connection_emit_accept_certificate(GTlsConnection *conn , GTlsCertificate *peer_cert ,
                                                         GTlsCertificateFlags errors ) ;
#line 55 "/usr/include/glib-2.0/gio/gtlsclientconnection.h"
extern GType g_tls_client_connection_get_type(void) ;
#line 58
extern GIOStream *g_tls_client_connection_new(GIOStream *base_io_stream , GSocketConnectable *server_identity ,
                                              GError **error ) ;
#line 63
extern GTlsCertificateFlags g_tls_client_connection_get_validation_flags(GTlsClientConnection *conn ) ;
#line 65
extern void g_tls_client_connection_set_validation_flags(GTlsClientConnection *conn ,
                                                         GTlsCertificateFlags flags ) ;
#line 68
extern GSocketConnectable *g_tls_client_connection_get_server_identity(GTlsClientConnection *conn ) ;
#line 70
extern void g_tls_client_connection_set_server_identity(GTlsClientConnection *conn ,
                                                        GSocketConnectable *identity ) ;
#line 73
extern gboolean g_tls_client_connection_get_use_ssl3(GTlsClientConnection *conn ) ;
#line 75
extern void g_tls_client_connection_set_use_ssl3(GTlsClientConnection *conn , gboolean use_ssl3 ) ;
#line 78
extern GList *g_tls_client_connection_get_accepted_cas(GTlsClientConnection *conn ) ;
#line 81
extern void g_tls_client_connection_copy_session_state(GTlsClientConnection *conn ,
                                                       GTlsClientConnection *source ) ;
#line 147 "/usr/include/glib-2.0/gio/gtlsdatabase.h"
extern GType g_tls_database_get_type(void) ;
#line 150
extern GTlsCertificateFlags g_tls_database_verify_chain(GTlsDatabase *self , GTlsCertificate *chain ,
                                                        gchar *purpose , GSocketConnectable *identity ,
                                                        GTlsInteraction *interaction ,
                                                        GTlsDatabaseVerifyFlags flags ,
                                                        GCancellable *cancellable ,
                                                        GError **error ) ;
#line 160
extern void g_tls_database_verify_chain_async(GTlsDatabase *self , GTlsCertificate *chain ,
                                              gchar *purpose , GSocketConnectable *identity ,
                                              GTlsInteraction *interaction , GTlsDatabaseVerifyFlags flags ,
                                              GCancellable *cancellable , GAsyncReadyCallback callback ,
                                              gpointer user_data ) ;
#line 171
extern GTlsCertificateFlags g_tls_database_verify_chain_finish(GTlsDatabase *self ,
                                                               GAsyncResult *result ,
                                                               GError **error ) ;
#line 176
extern gchar *g_tls_database_create_certificate_handle(GTlsDatabase *self , GTlsCertificate *certificate ) ;
#line 180
extern GTlsCertificate *g_tls_database_lookup_certificate_for_handle(GTlsDatabase *self ,
                                                                     gchar *handle ,
                                                                     GTlsInteraction *interaction ,
                                                                     GTlsDatabaseLookupFlags flags ,
                                                                     GCancellable *cancellable ,
                                                                     GError **error ) ;
#line 188
extern void g_tls_database_lookup_certificate_for_handle_async(GTlsDatabase *self ,
                                                               gchar *handle , GTlsInteraction *interaction ,
                                                               GTlsDatabaseLookupFlags flags ,
                                                               GCancellable *cancellable ,
                                                               GAsyncReadyCallback callback ,
                                                               gpointer user_data ) ;
#line 197
extern GTlsCertificate *g_tls_database_lookup_certificate_for_handle_finish(GTlsDatabase *self ,
                                                                            GAsyncResult *result ,
                                                                            GError **error ) ;
#line 202
extern GTlsCertificate *g_tls_database_lookup_certificate_issuer(GTlsDatabase *self ,
                                                                 GTlsCertificate *certificate ,
                                                                 GTlsInteraction *interaction ,
                                                                 GTlsDatabaseLookupFlags flags ,
                                                                 GCancellable *cancellable ,
                                                                 GError **error ) ;
#line 210
extern void g_tls_database_lookup_certificate_issuer_async(GTlsDatabase *self , GTlsCertificate *certificate ,
                                                           GTlsInteraction *interaction ,
                                                           GTlsDatabaseLookupFlags flags ,
                                                           GCancellable *cancellable ,
                                                           GAsyncReadyCallback callback ,
                                                           gpointer user_data ) ;
#line 219
extern GTlsCertificate *g_tls_database_lookup_certificate_issuer_finish(GTlsDatabase *self ,
                                                                        GAsyncResult *result ,
                                                                        GError **error ) ;
#line 224
extern GList *g_tls_database_lookup_certificates_issued_by(GTlsDatabase *self , GByteArray *issuer_raw_dn ,
                                                           GTlsInteraction *interaction ,
                                                           GTlsDatabaseLookupFlags flags ,
                                                           GCancellable *cancellable ,
                                                           GError **error ) ;
#line 232
extern void g_tls_database_lookup_certificates_issued_by_async(GTlsDatabase *self ,
                                                               GByteArray *issuer_raw_dn ,
                                                               GTlsInteraction *interaction ,
                                                               GTlsDatabaseLookupFlags flags ,
                                                               GCancellable *cancellable ,
                                                               GAsyncReadyCallback callback ,
                                                               gpointer user_data ) ;
#line 241
extern GList *g_tls_database_lookup_certificates_issued_by_finish(GTlsDatabase *self ,
                                                                  GAsyncResult *result ,
                                                                  GError **error ) ;
#line 50 "/usr/include/glib-2.0/gio/gtlsfiledatabase.h"
extern GType g_tls_file_database_get_type(void) ;
#line 53
extern GTlsDatabase *g_tls_file_database_new(gchar *anchors , GError **error ) ;
#line 93 "/usr/include/glib-2.0/gio/gtlsinteraction.h"
extern GType g_tls_interaction_get_type(void) ;
#line 96
extern GTlsInteractionResult g_tls_interaction_invoke_ask_password(GTlsInteraction *interaction ,
                                                                   GTlsPassword *password ,
                                                                   GCancellable *cancellable ,
                                                                   GError **error ) ;
#line 102
extern GTlsInteractionResult g_tls_interaction_ask_password(GTlsInteraction *interaction ,
                                                            GTlsPassword *password ,
                                                            GCancellable *cancellable ,
                                                            GError **error ) ;
#line 108
extern void g_tls_interaction_ask_password_async(GTlsInteraction *interaction , GTlsPassword *password ,
                                                 GCancellable *cancellable , GAsyncReadyCallback callback ,
                                                 gpointer user_data ) ;
#line 115
extern GTlsInteractionResult g_tls_interaction_ask_password_finish(GTlsInteraction *interaction ,
                                                                   GAsyncResult *result ,
                                                                   GError **error ) ;
#line 120
extern GTlsInteractionResult g_tls_interaction_invoke_request_certificate(GTlsInteraction *interaction ,
                                                                          GTlsConnection *connection ,
                                                                          GTlsCertificateRequestFlags flags ,
                                                                          GCancellable *cancellable ,
                                                                          GError **error ) ;
#line 127
extern GTlsInteractionResult g_tls_interaction_request_certificate(GTlsInteraction *interaction ,
                                                                   GTlsConnection *connection ,
                                                                   GTlsCertificateRequestFlags flags ,
                                                                   GCancellable *cancellable ,
                                                                   GError **error ) ;
#line 134
extern void g_tls_interaction_request_certificate_async(GTlsInteraction *interaction ,
                                                        GTlsConnection *connection ,
                                                        GTlsCertificateRequestFlags flags ,
                                                        GCancellable *cancellable ,
                                                        GAsyncReadyCallback callback ,
                                                        gpointer user_data ) ;
#line 142
extern GTlsInteractionResult g_tls_interaction_request_certificate_finish(GTlsInteraction *interaction ,
                                                                          GAsyncResult *result ,
                                                                          GError **error ) ;
#line 80 "/usr/include/glib-2.0/gio/gtlspassword.h"
extern GType g_tls_password_get_type(void) ;
#line 83
extern GTlsPassword *g_tls_password_new(GTlsPasswordFlags flags , gchar *description ) ;
#line 87
extern guchar *g_tls_password_get_value(GTlsPassword *password , gsize *length ) ;
#line 90
extern void g_tls_password_set_value(GTlsPassword *password , guchar *value , gssize length ) ;
#line 94
extern void g_tls_password_set_value_full(GTlsPassword *password , guchar *value ,
                                          gssize length , GDestroyNotify destroy ) ;
#line 100
extern GTlsPasswordFlags g_tls_password_get_flags(GTlsPassword *password ) ;
#line 102
extern void g_tls_password_set_flags(GTlsPassword *password , GTlsPasswordFlags flags ) ;
#line 106
extern gchar *g_tls_password_get_description(GTlsPassword *password ) ;
#line 108
extern void g_tls_password_set_description(GTlsPassword *password , gchar *description ) ;
#line 112
extern gchar *g_tls_password_get_warning(GTlsPassword *password ) ;
#line 114
extern void g_tls_password_set_warning(GTlsPassword *password , gchar *warning ) ;
#line 60 "/usr/include/glib-2.0/gio/gtlsserverconnection.h"
extern GType g_tls_server_connection_get_type(void) ;
#line 63
extern GIOStream *g_tls_server_connection_new(GIOStream *base_io_stream , GTlsCertificate *certificate ,
                                              GError **error ) ;
#line 130 "/usr/include/glib-2.0/gio/gvfs.h"
extern GType g_vfs_get_type(void) ;
#line 133
extern gboolean g_vfs_is_active(GVfs *vfs ) ;
#line 135
extern GFile *g_vfs_get_file_for_path(GVfs *vfs , char const   *path ) ;
#line 138
extern GFile *g_vfs_get_file_for_uri(GVfs *vfs , char const   *uri ) ;
#line 141
extern gchar * const  *g_vfs_get_supported_uri_schemes(GVfs *vfs ) ;
#line 144
extern GFile *g_vfs_parse_name(GVfs *vfs , char const   *parse_name ) ;
#line 148
extern GVfs *g_vfs_get_default(void) ;
#line 150
extern GVfs *g_vfs_get_local(void) ;
#line 153
extern gboolean g_vfs_register_uri_scheme(GVfs *vfs , char const   *scheme , GVfsFileLookupFunc uri_func ,
                                          gpointer uri_data , GDestroyNotify uri_destroy ,
                                          GVfsFileLookupFunc parse_name_func , gpointer parse_name_data ,
                                          GDestroyNotify parse_name_destroy ) ;
#line 162
extern gboolean g_vfs_unregister_uri_scheme(GVfs *vfs , char const   *scheme ) ;
#line 185 "/usr/include/glib-2.0/gio/gvolume.h"
extern GType g_volume_get_type(void) ;
#line 188
extern char *g_volume_get_name(GVolume *volume ) ;
#line 190
extern GIcon *g_volume_get_icon(GVolume *volume ) ;
#line 192
extern GIcon *g_volume_get_symbolic_icon(GVolume *volume ) ;
#line 194
extern char *g_volume_get_uuid(GVolume *volume ) ;
#line 196
extern GDrive *g_volume_get_drive(GVolume *volume ) ;
#line 198
extern GMount *g_volume_get_mount(GVolume *volume ) ;
#line 200
extern gboolean g_volume_can_mount(GVolume *volume ) ;
#line 202
extern gboolean g_volume_can_eject(GVolume *volume ) ;
#line 204
extern gboolean g_volume_should_automount(GVolume *volume ) ;
#line 206
extern void g_volume_mount(GVolume *volume , GMountMountFlags flags , GMountOperation *mount_operation ,
                           GCancellable *cancellable , GAsyncReadyCallback callback ,
                           gpointer user_data ) ;
#line 213
extern gboolean g_volume_mount_finish(GVolume *volume , GAsyncResult *result , GError **error ) ;
#line 217
extern void g_volume_eject(GVolume *volume , GMountUnmountFlags flags , GCancellable *cancellable ,
                           GAsyncReadyCallback callback , gpointer user_data ) ;
#line 224
extern gboolean g_volume_eject_finish(GVolume *volume , GAsyncResult *result , GError **error ) ;
#line 228
extern char *g_volume_get_identifier(GVolume *volume , char const   *kind ) ;
#line 231
extern char **g_volume_enumerate_identifiers(GVolume *volume ) ;
#line 234
extern GFile *g_volume_get_activation_root(GVolume *volume ) ;
#line 237
extern void g_volume_eject_with_operation(GVolume *volume , GMountUnmountFlags flags ,
                                          GMountOperation *mount_operation , GCancellable *cancellable ,
                                          GAsyncReadyCallback callback , gpointer user_data ) ;
#line 244
extern gboolean g_volume_eject_with_operation_finish(GVolume *volume , GAsyncResult *result ,
                                                     GError **error ) ;
#line 249
extern gchar *g_volume_get_sort_key(GVolume *volume ) ;
#line 48 "/usr/include/glib-2.0/gio/gzlibcompressor.h"
extern GType g_zlib_compressor_get_type(void) ;
#line 51
extern GZlibCompressor *g_zlib_compressor_new(GZlibCompressorFormat format , int level ) ;
#line 55
extern GFileInfo *g_zlib_compressor_get_file_info(GZlibCompressor *compressor ) ;
#line 57
extern void g_zlib_compressor_set_file_info(GZlibCompressor *compressor , GFileInfo *file_info ) ;
#line 48 "/usr/include/glib-2.0/gio/gzlibdecompressor.h"
extern GType g_zlib_decompressor_get_type(void) ;
#line 51
extern GZlibDecompressor *g_zlib_decompressor_new(GZlibCompressorFormat format ) ;
#line 54
extern GFileInfo *g_zlib_decompressor_get_file_info(GZlibDecompressor *decompressor ) ;
#line 24 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GAction(GAction *_ptr ) 
{ 


  {
#line 24
  if (_ptr) {
    {
#line 24
    g_object_unref((GAction *)_ptr);
    }
  }
  return;
}
}
#line 24 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GAction(GAction **_ptr ) 
{ 


  {
  {
#line 24
  glib_autoptr_clear_GAction(*_ptr);
  }
  return;
}
}
#line 25 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GActionMap(GActionMap *_ptr ) 
{ 


  {
#line 25
  if (_ptr) {
    {
#line 25
    g_object_unref((GActionMap *)_ptr);
    }
  }
  return;
}
}
#line 25 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GActionMap(GActionMap **_ptr ) 
{ 


  {
  {
#line 25
  glib_autoptr_clear_GActionMap(*_ptr);
  }
  return;
}
}
#line 26 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GAppInfo(GAppInfo *_ptr ) 
{ 


  {
#line 26
  if (_ptr) {
    {
#line 26
    g_object_unref((GAppInfo *)_ptr);
    }
  }
  return;
}
}
#line 26 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GAppInfo(GAppInfo **_ptr ) 
{ 


  {
  {
#line 26
  glib_autoptr_clear_GAppInfo(*_ptr);
  }
  return;
}
}
#line 27 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GAppLaunchContext(GAppLaunchContext *_ptr ) 
{ 


  {
#line 27
  if (_ptr) {
    {
#line 27
    g_object_unref((GAppLaunchContext *)_ptr);
    }
  }
  return;
}
}
#line 27 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GAppLaunchContext(GAppLaunchContext **_ptr ) 
{ 


  {
  {
#line 27
  glib_autoptr_clear_GAppLaunchContext(*_ptr);
  }
  return;
}
}
#line 28 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GAppInfoMonitor(GAppInfoMonitor *_ptr ) 
{ 


  {
#line 28
  if (_ptr) {
    {
#line 28
    g_object_unref((GAppInfoMonitor *)_ptr);
    }
  }
  return;
}
}
#line 28 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GAppInfoMonitor(GAppInfoMonitor **_ptr ) 
{ 


  {
  {
#line 28
  glib_autoptr_clear_GAppInfoMonitor(*_ptr);
  }
  return;
}
}
#line 29 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GApplicationCommandLine(GApplicationCommandLine *_ptr ) 
{ 


  {
#line 29
  if (_ptr) {
    {
#line 29
    g_object_unref((GApplicationCommandLine *)_ptr);
    }
  }
  return;
}
}
#line 29 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GApplicationCommandLine(GApplicationCommandLine **_ptr ) 
{ 


  {
  {
#line 29
  glib_autoptr_clear_GApplicationCommandLine(*_ptr);
  }
  return;
}
}
#line 30 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GApplication(GApplication *_ptr ) 
{ 


  {
#line 30
  if (_ptr) {
    {
#line 30
    g_object_unref((GApplication *)_ptr);
    }
  }
  return;
}
}
#line 30 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GApplication(GApplication **_ptr ) 
{ 


  {
  {
#line 30
  glib_autoptr_clear_GApplication(*_ptr);
  }
  return;
}
}
#line 31 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GAsyncInitable(GAsyncInitable *_ptr ) 
{ 


  {
#line 31
  if (_ptr) {
    {
#line 31
    g_object_unref((GAsyncInitable *)_ptr);
    }
  }
  return;
}
}
#line 31 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GAsyncInitable(GAsyncInitable **_ptr ) 
{ 


  {
  {
#line 31
  glib_autoptr_clear_GAsyncInitable(*_ptr);
  }
  return;
}
}
#line 32 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GAsyncResult(GAsyncResult *_ptr ) 
{ 


  {
#line 32
  if (_ptr) {
    {
#line 32
    g_object_unref((GAsyncResult *)_ptr);
    }
  }
  return;
}
}
#line 32 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GAsyncResult(GAsyncResult **_ptr ) 
{ 


  {
  {
#line 32
  glib_autoptr_clear_GAsyncResult(*_ptr);
  }
  return;
}
}
#line 33 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GBufferedInputStream(GBufferedInputStream *_ptr ) 
{ 


  {
#line 33
  if (_ptr) {
    {
#line 33
    g_object_unref((GBufferedInputStream *)_ptr);
    }
  }
  return;
}
}
#line 33 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GBufferedInputStream(GBufferedInputStream **_ptr ) 
{ 


  {
  {
#line 33
  glib_autoptr_clear_GBufferedInputStream(*_ptr);
  }
  return;
}
}
#line 34 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GBufferedOutputStream(GBufferedOutputStream *_ptr ) 
{ 


  {
#line 34
  if (_ptr) {
    {
#line 34
    g_object_unref((GBufferedOutputStream *)_ptr);
    }
  }
  return;
}
}
#line 34 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GBufferedOutputStream(GBufferedOutputStream **_ptr ) 
{ 


  {
  {
#line 34
  glib_autoptr_clear_GBufferedOutputStream(*_ptr);
  }
  return;
}
}
#line 35 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GBytesIcon(GBytesIcon *_ptr ) 
{ 


  {
#line 35
  if (_ptr) {
    {
#line 35
    g_object_unref((GBytesIcon *)_ptr);
    }
  }
  return;
}
}
#line 35 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GBytesIcon(GBytesIcon **_ptr ) 
{ 


  {
  {
#line 35
  glib_autoptr_clear_GBytesIcon(*_ptr);
  }
  return;
}
}
#line 36 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GCancellable(GCancellable *_ptr ) 
{ 


  {
#line 36
  if (_ptr) {
    {
#line 36
    g_object_unref((GCancellable *)_ptr);
    }
  }
  return;
}
}
#line 36 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GCancellable(GCancellable **_ptr ) 
{ 


  {
  {
#line 36
  glib_autoptr_clear_GCancellable(*_ptr);
  }
  return;
}
}
#line 37 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GCharsetConverter(GCharsetConverter *_ptr ) 
{ 


  {
#line 37
  if (_ptr) {
    {
#line 37
    g_object_unref((GCharsetConverter *)_ptr);
    }
  }
  return;
}
}
#line 37 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GCharsetConverter(GCharsetConverter **_ptr ) 
{ 


  {
  {
#line 37
  glib_autoptr_clear_GCharsetConverter(*_ptr);
  }
  return;
}
}
#line 38 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GConverter(GConverter *_ptr ) 
{ 


  {
#line 38
  if (_ptr) {
    {
#line 38
    g_object_unref((GConverter *)_ptr);
    }
  }
  return;
}
}
#line 38 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GConverter(GConverter **_ptr ) 
{ 


  {
  {
#line 38
  glib_autoptr_clear_GConverter(*_ptr);
  }
  return;
}
}
#line 39 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GConverterInputStream(GConverterInputStream *_ptr ) 
{ 


  {
#line 39
  if (_ptr) {
    {
#line 39
    g_object_unref((GConverterInputStream *)_ptr);
    }
  }
  return;
}
}
#line 39 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GConverterInputStream(GConverterInputStream **_ptr ) 
{ 


  {
  {
#line 39
  glib_autoptr_clear_GConverterInputStream(*_ptr);
  }
  return;
}
}
#line 40 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GConverterOutputStream(GConverterOutputStream *_ptr ) 
{ 


  {
#line 40
  if (_ptr) {
    {
#line 40
    g_object_unref((GConverterOutputStream *)_ptr);
    }
  }
  return;
}
}
#line 40 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GConverterOutputStream(GConverterOutputStream **_ptr ) 
{ 


  {
  {
#line 40
  glib_autoptr_clear_GConverterOutputStream(*_ptr);
  }
  return;
}
}
#line 41 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GCredentials(GCredentials *_ptr ) 
{ 


  {
#line 41
  if (_ptr) {
    {
#line 41
    g_object_unref((GCredentials *)_ptr);
    }
  }
  return;
}
}
#line 41 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GCredentials(GCredentials **_ptr ) 
{ 


  {
  {
#line 41
  glib_autoptr_clear_GCredentials(*_ptr);
  }
  return;
}
}
#line 42 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDatagramBased(GDatagramBased *_ptr ) 
{ 


  {
#line 42
  if (_ptr) {
    {
#line 42
    g_object_unref((GDatagramBased *)_ptr);
    }
  }
  return;
}
}
#line 42 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDatagramBased(GDatagramBased **_ptr ) 
{ 


  {
  {
#line 42
  glib_autoptr_clear_GDatagramBased(*_ptr);
  }
  return;
}
}
#line 43 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDataInputStream(GDataInputStream *_ptr ) 
{ 


  {
#line 43
  if (_ptr) {
    {
#line 43
    g_object_unref((GDataInputStream *)_ptr);
    }
  }
  return;
}
}
#line 43 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDataInputStream(GDataInputStream **_ptr ) 
{ 


  {
  {
#line 43
  glib_autoptr_clear_GDataInputStream(*_ptr);
  }
  return;
}
}
#line 44 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDataOutputStream(GDataOutputStream *_ptr ) 
{ 


  {
#line 44
  if (_ptr) {
    {
#line 44
    g_object_unref((GDataOutputStream *)_ptr);
    }
  }
  return;
}
}
#line 44 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDataOutputStream(GDataOutputStream **_ptr ) 
{ 


  {
  {
#line 44
  glib_autoptr_clear_GDataOutputStream(*_ptr);
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusActionGroup(GDBusActionGroup *_ptr ) 
{ 


  {
#line 45
  if (_ptr) {
    {
#line 45
    g_object_unref((GDBusActionGroup *)_ptr);
    }
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusActionGroup(GDBusActionGroup **_ptr ) 
{ 


  {
  {
#line 45
  glib_autoptr_clear_GDBusActionGroup(*_ptr);
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusAuthObserver(GDBusAuthObserver *_ptr ) 
{ 


  {
#line 46
  if (_ptr) {
    {
#line 46
    g_object_unref((GDBusAuthObserver *)_ptr);
    }
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusAuthObserver(GDBusAuthObserver **_ptr ) 
{ 


  {
  {
#line 46
  glib_autoptr_clear_GDBusAuthObserver(*_ptr);
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusConnection(GDBusConnection *_ptr ) 
{ 


  {
#line 47
  if (_ptr) {
    {
#line 47
    g_object_unref((GDBusConnection *)_ptr);
    }
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusConnection(GDBusConnection **_ptr ) 
{ 


  {
  {
#line 47
  glib_autoptr_clear_GDBusConnection(*_ptr);
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusInterface(GDBusInterface *_ptr ) 
{ 


  {
#line 48
  if (_ptr) {
    {
#line 48
    g_object_unref((GDBusInterface *)_ptr);
    }
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusInterface(GDBusInterface **_ptr ) 
{ 


  {
  {
#line 48
  glib_autoptr_clear_GDBusInterface(*_ptr);
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusInterfaceSkeleton(GDBusInterfaceSkeleton *_ptr ) 
{ 


  {
#line 49
  if (_ptr) {
    {
#line 49
    g_object_unref((GDBusInterfaceSkeleton *)_ptr);
    }
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusInterfaceSkeleton(GDBusInterfaceSkeleton **_ptr ) 
{ 


  {
  {
#line 49
  glib_autoptr_clear_GDBusInterfaceSkeleton(*_ptr);
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusMenuModel(GDBusMenuModel *_ptr ) 
{ 


  {
#line 50
  if (_ptr) {
    {
#line 50
    g_object_unref((GDBusMenuModel *)_ptr);
    }
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusMenuModel(GDBusMenuModel **_ptr ) 
{ 


  {
  {
#line 50
  glib_autoptr_clear_GDBusMenuModel(*_ptr);
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusMessage(GDBusMessage *_ptr ) 
{ 


  {
#line 51
  if (_ptr) {
    {
#line 51
    g_object_unref((GDBusMessage *)_ptr);
    }
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusMessage(GDBusMessage **_ptr ) 
{ 


  {
  {
#line 51
  glib_autoptr_clear_GDBusMessage(*_ptr);
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusMethodInvocation(GDBusMethodInvocation *_ptr ) 
{ 


  {
#line 52
  if (_ptr) {
    {
#line 52
    g_object_unref((GDBusMethodInvocation *)_ptr);
    }
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusMethodInvocation(GDBusMethodInvocation **_ptr ) 
{ 


  {
  {
#line 52
  glib_autoptr_clear_GDBusMethodInvocation(*_ptr);
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusNodeInfo(GDBusNodeInfo *_ptr ) 
{ 


  {
#line 53
  if (_ptr) {
    {
#line 53
    g_dbus_node_info_unref((GDBusNodeInfo *)_ptr);
    }
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusNodeInfo(GDBusNodeInfo **_ptr ) 
{ 


  {
  {
#line 53
  glib_autoptr_clear_GDBusNodeInfo(*_ptr);
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GDBusNodeInfo(GList **_l ) 
{ 


  {
  {
#line 53
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_dbus_node_info_unref)));
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GDBusNodeInfo(GSList **_l ) 
{ 


  {
  {
#line 53
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_dbus_node_info_unref)));
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GDBusNodeInfo(GQueue **_q ) 
{ 


  {
#line 53
  if (*_q) {
    {
#line 53
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_dbus_node_info_unref)));
    }
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusObject(GDBusObject *_ptr ) 
{ 


  {
#line 54
  if (_ptr) {
    {
#line 54
    g_object_unref((GDBusObject *)_ptr);
    }
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusObject(GDBusObject **_ptr ) 
{ 


  {
  {
#line 54
  glib_autoptr_clear_GDBusObject(*_ptr);
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusObjectManagerClient(GDBusObjectManagerClient *_ptr ) 
{ 


  {
#line 55
  if (_ptr) {
    {
#line 55
    g_object_unref((GDBusObjectManagerClient *)_ptr);
    }
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusObjectManagerClient(GDBusObjectManagerClient **_ptr ) 
{ 


  {
  {
#line 55
  glib_autoptr_clear_GDBusObjectManagerClient(*_ptr);
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusObjectManager(GDBusObjectManager *_ptr ) 
{ 


  {
#line 56
  if (_ptr) {
    {
#line 56
    g_object_unref((GDBusObjectManager *)_ptr);
    }
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusObjectManager(GDBusObjectManager **_ptr ) 
{ 


  {
  {
#line 56
  glib_autoptr_clear_GDBusObjectManager(*_ptr);
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusObjectManagerServer(GDBusObjectManagerServer *_ptr ) 
{ 


  {
#line 57
  if (_ptr) {
    {
#line 57
    g_object_unref((GDBusObjectManagerServer *)_ptr);
    }
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusObjectManagerServer(GDBusObjectManagerServer **_ptr ) 
{ 


  {
  {
#line 57
  glib_autoptr_clear_GDBusObjectManagerServer(*_ptr);
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusObjectProxy(GDBusObjectProxy *_ptr ) 
{ 


  {
#line 58
  if (_ptr) {
    {
#line 58
    g_object_unref((GDBusObjectProxy *)_ptr);
    }
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusObjectProxy(GDBusObjectProxy **_ptr ) 
{ 


  {
  {
#line 58
  glib_autoptr_clear_GDBusObjectProxy(*_ptr);
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusObjectSkeleton(GDBusObjectSkeleton *_ptr ) 
{ 


  {
#line 59
  if (_ptr) {
    {
#line 59
    g_object_unref((GDBusObjectSkeleton *)_ptr);
    }
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusObjectSkeleton(GDBusObjectSkeleton **_ptr ) 
{ 


  {
  {
#line 59
  glib_autoptr_clear_GDBusObjectSkeleton(*_ptr);
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusProxy(GDBusProxy *_ptr ) 
{ 


  {
#line 60
  if (_ptr) {
    {
#line 60
    g_object_unref((GDBusProxy *)_ptr);
    }
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusProxy(GDBusProxy **_ptr ) 
{ 


  {
  {
#line 60
  glib_autoptr_clear_GDBusProxy(*_ptr);
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusServer(GDBusServer *_ptr ) 
{ 


  {
#line 61
  if (_ptr) {
    {
#line 61
    g_object_unref((GDBusServer *)_ptr);
    }
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusServer(GDBusServer **_ptr ) 
{ 


  {
  {
#line 61
  glib_autoptr_clear_GDBusServer(*_ptr);
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDrive(GDrive *_ptr ) 
{ 


  {
#line 62
  if (_ptr) {
    {
#line 62
    g_object_unref((GDrive *)_ptr);
    }
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDrive(GDrive **_ptr ) 
{ 


  {
  {
#line 62
  glib_autoptr_clear_GDrive(*_ptr);
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GEmblemedIcon(GEmblemedIcon *_ptr ) 
{ 


  {
#line 63
  if (_ptr) {
    {
#line 63
    g_object_unref((GEmblemedIcon *)_ptr);
    }
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GEmblemedIcon(GEmblemedIcon **_ptr ) 
{ 


  {
  {
#line 63
  glib_autoptr_clear_GEmblemedIcon(*_ptr);
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GEmblem(GEmblem *_ptr ) 
{ 


  {
#line 64
  if (_ptr) {
    {
#line 64
    g_object_unref((GEmblem *)_ptr);
    }
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GEmblem(GEmblem **_ptr ) 
{ 


  {
  {
#line 64
  glib_autoptr_clear_GEmblem(*_ptr);
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFileEnumerator(GFileEnumerator *_ptr ) 
{ 


  {
#line 65
  if (_ptr) {
    {
#line 65
    g_object_unref((GFileEnumerator *)_ptr);
    }
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFileEnumerator(GFileEnumerator **_ptr ) 
{ 


  {
  {
#line 65
  glib_autoptr_clear_GFileEnumerator(*_ptr);
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFile(GFile *_ptr ) 
{ 


  {
#line 66
  if (_ptr) {
    {
#line 66
    g_object_unref((GFile *)_ptr);
    }
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFile(GFile **_ptr ) 
{ 


  {
  {
#line 66
  glib_autoptr_clear_GFile(*_ptr);
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFileAttributeInfoList(GFileAttributeInfoList *_ptr ) 
{ 


  {
#line 67
  if (_ptr) {
    {
#line 67
    g_file_attribute_info_list_unref((GFileAttributeInfoList *)_ptr);
    }
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFileAttributeInfoList(GFileAttributeInfoList **_ptr ) 
{ 


  {
  {
#line 67
  glib_autoptr_clear_GFileAttributeInfoList(*_ptr);
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GFileAttributeInfoList(GList **_l ) 
{ 


  {
  {
#line 67
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_file_attribute_info_list_unref)));
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GFileAttributeInfoList(GSList **_l ) 
{ 


  {
  {
#line 67
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_file_attribute_info_list_unref)));
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GFileAttributeInfoList(GQueue **_q ) 
{ 


  {
#line 67
  if (*_q) {
    {
#line 67
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_file_attribute_info_list_unref)));
    }
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFileIcon(GFileIcon *_ptr ) 
{ 


  {
#line 68
  if (_ptr) {
    {
#line 68
    g_object_unref((GFileIcon *)_ptr);
    }
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFileIcon(GFileIcon **_ptr ) 
{ 


  {
  {
#line 68
  glib_autoptr_clear_GFileIcon(*_ptr);
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFileInfo(GFileInfo *_ptr ) 
{ 


  {
#line 69
  if (_ptr) {
    {
#line 69
    g_object_unref((GFileInfo *)_ptr);
    }
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFileInfo(GFileInfo **_ptr ) 
{ 


  {
  {
#line 69
  glib_autoptr_clear_GFileInfo(*_ptr);
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFileInputStream(GFileInputStream *_ptr ) 
{ 


  {
#line 70
  if (_ptr) {
    {
#line 70
    g_object_unref((GFileInputStream *)_ptr);
    }
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFileInputStream(GFileInputStream **_ptr ) 
{ 


  {
  {
#line 70
  glib_autoptr_clear_GFileInputStream(*_ptr);
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFileIOStream(GFileIOStream *_ptr ) 
{ 


  {
#line 71
  if (_ptr) {
    {
#line 71
    g_object_unref((GFileIOStream *)_ptr);
    }
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFileIOStream(GFileIOStream **_ptr ) 
{ 


  {
  {
#line 71
  glib_autoptr_clear_GFileIOStream(*_ptr);
  }
  return;
}
}
#line 72 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFileMonitor(GFileMonitor *_ptr ) 
{ 


  {
#line 72
  if (_ptr) {
    {
#line 72
    g_object_unref((GFileMonitor *)_ptr);
    }
  }
  return;
}
}
#line 72 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFileMonitor(GFileMonitor **_ptr ) 
{ 


  {
  {
#line 72
  glib_autoptr_clear_GFileMonitor(*_ptr);
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFilenameCompleter(GFilenameCompleter *_ptr ) 
{ 


  {
#line 73
  if (_ptr) {
    {
#line 73
    g_object_unref((GFilenameCompleter *)_ptr);
    }
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFilenameCompleter(GFilenameCompleter **_ptr ) 
{ 


  {
  {
#line 73
  glib_autoptr_clear_GFilenameCompleter(*_ptr);
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFileOutputStream(GFileOutputStream *_ptr ) 
{ 


  {
#line 74
  if (_ptr) {
    {
#line 74
    g_object_unref((GFileOutputStream *)_ptr);
    }
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFileOutputStream(GFileOutputStream **_ptr ) 
{ 


  {
  {
#line 74
  glib_autoptr_clear_GFileOutputStream(*_ptr);
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFilterInputStream(GFilterInputStream *_ptr ) 
{ 


  {
#line 75
  if (_ptr) {
    {
#line 75
    g_object_unref((GFilterInputStream *)_ptr);
    }
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFilterInputStream(GFilterInputStream **_ptr ) 
{ 


  {
  {
#line 75
  glib_autoptr_clear_GFilterInputStream(*_ptr);
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFilterOutputStream(GFilterOutputStream *_ptr ) 
{ 


  {
#line 76
  if (_ptr) {
    {
#line 76
    g_object_unref((GFilterOutputStream *)_ptr);
    }
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFilterOutputStream(GFilterOutputStream **_ptr ) 
{ 


  {
  {
#line 76
  glib_autoptr_clear_GFilterOutputStream(*_ptr);
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GIcon(GIcon *_ptr ) 
{ 


  {
#line 77
  if (_ptr) {
    {
#line 77
    g_object_unref((GIcon *)_ptr);
    }
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GIcon(GIcon **_ptr ) 
{ 


  {
  {
#line 77
  glib_autoptr_clear_GIcon(*_ptr);
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GInetAddress(GInetAddress *_ptr ) 
{ 


  {
#line 78
  if (_ptr) {
    {
#line 78
    g_object_unref((GInetAddress *)_ptr);
    }
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GInetAddress(GInetAddress **_ptr ) 
{ 


  {
  {
#line 78
  glib_autoptr_clear_GInetAddress(*_ptr);
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GInetAddressMask(GInetAddressMask *_ptr ) 
{ 


  {
#line 79
  if (_ptr) {
    {
#line 79
    g_object_unref((GInetAddressMask *)_ptr);
    }
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GInetAddressMask(GInetAddressMask **_ptr ) 
{ 


  {
  {
#line 79
  glib_autoptr_clear_GInetAddressMask(*_ptr);
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GInetSocketAddress(GInetSocketAddress *_ptr ) 
{ 


  {
#line 80
  if (_ptr) {
    {
#line 80
    g_object_unref((GInetSocketAddress *)_ptr);
    }
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GInetSocketAddress(GInetSocketAddress **_ptr ) 
{ 


  {
  {
#line 80
  glib_autoptr_clear_GInetSocketAddress(*_ptr);
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GInitable(GInitable *_ptr ) 
{ 


  {
#line 81
  if (_ptr) {
    {
#line 81
    g_object_unref((GInitable *)_ptr);
    }
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GInitable(GInitable **_ptr ) 
{ 


  {
  {
#line 81
  glib_autoptr_clear_GInitable(*_ptr);
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GInputStream(GInputStream *_ptr ) 
{ 


  {
#line 82
  if (_ptr) {
    {
#line 82
    g_object_unref((GInputStream *)_ptr);
    }
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GInputStream(GInputStream **_ptr ) 
{ 


  {
  {
#line 82
  glib_autoptr_clear_GInputStream(*_ptr);
  }
  return;
}
}
#line 83 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GIOModule(GIOModule *_ptr ) 
{ 


  {
#line 83
  if (_ptr) {
    {
#line 83
    g_object_unref((GIOModule *)_ptr);
    }
  }
  return;
}
}
#line 83 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GIOModule(GIOModule **_ptr ) 
{ 


  {
  {
#line 83
  glib_autoptr_clear_GIOModule(*_ptr);
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GIOStream(GIOStream *_ptr ) 
{ 


  {
#line 84
  if (_ptr) {
    {
#line 84
    g_object_unref((GIOStream *)_ptr);
    }
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GIOStream(GIOStream **_ptr ) 
{ 


  {
  {
#line 84
  glib_autoptr_clear_GIOStream(*_ptr);
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GLoadableIcon(GLoadableIcon *_ptr ) 
{ 


  {
#line 85
  if (_ptr) {
    {
#line 85
    g_object_unref((GLoadableIcon *)_ptr);
    }
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GLoadableIcon(GLoadableIcon **_ptr ) 
{ 


  {
  {
#line 85
  glib_autoptr_clear_GLoadableIcon(*_ptr);
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GMemoryInputStream(GMemoryInputStream *_ptr ) 
{ 


  {
#line 86
  if (_ptr) {
    {
#line 86
    g_object_unref((GMemoryInputStream *)_ptr);
    }
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMemoryInputStream(GMemoryInputStream **_ptr ) 
{ 


  {
  {
#line 86
  glib_autoptr_clear_GMemoryInputStream(*_ptr);
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GMemoryOutputStream(GMemoryOutputStream *_ptr ) 
{ 


  {
#line 87
  if (_ptr) {
    {
#line 87
    g_object_unref((GMemoryOutputStream *)_ptr);
    }
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMemoryOutputStream(GMemoryOutputStream **_ptr ) 
{ 


  {
  {
#line 87
  glib_autoptr_clear_GMemoryOutputStream(*_ptr);
  }
  return;
}
}
#line 88 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GMenu(GMenu *_ptr ) 
{ 


  {
#line 88
  if (_ptr) {
    {
#line 88
    g_object_unref((GMenu *)_ptr);
    }
  }
  return;
}
}
#line 88 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMenu(GMenu **_ptr ) 
{ 


  {
  {
#line 88
  glib_autoptr_clear_GMenu(*_ptr);
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GMenuItem(GMenuItem *_ptr ) 
{ 


  {
#line 89
  if (_ptr) {
    {
#line 89
    g_object_unref((GMenuItem *)_ptr);
    }
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMenuItem(GMenuItem **_ptr ) 
{ 


  {
  {
#line 89
  glib_autoptr_clear_GMenuItem(*_ptr);
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GMenuModel(GMenuModel *_ptr ) 
{ 


  {
#line 90
  if (_ptr) {
    {
#line 90
    g_object_unref((GMenuModel *)_ptr);
    }
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMenuModel(GMenuModel **_ptr ) 
{ 


  {
  {
#line 90
  glib_autoptr_clear_GMenuModel(*_ptr);
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GMenuAttributeIter(GMenuAttributeIter *_ptr ) 
{ 


  {
#line 91
  if (_ptr) {
    {
#line 91
    g_object_unref((GMenuAttributeIter *)_ptr);
    }
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMenuAttributeIter(GMenuAttributeIter **_ptr ) 
{ 


  {
  {
#line 91
  glib_autoptr_clear_GMenuAttributeIter(*_ptr);
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GMenuLinkIter(GMenuLinkIter *_ptr ) 
{ 


  {
#line 92
  if (_ptr) {
    {
#line 92
    g_object_unref((GMenuLinkIter *)_ptr);
    }
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMenuLinkIter(GMenuLinkIter **_ptr ) 
{ 


  {
  {
#line 92
  glib_autoptr_clear_GMenuLinkIter(*_ptr);
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GMount(GMount *_ptr ) 
{ 


  {
#line 93
  if (_ptr) {
    {
#line 93
    g_object_unref((GMount *)_ptr);
    }
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMount(GMount **_ptr ) 
{ 


  {
  {
#line 93
  glib_autoptr_clear_GMount(*_ptr);
  }
  return;
}
}
#line 94 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GMountOperation(GMountOperation *_ptr ) 
{ 


  {
#line 94
  if (_ptr) {
    {
#line 94
    g_object_unref((GMountOperation *)_ptr);
    }
  }
  return;
}
}
#line 94 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMountOperation(GMountOperation **_ptr ) 
{ 


  {
  {
#line 94
  glib_autoptr_clear_GMountOperation(*_ptr);
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GNativeVolumeMonitor(GNativeVolumeMonitor *_ptr ) 
{ 


  {
#line 95
  if (_ptr) {
    {
#line 95
    g_object_unref((GNativeVolumeMonitor *)_ptr);
    }
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GNativeVolumeMonitor(GNativeVolumeMonitor **_ptr ) 
{ 


  {
  {
#line 95
  glib_autoptr_clear_GNativeVolumeMonitor(*_ptr);
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GNetworkAddress(GNetworkAddress *_ptr ) 
{ 


  {
#line 96
  if (_ptr) {
    {
#line 96
    g_object_unref((GNetworkAddress *)_ptr);
    }
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GNetworkAddress(GNetworkAddress **_ptr ) 
{ 


  {
  {
#line 96
  glib_autoptr_clear_GNetworkAddress(*_ptr);
  }
  return;
}
}
#line 97 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GNetworkMonitor(GNetworkMonitor *_ptr ) 
{ 


  {
#line 97
  if (_ptr) {
    {
#line 97
    g_object_unref((GNetworkMonitor *)_ptr);
    }
  }
  return;
}
}
#line 97 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GNetworkMonitor(GNetworkMonitor **_ptr ) 
{ 


  {
  {
#line 97
  glib_autoptr_clear_GNetworkMonitor(*_ptr);
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GNetworkService(GNetworkService *_ptr ) 
{ 


  {
#line 98
  if (_ptr) {
    {
#line 98
    g_object_unref((GNetworkService *)_ptr);
    }
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GNetworkService(GNetworkService **_ptr ) 
{ 


  {
  {
#line 98
  glib_autoptr_clear_GNetworkService(*_ptr);
  }
  return;
}
}
#line 99 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GNotification(GNotification *_ptr ) 
{ 


  {
#line 99
  if (_ptr) {
    {
#line 99
    g_object_unref((GNotification *)_ptr);
    }
  }
  return;
}
}
#line 99 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GNotification(GNotification **_ptr ) 
{ 


  {
  {
#line 99
  glib_autoptr_clear_GNotification(*_ptr);
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GOutputStream(GOutputStream *_ptr ) 
{ 


  {
#line 100
  if (_ptr) {
    {
#line 100
    g_object_unref((GOutputStream *)_ptr);
    }
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GOutputStream(GOutputStream **_ptr ) 
{ 


  {
  {
#line 100
  glib_autoptr_clear_GOutputStream(*_ptr);
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GPermission(GPermission *_ptr ) 
{ 


  {
#line 101
  if (_ptr) {
    {
#line 101
    g_object_unref((GPermission *)_ptr);
    }
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GPermission(GPermission **_ptr ) 
{ 


  {
  {
#line 101
  glib_autoptr_clear_GPermission(*_ptr);
  }
  return;
}
}
#line 102 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GPollableInputStream(GPollableInputStream *_ptr ) 
{ 


  {
#line 102
  if (_ptr) {
    {
#line 102
    g_object_unref((GPollableInputStream *)_ptr);
    }
  }
  return;
}
}
#line 102 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GPollableInputStream(GPollableInputStream **_ptr ) 
{ 


  {
  {
#line 102
  glib_autoptr_clear_GPollableInputStream(*_ptr);
  }
  return;
}
}
#line 103 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GPollableOutputStream(GPollableOutputStream *_ptr ) 
{ 


  {
#line 103
  if (_ptr) {
    {
#line 103
    g_object_unref((GPollableOutputStream *)_ptr);
    }
  }
  return;
}
}
#line 103 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GPollableOutputStream(GPollableOutputStream **_ptr ) 
{ 


  {
  {
#line 103
  glib_autoptr_clear_GPollableOutputStream(*_ptr);
  }
  return;
}
}
#line 104 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GPropertyAction(GPropertyAction *_ptr ) 
{ 


  {
#line 104
  if (_ptr) {
    {
#line 104
    g_object_unref((GPropertyAction *)_ptr);
    }
  }
  return;
}
}
#line 104 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GPropertyAction(GPropertyAction **_ptr ) 
{ 


  {
  {
#line 104
  glib_autoptr_clear_GPropertyAction(*_ptr);
  }
  return;
}
}
#line 105 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GProxyAddressEnumerator(GProxyAddressEnumerator *_ptr ) 
{ 


  {
#line 105
  if (_ptr) {
    {
#line 105
    g_object_unref((GProxyAddressEnumerator *)_ptr);
    }
  }
  return;
}
}
#line 105 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GProxyAddressEnumerator(GProxyAddressEnumerator **_ptr ) 
{ 


  {
  {
#line 105
  glib_autoptr_clear_GProxyAddressEnumerator(*_ptr);
  }
  return;
}
}
#line 106 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GProxyAddress(GProxyAddress *_ptr ) 
{ 


  {
#line 106
  if (_ptr) {
    {
#line 106
    g_object_unref((GProxyAddress *)_ptr);
    }
  }
  return;
}
}
#line 106 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GProxyAddress(GProxyAddress **_ptr ) 
{ 


  {
  {
#line 106
  glib_autoptr_clear_GProxyAddress(*_ptr);
  }
  return;
}
}
#line 107 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GProxy(GProxy *_ptr ) 
{ 


  {
#line 107
  if (_ptr) {
    {
#line 107
    g_object_unref((GProxy *)_ptr);
    }
  }
  return;
}
}
#line 107 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GProxy(GProxy **_ptr ) 
{ 


  {
  {
#line 107
  glib_autoptr_clear_GProxy(*_ptr);
  }
  return;
}
}
#line 108 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GProxyResolver(GProxyResolver *_ptr ) 
{ 


  {
#line 108
  if (_ptr) {
    {
#line 108
    g_object_unref((GProxyResolver *)_ptr);
    }
  }
  return;
}
}
#line 108 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GProxyResolver(GProxyResolver **_ptr ) 
{ 


  {
  {
#line 108
  glib_autoptr_clear_GProxyResolver(*_ptr);
  }
  return;
}
}
#line 109 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GRemoteActionGroup(GRemoteActionGroup *_ptr ) 
{ 


  {
#line 109
  if (_ptr) {
    {
#line 109
    g_object_unref((GRemoteActionGroup *)_ptr);
    }
  }
  return;
}
}
#line 109 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRemoteActionGroup(GRemoteActionGroup **_ptr ) 
{ 


  {
  {
#line 109
  glib_autoptr_clear_GRemoteActionGroup(*_ptr);
  }
  return;
}
}
#line 110 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GResolver(GResolver *_ptr ) 
{ 


  {
#line 110
  if (_ptr) {
    {
#line 110
    g_object_unref((GResolver *)_ptr);
    }
  }
  return;
}
}
#line 110 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GResolver(GResolver **_ptr ) 
{ 


  {
  {
#line 110
  glib_autoptr_clear_GResolver(*_ptr);
  }
  return;
}
}
#line 111 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GResource(GResource *_ptr ) 
{ 


  {
#line 111
  if (_ptr) {
    {
#line 111
    g_resource_unref((GResource *)_ptr);
    }
  }
  return;
}
}
#line 111 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GResource(GResource **_ptr ) 
{ 


  {
  {
#line 111
  glib_autoptr_clear_GResource(*_ptr);
  }
  return;
}
}
#line 111 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GResource(GList **_l ) 
{ 


  {
  {
#line 111
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_resource_unref)));
  }
  return;
}
}
#line 111 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GResource(GSList **_l ) 
{ 


  {
  {
#line 111
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_resource_unref)));
  }
  return;
}
}
#line 111 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GResource(GQueue **_q ) 
{ 


  {
#line 111
  if (*_q) {
    {
#line 111
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_resource_unref)));
    }
  }
  return;
}
}
#line 112 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSeekable(GSeekable *_ptr ) 
{ 


  {
#line 112
  if (_ptr) {
    {
#line 112
    g_object_unref((GSeekable *)_ptr);
    }
  }
  return;
}
}
#line 112 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSeekable(GSeekable **_ptr ) 
{ 


  {
  {
#line 112
  glib_autoptr_clear_GSeekable(*_ptr);
  }
  return;
}
}
#line 113 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSettingsBackend(GSettingsBackend *_ptr ) 
{ 


  {
#line 113
  if (_ptr) {
    {
#line 113
    g_object_unref((GSettingsBackend *)_ptr);
    }
  }
  return;
}
}
#line 113 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSettingsBackend(GSettingsBackend **_ptr ) 
{ 


  {
  {
#line 113
  glib_autoptr_clear_GSettingsBackend(*_ptr);
  }
  return;
}
}
#line 114 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSettingsSchema(GSettingsSchema *_ptr ) 
{ 


  {
#line 114
  if (_ptr) {
    {
#line 114
    g_settings_schema_unref((GSettingsSchema *)_ptr);
    }
  }
  return;
}
}
#line 114 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSettingsSchema(GSettingsSchema **_ptr ) 
{ 


  {
  {
#line 114
  glib_autoptr_clear_GSettingsSchema(*_ptr);
  }
  return;
}
}
#line 114 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GSettingsSchema(GList **_l ) 
{ 


  {
  {
#line 114
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_settings_schema_unref)));
  }
  return;
}
}
#line 114 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GSettingsSchema(GSList **_l ) 
{ 


  {
  {
#line 114
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_settings_schema_unref)));
  }
  return;
}
}
#line 114 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GSettingsSchema(GQueue **_q ) 
{ 


  {
#line 114
  if (*_q) {
    {
#line 114
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_settings_schema_unref)));
    }
  }
  return;
}
}
#line 115 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSettingsSchemaKey(GSettingsSchemaKey *_ptr ) 
{ 


  {
#line 115
  if (_ptr) {
    {
#line 115
    g_settings_schema_key_unref((GSettingsSchemaKey *)_ptr);
    }
  }
  return;
}
}
#line 115 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSettingsSchemaKey(GSettingsSchemaKey **_ptr ) 
{ 


  {
  {
#line 115
  glib_autoptr_clear_GSettingsSchemaKey(*_ptr);
  }
  return;
}
}
#line 115 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GSettingsSchemaKey(GList **_l ) 
{ 


  {
  {
#line 115
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_settings_schema_key_unref)));
  }
  return;
}
}
#line 115 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GSettingsSchemaKey(GSList **_l ) 
{ 


  {
  {
#line 115
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_settings_schema_key_unref)));
  }
  return;
}
}
#line 115 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GSettingsSchemaKey(GQueue **_q ) 
{ 


  {
#line 115
  if (*_q) {
    {
#line 115
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_settings_schema_key_unref)));
    }
  }
  return;
}
}
#line 116 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSettingsSchemaSource(GSettingsSchemaSource *_ptr ) 
{ 


  {
#line 116
  if (_ptr) {
    {
#line 116
    g_settings_schema_source_unref((GSettingsSchemaSource *)_ptr);
    }
  }
  return;
}
}
#line 116 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSettingsSchemaSource(GSettingsSchemaSource **_ptr ) 
{ 


  {
  {
#line 116
  glib_autoptr_clear_GSettingsSchemaSource(*_ptr);
  }
  return;
}
}
#line 116 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GSettingsSchemaSource(GList **_l ) 
{ 


  {
  {
#line 116
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_settings_schema_source_unref)));
  }
  return;
}
}
#line 116 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GSettingsSchemaSource(GSList **_l ) 
{ 


  {
  {
#line 116
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_settings_schema_source_unref)));
  }
  return;
}
}
#line 116 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GSettingsSchemaSource(GQueue **_q ) 
{ 


  {
#line 116
  if (*_q) {
    {
#line 116
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_settings_schema_source_unref)));
    }
  }
  return;
}
}
#line 117 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSettings(GSettings *_ptr ) 
{ 


  {
#line 117
  if (_ptr) {
    {
#line 117
    g_object_unref((GSettings *)_ptr);
    }
  }
  return;
}
}
#line 117 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSettings(GSettings **_ptr ) 
{ 


  {
  {
#line 117
  glib_autoptr_clear_GSettings(*_ptr);
  }
  return;
}
}
#line 118 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSimpleActionGroup(GSimpleActionGroup *_ptr ) 
{ 


  {
#line 118
  if (_ptr) {
    {
#line 118
    g_object_unref((GSimpleActionGroup *)_ptr);
    }
  }
  return;
}
}
#line 118 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSimpleActionGroup(GSimpleActionGroup **_ptr ) 
{ 


  {
  {
#line 118
  glib_autoptr_clear_GSimpleActionGroup(*_ptr);
  }
  return;
}
}
#line 119 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSimpleAction(GSimpleAction *_ptr ) 
{ 


  {
#line 119
  if (_ptr) {
    {
#line 119
    g_object_unref((GSimpleAction *)_ptr);
    }
  }
  return;
}
}
#line 119 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSimpleAction(GSimpleAction **_ptr ) 
{ 


  {
  {
#line 119
  glib_autoptr_clear_GSimpleAction(*_ptr);
  }
  return;
}
}
#line 120 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSimpleAsyncResult(GSimpleAsyncResult *_ptr ) 
{ 


  {
#line 120
  if (_ptr) {
    {
#line 120
    g_object_unref((GSimpleAsyncResult *)_ptr);
    }
  }
  return;
}
}
#line 120 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSimpleAsyncResult(GSimpleAsyncResult **_ptr ) 
{ 


  {
  {
#line 120
  glib_autoptr_clear_GSimpleAsyncResult(*_ptr);
  }
  return;
}
}
#line 121 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSimplePermission(GSimplePermission *_ptr ) 
{ 


  {
#line 121
  if (_ptr) {
    {
#line 121
    g_object_unref((GSimplePermission *)_ptr);
    }
  }
  return;
}
}
#line 121 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSimplePermission(GSimplePermission **_ptr ) 
{ 


  {
  {
#line 121
  glib_autoptr_clear_GSimplePermission(*_ptr);
  }
  return;
}
}
#line 122 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSimpleProxyResolver(GSimpleProxyResolver *_ptr ) 
{ 


  {
#line 122
  if (_ptr) {
    {
#line 122
    g_object_unref((GSimpleProxyResolver *)_ptr);
    }
  }
  return;
}
}
#line 122 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSimpleProxyResolver(GSimpleProxyResolver **_ptr ) 
{ 


  {
  {
#line 122
  glib_autoptr_clear_GSimpleProxyResolver(*_ptr);
  }
  return;
}
}
#line 123 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSocketAddressEnumerator(GSocketAddressEnumerator *_ptr ) 
{ 


  {
#line 123
  if (_ptr) {
    {
#line 123
    g_object_unref((GSocketAddressEnumerator *)_ptr);
    }
  }
  return;
}
}
#line 123 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSocketAddressEnumerator(GSocketAddressEnumerator **_ptr ) 
{ 


  {
  {
#line 123
  glib_autoptr_clear_GSocketAddressEnumerator(*_ptr);
  }
  return;
}
}
#line 124 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSocketAddress(GSocketAddress *_ptr ) 
{ 


  {
#line 124
  if (_ptr) {
    {
#line 124
    g_object_unref((GSocketAddress *)_ptr);
    }
  }
  return;
}
}
#line 124 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSocketAddress(GSocketAddress **_ptr ) 
{ 


  {
  {
#line 124
  glib_autoptr_clear_GSocketAddress(*_ptr);
  }
  return;
}
}
#line 125 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSocketClient(GSocketClient *_ptr ) 
{ 


  {
#line 125
  if (_ptr) {
    {
#line 125
    g_object_unref((GSocketClient *)_ptr);
    }
  }
  return;
}
}
#line 125 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSocketClient(GSocketClient **_ptr ) 
{ 


  {
  {
#line 125
  glib_autoptr_clear_GSocketClient(*_ptr);
  }
  return;
}
}
#line 126 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSocketConnectable(GSocketConnectable *_ptr ) 
{ 


  {
#line 126
  if (_ptr) {
    {
#line 126
    g_object_unref((GSocketConnectable *)_ptr);
    }
  }
  return;
}
}
#line 126 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSocketConnectable(GSocketConnectable **_ptr ) 
{ 


  {
  {
#line 126
  glib_autoptr_clear_GSocketConnectable(*_ptr);
  }
  return;
}
}
#line 127 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSocketConnection(GSocketConnection *_ptr ) 
{ 


  {
#line 127
  if (_ptr) {
    {
#line 127
    g_object_unref((GSocketConnection *)_ptr);
    }
  }
  return;
}
}
#line 127 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSocketConnection(GSocketConnection **_ptr ) 
{ 


  {
  {
#line 127
  glib_autoptr_clear_GSocketConnection(*_ptr);
  }
  return;
}
}
#line 128 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSocketControlMessage(GSocketControlMessage *_ptr ) 
{ 


  {
#line 128
  if (_ptr) {
    {
#line 128
    g_object_unref((GSocketControlMessage *)_ptr);
    }
  }
  return;
}
}
#line 128 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSocketControlMessage(GSocketControlMessage **_ptr ) 
{ 


  {
  {
#line 128
  glib_autoptr_clear_GSocketControlMessage(*_ptr);
  }
  return;
}
}
#line 129 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSocket(GSocket *_ptr ) 
{ 


  {
#line 129
  if (_ptr) {
    {
#line 129
    g_object_unref((GSocket *)_ptr);
    }
  }
  return;
}
}
#line 129 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSocket(GSocket **_ptr ) 
{ 


  {
  {
#line 129
  glib_autoptr_clear_GSocket(*_ptr);
  }
  return;
}
}
#line 130 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSocketListener(GSocketListener *_ptr ) 
{ 


  {
#line 130
  if (_ptr) {
    {
#line 130
    g_object_unref((GSocketListener *)_ptr);
    }
  }
  return;
}
}
#line 130 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSocketListener(GSocketListener **_ptr ) 
{ 


  {
  {
#line 130
  glib_autoptr_clear_GSocketListener(*_ptr);
  }
  return;
}
}
#line 131 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSocketService(GSocketService *_ptr ) 
{ 


  {
#line 131
  if (_ptr) {
    {
#line 131
    g_object_unref((GSocketService *)_ptr);
    }
  }
  return;
}
}
#line 131 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSocketService(GSocketService **_ptr ) 
{ 


  {
  {
#line 131
  glib_autoptr_clear_GSocketService(*_ptr);
  }
  return;
}
}
#line 132 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSubprocess(GSubprocess *_ptr ) 
{ 


  {
#line 132
  if (_ptr) {
    {
#line 132
    g_object_unref((GSubprocess *)_ptr);
    }
  }
  return;
}
}
#line 132 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSubprocess(GSubprocess **_ptr ) 
{ 


  {
  {
#line 132
  glib_autoptr_clear_GSubprocess(*_ptr);
  }
  return;
}
}
#line 133 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSubprocessLauncher(GSubprocessLauncher *_ptr ) 
{ 


  {
#line 133
  if (_ptr) {
    {
#line 133
    g_object_unref((GSubprocessLauncher *)_ptr);
    }
  }
  return;
}
}
#line 133 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSubprocessLauncher(GSubprocessLauncher **_ptr ) 
{ 


  {
  {
#line 133
  glib_autoptr_clear_GSubprocessLauncher(*_ptr);
  }
  return;
}
}
#line 134 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTask(GTask *_ptr ) 
{ 


  {
#line 134
  if (_ptr) {
    {
#line 134
    g_object_unref((GTask *)_ptr);
    }
  }
  return;
}
}
#line 134 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTask(GTask **_ptr ) 
{ 


  {
  {
#line 134
  glib_autoptr_clear_GTask(*_ptr);
  }
  return;
}
}
#line 135 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTcpConnection(GTcpConnection *_ptr ) 
{ 


  {
#line 135
  if (_ptr) {
    {
#line 135
    g_object_unref((GTcpConnection *)_ptr);
    }
  }
  return;
}
}
#line 135 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTcpConnection(GTcpConnection **_ptr ) 
{ 


  {
  {
#line 135
  glib_autoptr_clear_GTcpConnection(*_ptr);
  }
  return;
}
}
#line 136 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTcpWrapperConnection(GTcpWrapperConnection *_ptr ) 
{ 


  {
#line 136
  if (_ptr) {
    {
#line 136
    g_object_unref((GTcpWrapperConnection *)_ptr);
    }
  }
  return;
}
}
#line 136 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTcpWrapperConnection(GTcpWrapperConnection **_ptr ) 
{ 


  {
  {
#line 136
  glib_autoptr_clear_GTcpWrapperConnection(*_ptr);
  }
  return;
}
}
#line 137 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTestDBus(GTestDBus *_ptr ) 
{ 


  {
#line 137
  if (_ptr) {
    {
#line 137
    g_object_unref((GTestDBus *)_ptr);
    }
  }
  return;
}
}
#line 137 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTestDBus(GTestDBus **_ptr ) 
{ 


  {
  {
#line 137
  glib_autoptr_clear_GTestDBus(*_ptr);
  }
  return;
}
}
#line 138 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GThemedIcon(GThemedIcon *_ptr ) 
{ 


  {
#line 138
  if (_ptr) {
    {
#line 138
    g_object_unref((GThemedIcon *)_ptr);
    }
  }
  return;
}
}
#line 138 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GThemedIcon(GThemedIcon **_ptr ) 
{ 


  {
  {
#line 138
  glib_autoptr_clear_GThemedIcon(*_ptr);
  }
  return;
}
}
#line 139 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GThreadedSocketService(GThreadedSocketService *_ptr ) 
{ 


  {
#line 139
  if (_ptr) {
    {
#line 139
    g_object_unref((GThreadedSocketService *)_ptr);
    }
  }
  return;
}
}
#line 139 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GThreadedSocketService(GThreadedSocketService **_ptr ) 
{ 


  {
  {
#line 139
  glib_autoptr_clear_GThreadedSocketService(*_ptr);
  }
  return;
}
}
#line 140 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTlsBackend(GTlsBackend *_ptr ) 
{ 


  {
#line 140
  if (_ptr) {
    {
#line 140
    g_object_unref((GTlsBackend *)_ptr);
    }
  }
  return;
}
}
#line 140 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTlsBackend(GTlsBackend **_ptr ) 
{ 


  {
  {
#line 140
  glib_autoptr_clear_GTlsBackend(*_ptr);
  }
  return;
}
}
#line 141 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTlsCertificate(GTlsCertificate *_ptr ) 
{ 


  {
#line 141
  if (_ptr) {
    {
#line 141
    g_object_unref((GTlsCertificate *)_ptr);
    }
  }
  return;
}
}
#line 141 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTlsCertificate(GTlsCertificate **_ptr ) 
{ 


  {
  {
#line 141
  glib_autoptr_clear_GTlsCertificate(*_ptr);
  }
  return;
}
}
#line 142 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTlsClientConnection(GTlsClientConnection *_ptr ) 
{ 


  {
#line 142
  if (_ptr) {
    {
#line 142
    g_object_unref((GTlsClientConnection *)_ptr);
    }
  }
  return;
}
}
#line 142 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTlsClientConnection(GTlsClientConnection **_ptr ) 
{ 


  {
  {
#line 142
  glib_autoptr_clear_GTlsClientConnection(*_ptr);
  }
  return;
}
}
#line 143 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTlsConnection(GTlsConnection *_ptr ) 
{ 


  {
#line 143
  if (_ptr) {
    {
#line 143
    g_object_unref((GTlsConnection *)_ptr);
    }
  }
  return;
}
}
#line 143 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTlsConnection(GTlsConnection **_ptr ) 
{ 


  {
  {
#line 143
  glib_autoptr_clear_GTlsConnection(*_ptr);
  }
  return;
}
}
#line 144 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTlsDatabase(GTlsDatabase *_ptr ) 
{ 


  {
#line 144
  if (_ptr) {
    {
#line 144
    g_object_unref((GTlsDatabase *)_ptr);
    }
  }
  return;
}
}
#line 144 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTlsDatabase(GTlsDatabase **_ptr ) 
{ 


  {
  {
#line 144
  glib_autoptr_clear_GTlsDatabase(*_ptr);
  }
  return;
}
}
#line 145 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTlsFileDatabase(GTlsFileDatabase *_ptr ) 
{ 


  {
#line 145
  if (_ptr) {
    {
#line 145
    g_object_unref((GTlsFileDatabase *)_ptr);
    }
  }
  return;
}
}
#line 145 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTlsFileDatabase(GTlsFileDatabase **_ptr ) 
{ 


  {
  {
#line 145
  glib_autoptr_clear_GTlsFileDatabase(*_ptr);
  }
  return;
}
}
#line 146 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTlsInteraction(GTlsInteraction *_ptr ) 
{ 


  {
#line 146
  if (_ptr) {
    {
#line 146
    g_object_unref((GTlsInteraction *)_ptr);
    }
  }
  return;
}
}
#line 146 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTlsInteraction(GTlsInteraction **_ptr ) 
{ 


  {
  {
#line 146
  glib_autoptr_clear_GTlsInteraction(*_ptr);
  }
  return;
}
}
#line 147 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTlsPassword(GTlsPassword *_ptr ) 
{ 


  {
#line 147
  if (_ptr) {
    {
#line 147
    g_object_unref((GTlsPassword *)_ptr);
    }
  }
  return;
}
}
#line 147 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTlsPassword(GTlsPassword **_ptr ) 
{ 


  {
  {
#line 147
  glib_autoptr_clear_GTlsPassword(*_ptr);
  }
  return;
}
}
#line 148 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTlsServerConnection(GTlsServerConnection *_ptr ) 
{ 


  {
#line 148
  if (_ptr) {
    {
#line 148
    g_object_unref((GTlsServerConnection *)_ptr);
    }
  }
  return;
}
}
#line 148 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTlsServerConnection(GTlsServerConnection **_ptr ) 
{ 


  {
  {
#line 148
  glib_autoptr_clear_GTlsServerConnection(*_ptr);
  }
  return;
}
}
#line 149 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GVfs(GVfs *_ptr ) 
{ 


  {
#line 149
  if (_ptr) {
    {
#line 149
    g_object_unref((GVfs *)_ptr);
    }
  }
  return;
}
}
#line 149 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVfs(GVfs **_ptr ) 
{ 


  {
  {
#line 149
  glib_autoptr_clear_GVfs(*_ptr);
  }
  return;
}
}
#line 150 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GVolume(GVolume *_ptr ) 
{ 


  {
#line 150
  if (_ptr) {
    {
#line 150
    g_object_unref((GVolume *)_ptr);
    }
  }
  return;
}
}
#line 150 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVolume(GVolume **_ptr ) 
{ 


  {
  {
#line 150
  glib_autoptr_clear_GVolume(*_ptr);
  }
  return;
}
}
#line 151 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GVolumeMonitor(GVolumeMonitor *_ptr ) 
{ 


  {
#line 151
  if (_ptr) {
    {
#line 151
    g_object_unref((GVolumeMonitor *)_ptr);
    }
  }
  return;
}
}
#line 151 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVolumeMonitor(GVolumeMonitor **_ptr ) 
{ 


  {
  {
#line 151
  glib_autoptr_clear_GVolumeMonitor(*_ptr);
  }
  return;
}
}
#line 152 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GZlibCompressor(GZlibCompressor *_ptr ) 
{ 


  {
#line 152
  if (_ptr) {
    {
#line 152
    g_object_unref((GZlibCompressor *)_ptr);
    }
  }
  return;
}
}
#line 152 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GZlibCompressor(GZlibCompressor **_ptr ) 
{ 


  {
  {
#line 152
  glib_autoptr_clear_GZlibCompressor(*_ptr);
  }
  return;
}
}
#line 153 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GZlibDecompressor(GZlibDecompressor *_ptr ) 
{ 


  {
#line 153
  if (_ptr) {
    {
#line 153
    g_object_unref((GZlibDecompressor *)_ptr);
    }
  }
  return;
}
}
#line 153 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GZlibDecompressor(GZlibDecompressor **_ptr ) 
{ 


  {
  {
#line 153
  glib_autoptr_clear_GZlibDecompressor(*_ptr);
  }
  return;
}
}
#line 86 "/usr/include/cairo/cairo.h"
int cairo_version(void) ;
#line 89
char const   *cairo_version_string(void) ;
#line 491
cairo_t *cairo_create(cairo_surface_t *target ) ;
#line 494
cairo_t *cairo_reference(cairo_t *cr ) ;
#line 497
void cairo_destroy(cairo_t *cr ) ;
#line 500
unsigned int cairo_get_reference_count(cairo_t *cr ) ;
#line 503
void *cairo_get_user_data(cairo_t *cr , cairo_user_data_key_t *key ) ;
#line 507
cairo_status_t cairo_set_user_data(cairo_t *cr , cairo_user_data_key_t *key , void *user_data ,
                                   cairo_destroy_func_t destroy ) ;
#line 513
void cairo_save(cairo_t *cr ) ;
#line 516
void cairo_restore(cairo_t *cr ) ;
#line 519
void cairo_push_group(cairo_t *cr ) ;
#line 522
void cairo_push_group_with_content(cairo_t *cr , cairo_content_t content ) ;
#line 525
cairo_pattern_t *cairo_pop_group(cairo_t *cr ) ;
#line 528
void cairo_pop_group_to_source(cairo_t *cr ) ;
#line 650
void cairo_set_operator(cairo_t *cr , cairo_operator_t op ) ;
#line 653
void cairo_set_source(cairo_t *cr , cairo_pattern_t *source ) ;
#line 656
void cairo_set_source_rgb(cairo_t *cr , double red , double green , double blue ) ;
#line 659
void cairo_set_source_rgba(cairo_t *cr , double red , double green , double blue ,
                           double alpha ) ;
#line 664
void cairo_set_source_surface(cairo_t *cr , cairo_surface_t *surface , double x ,
                              double y ) ;
#line 670
void cairo_set_tolerance(cairo_t *cr , double tolerance ) ;
#line 724
void cairo_set_antialias(cairo_t *cr , cairo_antialias_t antialias ) ;
#line 759
void cairo_set_fill_rule(cairo_t *cr , cairo_fill_rule_t fill_rule ) ;
#line 762
void cairo_set_line_width(cairo_t *cr , double width ) ;
#line 783
void cairo_set_line_cap(cairo_t *cr , cairo_line_cap_t line_cap ) ;
#line 807
void cairo_set_line_join(cairo_t *cr , cairo_line_join_t line_join ) ;
#line 810
void cairo_set_dash(cairo_t *cr , double const   *dashes , int num_dashes , double offset ) ;
#line 816
void cairo_set_miter_limit(cairo_t *cr , double limit ) ;
#line 819
void cairo_translate(cairo_t *cr , double tx , double ty ) ;
#line 822
void cairo_scale(cairo_t *cr , double sx , double sy ) ;
#line 825
void cairo_rotate(cairo_t *cr , double angle ) ;
#line 828
void cairo_transform(cairo_t *cr , cairo_matrix_t *matrix ) ;
#line 832
void cairo_set_matrix(cairo_t *cr , cairo_matrix_t *matrix ) ;
#line 836
void cairo_identity_matrix(cairo_t *cr ) ;
#line 839
void cairo_user_to_device(cairo_t *cr , double *x , double *y ) ;
#line 842
void cairo_user_to_device_distance(cairo_t *cr , double *dx , double *dy ) ;
#line 845
void cairo_device_to_user(cairo_t *cr , double *x , double *y ) ;
#line 848
void cairo_device_to_user_distance(cairo_t *cr , double *dx , double *dy ) ;
#line 852
void cairo_new_path(cairo_t *cr ) ;
#line 855
void cairo_move_to(cairo_t *cr , double x , double y ) ;
#line 858
void cairo_new_sub_path(cairo_t *cr ) ;
#line 861
void cairo_line_to(cairo_t *cr , double x , double y ) ;
#line 864
void cairo_curve_to(cairo_t *cr , double x1 , double y1 , double x2 , double y2 ,
                    double x3 , double y3 ) ;
#line 870
void cairo_arc(cairo_t *cr , double xc , double yc , double radius , double angle1 ,
               double angle2 ) ;
#line 876
void cairo_arc_negative(cairo_t *cr , double xc , double yc , double radius , double angle1 ,
                        double angle2 ) ;
#line 890
void cairo_rel_move_to(cairo_t *cr , double dx , double dy ) ;
#line 893
void cairo_rel_line_to(cairo_t *cr , double dx , double dy ) ;
#line 896
void cairo_rel_curve_to(cairo_t *cr , double dx1 , double dy1 , double dx2 , double dy2 ,
                        double dx3 , double dy3 ) ;
#line 902
void cairo_rectangle(cairo_t *cr , double x , double y , double width , double height ) ;
#line 912
void cairo_close_path(cairo_t *cr ) ;
#line 915
void cairo_path_extents(cairo_t *cr , double *x1 , double *y1 , double *x2 , double *y2 ) ;
#line 921
void cairo_paint(cairo_t *cr ) ;
#line 924
void cairo_paint_with_alpha(cairo_t *cr , double alpha ) ;
#line 928
void cairo_mask(cairo_t *cr , cairo_pattern_t *pattern ) ;
#line 932
void cairo_mask_surface(cairo_t *cr , cairo_surface_t *surface , double surface_x ,
                        double surface_y ) ;
#line 938
void cairo_stroke(cairo_t *cr ) ;
#line 941
void cairo_stroke_preserve(cairo_t *cr ) ;
#line 944
void cairo_fill(cairo_t *cr ) ;
#line 947
void cairo_fill_preserve(cairo_t *cr ) ;
#line 950
void cairo_copy_page(cairo_t *cr ) ;
#line 953
void cairo_show_page(cairo_t *cr ) ;
#line 957
cairo_bool_t cairo_in_stroke(cairo_t *cr , double x , double y ) ;
#line 960
cairo_bool_t cairo_in_fill(cairo_t *cr , double x , double y ) ;
#line 963
cairo_bool_t cairo_in_clip(cairo_t *cr , double x , double y ) ;
#line 967
void cairo_stroke_extents(cairo_t *cr , double *x1 , double *y1 , double *x2 , double *y2 ) ;
#line 972
void cairo_fill_extents(cairo_t *cr , double *x1 , double *y1 , double *x2 , double *y2 ) ;
#line 978
void cairo_reset_clip(cairo_t *cr ) ;
#line 981
void cairo_clip(cairo_t *cr ) ;
#line 984
void cairo_clip_preserve(cairo_t *cr ) ;
#line 987
void cairo_clip_extents(cairo_t *cr , double *x1 , double *y1 , double *x2 , double *y2 ) ;
#line 1024
cairo_rectangle_list_t *cairo_copy_clip_rectangle_list(cairo_t *cr ) ;
#line 1027
void cairo_rectangle_list_destroy(cairo_rectangle_list_t *rectangle_list ) ;
#line 1035
void cairo_tag_begin(cairo_t *cr , char const   *tag_name , char const   *attributes ) ;
#line 1038
void cairo_tag_end(cairo_t *cr , char const   *tag_name ) ;
#line 1115
cairo_glyph_t *cairo_glyph_allocate(int num_glyphs ) ;
#line 1118
void cairo_glyph_free(cairo_glyph_t *glyphs ) ;
#line 1146
cairo_text_cluster_t *cairo_text_cluster_allocate(int num_clusters ) ;
#line 1149
void cairo_text_cluster_free(cairo_text_cluster_t *clusters ) ;
#line 1388
cairo_font_options_t *cairo_font_options_create(void) ;
#line 1391
cairo_font_options_t *cairo_font_options_copy(cairo_font_options_t *original ) ;
#line 1394
void cairo_font_options_destroy(cairo_font_options_t *options ) ;
#line 1397
cairo_status_t cairo_font_options_status(cairo_font_options_t *options ) ;
#line 1400
void cairo_font_options_merge(cairo_font_options_t *options , cairo_font_options_t *other ) ;
#line 1403
cairo_bool_t cairo_font_options_equal(cairo_font_options_t *options , cairo_font_options_t *other ) ;
#line 1407
unsigned long cairo_font_options_hash(cairo_font_options_t *options ) ;
#line 1410
void cairo_font_options_set_antialias(cairo_font_options_t *options , cairo_antialias_t antialias ) ;
#line 1413
cairo_antialias_t cairo_font_options_get_antialias(cairo_font_options_t *options ) ;
#line 1416
void cairo_font_options_set_subpixel_order(cairo_font_options_t *options , cairo_subpixel_order_t subpixel_order ) ;
#line 1419
cairo_subpixel_order_t cairo_font_options_get_subpixel_order(cairo_font_options_t *options ) ;
#line 1422
void cairo_font_options_set_hint_style(cairo_font_options_t *options , cairo_hint_style_t hint_style ) ;
#line 1425
cairo_hint_style_t cairo_font_options_get_hint_style(cairo_font_options_t *options ) ;
#line 1428
void cairo_font_options_set_hint_metrics(cairo_font_options_t *options , cairo_hint_metrics_t hint_metrics ) ;
#line 1431
cairo_hint_metrics_t cairo_font_options_get_hint_metrics(cairo_font_options_t *options ) ;
#line 1434
char const   *cairo_font_options_get_variations(cairo_font_options_t *options ) ;
#line 1437
void cairo_font_options_set_variations(cairo_font_options_t *options , char const   *variations ) ;
#line 1444
void cairo_select_font_face(cairo_t *cr , char const   *family , cairo_font_slant_t slant ,
                            cairo_font_weight_t weight ) ;
#line 1450
void cairo_set_font_size(cairo_t *cr , double size ) ;
#line 1453
void cairo_set_font_matrix(cairo_t *cr , cairo_matrix_t *matrix ) ;
#line 1457
void cairo_get_font_matrix(cairo_t *cr , cairo_matrix_t *matrix ) ;
#line 1461
void cairo_set_font_options(cairo_t *cr , cairo_font_options_t *options ) ;
#line 1465
void cairo_get_font_options(cairo_t *cr , cairo_font_options_t *options ) ;
#line 1469
void cairo_set_font_face(cairo_t *cr , cairo_font_face_t *font_face ) ;
#line 1472
cairo_font_face_t *cairo_get_font_face(cairo_t *cr ) ;
#line 1475
void cairo_set_scaled_font(cairo_t *cr , cairo_scaled_font_t *scaled_font ) ;
#line 1479
cairo_scaled_font_t *cairo_get_scaled_font(cairo_t *cr ) ;
#line 1482
void cairo_show_text(cairo_t *cr , char const   *utf8 ) ;
#line 1485
void cairo_show_glyphs(cairo_t *cr , cairo_glyph_t *glyphs , int num_glyphs ) ;
#line 1488
void cairo_show_text_glyphs(cairo_t *cr , char const   *utf8 , int utf8_len , cairo_glyph_t *glyphs ,
                            int num_glyphs , cairo_text_cluster_t *clusters , int num_clusters ,
                            cairo_text_cluster_flags_t cluster_flags ) ;
#line 1498
void cairo_text_path(cairo_t *cr , char const   *utf8 ) ;
#line 1501
void cairo_glyph_path(cairo_t *cr , cairo_glyph_t *glyphs , int num_glyphs ) ;
#line 1504
void cairo_text_extents(cairo_t *cr , char const   *utf8 , cairo_text_extents_t *extents ) ;
#line 1509
void cairo_glyph_extents(cairo_t *cr , cairo_glyph_t *glyphs , int num_glyphs , cairo_text_extents_t *extents ) ;
#line 1515
void cairo_font_extents(cairo_t *cr , cairo_font_extents_t *extents ) ;
#line 1521
cairo_font_face_t *cairo_font_face_reference(cairo_font_face_t *font_face ) ;
#line 1524
void cairo_font_face_destroy(cairo_font_face_t *font_face ) ;
#line 1527
unsigned int cairo_font_face_get_reference_count(cairo_font_face_t *font_face ) ;
#line 1530
cairo_status_t cairo_font_face_status(cairo_font_face_t *font_face ) ;
#line 1581
cairo_font_type_t cairo_font_face_get_type(cairo_font_face_t *font_face ) ;
#line 1584
void *cairo_font_face_get_user_data(cairo_font_face_t *font_face , cairo_user_data_key_t *key ) ;
#line 1588
cairo_status_t cairo_font_face_set_user_data(cairo_font_face_t *font_face , cairo_user_data_key_t *key ,
                                             void *user_data , cairo_destroy_func_t destroy ) ;
#line 1596
cairo_scaled_font_t *cairo_scaled_font_create(cairo_font_face_t *font_face , cairo_matrix_t *font_matrix ,
                                              cairo_matrix_t *ctm , cairo_font_options_t *options ) ;
#line 1602
cairo_scaled_font_t *cairo_scaled_font_reference(cairo_scaled_font_t *scaled_font ) ;
#line 1605
void cairo_scaled_font_destroy(cairo_scaled_font_t *scaled_font ) ;
#line 1608
unsigned int cairo_scaled_font_get_reference_count(cairo_scaled_font_t *scaled_font ) ;
#line 1611
cairo_status_t cairo_scaled_font_status(cairo_scaled_font_t *scaled_font ) ;
#line 1614
cairo_font_type_t cairo_scaled_font_get_type(cairo_scaled_font_t *scaled_font ) ;
#line 1617
void *cairo_scaled_font_get_user_data(cairo_scaled_font_t *scaled_font , cairo_user_data_key_t *key ) ;
#line 1621
cairo_status_t cairo_scaled_font_set_user_data(cairo_scaled_font_t *scaled_font ,
                                               cairo_user_data_key_t *key , void *user_data ,
                                               cairo_destroy_func_t destroy ) ;
#line 1627
void cairo_scaled_font_extents(cairo_scaled_font_t *scaled_font , cairo_font_extents_t *extents ) ;
#line 1631
void cairo_scaled_font_text_extents(cairo_scaled_font_t *scaled_font , char const   *utf8 ,
                                    cairo_text_extents_t *extents ) ;
#line 1636
void cairo_scaled_font_glyph_extents(cairo_scaled_font_t *scaled_font , cairo_glyph_t *glyphs ,
                                     int num_glyphs , cairo_text_extents_t *extents ) ;
#line 1642
cairo_status_t cairo_scaled_font_text_to_glyphs(cairo_scaled_font_t *scaled_font ,
                                                double x , double y , char const   *utf8 ,
                                                int utf8_len , cairo_glyph_t **glyphs ,
                                                int *num_glyphs , cairo_text_cluster_t **clusters ,
                                                int *num_clusters , cairo_text_cluster_flags_t *cluster_flags ) ;
#line 1654
cairo_font_face_t *cairo_scaled_font_get_font_face(cairo_scaled_font_t *scaled_font ) ;
#line 1657
void cairo_scaled_font_get_font_matrix(cairo_scaled_font_t *scaled_font , cairo_matrix_t *font_matrix ) ;
#line 1661
void cairo_scaled_font_get_ctm(cairo_scaled_font_t *scaled_font , cairo_matrix_t *ctm ) ;
#line 1665
void cairo_scaled_font_get_scale_matrix(cairo_scaled_font_t *scaled_font , cairo_matrix_t *scale_matrix ) ;
#line 1669
void cairo_scaled_font_get_font_options(cairo_scaled_font_t *scaled_font , cairo_font_options_t *options ) ;
#line 1676
cairo_font_face_t *cairo_toy_font_face_create(char const   *family , cairo_font_slant_t slant ,
                                              cairo_font_weight_t weight ) ;
#line 1681
char const   *cairo_toy_font_face_get_family(cairo_font_face_t *font_face ) ;
#line 1684
cairo_font_slant_t cairo_toy_font_face_get_slant(cairo_font_face_t *font_face ) ;
#line 1687
cairo_font_weight_t cairo_toy_font_face_get_weight(cairo_font_face_t *font_face ) ;
#line 1693
cairo_font_face_t *cairo_user_font_face_create(void) ;
#line 1900
void cairo_user_font_face_set_init_func(cairo_font_face_t *font_face , cairo_user_scaled_font_init_func_t init_func ) ;
#line 1904
void cairo_user_font_face_set_render_glyph_func(cairo_font_face_t *font_face , cairo_user_scaled_font_render_glyph_func_t render_glyph_func ) ;
#line 1908
void cairo_user_font_face_set_text_to_glyphs_func(cairo_font_face_t *font_face , cairo_user_scaled_font_text_to_glyphs_func_t text_to_glyphs_func ) ;
#line 1912
void cairo_user_font_face_set_unicode_to_glyph_func(cairo_font_face_t *font_face ,
                                                    cairo_user_scaled_font_unicode_to_glyph_func_t unicode_to_glyph_func ) ;
#line 1918
cairo_user_scaled_font_init_func_t cairo_user_font_face_get_init_func(cairo_font_face_t *font_face ) ;
#line 1921
cairo_user_scaled_font_render_glyph_func_t cairo_user_font_face_get_render_glyph_func(cairo_font_face_t *font_face ) ;
#line 1924
cairo_user_scaled_font_text_to_glyphs_func_t cairo_user_font_face_get_text_to_glyphs_func(cairo_font_face_t *font_face ) ;
#line 1927
cairo_user_scaled_font_unicode_to_glyph_func_t cairo_user_font_face_get_unicode_to_glyph_func(cairo_font_face_t *font_face ) ;
#line 1933
cairo_operator_t cairo_get_operator(cairo_t *cr ) ;
#line 1936
cairo_pattern_t *cairo_get_source(cairo_t *cr ) ;
#line 1939
double cairo_get_tolerance(cairo_t *cr ) ;
#line 1942
cairo_antialias_t cairo_get_antialias(cairo_t *cr ) ;
#line 1945
cairo_bool_t cairo_has_current_point(cairo_t *cr ) ;
#line 1948
void cairo_get_current_point(cairo_t *cr , double *x , double *y ) ;
#line 1951
cairo_fill_rule_t cairo_get_fill_rule(cairo_t *cr ) ;
#line 1954
double cairo_get_line_width(cairo_t *cr ) ;
#line 1957
cairo_line_cap_t cairo_get_line_cap(cairo_t *cr ) ;
#line 1960
cairo_line_join_t cairo_get_line_join(cairo_t *cr ) ;
#line 1963
double cairo_get_miter_limit(cairo_t *cr ) ;
#line 1966
int cairo_get_dash_count(cairo_t *cr ) ;
#line 1969
void cairo_get_dash(cairo_t *cr , double *dashes , double *offset ) ;
#line 1972
void cairo_get_matrix(cairo_t *cr , cairo_matrix_t *matrix ) ;
#line 1975
cairo_surface_t *cairo_get_target(cairo_t *cr ) ;
#line 1978
cairo_surface_t *cairo_get_group_target(cairo_t *cr ) ;
#line 2107
cairo_path_t *cairo_copy_path(cairo_t *cr ) ;
#line 2110
cairo_path_t *cairo_copy_path_flat(cairo_t *cr ) ;
#line 2113
void cairo_append_path(cairo_t *cr , cairo_path_t *path ) ;
#line 2117
void cairo_path_destroy(cairo_path_t *path ) ;
#line 2122
cairo_status_t cairo_status(cairo_t *cr ) ;
#line 2125
char const   *cairo_status_to_string(cairo_status_t status ) ;
#line 2130
cairo_device_t *cairo_device_reference(cairo_device_t *device ) ;
#line 2177
cairo_device_type_t cairo_device_get_type(cairo_device_t *device ) ;
#line 2180
cairo_status_t cairo_device_status(cairo_device_t *device ) ;
#line 2183
cairo_status_t cairo_device_acquire(cairo_device_t *device ) ;
#line 2186
void cairo_device_release(cairo_device_t *device ) ;
#line 2189
void cairo_device_flush(cairo_device_t *device ) ;
#line 2192
void cairo_device_finish(cairo_device_t *device ) ;
#line 2195
void cairo_device_destroy(cairo_device_t *device ) ;
#line 2198
unsigned int cairo_device_get_reference_count(cairo_device_t *device ) ;
#line 2201
void *cairo_device_get_user_data(cairo_device_t *device , cairo_user_data_key_t *key ) ;
#line 2205
cairo_status_t cairo_device_set_user_data(cairo_device_t *device , cairo_user_data_key_t *key ,
                                          void *user_data , cairo_destroy_func_t destroy ) ;
#line 2214
cairo_surface_t *cairo_surface_create_similar(cairo_surface_t *other , cairo_content_t content ,
                                              int width , int height ) ;
#line 2220
cairo_surface_t *cairo_surface_create_similar_image(cairo_surface_t *other , cairo_format_t format ,
                                                    int width , int height ) ;
#line 2226
cairo_surface_t *cairo_surface_map_to_image(cairo_surface_t *surface , cairo_rectangle_int_t *extents ) ;
#line 2230
void cairo_surface_unmap_image(cairo_surface_t *surface , cairo_surface_t *image ) ;
#line 2234
cairo_surface_t *cairo_surface_create_for_rectangle(cairo_surface_t *target , double x ,
                                                    double y , double width , double height ) ;
#line 2255
cairo_surface_t *cairo_surface_create_observer(cairo_surface_t *target , cairo_surface_observer_mode_t mode ) ;
#line 2263
cairo_status_t cairo_surface_observer_add_paint_callback(cairo_surface_t *abstract_surface ,
                                                         cairo_surface_observer_callback_t func ,
                                                         void *data ) ;
#line 2268
cairo_status_t cairo_surface_observer_add_mask_callback(cairo_surface_t *abstract_surface ,
                                                        cairo_surface_observer_callback_t func ,
                                                        void *data ) ;
#line 2273
cairo_status_t cairo_surface_observer_add_fill_callback(cairo_surface_t *abstract_surface ,
                                                        cairo_surface_observer_callback_t func ,
                                                        void *data ) ;
#line 2278
cairo_status_t cairo_surface_observer_add_stroke_callback(cairo_surface_t *abstract_surface ,
                                                          cairo_surface_observer_callback_t func ,
                                                          void *data ) ;
#line 2283
cairo_status_t cairo_surface_observer_add_glyphs_callback(cairo_surface_t *abstract_surface ,
                                                          cairo_surface_observer_callback_t func ,
                                                          void *data ) ;
#line 2288
cairo_status_t cairo_surface_observer_add_flush_callback(cairo_surface_t *abstract_surface ,
                                                         cairo_surface_observer_callback_t func ,
                                                         void *data ) ;
#line 2293
cairo_status_t cairo_surface_observer_add_finish_callback(cairo_surface_t *abstract_surface ,
                                                          cairo_surface_observer_callback_t func ,
                                                          void *data ) ;
#line 2298
cairo_status_t cairo_surface_observer_print(cairo_surface_t *surface , cairo_write_func_t write_func ,
                                            void *closure ) ;
#line 2302
double cairo_surface_observer_elapsed(cairo_surface_t *surface ) ;
#line 2305
cairo_status_t cairo_device_observer_print(cairo_device_t *device , cairo_write_func_t write_func ,
                                           void *closure ) ;
#line 2310
double cairo_device_observer_elapsed(cairo_device_t *device ) ;
#line 2313
double cairo_device_observer_paint_elapsed(cairo_device_t *device ) ;
#line 2316
double cairo_device_observer_mask_elapsed(cairo_device_t *device ) ;
#line 2319
double cairo_device_observer_fill_elapsed(cairo_device_t *device ) ;
#line 2322
double cairo_device_observer_stroke_elapsed(cairo_device_t *device ) ;
#line 2325
double cairo_device_observer_glyphs_elapsed(cairo_device_t *device ) ;
#line 2328
cairo_surface_t *cairo_surface_reference(cairo_surface_t *surface ) ;
#line 2331
void cairo_surface_finish(cairo_surface_t *surface ) ;
#line 2334
void cairo_surface_destroy(cairo_surface_t *surface ) ;
#line 2337
cairo_device_t *cairo_surface_get_device(cairo_surface_t *surface ) ;
#line 2340
unsigned int cairo_surface_get_reference_count(cairo_surface_t *surface ) ;
#line 2343
cairo_status_t cairo_surface_status(cairo_surface_t *surface ) ;
#line 2426
cairo_surface_type_t cairo_surface_get_type(cairo_surface_t *surface ) ;
#line 2429
cairo_content_t cairo_surface_get_content(cairo_surface_t *surface ) ;
#line 2434
cairo_status_t cairo_surface_write_to_png(cairo_surface_t *surface , char const   *filename ) ;
#line 2438
cairo_status_t cairo_surface_write_to_png_stream(cairo_surface_t *surface , cairo_write_func_t write_func ,
                                                 void *closure ) ;
#line 2445
void *cairo_surface_get_user_data(cairo_surface_t *surface , cairo_user_data_key_t *key ) ;
#line 2449
cairo_status_t cairo_surface_set_user_data(cairo_surface_t *surface , cairo_user_data_key_t *key ,
                                           void *user_data , cairo_destroy_func_t destroy ) ;
#line 2468
void cairo_surface_get_mime_data(cairo_surface_t *surface , char const   *mime_type ,
                                 unsigned char const   **data , unsigned long *length ) ;
#line 2474
cairo_status_t cairo_surface_set_mime_data(cairo_surface_t *surface , char const   *mime_type ,
                                           unsigned char const   *data , unsigned long length ,
                                           cairo_destroy_func_t destroy , void *closure ) ;
#line 2482
cairo_bool_t cairo_surface_supports_mime_type(cairo_surface_t *surface , char const   *mime_type ) ;
#line 2486
void cairo_surface_get_font_options(cairo_surface_t *surface , cairo_font_options_t *options ) ;
#line 2490
void cairo_surface_flush(cairo_surface_t *surface ) ;
#line 2493
void cairo_surface_mark_dirty(cairo_surface_t *surface ) ;
#line 2496
void cairo_surface_mark_dirty_rectangle(cairo_surface_t *surface , int x , int y ,
                                        int width , int height ) ;
#line 2503
void cairo_surface_set_device_scale(cairo_surface_t *surface , double x_scale , double y_scale ) ;
#line 2508
void cairo_surface_get_device_scale(cairo_surface_t *surface , double *x_scale , double *y_scale ) ;
#line 2513
void cairo_surface_set_device_offset(cairo_surface_t *surface , double x_offset ,
                                     double y_offset ) ;
#line 2518
void cairo_surface_get_device_offset(cairo_surface_t *surface , double *x_offset ,
                                     double *y_offset ) ;
#line 2523
void cairo_surface_set_fallback_resolution(cairo_surface_t *surface , double x_pixels_per_inch ,
                                           double y_pixels_per_inch ) ;
#line 2528
void cairo_surface_get_fallback_resolution(cairo_surface_t *surface , double *x_pixels_per_inch ,
                                           double *y_pixels_per_inch ) ;
#line 2533
void cairo_surface_copy_page(cairo_surface_t *surface ) ;
#line 2536
void cairo_surface_show_page(cairo_surface_t *surface ) ;
#line 2539
cairo_bool_t cairo_surface_has_show_text_glyphs(cairo_surface_t *surface ) ;
#line 2544
cairo_surface_t *cairo_image_surface_create(cairo_format_t format , int width , int height ) ;
#line 2549
int cairo_format_stride_for_width(cairo_format_t format , int width ) ;
#line 2553
cairo_surface_t *cairo_image_surface_create_for_data(unsigned char *data , cairo_format_t format ,
                                                     int width , int height , int stride ) ;
#line 2560
unsigned char *cairo_image_surface_get_data(cairo_surface_t *surface ) ;
#line 2563
cairo_format_t cairo_image_surface_get_format(cairo_surface_t *surface ) ;
#line 2566
int cairo_image_surface_get_width(cairo_surface_t *surface ) ;
#line 2569
int cairo_image_surface_get_height(cairo_surface_t *surface ) ;
#line 2572
int cairo_image_surface_get_stride(cairo_surface_t *surface ) ;
#line 2577
cairo_surface_t *cairo_image_surface_create_from_png(char const   *filename ) ;
#line 2580
cairo_surface_t *cairo_image_surface_create_from_png_stream(cairo_read_func_t read_func ,
                                                            void *closure ) ;
#line 2588
cairo_surface_t *cairo_recording_surface_create(cairo_content_t content , cairo_rectangle_t *extents ) ;
#line 2592
void cairo_recording_surface_ink_extents(cairo_surface_t *surface , double *x0 , double *y0 ,
                                         double *width , double *height ) ;
#line 2599
cairo_bool_t cairo_recording_surface_get_extents(cairo_surface_t *surface , cairo_rectangle_t *extents ) ;
#line 2706
cairo_pattern_t *cairo_pattern_create_raster_source(void *user_data , cairo_content_t content ,
                                                    int width , int height ) ;
#line 2711
void cairo_raster_source_pattern_set_callback_data(cairo_pattern_t *pattern , void *data ) ;
#line 2715
void *cairo_raster_source_pattern_get_callback_data(cairo_pattern_t *pattern ) ;
#line 2718
void cairo_raster_source_pattern_set_acquire(cairo_pattern_t *pattern , cairo_raster_source_acquire_func_t acquire ,
                                             cairo_raster_source_release_func_t release ) ;
#line 2723
void cairo_raster_source_pattern_get_acquire(cairo_pattern_t *pattern , cairo_raster_source_acquire_func_t *acquire ,
                                             cairo_raster_source_release_func_t *release ) ;
#line 2727
void cairo_raster_source_pattern_set_snapshot(cairo_pattern_t *pattern , cairo_raster_source_snapshot_func_t snapshot ) ;
#line 2731
cairo_raster_source_snapshot_func_t cairo_raster_source_pattern_get_snapshot(cairo_pattern_t *pattern ) ;
#line 2734
void cairo_raster_source_pattern_set_copy(cairo_pattern_t *pattern , cairo_raster_source_copy_func_t copy ) ;
#line 2738
cairo_raster_source_copy_func_t cairo_raster_source_pattern_get_copy(cairo_pattern_t *pattern ) ;
#line 2741
void cairo_raster_source_pattern_set_finish(cairo_pattern_t *pattern , cairo_raster_source_finish_func_t finish ) ;
#line 2745
cairo_raster_source_finish_func_t cairo_raster_source_pattern_get_finish(cairo_pattern_t *pattern ) ;
#line 2750
cairo_pattern_t *cairo_pattern_create_rgb(double red , double green , double blue ) ;
#line 2753
cairo_pattern_t *cairo_pattern_create_rgba(double red , double green , double blue ,
                                           double alpha ) ;
#line 2757
cairo_pattern_t *cairo_pattern_create_for_surface(cairo_surface_t *surface ) ;
#line 2760
cairo_pattern_t *cairo_pattern_create_linear(double x0 , double y0 , double x1 , double y1 ) ;
#line 2764
cairo_pattern_t *cairo_pattern_create_radial(double cx0 , double cy0 , double radius0 ,
                                             double cx1 , double cy1 , double radius1 ) ;
#line 2768
cairo_pattern_t *cairo_pattern_create_mesh(void) ;
#line 2771
cairo_pattern_t *cairo_pattern_reference(cairo_pattern_t *pattern ) ;
#line 2774
void cairo_pattern_destroy(cairo_pattern_t *pattern ) ;
#line 2777
unsigned int cairo_pattern_get_reference_count(cairo_pattern_t *pattern ) ;
#line 2780
cairo_status_t cairo_pattern_status(cairo_pattern_t *pattern ) ;
#line 2783
void *cairo_pattern_get_user_data(cairo_pattern_t *pattern , cairo_user_data_key_t *key ) ;
#line 2787
cairo_status_t cairo_pattern_set_user_data(cairo_pattern_t *pattern , cairo_user_data_key_t *key ,
                                           void *user_data , cairo_destroy_func_t destroy ) ;
#line 2834
cairo_pattern_type_t cairo_pattern_get_type(cairo_pattern_t *pattern ) ;
#line 2837
void cairo_pattern_add_color_stop_rgb(cairo_pattern_t *pattern , double offset , double red ,
                                      double green , double blue ) ;
#line 2842
void cairo_pattern_add_color_stop_rgba(cairo_pattern_t *pattern , double offset ,
                                       double red , double green , double blue , double alpha ) ;
#line 2848
void cairo_mesh_pattern_begin_patch(cairo_pattern_t *pattern ) ;
#line 2851
void cairo_mesh_pattern_end_patch(cairo_pattern_t *pattern ) ;
#line 2854
void cairo_mesh_pattern_curve_to(cairo_pattern_t *pattern , double x1 , double y1 ,
                                 double x2 , double y2 , double x3 , double y3 ) ;
#line 2860
void cairo_mesh_pattern_line_to(cairo_pattern_t *pattern , double x , double y ) ;
#line 2864
void cairo_mesh_pattern_move_to(cairo_pattern_t *pattern , double x , double y ) ;
#line 2868
void cairo_mesh_pattern_set_control_point(cairo_pattern_t *pattern , unsigned int point_num ,
                                          double x , double y ) ;
#line 2873
void cairo_mesh_pattern_set_corner_color_rgb(cairo_pattern_t *pattern , unsigned int corner_num ,
                                             double red , double green , double blue ) ;
#line 2878
void cairo_mesh_pattern_set_corner_color_rgba(cairo_pattern_t *pattern , unsigned int corner_num ,
                                              double red , double green , double blue ,
                                              double alpha ) ;
#line 2884
void cairo_pattern_set_matrix(cairo_pattern_t *pattern , cairo_matrix_t *matrix ) ;
#line 2888
void cairo_pattern_get_matrix(cairo_pattern_t *pattern , cairo_matrix_t *matrix ) ;
#line 2924
void cairo_pattern_set_extend(cairo_pattern_t *pattern , cairo_extend_t extend ) ;
#line 2927
cairo_extend_t cairo_pattern_get_extend(cairo_pattern_t *pattern ) ;
#line 2959
void cairo_pattern_set_filter(cairo_pattern_t *pattern , cairo_filter_t filter ) ;
#line 2962
cairo_filter_t cairo_pattern_get_filter(cairo_pattern_t *pattern ) ;
#line 2965
cairo_status_t cairo_pattern_get_rgba(cairo_pattern_t *pattern , double *red , double *green ,
                                      double *blue , double *alpha ) ;
#line 2970
cairo_status_t cairo_pattern_get_surface(cairo_pattern_t *pattern , cairo_surface_t **surface ) ;
#line 2975
cairo_status_t cairo_pattern_get_color_stop_rgba(cairo_pattern_t *pattern , int index ,
                                                 double *offset , double *red , double *green ,
                                                 double *blue , double *alpha ) ;
#line 2981
cairo_status_t cairo_pattern_get_color_stop_count(cairo_pattern_t *pattern , int *count ) ;
#line 2985
cairo_status_t cairo_pattern_get_linear_points(cairo_pattern_t *pattern , double *x0 ,
                                               double *y0 , double *x1 , double *y1 ) ;
#line 2990
cairo_status_t cairo_pattern_get_radial_circles(cairo_pattern_t *pattern , double *x0 ,
                                                double *y0 , double *r0 , double *x1 ,
                                                double *y1 , double *r1 ) ;
#line 2995
cairo_status_t cairo_mesh_pattern_get_patch_count(cairo_pattern_t *pattern , unsigned int *count ) ;
#line 2999
cairo_path_t *cairo_mesh_pattern_get_path(cairo_pattern_t *pattern , unsigned int patch_num ) ;
#line 3003
cairo_status_t cairo_mesh_pattern_get_corner_color_rgba(cairo_pattern_t *pattern ,
                                                        unsigned int patch_num , unsigned int corner_num ,
                                                        double *red , double *green ,
                                                        double *blue , double *alpha ) ;
#line 3010
cairo_status_t cairo_mesh_pattern_get_control_point(cairo_pattern_t *pattern , unsigned int patch_num ,
                                                    unsigned int point_num , double *x ,
                                                    double *y ) ;
#line 3018
void cairo_matrix_init(cairo_matrix_t *matrix , double xx , double yx , double xy ,
                       double yy , double x0 , double y0 ) ;
#line 3024
void cairo_matrix_init_identity(cairo_matrix_t *matrix ) ;
#line 3027
void cairo_matrix_init_translate(cairo_matrix_t *matrix , double tx , double ty ) ;
#line 3031
void cairo_matrix_init_scale(cairo_matrix_t *matrix , double sx , double sy ) ;
#line 3035
void cairo_matrix_init_rotate(cairo_matrix_t *matrix , double radians ) ;
#line 3039
void cairo_matrix_translate(cairo_matrix_t *matrix , double tx , double ty ) ;
#line 3042
void cairo_matrix_scale(cairo_matrix_t *matrix , double sx , double sy ) ;
#line 3045
void cairo_matrix_rotate(cairo_matrix_t *matrix , double radians ) ;
#line 3048
cairo_status_t cairo_matrix_invert(cairo_matrix_t *matrix ) ;
#line 3051
void cairo_matrix_multiply(cairo_matrix_t *result , cairo_matrix_t *a , cairo_matrix_t *b ) ;
#line 3056
void cairo_matrix_transform_distance(cairo_matrix_t *matrix , double *dx , double *dy ) ;
#line 3060
void cairo_matrix_transform_point(cairo_matrix_t *matrix , double *x , double *y ) ;
#line 3098
cairo_region_t *cairo_region_create(void) ;
#line 3101
cairo_region_t *cairo_region_create_rectangle(cairo_rectangle_int_t *rectangle ) ;
#line 3104
cairo_region_t *cairo_region_create_rectangles(cairo_rectangle_int_t *rects , int count ) ;
#line 3108
cairo_region_t *cairo_region_copy(cairo_region_t *original ) ;
#line 3111
cairo_region_t *cairo_region_reference(cairo_region_t *region ) ;
#line 3114
void cairo_region_destroy(cairo_region_t *region ) ;
#line 3117
cairo_bool_t cairo_region_equal(cairo_region_t *a , cairo_region_t *b ) ;
#line 3120
cairo_status_t cairo_region_status(cairo_region_t *region ) ;
#line 3123
void cairo_region_get_extents(cairo_region_t *region , cairo_rectangle_int_t *extents ) ;
#line 3127
int cairo_region_num_rectangles(cairo_region_t *region ) ;
#line 3130
void cairo_region_get_rectangle(cairo_region_t *region , int nth , cairo_rectangle_int_t *rectangle ) ;
#line 3135
cairo_bool_t cairo_region_is_empty(cairo_region_t *region ) ;
#line 3138
cairo_region_overlap_t cairo_region_contains_rectangle(cairo_region_t *region , cairo_rectangle_int_t *rectangle ) ;
#line 3142
cairo_bool_t cairo_region_contains_point(cairo_region_t *region , int x , int y ) ;
#line 3145
void cairo_region_translate(cairo_region_t *region , int dx , int dy ) ;
#line 3148
cairo_status_t cairo_region_subtract(cairo_region_t *dst , cairo_region_t *other ) ;
#line 3151
cairo_status_t cairo_region_subtract_rectangle(cairo_region_t *dst , cairo_rectangle_int_t *rectangle ) ;
#line 3155
cairo_status_t cairo_region_intersect(cairo_region_t *dst , cairo_region_t *other ) ;
#line 3158
cairo_status_t cairo_region_intersect_rectangle(cairo_region_t *dst , cairo_rectangle_int_t *rectangle ) ;
#line 3162
cairo_status_t cairo_region_union(cairo_region_t *dst , cairo_region_t *other ) ;
#line 3165
cairo_status_t cairo_region_union_rectangle(cairo_region_t *dst , cairo_rectangle_int_t *rectangle ) ;
#line 3169
cairo_status_t cairo_region_xor(cairo_region_t *dst , cairo_region_t *other ) ;
#line 3172
cairo_status_t cairo_region_xor_rectangle(cairo_region_t *dst , cairo_rectangle_int_t *rectangle ) ;
#line 3177
void cairo_debug_reset_static_data(void) ;
#line 171 "/usr/include/harfbuzz/hb-common.h"
extern hb_tag_t hb_tag_from_string(char const   *str , int len ) ;
#line 175
extern void hb_tag_to_string(hb_tag_t tag , char *buf ) ;
#line 203
extern hb_direction_t hb_direction_from_string(char const   *str , int len ) ;
#line 206
extern char const   *hb_direction_to_string(hb_direction_t direction ) ;
#line 269
extern hb_language_t hb_language_from_string(char const   *str , int len ) ;
#line 272
extern char const   *hb_language_to_string(hb_language_t language ) ;
#line 277
extern hb_language_t hb_language_get_default(void) ;
#line 665
extern hb_script_t hb_script_from_iso15924_tag(hb_tag_t tag ) ;
#line 668
extern hb_script_t hb_script_from_string(char const   *str , int len ) ;
#line 671
extern hb_tag_t hb_script_to_iso15924_tag(hb_script_t script ) ;
#line 674
extern hb_direction_t hb_script_get_horizontal_direction(hb_script_t script ) ;
#line 731
extern hb_bool_t hb_feature_from_string(char const   *str , int len , hb_feature_t *feature ) ;
#line 735
extern void hb_feature_to_string(hb_feature_t *feature , char *buf , unsigned int size ) ;
#line 755
extern hb_bool_t hb_variation_from_string(char const   *str , int len , hb_variation_t *variation ) ;
#line 759
extern void hb_variation_to_string(hb_variation_t *variation , char *buf , unsigned int size ) ;
#line 775
extern uint8_t hb_color_get_alpha(hb_color_t color ) ;
#line 779
extern uint8_t hb_color_get_red(hb_color_t color ) ;
#line 783
extern uint8_t hb_color_get_green(hb_color_t color ) ;
#line 787
extern uint8_t hb_color_get_blue(hb_color_t color ) ;
#line 85 "/usr/include/harfbuzz/hb-blob.h"
extern hb_blob_t *hb_blob_create(char const   *data , unsigned int length , hb_memory_mode_t mode ,
                                 void *user_data , hb_destroy_func_t destroy ) ;
#line 92
extern hb_blob_t *hb_blob_create_from_file(char const   *file_name ) ;
#line 101
extern hb_blob_t *hb_blob_create_sub_blob(hb_blob_t *parent , unsigned int offset ,
                                          unsigned int length ) ;
#line 106
extern hb_blob_t *hb_blob_copy_writable_or_fail(hb_blob_t *blob ) ;
#line 109
extern hb_blob_t *hb_blob_get_empty(void) ;
#line 112
extern hb_blob_t *hb_blob_reference(hb_blob_t *blob ) ;
#line 115
extern void hb_blob_destroy(hb_blob_t *blob ) ;
#line 118
extern hb_bool_t hb_blob_set_user_data(hb_blob_t *blob , hb_user_data_key_t *key ,
                                       void *data , hb_destroy_func_t destroy , hb_bool_t replace ) ;
#line 126
extern void *hb_blob_get_user_data(hb_blob_t *blob , hb_user_data_key_t *key ) ;
#line 131
extern void hb_blob_make_immutable(hb_blob_t *blob ) ;
#line 134
extern hb_bool_t hb_blob_is_immutable(hb_blob_t *blob ) ;
#line 138
extern unsigned int hb_blob_get_length(hb_blob_t *blob ) ;
#line 141
extern char const   *hb_blob_get_data(hb_blob_t *blob , unsigned int *length ) ;
#line 144
extern char *hb_blob_get_data_writable(hb_blob_t *blob , unsigned int *length ) ;
#line 294 "/usr/include/harfbuzz/hb-unicode.h"
extern hb_unicode_funcs_t *hb_unicode_funcs_get_default(void) ;
#line 298
extern hb_unicode_funcs_t *hb_unicode_funcs_create(hb_unicode_funcs_t *parent ) ;
#line 301
extern hb_unicode_funcs_t *hb_unicode_funcs_get_empty(void) ;
#line 304
extern hb_unicode_funcs_t *hb_unicode_funcs_reference(hb_unicode_funcs_t *ufuncs ) ;
#line 307
extern void hb_unicode_funcs_destroy(hb_unicode_funcs_t *ufuncs ) ;
#line 310
extern hb_bool_t hb_unicode_funcs_set_user_data(hb_unicode_funcs_t *ufuncs , hb_user_data_key_t *key ,
                                                void *data , hb_destroy_func_t destroy ,
                                                hb_bool_t replace ) ;
#line 318
extern void *hb_unicode_funcs_get_user_data(hb_unicode_funcs_t *ufuncs , hb_user_data_key_t *key ) ;
#line 323
extern void hb_unicode_funcs_make_immutable(hb_unicode_funcs_t *ufuncs ) ;
#line 326
extern hb_bool_t hb_unicode_funcs_is_immutable(hb_unicode_funcs_t *ufuncs ) ;
#line 329
extern hb_unicode_funcs_t *hb_unicode_funcs_get_parent(hb_unicode_funcs_t *ufuncs ) ;
#line 477
extern void hb_unicode_funcs_set_combining_class_func(hb_unicode_funcs_t *ufuncs ,
                                                      hb_unicode_combining_class_func_t func ,
                                                      void *user_data , hb_destroy_func_t destroy ) ;
#line 493
extern void hb_unicode_funcs_set_general_category_func(hb_unicode_funcs_t *ufuncs ,
                                                       hb_unicode_general_category_func_t func ,
                                                       void *user_data , hb_destroy_func_t destroy ) ;
#line 509
extern void hb_unicode_funcs_set_mirroring_func(hb_unicode_funcs_t *ufuncs , hb_unicode_mirroring_func_t func ,
                                                void *user_data , hb_destroy_func_t destroy ) ;
#line 525
extern void hb_unicode_funcs_set_script_func(hb_unicode_funcs_t *ufuncs , hb_unicode_script_func_t func ,
                                             void *user_data , hb_destroy_func_t destroy ) ;
#line 541
extern void hb_unicode_funcs_set_compose_func(hb_unicode_funcs_t *ufuncs , hb_unicode_compose_func_t func ,
                                              void *user_data , hb_destroy_func_t destroy ) ;
#line 557
extern void hb_unicode_funcs_set_decompose_func(hb_unicode_funcs_t *ufuncs , hb_unicode_decompose_func_t func ,
                                                void *user_data , hb_destroy_func_t destroy ) ;
#line 576
extern hb_unicode_combining_class_t hb_unicode_combining_class(hb_unicode_funcs_t *ufuncs ,
                                                               hb_codepoint_t unicode ) ;
#line 592
extern hb_unicode_general_category_t hb_unicode_general_category(hb_unicode_funcs_t *ufuncs ,
                                                                 hb_codepoint_t unicode ) ;
#line 608
extern hb_codepoint_t hb_unicode_mirroring(hb_unicode_funcs_t *ufuncs , hb_codepoint_t unicode ) ;
#line 624
extern hb_script_t hb_unicode_script(hb_unicode_funcs_t *ufuncs , hb_codepoint_t unicode ) ;
#line 642
extern hb_bool_t hb_unicode_compose(hb_unicode_funcs_t *ufuncs , hb_codepoint_t a ,
                                    hb_codepoint_t b , hb_codepoint_t *ab ) ;
#line 662
extern hb_bool_t hb_unicode_decompose(hb_unicode_funcs_t *ufuncs , hb_codepoint_t ab ,
                                      hb_codepoint_t *a , hb_codepoint_t *b ) ;
#line 57 "/usr/include/harfbuzz/hb-set.h"
extern hb_set_t *hb_set_create(void) ;
#line 60
extern hb_set_t *hb_set_get_empty(void) ;
#line 63
extern hb_set_t *hb_set_reference(hb_set_t *set ) ;
#line 66
extern void hb_set_destroy(hb_set_t *set ) ;
#line 69
extern hb_bool_t hb_set_set_user_data(hb_set_t *set , hb_user_data_key_t *key , void *data ,
                                      hb_destroy_func_t destroy , hb_bool_t replace ) ;
#line 76
extern void *hb_set_get_user_data(hb_set_t *set , hb_user_data_key_t *key ) ;
#line 82
extern hb_bool_t hb_set_allocation_successful(hb_set_t *set ) ;
#line 85
extern void hb_set_clear(hb_set_t *set ) ;
#line 88
extern hb_bool_t hb_set_is_empty(hb_set_t *set ) ;
#line 91
extern hb_bool_t hb_set_has(hb_set_t *set , hb_codepoint_t codepoint ) ;
#line 95
extern void hb_set_add(hb_set_t *set , hb_codepoint_t codepoint ) ;
#line 99
extern void hb_set_add_range(hb_set_t *set , hb_codepoint_t first , hb_codepoint_t last ) ;
#line 104
extern void hb_set_del(hb_set_t *set , hb_codepoint_t codepoint ) ;
#line 108
extern void hb_set_del_range(hb_set_t *set , hb_codepoint_t first , hb_codepoint_t last ) ;
#line 113
extern hb_bool_t hb_set_is_equal(hb_set_t *set , hb_set_t *other ) ;
#line 117
extern hb_bool_t hb_set_is_subset(hb_set_t *set , hb_set_t *larger_set ) ;
#line 121
extern void hb_set_set(hb_set_t *set , hb_set_t *other ) ;
#line 125
extern void hb_set_union(hb_set_t *set , hb_set_t *other ) ;
#line 129
extern void hb_set_intersect(hb_set_t *set , hb_set_t *other ) ;
#line 133
extern void hb_set_subtract(hb_set_t *set , hb_set_t *other ) ;
#line 137
extern void hb_set_symmetric_difference(hb_set_t *set , hb_set_t *other ) ;
#line 141
extern unsigned int hb_set_get_population(hb_set_t *set ) ;
#line 145
extern hb_codepoint_t hb_set_get_min(hb_set_t *set ) ;
#line 149
extern hb_codepoint_t hb_set_get_max(hb_set_t *set ) ;
#line 153
extern hb_bool_t hb_set_next(hb_set_t *set , hb_codepoint_t *codepoint ) ;
#line 158
extern hb_bool_t hb_set_previous(hb_set_t *set , hb_codepoint_t *codepoint ) ;
#line 163
extern hb_bool_t hb_set_next_range(hb_set_t *set , hb_codepoint_t *first , hb_codepoint_t *last ) ;
#line 169
extern hb_bool_t hb_set_previous_range(hb_set_t *set , hb_codepoint_t *first , hb_codepoint_t *last ) ;
#line 42 "/usr/include/harfbuzz/hb-face.h"
extern unsigned int hb_face_count(hb_blob_t *blob ) ;
#line 58
extern hb_face_t *hb_face_create(hb_blob_t *blob , unsigned int index ) ;
#line 65
extern hb_face_t *hb_face_create_for_tables(hb_reference_table_func_t reference_table_func ,
                                            void *user_data , hb_destroy_func_t destroy ) ;
#line 70
extern hb_face_t *hb_face_get_empty(void) ;
#line 73
extern hb_face_t *hb_face_reference(hb_face_t *face ) ;
#line 76
extern void hb_face_destroy(hb_face_t *face ) ;
#line 79
extern hb_bool_t hb_face_set_user_data(hb_face_t *face , hb_user_data_key_t *key ,
                                       void *data , hb_destroy_func_t destroy , hb_bool_t replace ) ;
#line 86
extern void *hb_face_get_user_data(hb_face_t *face , hb_user_data_key_t *key ) ;
#line 90
extern void hb_face_make_immutable(hb_face_t *face ) ;
#line 93
extern hb_bool_t hb_face_is_immutable(hb_face_t *face ) ;
#line 97
extern hb_blob_t *hb_face_reference_table(hb_face_t *face , hb_tag_t tag ) ;
#line 101
extern hb_blob_t *hb_face_reference_blob(hb_face_t *face ) ;
#line 104
extern void hb_face_set_index(hb_face_t *face , unsigned int index ) ;
#line 108
extern unsigned int hb_face_get_index(hb_face_t *face ) ;
#line 111
extern void hb_face_set_upem(hb_face_t *face , unsigned int upem ) ;
#line 115
extern unsigned int hb_face_get_upem(hb_face_t *face ) ;
#line 118
extern void hb_face_set_glyph_count(hb_face_t *face , unsigned int glyph_count ) ;
#line 122
extern unsigned int hb_face_get_glyph_count(hb_face_t *face ) ;
#line 125
extern unsigned int hb_face_get_table_tags(hb_face_t *face , unsigned int start_offset ,
                                           unsigned int *table_count , hb_tag_t *table_tags ) ;
#line 136
extern void hb_face_collect_unicodes(hb_face_t *face , hb_set_t *out ) ;
#line 140
extern void hb_face_collect_variation_selectors(hb_face_t *face , hb_set_t *out ) ;
#line 144
extern void hb_face_collect_variation_unicodes(hb_face_t *face , hb_codepoint_t variation_selector ,
                                               hb_set_t *out ) ;
#line 154
extern hb_face_t *hb_face_builder_create(void) ;
#line 157
extern hb_bool_t hb_face_builder_add_table(hb_face_t *face , hb_tag_t tag , hb_blob_t *blob ) ;
#line 64 "/usr/include/harfbuzz/hb-font.h"
extern hb_font_funcs_t *hb_font_funcs_create(void) ;
#line 67
extern hb_font_funcs_t *hb_font_funcs_get_empty(void) ;
#line 70
extern hb_font_funcs_t *hb_font_funcs_reference(hb_font_funcs_t *ffuncs ) ;
#line 73
extern void hb_font_funcs_destroy(hb_font_funcs_t *ffuncs ) ;
#line 76
extern hb_bool_t hb_font_funcs_set_user_data(hb_font_funcs_t *ffuncs , hb_user_data_key_t *key ,
                                             void *data , hb_destroy_func_t destroy ,
                                             hb_bool_t replace ) ;
#line 84
extern void *hb_font_funcs_get_user_data(hb_font_funcs_t *ffuncs , hb_user_data_key_t *key ) ;
#line 89
extern void hb_font_funcs_make_immutable(hb_font_funcs_t *ffuncs ) ;
#line 92
extern hb_bool_t hb_font_funcs_is_immutable(hb_font_funcs_t *ffuncs ) ;
#line 414
extern void hb_font_funcs_set_font_h_extents_func(hb_font_funcs_t *ffuncs , hb_font_get_font_h_extents_func_t func ,
                                                  void *user_data , hb_destroy_func_t destroy ) ;
#line 430
extern void hb_font_funcs_set_font_v_extents_func(hb_font_funcs_t *ffuncs , hb_font_get_font_v_extents_func_t func ,
                                                  void *user_data , hb_destroy_func_t destroy ) ;
#line 446
extern void hb_font_funcs_set_nominal_glyph_func(hb_font_funcs_t *ffuncs , hb_font_get_nominal_glyph_func_t func ,
                                                 void *user_data , hb_destroy_func_t destroy ) ;
#line 462
extern void hb_font_funcs_set_nominal_glyphs_func(hb_font_funcs_t *ffuncs , hb_font_get_nominal_glyphs_func_t func ,
                                                  void *user_data , hb_destroy_func_t destroy ) ;
#line 478
extern void hb_font_funcs_set_variation_glyph_func(hb_font_funcs_t *ffuncs , hb_font_get_variation_glyph_func_t func ,
                                                   void *user_data , hb_destroy_func_t destroy ) ;
#line 494
extern void hb_font_funcs_set_glyph_h_advance_func(hb_font_funcs_t *ffuncs , hb_font_get_glyph_h_advance_func_t func ,
                                                   void *user_data , hb_destroy_func_t destroy ) ;
#line 510
extern void hb_font_funcs_set_glyph_v_advance_func(hb_font_funcs_t *ffuncs , hb_font_get_glyph_v_advance_func_t func ,
                                                   void *user_data , hb_destroy_func_t destroy ) ;
#line 526
extern void hb_font_funcs_set_glyph_h_advances_func(hb_font_funcs_t *ffuncs , hb_font_get_glyph_h_advances_func_t func ,
                                                    void *user_data , hb_destroy_func_t destroy ) ;
#line 542
extern void hb_font_funcs_set_glyph_v_advances_func(hb_font_funcs_t *ffuncs , hb_font_get_glyph_v_advances_func_t func ,
                                                    void *user_data , hb_destroy_func_t destroy ) ;
#line 558
extern void hb_font_funcs_set_glyph_h_origin_func(hb_font_funcs_t *ffuncs , hb_font_get_glyph_h_origin_func_t func ,
                                                  void *user_data , hb_destroy_func_t destroy ) ;
#line 574
extern void hb_font_funcs_set_glyph_v_origin_func(hb_font_funcs_t *ffuncs , hb_font_get_glyph_v_origin_func_t func ,
                                                  void *user_data , hb_destroy_func_t destroy ) ;
#line 590
extern void hb_font_funcs_set_glyph_h_kerning_func(hb_font_funcs_t *ffuncs , hb_font_get_glyph_h_kerning_func_t func ,
                                                   void *user_data , hb_destroy_func_t destroy ) ;
#line 606
extern void hb_font_funcs_set_glyph_extents_func(hb_font_funcs_t *ffuncs , hb_font_get_glyph_extents_func_t func ,
                                                 void *user_data , hb_destroy_func_t destroy ) ;
#line 622
extern void hb_font_funcs_set_glyph_contour_point_func(hb_font_funcs_t *ffuncs , hb_font_get_glyph_contour_point_func_t func ,
                                                       void *user_data , hb_destroy_func_t destroy ) ;
#line 638
extern void hb_font_funcs_set_glyph_name_func(hb_font_funcs_t *ffuncs , hb_font_get_glyph_name_func_t func ,
                                              void *user_data , hb_destroy_func_t destroy ) ;
#line 654
extern void hb_font_funcs_set_glyph_from_name_func(hb_font_funcs_t *ffuncs , hb_font_get_glyph_from_name_func_t func ,
                                                   void *user_data , hb_destroy_func_t destroy ) ;
#line 661
extern hb_bool_t hb_font_get_h_extents(hb_font_t *font , hb_font_extents_t *extents ) ;
#line 664
extern hb_bool_t hb_font_get_v_extents(hb_font_t *font , hb_font_extents_t *extents ) ;
#line 668
extern hb_bool_t hb_font_get_nominal_glyph(hb_font_t *font , hb_codepoint_t unicode ,
                                           hb_codepoint_t *glyph ) ;
#line 672
extern hb_bool_t hb_font_get_variation_glyph(hb_font_t *font , hb_codepoint_t unicode ,
                                             hb_codepoint_t variation_selector , hb_codepoint_t *glyph ) ;
#line 677
extern unsigned int hb_font_get_nominal_glyphs(hb_font_t *font , unsigned int count ,
                                               hb_codepoint_t *first_unicode , unsigned int unicode_stride ,
                                               hb_codepoint_t *first_glyph , unsigned int glyph_stride ) ;
#line 685
extern hb_position_t hb_font_get_glyph_h_advance(hb_font_t *font , hb_codepoint_t glyph ) ;
#line 688
extern hb_position_t hb_font_get_glyph_v_advance(hb_font_t *font , hb_codepoint_t glyph ) ;
#line 692
extern void hb_font_get_glyph_h_advances(hb_font_t *font , unsigned int count , hb_codepoint_t *first_glyph ,
                                         unsigned int glyph_stride , hb_position_t *first_advance ,
                                         unsigned int advance_stride ) ;
#line 699
extern void hb_font_get_glyph_v_advances(hb_font_t *font , unsigned int count , hb_codepoint_t *first_glyph ,
                                         unsigned int glyph_stride , hb_position_t *first_advance ,
                                         unsigned int advance_stride ) ;
#line 707
extern hb_bool_t hb_font_get_glyph_h_origin(hb_font_t *font , hb_codepoint_t glyph ,
                                            hb_position_t *x , hb_position_t *y ) ;
#line 711
extern hb_bool_t hb_font_get_glyph_v_origin(hb_font_t *font , hb_codepoint_t glyph ,
                                            hb_position_t *x , hb_position_t *y ) ;
#line 716
extern hb_position_t hb_font_get_glyph_h_kerning(hb_font_t *font , hb_codepoint_t left_glyph ,
                                                 hb_codepoint_t right_glyph ) ;
#line 720
extern hb_bool_t hb_font_get_glyph_extents(hb_font_t *font , hb_codepoint_t glyph ,
                                           hb_glyph_extents_t *extents ) ;
#line 725
extern hb_bool_t hb_font_get_glyph_contour_point(hb_font_t *font , hb_codepoint_t glyph ,
                                                 unsigned int point_index , hb_position_t *x ,
                                                 hb_position_t *y ) ;
#line 730
extern hb_bool_t hb_font_get_glyph_name(hb_font_t *font , hb_codepoint_t glyph , char *name ,
                                        unsigned int size ) ;
#line 734
extern hb_bool_t hb_font_get_glyph_from_name(hb_font_t *font , char const   *name ,
                                             int len , hb_codepoint_t *glyph ) ;
#line 744
extern hb_bool_t hb_font_get_glyph(hb_font_t *font , hb_codepoint_t unicode , hb_codepoint_t variation_selector ,
                                   hb_codepoint_t *glyph ) ;
#line 749
extern void hb_font_get_extents_for_direction(hb_font_t *font , hb_direction_t direction ,
                                              hb_font_extents_t *extents ) ;
#line 753
extern void hb_font_get_glyph_advance_for_direction(hb_font_t *font , hb_codepoint_t glyph ,
                                                    hb_direction_t direction , hb_position_t *x ,
                                                    hb_position_t *y ) ;
#line 758
extern void hb_font_get_glyph_advances_for_direction(hb_font_t *font , hb_direction_t direction ,
                                                     unsigned int count , hb_codepoint_t *first_glyph ,
                                                     unsigned int glyph_stride , hb_position_t *first_advance ,
                                                     unsigned int advance_stride ) ;
#line 766
extern void hb_font_get_glyph_origin_for_direction(hb_font_t *font , hb_codepoint_t glyph ,
                                                   hb_direction_t direction , hb_position_t *x ,
                                                   hb_position_t *y ) ;
#line 771
extern void hb_font_add_glyph_origin_for_direction(hb_font_t *font , hb_codepoint_t glyph ,
                                                   hb_direction_t direction , hb_position_t *x ,
                                                   hb_position_t *y ) ;
#line 776
extern void hb_font_subtract_glyph_origin_for_direction(hb_font_t *font , hb_codepoint_t glyph ,
                                                        hb_direction_t direction ,
                                                        hb_position_t *x , hb_position_t *y ) ;
#line 782
extern void hb_font_get_glyph_kerning_for_direction(hb_font_t *font , hb_codepoint_t first_glyph ,
                                                    hb_codepoint_t second_glyph ,
                                                    hb_direction_t direction , hb_position_t *x ,
                                                    hb_position_t *y ) ;
#line 788
extern hb_bool_t hb_font_get_glyph_extents_for_origin(hb_font_t *font , hb_codepoint_t glyph ,
                                                      hb_direction_t direction , hb_glyph_extents_t *extents ) ;
#line 794
extern hb_bool_t hb_font_get_glyph_contour_point_for_origin(hb_font_t *font , hb_codepoint_t glyph ,
                                                            unsigned int point_index ,
                                                            hb_direction_t direction ,
                                                            hb_position_t *x , hb_position_t *y ) ;
#line 801
extern void hb_font_glyph_to_string(hb_font_t *font , hb_codepoint_t glyph , char *s ,
                                    unsigned int size ) ;
#line 806
extern hb_bool_t hb_font_glyph_from_string(hb_font_t *font , char const   *s , int len ,
                                           hb_codepoint_t *glyph ) ;
#line 818
extern hb_font_t *hb_font_create(hb_face_t *face ) ;
#line 821
extern hb_font_t *hb_font_create_sub_font(hb_font_t *parent ) ;
#line 824
extern hb_font_t *hb_font_get_empty(void) ;
#line 827
extern hb_font_t *hb_font_reference(hb_font_t *font ) ;
#line 830
extern void hb_font_destroy(hb_font_t *font ) ;
#line 833
extern hb_bool_t hb_font_set_user_data(hb_font_t *font , hb_user_data_key_t *key ,
                                       void *data , hb_destroy_func_t destroy , hb_bool_t replace ) ;
#line 841
extern void *hb_font_get_user_data(hb_font_t *font , hb_user_data_key_t *key ) ;
#line 845
extern void hb_font_make_immutable(hb_font_t *font ) ;
#line 848
extern hb_bool_t hb_font_is_immutable(hb_font_t *font ) ;
#line 851
extern void hb_font_set_parent(hb_font_t *font , hb_font_t *parent ) ;
#line 855
extern hb_font_t *hb_font_get_parent(hb_font_t *font ) ;
#line 858
extern void hb_font_set_face(hb_font_t *font , hb_face_t *face ) ;
#line 862
extern hb_face_t *hb_font_get_face(hb_font_t *font ) ;
#line 866
extern void hb_font_set_funcs(hb_font_t *font , hb_font_funcs_t *klass , void *font_data ,
                              hb_destroy_func_t destroy ) ;
#line 873
extern void hb_font_set_funcs_data(hb_font_t *font , void *font_data , hb_destroy_func_t destroy ) ;
#line 879
extern void hb_font_set_scale(hb_font_t *font , int x_scale , int y_scale ) ;
#line 884
extern void hb_font_get_scale(hb_font_t *font , int *x_scale , int *y_scale ) ;
#line 892
extern void hb_font_set_ppem(hb_font_t *font , unsigned int x_ppem , unsigned int y_ppem ) ;
#line 897
extern void hb_font_get_ppem(hb_font_t *font , unsigned int *x_ppem , unsigned int *y_ppem ) ;
#line 906
extern void hb_font_set_ptem(hb_font_t *font , float ptem ) ;
#line 909
extern float hb_font_get_ptem(hb_font_t *font ) ;
#line 912
extern void hb_font_set_variations(hb_font_t *font , hb_variation_t *variations ,
                                   unsigned int variations_length ) ;
#line 917
extern void hb_font_set_var_coords_design(hb_font_t *font , float const   *coords ,
                                          unsigned int coords_length ) ;
#line 928
extern void hb_font_set_var_coords_normalized(hb_font_t *font , int const   *coords ,
                                              unsigned int coords_length ) ;
#line 933
extern int const   *hb_font_get_var_coords_normalized(hb_font_t *font , unsigned int *length ) ;
#line 937
extern void hb_font_set_var_named_instance(hb_font_t *font , unsigned int instance_index ) ;
#line 102 "/usr/include/harfbuzz/hb-buffer.h"
extern hb_glyph_flags_t hb_glyph_info_get_glyph_flags(hb_glyph_info_t *info ) ;
#line 160
extern hb_bool_t hb_segment_properties_equal(hb_segment_properties_t *a , hb_segment_properties_t *b ) ;
#line 164
extern unsigned int hb_segment_properties_hash(hb_segment_properties_t *p ) ;
#line 178
extern hb_buffer_t *hb_buffer_create(void) ;
#line 181
extern hb_buffer_t *hb_buffer_get_empty(void) ;
#line 184
extern hb_buffer_t *hb_buffer_reference(hb_buffer_t *buffer ) ;
#line 187
extern void hb_buffer_destroy(hb_buffer_t *buffer ) ;
#line 190
extern hb_bool_t hb_buffer_set_user_data(hb_buffer_t *buffer , hb_user_data_key_t *key ,
                                         void *data , hb_destroy_func_t destroy ,
                                         hb_bool_t replace ) ;
#line 197
extern void *hb_buffer_get_user_data(hb_buffer_t *buffer , hb_user_data_key_t *key ) ;
#line 214
extern void hb_buffer_set_content_type(hb_buffer_t *buffer , hb_buffer_content_type_t content_type ) ;
#line 218
extern hb_buffer_content_type_t hb_buffer_get_content_type(hb_buffer_t *buffer ) ;
#line 222
extern void hb_buffer_set_unicode_funcs(hb_buffer_t *buffer , hb_unicode_funcs_t *unicode_funcs ) ;
#line 226
extern hb_unicode_funcs_t *hb_buffer_get_unicode_funcs(hb_buffer_t *buffer ) ;
#line 229
extern void hb_buffer_set_direction(hb_buffer_t *buffer , hb_direction_t direction ) ;
#line 233
extern hb_direction_t hb_buffer_get_direction(hb_buffer_t *buffer ) ;
#line 236
extern void hb_buffer_set_script(hb_buffer_t *buffer , hb_script_t script ) ;
#line 240
extern hb_script_t hb_buffer_get_script(hb_buffer_t *buffer ) ;
#line 243
extern void hb_buffer_set_language(hb_buffer_t *buffer , hb_language_t language ) ;
#line 248
extern hb_language_t hb_buffer_get_language(hb_buffer_t *buffer ) ;
#line 251
extern void hb_buffer_set_segment_properties(hb_buffer_t *buffer , hb_segment_properties_t *props ) ;
#line 255
extern void hb_buffer_get_segment_properties(hb_buffer_t *buffer , hb_segment_properties_t *props ) ;
#line 259
extern void hb_buffer_guess_segment_properties(hb_buffer_t *buffer ) ;
#line 303
extern void hb_buffer_set_flags(hb_buffer_t *buffer , hb_buffer_flags_t flags ) ;
#line 307
extern hb_buffer_flags_t hb_buffer_get_flags(hb_buffer_t *buffer ) ;
#line 345
extern void hb_buffer_set_cluster_level(hb_buffer_t *buffer , hb_buffer_cluster_level_t cluster_level ) ;
#line 349
extern hb_buffer_cluster_level_t hb_buffer_get_cluster_level(hb_buffer_t *buffer ) ;
#line 362
extern void hb_buffer_set_replacement_codepoint(hb_buffer_t *buffer , hb_codepoint_t replacement ) ;
#line 366
extern hb_codepoint_t hb_buffer_get_replacement_codepoint(hb_buffer_t *buffer ) ;
#line 369
extern void hb_buffer_set_invisible_glyph(hb_buffer_t *buffer , hb_codepoint_t invisible ) ;
#line 373
extern hb_codepoint_t hb_buffer_get_invisible_glyph(hb_buffer_t *buffer ) ;
#line 377
extern void hb_buffer_reset(hb_buffer_t *buffer ) ;
#line 380
extern void hb_buffer_clear_contents(hb_buffer_t *buffer ) ;
#line 383
extern hb_bool_t hb_buffer_pre_allocate(hb_buffer_t *buffer , unsigned int size ) ;
#line 388
extern hb_bool_t hb_buffer_allocation_successful(hb_buffer_t *buffer ) ;
#line 391
extern void hb_buffer_reverse(hb_buffer_t *buffer ) ;
#line 394
extern void hb_buffer_reverse_range(hb_buffer_t *buffer , unsigned int start , unsigned int end ) ;
#line 398
extern void hb_buffer_reverse_clusters(hb_buffer_t *buffer ) ;
#line 404
extern void hb_buffer_add(hb_buffer_t *buffer , hb_codepoint_t codepoint , unsigned int cluster ) ;
#line 409
extern void hb_buffer_add_utf8(hb_buffer_t *buffer , char const   *text , int text_length ,
                               unsigned int item_offset , int item_length ) ;
#line 416
extern void hb_buffer_add_utf16(hb_buffer_t *buffer , uint16_t *text , int text_length ,
                                unsigned int item_offset , int item_length ) ;
#line 423
extern void hb_buffer_add_utf32(hb_buffer_t *buffer , uint32_t *text , int text_length ,
                                unsigned int item_offset , int item_length ) ;
#line 430
extern void hb_buffer_add_latin1(hb_buffer_t *buffer , uint8_t *text , int text_length ,
                                 unsigned int item_offset , int item_length ) ;
#line 437
extern void hb_buffer_add_codepoints(hb_buffer_t *buffer , hb_codepoint_t *text ,
                                     int text_length , unsigned int item_offset ,
                                     int item_length ) ;
#line 444
extern void hb_buffer_append(hb_buffer_t *buffer , hb_buffer_t *source , unsigned int start ,
                             unsigned int end ) ;
#line 450
extern hb_bool_t hb_buffer_set_length(hb_buffer_t *buffer , unsigned int length ) ;
#line 454
extern unsigned int hb_buffer_get_length(hb_buffer_t *buffer ) ;
#line 459
extern hb_glyph_info_t *hb_buffer_get_glyph_infos(hb_buffer_t *buffer , unsigned int *length ) ;
#line 463
extern hb_glyph_position_t *hb_buffer_get_glyph_positions(hb_buffer_t *buffer , unsigned int *length ) ;
#line 467
extern hb_bool_t hb_buffer_has_positions(hb_buffer_t *buffer ) ;
#line 471
extern void hb_buffer_normalize_glyphs(hb_buffer_t *buffer ) ;
#line 521
extern hb_buffer_serialize_format_t hb_buffer_serialize_format_from_string(char const   *str ,
                                                                           int len ) ;
#line 524
extern char const   *hb_buffer_serialize_format_to_string(hb_buffer_serialize_format_t format ) ;
#line 527
extern char const   **hb_buffer_serialize_list_formats(void) ;
#line 530
extern unsigned int hb_buffer_serialize_glyphs(hb_buffer_t *buffer , unsigned int start ,
                                               unsigned int end , char *buf , unsigned int buf_size ,
                                               unsigned int *buf_consumed , hb_font_t *font ,
                                               hb_buffer_serialize_format_t format ,
                                               hb_buffer_serialize_flags_t flags ) ;
#line 541
extern unsigned int hb_buffer_serialize_unicode(hb_buffer_t *buffer , unsigned int start ,
                                                unsigned int end , char *buf , unsigned int buf_size ,
                                                unsigned int *buf_consumed , hb_buffer_serialize_format_t format ,
                                                hb_buffer_serialize_flags_t flags ) ;
#line 551
extern unsigned int hb_buffer_serialize(hb_buffer_t *buffer , unsigned int start ,
                                        unsigned int end , char *buf , unsigned int buf_size ,
                                        unsigned int *buf_consumed , hb_font_t *font ,
                                        hb_buffer_serialize_format_t format , hb_buffer_serialize_flags_t flags ) ;
#line 562
extern hb_bool_t hb_buffer_deserialize_glyphs(hb_buffer_t *buffer , char const   *buf ,
                                              int buf_len , char const   **end_ptr ,
                                              hb_font_t *font , hb_buffer_serialize_format_t format ) ;
#line 570
extern hb_bool_t hb_buffer_deserialize_unicode(hb_buffer_t *buffer , char const   *buf ,
                                               int buf_len , char const   **end_ptr ,
                                               hb_buffer_serialize_format_t format ) ;
#line 611
extern hb_buffer_diff_flags_t hb_buffer_diff(hb_buffer_t *buffer , hb_buffer_t *reference ,
                                             hb_codepoint_t dottedcircle_glyph , unsigned int position_fuzz ) ;
#line 627
extern void hb_buffer_set_message_func(hb_buffer_t *buffer , hb_buffer_message_func_t func ,
                                       void *user_data , hb_destroy_func_t destroy ) ;
#line 67 "/usr/include/harfbuzz/hb-deprecated.h"
extern void hb_font_funcs_set_glyph_func(hb_font_funcs_t *ffuncs , hb_font_get_glyph_func_t func ,
                                         void *user_data , hb_destroy_func_t destroy ) ;
#line 72
extern void hb_set_invert(hb_set_t *set ) ;
#line 96
extern void hb_unicode_funcs_set_eastasian_width_func(hb_unicode_funcs_t *ufuncs ,
                                                      hb_unicode_eastasian_width_func_t func ,
                                                      void *user_data , hb_destroy_func_t destroy ) ;
#line 107
extern unsigned int hb_unicode_eastasian_width(hb_unicode_funcs_t *ufuncs , hb_codepoint_t unicode ) ;
#line 158
extern void hb_unicode_funcs_set_decompose_compatibility_func(hb_unicode_funcs_t *ufuncs ,
                                                              hb_unicode_decompose_compatibility_func_t func ,
                                                              void *user_data , hb_destroy_func_t destroy ) ;
#line 163
extern unsigned int hb_unicode_decompose_compatibility(hb_unicode_funcs_t *ufuncs ,
                                                       hb_codepoint_t u , hb_codepoint_t *decomposed ) ;
#line 183
extern void hb_font_funcs_set_glyph_v_kerning_func(hb_font_funcs_t *ffuncs , hb_font_get_glyph_v_kerning_func_t func ,
                                                   void *user_data , hb_destroy_func_t destroy ) ;
#line 188
extern hb_position_t hb_font_get_glyph_v_kerning(hb_font_t *font , hb_codepoint_t top_glyph ,
                                                 hb_codepoint_t bottom_glyph ) ;
#line 54 "/usr/include/harfbuzz/hb-map.h"
extern hb_map_t *hb_map_create(void) ;
#line 57
extern hb_map_t *hb_map_get_empty(void) ;
#line 60
extern hb_map_t *hb_map_reference(hb_map_t *map ) ;
#line 63
extern void hb_map_destroy(hb_map_t *map ) ;
#line 66
extern hb_bool_t hb_map_set_user_data(hb_map_t *map , hb_user_data_key_t *key , void *data ,
                                      hb_destroy_func_t destroy , hb_bool_t replace ) ;
#line 73
extern void *hb_map_get_user_data(hb_map_t *map , hb_user_data_key_t *key ) ;
#line 79
extern hb_bool_t hb_map_allocation_successful(hb_map_t *map ) ;
#line 82
extern void hb_map_clear(hb_map_t *map ) ;
#line 85
extern hb_bool_t hb_map_is_empty(hb_map_t *map ) ;
#line 88
extern unsigned int hb_map_get_population(hb_map_t *map ) ;
#line 91
extern void hb_map_set(hb_map_t *map , hb_codepoint_t key , hb_codepoint_t value ) ;
#line 96
extern hb_codepoint_t hb_map_get(hb_map_t *map , hb_codepoint_t key ) ;
#line 100
extern void hb_map_del(hb_map_t *map , hb_codepoint_t key ) ;
#line 104
extern hb_bool_t hb_map_has(hb_map_t *map , hb_codepoint_t key ) ;
#line 44 "/usr/include/harfbuzz/hb-shape.h"
extern void hb_shape(hb_font_t *font , hb_buffer_t *buffer , hb_feature_t *features ,
                     unsigned int num_features ) ;
#line 50
extern hb_bool_t hb_shape_full(hb_font_t *font , hb_buffer_t *buffer , hb_feature_t *features ,
                               unsigned int num_features , char const   * const  *shaper_list ) ;
#line 57
extern char const   **hb_shape_list_shapers(void) ;
#line 56 "/usr/include/harfbuzz/hb-shape-plan.h"
extern hb_shape_plan_t *hb_shape_plan_create(hb_face_t *face , hb_segment_properties_t *props ,
                                             hb_feature_t *user_features , unsigned int num_user_features ,
                                             char const   * const  *shaper_list ) ;
#line 63
extern hb_shape_plan_t *hb_shape_plan_create_cached(hb_face_t *face , hb_segment_properties_t *props ,
                                                    hb_feature_t *user_features ,
                                                    unsigned int num_user_features ,
                                                    char const   * const  *shaper_list ) ;
#line 70
extern hb_shape_plan_t *hb_shape_plan_create2(hb_face_t *face , hb_segment_properties_t *props ,
                                              hb_feature_t *user_features , unsigned int num_user_features ,
                                              int const   *coords , unsigned int num_coords ,
                                              char const   * const  *shaper_list ) ;
#line 79
extern hb_shape_plan_t *hb_shape_plan_create_cached2(hb_face_t *face , hb_segment_properties_t *props ,
                                                     hb_feature_t *user_features ,
                                                     unsigned int num_user_features ,
                                                     int const   *coords , unsigned int num_coords ,
                                                     char const   * const  *shaper_list ) ;
#line 89
extern hb_shape_plan_t *hb_shape_plan_get_empty(void) ;
#line 92
extern hb_shape_plan_t *hb_shape_plan_reference(hb_shape_plan_t *shape_plan ) ;
#line 95
extern void hb_shape_plan_destroy(hb_shape_plan_t *shape_plan ) ;
#line 98
extern hb_bool_t hb_shape_plan_set_user_data(hb_shape_plan_t *shape_plan , hb_user_data_key_t *key ,
                                             void *data , hb_destroy_func_t destroy ,
                                             hb_bool_t replace ) ;
#line 105
extern void *hb_shape_plan_get_user_data(hb_shape_plan_t *shape_plan , hb_user_data_key_t *key ) ;
#line 110
extern hb_bool_t hb_shape_plan_execute(hb_shape_plan_t *shape_plan , hb_font_t *font ,
                                       hb_buffer_t *buffer , hb_feature_t *features ,
                                       unsigned int num_features ) ;
#line 117
extern char const   *hb_shape_plan_get_shaper(hb_shape_plan_t *shape_plan ) ;
#line 51 "/usr/include/harfbuzz/hb-version.h"
extern void hb_version(unsigned int *major , unsigned int *minor , unsigned int *micro ) ;
#line 56
extern char const   *hb_version_string(void) ;
#line 59
extern hb_bool_t hb_version_atleast(unsigned int major , unsigned int minor , unsigned int micro ) ;
#line 75 "/usr/include/pango-1.0/pango/pango-coverage.h"
extern GType pango_coverage_get_type(void) ;
#line 78
extern PangoCoverage *pango_coverage_new(void) ;
#line 80
extern PangoCoverage *pango_coverage_ref(PangoCoverage *coverage ) ;
#line 82
extern void pango_coverage_unref(PangoCoverage *coverage ) ;
#line 84
extern PangoCoverage *pango_coverage_copy(PangoCoverage *coverage ) ;
#line 86
extern PangoCoverageLevel pango_coverage_get(PangoCoverage *coverage , int index_ ) ;
#line 89
extern void pango_coverage_set(PangoCoverage *coverage , int index_ , PangoCoverageLevel level ) ;
#line 93
extern void pango_coverage_max(PangoCoverage *coverage , PangoCoverage *other ) ;
#line 97
extern void pango_coverage_to_bytes(PangoCoverage *coverage , guchar **bytes , int *n_bytes ) ;
#line 101
extern PangoCoverage *pango_coverage_from_bytes(guchar *bytes , int n_bytes ) ;
#line 104 "/usr/include/pango-1.0/pango/pango-coverage.h"
__inline static void glib_autoptr_clear_PangoCoverage(PangoCoverage *_ptr ) 
{ 


  {
#line 104
  if (_ptr) {
    {
#line 104
    g_object_unref((PangoCoverage *)_ptr);
    }
  }
  return;
}
}
#line 104 "/usr/include/pango-1.0/pango/pango-coverage.h"
__inline static void glib_autoptr_cleanup_PangoCoverage(PangoCoverage **_ptr ) 
{ 


  {
  {
#line 104
  glib_autoptr_clear_PangoCoverage(*_ptr);
  }
  return;
}
}
#line 150 "/usr/include/pango-1.0/pango/pango-types.h"
extern int pango_units_from_double(double d ) ;
#line 152
extern double pango_units_to_double(int i ) ;
#line 231
extern void pango_extents_to_pixels(PangoRectangle *inclusive , PangoRectangle *nearest ) ;
#line 84 "/usr/include/pango-1.0/pango/pango-matrix.h"
extern GType pango_matrix_get_type(void) ;
#line 87
extern PangoMatrix *pango_matrix_copy(PangoMatrix *matrix ) ;
#line 89
extern void pango_matrix_free(PangoMatrix *matrix ) ;
#line 92
extern void pango_matrix_translate(PangoMatrix *matrix , double tx , double ty ) ;
#line 96
extern void pango_matrix_scale(PangoMatrix *matrix , double scale_x , double scale_y ) ;
#line 100
extern void pango_matrix_rotate(PangoMatrix *matrix , double degrees ) ;
#line 103
extern void pango_matrix_concat(PangoMatrix *matrix , PangoMatrix *new_matrix ) ;
#line 106
extern void pango_matrix_transform_point(PangoMatrix *matrix , double *x , double *y ) ;
#line 110
extern void pango_matrix_transform_distance(PangoMatrix *matrix , double *dx , double *dy ) ;
#line 114
extern void pango_matrix_transform_rectangle(PangoMatrix *matrix , PangoRectangle *rect ) ;
#line 117
extern void pango_matrix_transform_pixel_rectangle(PangoMatrix *matrix , PangoRectangle *rect ) ;
#line 120
extern double pango_matrix_get_font_scale_factor(PangoMatrix *matrix ) ;
#line 122
extern void pango_matrix_get_font_scale_factors(PangoMatrix *matrix , double *xscale ,
                                                double *yscale ) ;
#line 125
extern double pango_matrix_get_slant_ratio(PangoMatrix *matrix ) ;
#line 310 "/usr/include/pango-1.0/pango/pango-script.h"
extern PangoScript pango_script_for_unichar(gunichar ch ) ;
#line 313
extern GType pango_script_iter_get_type(void) ;
#line 316
extern PangoScriptIter *pango_script_iter_new(char const   *text , int length ) ;
#line 319
extern void pango_script_iter_get_range(PangoScriptIter *iter , char const   **start ,
                                        char const   **end , PangoScript *script ) ;
#line 324
extern gboolean pango_script_iter_next(PangoScriptIter *iter ) ;
#line 326
extern void pango_script_iter_free(PangoScriptIter *iter ) ;
#line 37 "/usr/include/pango-1.0/pango/pango-language.h"
extern GType pango_language_get_type(void) ;
#line 40
extern PangoLanguage *pango_language_get_default(void) ;
#line 43
extern PangoLanguage **pango_language_get_preferred(void) ;
#line 46
extern PangoLanguage *pango_language_from_string(char const   *language ) ;
#line 49
extern char const   *pango_language_to_string(PangoLanguage *language ) ;
#line 55
extern char const   *pango_language_get_sample_string(PangoLanguage *language ) ;
#line 58
extern gboolean pango_language_matches(PangoLanguage *language , char const   *range_list ) ;
#line 62
extern gboolean pango_language_includes_script(PangoLanguage *language , PangoScript script ) ;
#line 65
extern PangoScript *pango_language_get_scripts(PangoLanguage *language , int *num_scripts ) ;
#line 331 "/usr/include/pango-1.0/pango/pango-script.h"
extern PangoLanguage *pango_script_get_sample_language(PangoScript script ) ;
#line 120 "/usr/include/pango-1.0/pango/pango-gravity.h"
extern double pango_gravity_to_rotation(PangoGravity gravity ) ;
#line 122
extern PangoGravity pango_gravity_get_for_matrix(PangoMatrix *matrix ) ;
#line 124
extern PangoGravity pango_gravity_get_for_script(PangoScript script , PangoGravity base_gravity ,
                                                 PangoGravityHint hint ) ;
#line 128
extern PangoGravity pango_gravity_get_for_script_and_width(PangoScript script , gboolean wide ,
                                                           PangoGravity base_gravity ,
                                                           PangoGravityHint hint ) ;
#line 102 "/usr/include/pango-1.0/pango/pango-bidi-type.h"
extern PangoBidiType pango_bidi_type_for_unichar(gunichar ch ) ;
#line 105
extern PangoDirection pango_unichar_direction(gunichar ch ) ;
#line 107
extern PangoDirection pango_find_base_dir(gchar *text , gint length ) ;
#line 111
extern gboolean pango_get_mirror_char(gunichar ch , gunichar *mirrored_ch ) ;
#line 248 "/usr/include/pango-1.0/pango/pango-font.h"
extern GType pango_font_description_get_type(void) ;
#line 250
extern PangoFontDescription *pango_font_description_new(void) ;
#line 252
extern PangoFontDescription *pango_font_description_copy(PangoFontDescription *desc ) ;
#line 254
extern PangoFontDescription *pango_font_description_copy_static(PangoFontDescription *desc ) ;
#line 256
extern guint pango_font_description_hash(PangoFontDescription *desc ) ;
#line 258
extern gboolean pango_font_description_equal(PangoFontDescription *desc1 , PangoFontDescription *desc2 ) ;
#line 261
extern void pango_font_description_free(PangoFontDescription *desc ) ;
#line 263
extern void pango_font_descriptions_free(PangoFontDescription **descs , int n_descs ) ;
#line 267
extern void pango_font_description_set_family(PangoFontDescription *desc , char const   *family ) ;
#line 270
extern void pango_font_description_set_family_static(PangoFontDescription *desc ,
                                                     char const   *family ) ;
#line 273
extern char const   *pango_font_description_get_family(PangoFontDescription *desc ) ;
#line 275
extern void pango_font_description_set_style(PangoFontDescription *desc , PangoStyle style ) ;
#line 278
extern PangoStyle pango_font_description_get_style(PangoFontDescription *desc ) ;
#line 280
extern void pango_font_description_set_variant(PangoFontDescription *desc , PangoVariant variant ) ;
#line 283
extern PangoVariant pango_font_description_get_variant(PangoFontDescription *desc ) ;
#line 285
extern void pango_font_description_set_weight(PangoFontDescription *desc , PangoWeight weight ) ;
#line 288
extern PangoWeight pango_font_description_get_weight(PangoFontDescription *desc ) ;
#line 290
extern void pango_font_description_set_stretch(PangoFontDescription *desc , PangoStretch stretch ) ;
#line 293
extern PangoStretch pango_font_description_get_stretch(PangoFontDescription *desc ) ;
#line 295
extern void pango_font_description_set_size(PangoFontDescription *desc , gint size ) ;
#line 298
extern gint pango_font_description_get_size(PangoFontDescription *desc ) ;
#line 300
extern void pango_font_description_set_absolute_size(PangoFontDescription *desc ,
                                                     double size ) ;
#line 303
extern gboolean pango_font_description_get_size_is_absolute(PangoFontDescription *desc ) ;
#line 305
extern void pango_font_description_set_gravity(PangoFontDescription *desc , PangoGravity gravity ) ;
#line 308
extern PangoGravity pango_font_description_get_gravity(PangoFontDescription *desc ) ;
#line 311
extern void pango_font_description_set_variations_static(PangoFontDescription *desc ,
                                                         char const   *variations ) ;
#line 314
extern void pango_font_description_set_variations(PangoFontDescription *desc , char const   *variations ) ;
#line 317
extern char const   *pango_font_description_get_variations(PangoFontDescription *desc ) ;
#line 320
extern PangoFontMask pango_font_description_get_set_fields(PangoFontDescription *desc ) ;
#line 322
extern void pango_font_description_unset_fields(PangoFontDescription *desc , PangoFontMask to_unset ) ;
#line 326
extern void pango_font_description_merge(PangoFontDescription *desc , PangoFontDescription *desc_to_merge ,
                                         gboolean replace_existing ) ;
#line 330
extern void pango_font_description_merge_static(PangoFontDescription *desc , PangoFontDescription *desc_to_merge ,
                                                gboolean replace_existing ) ;
#line 335
extern gboolean pango_font_description_better_match(PangoFontDescription *desc , PangoFontDescription *old_match ,
                                                    PangoFontDescription *new_match ) ;
#line 340
extern PangoFontDescription *pango_font_description_from_string(char const   *str ) ;
#line 342
extern char *pango_font_description_to_string(PangoFontDescription *desc ) ;
#line 344
extern char *pango_font_description_to_filename(PangoFontDescription *desc ) ;
#line 369
extern GType pango_font_metrics_get_type(void) ;
#line 371
extern PangoFontMetrics *pango_font_metrics_ref(PangoFontMetrics *metrics ) ;
#line 373
extern void pango_font_metrics_unref(PangoFontMetrics *metrics ) ;
#line 375
extern int pango_font_metrics_get_ascent(PangoFontMetrics *metrics ) ;
#line 377
extern int pango_font_metrics_get_descent(PangoFontMetrics *metrics ) ;
#line 379
extern int pango_font_metrics_get_height(PangoFontMetrics *metrics ) ;
#line 381
extern int pango_font_metrics_get_approximate_char_width(PangoFontMetrics *metrics ) ;
#line 383
extern int pango_font_metrics_get_approximate_digit_width(PangoFontMetrics *metrics ) ;
#line 385
extern int pango_font_metrics_get_underline_position(PangoFontMetrics *metrics ) ;
#line 387
extern int pango_font_metrics_get_underline_thickness(PangoFontMetrics *metrics ) ;
#line 389
extern int pango_font_metrics_get_strikethrough_position(PangoFontMetrics *metrics ) ;
#line 391
extern int pango_font_metrics_get_strikethrough_thickness(PangoFontMetrics *metrics ) ;
#line 451
extern GType pango_font_family_get_type(void) ;
#line 454
extern void pango_font_family_list_faces(PangoFontFamily *family , PangoFontFace ***faces ,
                                         int *n_faces ) ;
#line 458
extern char const   *pango_font_family_get_name(PangoFontFamily *family ) ;
#line 460
extern gboolean pango_font_family_is_monospace(PangoFontFamily *family ) ;
#line 462
extern gboolean pango_font_family_is_variable(PangoFontFamily *family ) ;
#line 465
extern PangoFontFace *pango_font_family_get_face(PangoFontFamily *family , char const   *name ) ;
#line 519
extern GType pango_font_face_get_type(void) ;
#line 522
extern PangoFontDescription *pango_font_face_describe(PangoFontFace *face ) ;
#line 524
extern char const   *pango_font_face_get_face_name(PangoFontFace *face ) ;
#line 526
extern void pango_font_face_list_sizes(PangoFontFace *face , int **sizes , int *n_sizes ) ;
#line 530
extern gboolean pango_font_face_is_synthesized(PangoFontFace *face ) ;
#line 533
extern PangoFontFamily *pango_font_face_get_family(PangoFontFace *face ) ;
#line 589
extern GType pango_font_get_type(void) ;
#line 592
extern PangoFontDescription *pango_font_describe(PangoFont *font ) ;
#line 594
extern PangoFontDescription *pango_font_describe_with_absolute_size(PangoFont *font ) ;
#line 596
extern PangoCoverage *pango_font_get_coverage(PangoFont *font , PangoLanguage *language ) ;
#line 600
extern PangoEngineShape *pango_font_find_shaper(PangoFont *font , PangoLanguage *language ,
                                                guint32 ch ) ;
#line 605
extern PangoFontMetrics *pango_font_get_metrics(PangoFont *font , PangoLanguage *language ) ;
#line 608
extern void pango_font_get_glyph_extents(PangoFont *font , PangoGlyph glyph , PangoRectangle *ink_rect ,
                                         PangoRectangle *logical_rect ) ;
#line 613
extern PangoFontMap *pango_font_get_font_map(PangoFont *font ) ;
#line 616
extern PangoFontFace *pango_font_get_face(PangoFont *font ) ;
#line 619
extern gboolean pango_font_has_char(PangoFont *font , gunichar wc ) ;
#line 622
extern void pango_font_get_features(PangoFont *font , hb_feature_t *features , guint len ,
                                    guint *num_features ) ;
#line 627
extern hb_font_t *pango_font_get_hb_font(PangoFont *font ) ;
#line 630
extern PangoLanguage **pango_font_get_languages(PangoFont *font ) ;
#line 633
extern GBytes *pango_font_serialize(PangoFont *font ) ;
#line 636
extern PangoFont *pango_font_deserialize(PangoContext *context , GBytes *bytes , GError **error ) ;
#line 692 "/usr/include/pango-1.0/pango/pango-font.h"
__inline static void glib_autoptr_clear_PangoFontFamily(PangoFontFamily *_ptr ) 
{ 


  {
#line 692
  if (_ptr) {
    {
#line 692
    g_object_unref((PangoFontFamily *)_ptr);
    }
  }
  return;
}
}
#line 692 "/usr/include/pango-1.0/pango/pango-font.h"
__inline static void glib_autoptr_cleanup_PangoFontFamily(PangoFontFamily **_ptr ) 
{ 


  {
  {
#line 692
  glib_autoptr_clear_PangoFontFamily(*_ptr);
  }
  return;
}
}
#line 693 "/usr/include/pango-1.0/pango/pango-font.h"
__inline static void glib_autoptr_clear_PangoFontFace(PangoFontFace *_ptr ) 
{ 


  {
#line 693
  if (_ptr) {
    {
#line 693
    g_object_unref((PangoFontFace *)_ptr);
    }
  }
  return;
}
}
#line 693 "/usr/include/pango-1.0/pango/pango-font.h"
__inline static void glib_autoptr_cleanup_PangoFontFace(PangoFontFace **_ptr ) 
{ 


  {
  {
#line 693
  glib_autoptr_clear_PangoFontFace(*_ptr);
  }
  return;
}
}
#line 694 "/usr/include/pango-1.0/pango/pango-font.h"
__inline static void glib_autoptr_clear_PangoFont(PangoFont *_ptr ) 
{ 


  {
#line 694
  if (_ptr) {
    {
#line 694
    g_object_unref((PangoFont *)_ptr);
    }
  }
  return;
}
}
#line 694 "/usr/include/pango-1.0/pango/pango-font.h"
__inline static void glib_autoptr_cleanup_PangoFont(PangoFont **_ptr ) 
{ 


  {
  {
#line 694
  glib_autoptr_clear_PangoFont(*_ptr);
  }
  return;
}
}
#line 695 "/usr/include/pango-1.0/pango/pango-font.h"
__inline static void glib_autoptr_clear_PangoFontDescription(PangoFontDescription *_ptr ) 
{ 


  {
#line 695
  if (_ptr) {
    {
#line 695
    pango_font_description_free((PangoFontDescription *)_ptr);
    }
  }
  return;
}
}
#line 695 "/usr/include/pango-1.0/pango/pango-font.h"
__inline static void glib_autoptr_cleanup_PangoFontDescription(PangoFontDescription **_ptr ) 
{ 


  {
  {
#line 695
  glib_autoptr_clear_PangoFontDescription(*_ptr);
  }
  return;
}
}
#line 695 "/usr/include/pango-1.0/pango/pango-font.h"
__inline static void glib_listautoptr_cleanup_PangoFontDescription(GList **_l ) 
{ 


  {
  {
#line 695
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& pango_font_description_free)));
  }
  return;
}
}
#line 695 "/usr/include/pango-1.0/pango/pango-font.h"
__inline static void glib_slistautoptr_cleanup_PangoFontDescription(GSList **_l ) 
{ 


  {
  {
#line 695
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& pango_font_description_free)));
  }
  return;
}
}
#line 695 "/usr/include/pango-1.0/pango/pango-font.h"
__inline static void glib_queueautoptr_cleanup_PangoFontDescription(GQueue **_q ) 
{ 


  {
#line 695
  if (*_q) {
    {
#line 695
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& pango_font_description_free)));
    }
  }
  return;
}
}
#line 52 "/usr/include/pango-1.0/pango/pango-color.h"
extern GType pango_color_get_type(void) ;
#line 55
extern PangoColor *pango_color_copy(PangoColor *src ) ;
#line 58
extern void pango_color_free(PangoColor *color ) ;
#line 61
extern gboolean pango_color_parse(PangoColor *color , char const   *spec ) ;
#line 65
extern gboolean pango_color_parse_with_alpha(PangoColor *color , guint16 *alpha ,
                                             char const   *spec ) ;
#line 70
extern char *pango_color_to_string(PangoColor *color ) ;
#line 501 "/usr/include/pango-1.0/pango/pango-attributes.h"
extern GType pango_attribute_get_type(void) ;
#line 504
extern PangoAttrType pango_attr_type_register(char const   *name ) ;
#line 506
extern char const   *pango_attr_type_get_name(PangoAttrType type ) ;
#line 508
extern void pango_attribute_init(PangoAttribute *attr , PangoAttrClass *klass ) ;
#line 511
extern PangoAttribute *pango_attribute_copy(PangoAttribute *attr ) ;
#line 513
extern void pango_attribute_destroy(PangoAttribute *attr ) ;
#line 515
extern gboolean pango_attribute_equal(PangoAttribute *attr1 , PangoAttribute *attr2 ) ;
#line 519
extern PangoAttribute *pango_attr_language_new(PangoLanguage *language ) ;
#line 521
extern PangoAttribute *pango_attr_family_new(char const   *family ) ;
#line 523
extern PangoAttribute *pango_attr_foreground_new(guint16 red , guint16 green , guint16 blue ) ;
#line 527
extern PangoAttribute *pango_attr_background_new(guint16 red , guint16 green , guint16 blue ) ;
#line 531
extern PangoAttribute *pango_attr_size_new(int size ) ;
#line 533
extern PangoAttribute *pango_attr_size_new_absolute(int size ) ;
#line 535
extern PangoAttribute *pango_attr_style_new(PangoStyle style ) ;
#line 537
extern PangoAttribute *pango_attr_weight_new(PangoWeight weight ) ;
#line 539
extern PangoAttribute *pango_attr_variant_new(PangoVariant variant ) ;
#line 541
extern PangoAttribute *pango_attr_stretch_new(PangoStretch stretch ) ;
#line 543
extern PangoAttribute *pango_attr_font_desc_new(PangoFontDescription *desc ) ;
#line 546
extern PangoAttribute *pango_attr_underline_new(PangoUnderline underline ) ;
#line 548
extern PangoAttribute *pango_attr_underline_color_new(guint16 red , guint16 green ,
                                                      guint16 blue ) ;
#line 552
extern PangoAttribute *pango_attr_strikethrough_new(gboolean strikethrough ) ;
#line 554
extern PangoAttribute *pango_attr_strikethrough_color_new(guint16 red , guint16 green ,
                                                          guint16 blue ) ;
#line 558
extern PangoAttribute *pango_attr_rise_new(int rise ) ;
#line 560
extern PangoAttribute *pango_attr_baseline_shift_new(int shift ) ;
#line 562
extern PangoAttribute *pango_attr_font_scale_new(PangoFontScale scale ) ;
#line 564
extern PangoAttribute *pango_attr_scale_new(double scale_factor ) ;
#line 566
extern PangoAttribute *pango_attr_fallback_new(gboolean enable_fallback ) ;
#line 568
extern PangoAttribute *pango_attr_letter_spacing_new(int letter_spacing ) ;
#line 570
extern PangoAttribute *pango_attr_shape_new(PangoRectangle *ink_rect , PangoRectangle *logical_rect ) ;
#line 573
extern PangoAttribute *pango_attr_shape_new_with_data(PangoRectangle *ink_rect , PangoRectangle *logical_rect ,
                                                      gpointer data , PangoAttrDataCopyFunc copy_func ,
                                                      GDestroyNotify destroy_func ) ;
#line 579
extern PangoAttribute *pango_attr_gravity_new(PangoGravity gravity ) ;
#line 581
extern PangoAttribute *pango_attr_gravity_hint_new(PangoGravityHint hint ) ;
#line 583
extern PangoAttribute *pango_attr_font_features_new(char const   *features ) ;
#line 585
extern PangoAttribute *pango_attr_foreground_alpha_new(guint16 alpha ) ;
#line 587
extern PangoAttribute *pango_attr_background_alpha_new(guint16 alpha ) ;
#line 589
extern PangoAttribute *pango_attr_allow_breaks_new(gboolean allow_breaks ) ;
#line 592
extern PangoAttribute *pango_attr_word_new(void) ;
#line 594
extern PangoAttribute *pango_attr_sentence_new(void) ;
#line 597
extern PangoAttribute *pango_attr_insert_hyphens_new(gboolean insert_hyphens ) ;
#line 599
extern PangoAttribute *pango_attr_overline_new(PangoOverline overline ) ;
#line 601
extern PangoAttribute *pango_attr_overline_color_new(guint16 red , guint16 green ,
                                                     guint16 blue ) ;
#line 605
extern PangoAttribute *pango_attr_show_new(PangoShowFlags flags ) ;
#line 607
extern PangoAttribute *pango_attr_line_height_new(double factor ) ;
#line 609
extern PangoAttribute *pango_attr_line_height_new_absolute(int height ) ;
#line 611
extern PangoAttribute *pango_attr_text_transform_new(PangoTextTransform transform ) ;
#line 614
extern PangoAttrString *pango_attribute_as_string(PangoAttribute *attr ) ;
#line 616
extern PangoAttrLanguage *pango_attribute_as_language(PangoAttribute *attr ) ;
#line 618
extern PangoAttrInt *pango_attribute_as_int(PangoAttribute *attr ) ;
#line 620
extern PangoAttrSize *pango_attribute_as_size(PangoAttribute *attr ) ;
#line 622
extern PangoAttrFloat *pango_attribute_as_float(PangoAttribute *attr ) ;
#line 624
extern PangoAttrColor *pango_attribute_as_color(PangoAttribute *attr ) ;
#line 626
extern PangoAttrFontDesc *pango_attribute_as_font_desc(PangoAttribute *attr ) ;
#line 628
extern PangoAttrShape *pango_attribute_as_shape(PangoAttribute *attr ) ;
#line 630
extern PangoAttrFontFeatures *pango_attribute_as_font_features(PangoAttribute *attr ) ;
#line 668
extern GType pango_attr_list_get_type(void) ;
#line 671
extern PangoAttrList *pango_attr_list_new(void) ;
#line 673
extern PangoAttrList *pango_attr_list_ref(PangoAttrList *list ) ;
#line 675
extern void pango_attr_list_unref(PangoAttrList *list ) ;
#line 677
extern PangoAttrList *pango_attr_list_copy(PangoAttrList *list ) ;
#line 679
extern void pango_attr_list_insert(PangoAttrList *list , PangoAttribute *attr ) ;
#line 682
extern void pango_attr_list_insert_before(PangoAttrList *list , PangoAttribute *attr ) ;
#line 685
extern void pango_attr_list_change(PangoAttrList *list , PangoAttribute *attr ) ;
#line 688
extern void pango_attr_list_splice(PangoAttrList *list , PangoAttrList *other , int pos ,
                                   int len ) ;
#line 693
extern void pango_attr_list_update(PangoAttrList *list , int pos , int remove , int add ) ;
#line 699
extern PangoAttrList *pango_attr_list_filter(PangoAttrList *list , PangoAttrFilterFunc func ,
                                             gpointer data ) ;
#line 704
extern GSList *pango_attr_list_get_attributes(PangoAttrList *list ) ;
#line 707
extern gboolean pango_attr_list_equal(PangoAttrList *list , PangoAttrList *other_list ) ;
#line 711
extern char *pango_attr_list_to_string(PangoAttrList *list ) ;
#line 713
extern PangoAttrList *pango_attr_list_from_string(char const   *text ) ;
#line 716
extern GType pango_attr_iterator_get_type(void) ;
#line 719
extern PangoAttrIterator *pango_attr_list_get_iterator(PangoAttrList *list ) ;
#line 722
extern void pango_attr_iterator_range(PangoAttrIterator *iterator , int *start , int *end ) ;
#line 726
extern gboolean pango_attr_iterator_next(PangoAttrIterator *iterator ) ;
#line 728
extern PangoAttrIterator *pango_attr_iterator_copy(PangoAttrIterator *iterator ) ;
#line 730
extern void pango_attr_iterator_destroy(PangoAttrIterator *iterator ) ;
#line 732
extern PangoAttribute *pango_attr_iterator_get(PangoAttrIterator *iterator , PangoAttrType type ) ;
#line 735
extern void pango_attr_iterator_get_font(PangoAttrIterator *iterator , PangoFontDescription *desc ,
                                         PangoLanguage **language , GSList **extra_attrs ) ;
#line 740
extern GSList *pango_attr_iterator_get_attrs(PangoAttrIterator *iterator ) ;
#line 742 "/usr/include/pango-1.0/pango/pango-attributes.h"
__inline static void glib_autoptr_clear_PangoAttribute(PangoAttribute *_ptr ) 
{ 


  {
#line 742
  if (_ptr) {
    {
#line 742
    pango_attribute_destroy((PangoAttribute *)_ptr);
    }
  }
  return;
}
}
#line 742 "/usr/include/pango-1.0/pango/pango-attributes.h"
__inline static void glib_autoptr_cleanup_PangoAttribute(PangoAttribute **_ptr ) 
{ 


  {
  {
#line 742
  glib_autoptr_clear_PangoAttribute(*_ptr);
  }
  return;
}
}
#line 742 "/usr/include/pango-1.0/pango/pango-attributes.h"
__inline static void glib_listautoptr_cleanup_PangoAttribute(GList **_l ) 
{ 


  {
  {
#line 742
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& pango_attribute_destroy)));
  }
  return;
}
}
#line 742 "/usr/include/pango-1.0/pango/pango-attributes.h"
__inline static void glib_slistautoptr_cleanup_PangoAttribute(GSList **_l ) 
{ 


  {
  {
#line 742
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& pango_attribute_destroy)));
  }
  return;
}
}
#line 742 "/usr/include/pango-1.0/pango/pango-attributes.h"
__inline static void glib_queueautoptr_cleanup_PangoAttribute(GQueue **_q ) 
{ 


  {
#line 742
  if (*_q) {
    {
#line 742
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& pango_attribute_destroy)));
    }
  }
  return;
}
}
#line 743 "/usr/include/pango-1.0/pango/pango-attributes.h"
__inline static void glib_autoptr_clear_PangoAttrList(PangoAttrList *_ptr ) 
{ 


  {
#line 743
  if (_ptr) {
    {
#line 743
    pango_attr_list_unref((PangoAttrList *)_ptr);
    }
  }
  return;
}
}
#line 743 "/usr/include/pango-1.0/pango/pango-attributes.h"
__inline static void glib_autoptr_cleanup_PangoAttrList(PangoAttrList **_ptr ) 
{ 


  {
  {
#line 743
  glib_autoptr_clear_PangoAttrList(*_ptr);
  }
  return;
}
}
#line 743 "/usr/include/pango-1.0/pango/pango-attributes.h"
__inline static void glib_listautoptr_cleanup_PangoAttrList(GList **_l ) 
{ 


  {
  {
#line 743
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& pango_attr_list_unref)));
  }
  return;
}
}
#line 743 "/usr/include/pango-1.0/pango/pango-attributes.h"
__inline static void glib_slistautoptr_cleanup_PangoAttrList(GSList **_l ) 
{ 


  {
  {
#line 743
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& pango_attr_list_unref)));
  }
  return;
}
}
#line 743 "/usr/include/pango-1.0/pango/pango-attributes.h"
__inline static void glib_queueautoptr_cleanup_PangoAttrList(GQueue **_q ) 
{ 


  {
#line 743
  if (*_q) {
    {
#line 743
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& pango_attr_list_unref)));
    }
  }
  return;
}
}
#line 744 "/usr/include/pango-1.0/pango/pango-attributes.h"
__inline static void glib_autoptr_clear_PangoAttrIterator(PangoAttrIterator *_ptr ) 
{ 


  {
#line 744
  if (_ptr) {
    {
#line 744
    pango_attr_iterator_destroy((PangoAttrIterator *)_ptr);
    }
  }
  return;
}
}
#line 744 "/usr/include/pango-1.0/pango/pango-attributes.h"
__inline static void glib_autoptr_cleanup_PangoAttrIterator(PangoAttrIterator **_ptr ) 
{ 


  {
  {
#line 744
  glib_autoptr_clear_PangoAttrIterator(*_ptr);
  }
  return;
}
}
#line 744 "/usr/include/pango-1.0/pango/pango-attributes.h"
__inline static void glib_listautoptr_cleanup_PangoAttrIterator(GList **_l ) 
{ 


  {
  {
#line 744
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& pango_attr_iterator_destroy)));
  }
  return;
}
}
#line 744 "/usr/include/pango-1.0/pango/pango-attributes.h"
__inline static void glib_slistautoptr_cleanup_PangoAttrIterator(GSList **_l ) 
{ 


  {
  {
#line 744
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& pango_attr_iterator_destroy)));
  }
  return;
}
}
#line 744 "/usr/include/pango-1.0/pango/pango-attributes.h"
__inline static void glib_queueautoptr_cleanup_PangoAttrIterator(GQueue **_q ) 
{ 


  {
#line 744
  if (*_q) {
    {
#line 744
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& pango_attr_iterator_destroy)));
    }
  }
  return;
}
}
#line 122 "/usr/include/pango-1.0/pango/pango-item.h"
extern GType pango_item_get_type(void) ;
#line 125
extern PangoItem *pango_item_new(void) ;
#line 127
extern PangoItem *pango_item_copy(PangoItem *item ) ;
#line 129
extern void pango_item_free(PangoItem *item ) ;
#line 132
extern PangoItem *pango_item_split(PangoItem *orig , int split_index , int split_offset ) ;
#line 137
extern void pango_item_apply_attrs(PangoItem *item , PangoAttrIterator *iter ) ;
#line 141
extern GList *pango_reorder_items(GList *items ) ;
#line 146
extern GList *pango_itemize(PangoContext *context , char const   *text , int start_index ,
                            int length , PangoAttrList *attrs , PangoAttrIterator *cached_iter ) ;
#line 154
extern GList *pango_itemize_with_base_dir(PangoContext *context , PangoDirection base_dir ,
                                          char const   *text , int start_index , int length ,
                                          PangoAttrList *attrs , PangoAttrIterator *cached_iter ) ;
#line 105 "/usr/include/pango-1.0/pango/pango-break.h"
extern void pango_break(char const   *text , int length , PangoAnalysis *analysis ,
                        PangoLogAttr *attrs , int attrs_len ) ;
#line 112
extern void pango_get_log_attrs(char const   *text , int length , int level , PangoLanguage *language ,
                                PangoLogAttr *attrs , int attrs_len ) ;
#line 120
extern void pango_default_break(char const   *text , int length , PangoAnalysis *analysis ,
                                PangoLogAttr *attrs , int attrs_len ) ;
#line 127
extern void pango_tailor_break(char const   *text , int length , PangoAnalysis *analysis ,
                               int offset , PangoLogAttr *attrs , int attrs_len ) ;
#line 135
extern void pango_attr_break(char const   *text , int length , PangoAttrList *attr_list ,
                             int offset , PangoLogAttr *attrs , int attrs_len ) ;
#line 45 "/usr/include/pango-1.0/pango/pango-fontset.h"
extern GType pango_fontset_get_type(void) ;
#line 122
extern PangoFont *pango_fontset_get_font(PangoFontset *fontset , guint wc ) ;
#line 125
extern PangoFontMetrics *pango_fontset_get_metrics(PangoFontset *fontset ) ;
#line 127
extern void pango_fontset_foreach(PangoFontset *fontset , PangoFontsetForeachFunc func ,
                                  gpointer data ) ;
#line 102 "/usr/include/pango-1.0/pango/pango-fontmap.h"
extern GType pango_font_map_get_type(void) ;
#line 104
extern PangoContext *pango_font_map_create_context(PangoFontMap *fontmap ) ;
#line 106
extern PangoFont *pango_font_map_load_font(PangoFontMap *fontmap , PangoContext *context ,
                                           PangoFontDescription *desc ) ;
#line 110
extern PangoFontset *pango_font_map_load_fontset(PangoFontMap *fontmap , PangoContext *context ,
                                                 PangoFontDescription *desc , PangoLanguage *language ) ;
#line 115
extern void pango_font_map_list_families(PangoFontMap *fontmap , PangoFontFamily ***families ,
                                         int *n_families ) ;
#line 119
extern guint pango_font_map_get_serial(PangoFontMap *fontmap ) ;
#line 121
extern void pango_font_map_changed(PangoFontMap *fontmap ) ;
#line 124
extern PangoFontFamily *pango_font_map_get_family(PangoFontMap *fontmap , char const   *name ) ;
#line 128 "/usr/include/pango-1.0/pango/pango-fontmap.h"
__inline static void glib_autoptr_clear_PangoFontMap(PangoFontMap *_ptr ) 
{ 


  {
#line 128
  if (_ptr) {
    {
#line 128
    g_object_unref((PangoFontMap *)_ptr);
    }
  }
  return;
}
}
#line 128 "/usr/include/pango-1.0/pango/pango-fontmap.h"
__inline static void glib_autoptr_cleanup_PangoFontMap(PangoFontMap **_ptr ) 
{ 


  {
  {
#line 128
  glib_autoptr_clear_PangoFontMap(*_ptr);
  }
  return;
}
}
#line 44 "/usr/include/pango-1.0/pango/pango-context.h"
extern GType pango_context_get_type(void) ;
#line 47
extern PangoContext *pango_context_new(void) ;
#line 49
extern void pango_context_changed(PangoContext *context ) ;
#line 51
extern void pango_context_set_font_map(PangoContext *context , PangoFontMap *font_map ) ;
#line 54
extern PangoFontMap *pango_context_get_font_map(PangoContext *context ) ;
#line 56
extern guint pango_context_get_serial(PangoContext *context ) ;
#line 58
extern void pango_context_list_families(PangoContext *context , PangoFontFamily ***families ,
                                        int *n_families ) ;
#line 62
extern PangoFont *pango_context_load_font(PangoContext *context , PangoFontDescription *desc ) ;
#line 65
extern PangoFontset *pango_context_load_fontset(PangoContext *context , PangoFontDescription *desc ,
                                                PangoLanguage *language ) ;
#line 70
extern PangoFontMetrics *pango_context_get_metrics(PangoContext *context , PangoFontDescription *desc ,
                                                   PangoLanguage *language ) ;
#line 75
extern void pango_context_set_font_description(PangoContext *context , PangoFontDescription *desc ) ;
#line 78
extern PangoFontDescription *pango_context_get_font_description(PangoContext *context ) ;
#line 80
extern PangoLanguage *pango_context_get_language(PangoContext *context ) ;
#line 82
extern void pango_context_set_language(PangoContext *context , PangoLanguage *language ) ;
#line 85
extern void pango_context_set_base_dir(PangoContext *context , PangoDirection direction ) ;
#line 88
extern PangoDirection pango_context_get_base_dir(PangoContext *context ) ;
#line 90
extern void pango_context_set_base_gravity(PangoContext *context , PangoGravity gravity ) ;
#line 93
extern PangoGravity pango_context_get_base_gravity(PangoContext *context ) ;
#line 95
extern PangoGravity pango_context_get_gravity(PangoContext *context ) ;
#line 97
extern void pango_context_set_gravity_hint(PangoContext *context , PangoGravityHint hint ) ;
#line 100
extern PangoGravityHint pango_context_get_gravity_hint(PangoContext *context ) ;
#line 103
extern void pango_context_set_matrix(PangoContext *context , PangoMatrix *matrix ) ;
#line 106
extern PangoMatrix *pango_context_get_matrix(PangoContext *context ) ;
#line 109
extern void pango_context_set_round_glyph_positions(PangoContext *context , gboolean round_positions ) ;
#line 112
extern gboolean pango_context_get_round_glyph_positions(PangoContext *context ) ;
#line 153 "/usr/include/pango-1.0/pango/pango-glyph.h"
extern GType pango_glyph_string_get_type(void) ;
#line 156
extern PangoGlyphString *pango_glyph_string_new(void) ;
#line 158
extern void pango_glyph_string_set_size(PangoGlyphString *string , int new_len ) ;
#line 162
extern PangoGlyphString *pango_glyph_string_copy(PangoGlyphString *string ) ;
#line 164
extern void pango_glyph_string_free(PangoGlyphString *string ) ;
#line 167
extern void pango_glyph_string_extents(PangoGlyphString *glyphs , PangoFont *font ,
                                       PangoRectangle *ink_rect , PangoRectangle *logical_rect ) ;
#line 172
extern int pango_glyph_string_get_width(PangoGlyphString *glyphs ) ;
#line 175
extern void pango_glyph_string_extents_range(PangoGlyphString *glyphs , int start ,
                                             int end , PangoFont *font , PangoRectangle *ink_rect ,
                                             PangoRectangle *logical_rect ) ;
#line 183
extern void pango_glyph_string_get_logical_widths(PangoGlyphString *glyphs , char const   *text ,
                                                  int length , int embedding_level ,
                                                  int *logical_widths ) ;
#line 190
extern void pango_glyph_string_index_to_x(PangoGlyphString *glyphs , char const   *text ,
                                          int length , PangoAnalysis *analysis , int index_ ,
                                          gboolean trailing , int *x_pos ) ;
#line 198
extern void pango_glyph_string_x_to_index(PangoGlyphString *glyphs , char const   *text ,
                                          int length , PangoAnalysis *analysis , int x_pos ,
                                          int *index_ , int *trailing ) ;
#line 207
extern void pango_glyph_string_index_to_x_full(PangoGlyphString *glyphs , char const   *text ,
                                               int length , PangoAnalysis *analysis ,
                                               PangoLogAttr *attrs , int index_ ,
                                               gboolean trailing , int *x_pos ) ;
#line 236
extern void pango_shape(char const   *text , int length , PangoAnalysis *analysis ,
                        PangoGlyphString *glyphs ) ;
#line 242
extern void pango_shape_full(char const   *item_text , int item_length , char const   *paragraph_text ,
                             int paragraph_length , PangoAnalysis *analysis , PangoGlyphString *glyphs ) ;
#line 250
extern void pango_shape_with_flags(char const   *item_text , int item_length , char const   *paragraph_text ,
                                   int paragraph_length , PangoAnalysis *analysis ,
                                   PangoGlyphString *glyphs , PangoShapeFlags flags ) ;
#line 260
extern void pango_shape_item(PangoItem *item , char const   *paragraph_text , int paragraph_length ,
                             PangoLogAttr *log_attrs , PangoGlyphString *glyphs ,
                             PangoShapeFlags flags ) ;
#line 88 "/usr/include/pango-1.0/pango/pango-engine.h"
extern GType pango_engine_get_type(void) ;
#line 155
extern GType pango_engine_lang_get_type(void) ;
#line 243
extern GType pango_engine_shape_get_type(void) ;
#line 305
extern void script_engine_list(PangoEngineInfo **engines , int *n_engines ) ;
#line 318
extern void script_engine_init(GTypeModule *module ) ;
#line 329
extern void script_engine_exit(void) ;
#line 340
extern PangoEngine *script_engine_create(char const   *id ) ;
#line 15 "/usr/include/pango-1.0/pango/pango-enum-types.h"
extern GType pango_attr_type_get_type(void) ;
#line 18
extern GType pango_underline_get_type(void) ;
#line 21
extern GType pango_overline_get_type(void) ;
#line 24
extern GType pango_show_flags_get_type(void) ;
#line 27
extern GType pango_text_transform_get_type(void) ;
#line 30
extern GType pango_baseline_shift_get_type(void) ;
#line 33
extern GType pango_font_scale_get_type(void) ;
#line 38
extern GType pango_bidi_type_get_type(void) ;
#line 43
extern GType pango_coverage_level_get_type(void) ;
#line 48
extern GType pango_direction_get_type(void) ;
#line 53
extern GType pango_style_get_type(void) ;
#line 56
extern GType pango_variant_get_type(void) ;
#line 59
extern GType pango_weight_get_type(void) ;
#line 62
extern GType pango_stretch_get_type(void) ;
#line 65
extern GType pango_font_mask_get_type(void) ;
#line 70
extern GType pango_shape_flags_get_type(void) ;
#line 75
extern GType pango_gravity_get_type(void) ;
#line 78
extern GType pango_gravity_hint_get_type(void) ;
#line 83
extern GType pango_alignment_get_type(void) ;
#line 86
extern GType pango_wrap_mode_get_type(void) ;
#line 89
extern GType pango_ellipsize_mode_get_type(void) ;
#line 92
extern GType pango_layout_serialize_flags_get_type(void) ;
#line 95
extern GType pango_layout_deserialize_error_get_type(void) ;
#line 98
extern GType pango_layout_deserialize_flags_get_type(void) ;
#line 103
extern GType pango_render_part_get_type(void) ;
#line 108
extern GType pango_script_get_type(void) ;
#line 113
extern GType pango_tab_align_get_type(void) ;
#line 51 "/usr/include/pango-1.0/pango/pango-fontset-simple.h"
extern GType pango_fontset_simple_get_type(void) ;
#line 54
extern PangoFontsetSimple *pango_fontset_simple_new(PangoLanguage *language ) ;
#line 56
extern void pango_fontset_simple_append(PangoFontsetSimple *fontset , PangoFont *font ) ;
#line 59
extern int pango_fontset_simple_size(PangoFontsetSimple *fontset ) ;
#line 64 "/usr/include/pango-1.0/pango/pango-glyph-item.h"
extern GType pango_glyph_item_get_type(void) ;
#line 67
extern PangoGlyphItem *pango_glyph_item_split(PangoGlyphItem *orig , char const   *text ,
                                              int split_index ) ;
#line 71
extern PangoGlyphItem *pango_glyph_item_copy(PangoGlyphItem *orig ) ;
#line 73
extern void pango_glyph_item_free(PangoGlyphItem *glyph_item ) ;
#line 75
extern GSList *pango_glyph_item_apply_attrs(PangoGlyphItem *glyph_item , char const   *text ,
                                            PangoAttrList *list ) ;
#line 79
extern void pango_glyph_item_letter_space(PangoGlyphItem *glyph_item , char const   *text ,
                                          PangoLogAttr *log_attrs , int letter_spacing ) ;
#line 84
extern void pango_glyph_item_get_logical_widths(PangoGlyphItem *glyph_item , char const   *text ,
                                                int *logical_widths ) ;
#line 154
extern GType pango_glyph_item_iter_get_type(void) ;
#line 156
extern PangoGlyphItemIter *pango_glyph_item_iter_copy(PangoGlyphItemIter *orig ) ;
#line 158
extern void pango_glyph_item_iter_free(PangoGlyphItemIter *iter ) ;
#line 161
extern gboolean pango_glyph_item_iter_init_start(PangoGlyphItemIter *iter , PangoGlyphItem *glyph_item ,
                                                 char const   *text ) ;
#line 165
extern gboolean pango_glyph_item_iter_init_end(PangoGlyphItemIter *iter , PangoGlyphItem *glyph_item ,
                                               char const   *text ) ;
#line 169
extern gboolean pango_glyph_item_iter_next_cluster(PangoGlyphItemIter *iter ) ;
#line 171
extern gboolean pango_glyph_item_iter_prev_cluster(PangoGlyphItemIter *iter ) ;
#line 56 "/usr/include/pango-1.0/pango/pango-tabs.h"
extern PangoTabArray *pango_tab_array_new(gint initial_size , gboolean positions_in_pixels ) ;
#line 59
extern PangoTabArray *pango_tab_array_new_with_positions(gint size , gboolean positions_in_pixels ,
                                                         PangoTabAlign first_alignment ,
                                                         gint first_position  , ...) ;
#line 65
extern GType pango_tab_array_get_type(void) ;
#line 67
extern PangoTabArray *pango_tab_array_copy(PangoTabArray *src ) ;
#line 69
extern void pango_tab_array_free(PangoTabArray *tab_array ) ;
#line 71
extern gint pango_tab_array_get_size(PangoTabArray *tab_array ) ;
#line 73
extern void pango_tab_array_resize(PangoTabArray *tab_array , gint new_size ) ;
#line 76
extern void pango_tab_array_set_tab(PangoTabArray *tab_array , gint tab_index , PangoTabAlign alignment ,
                                    gint location ) ;
#line 81
extern void pango_tab_array_get_tab(PangoTabArray *tab_array , gint tab_index , PangoTabAlign *alignment ,
                                    gint *location ) ;
#line 86
extern void pango_tab_array_get_tabs(PangoTabArray *tab_array , PangoTabAlign **alignments ,
                                     gint **locations ) ;
#line 91
extern gboolean pango_tab_array_get_positions_in_pixels(PangoTabArray *tab_array ) ;
#line 94
extern void pango_tab_array_set_positions_in_pixels(PangoTabArray *tab_array , gboolean positions_in_pixels ) ;
#line 98
extern char *pango_tab_array_to_string(PangoTabArray *tab_array ) ;
#line 100
extern PangoTabArray *pango_tab_array_from_string(char const   *text ) ;
#line 103
extern void pango_tab_array_set_decimal_point(PangoTabArray *tab_array , int tab_index ,
                                              gunichar decimal_point ) ;
#line 107
extern gunichar pango_tab_array_get_decimal_point(PangoTabArray *tab_array , int tab_index ) ;
#line 111
extern void pango_tab_array_sort(PangoTabArray *tab_array ) ;
#line 113 "/usr/include/pango-1.0/pango/pango-tabs.h"
__inline static void glib_autoptr_clear_PangoTabArray(PangoTabArray *_ptr ) 
{ 


  {
#line 113
  if (_ptr) {
    {
#line 113
    pango_tab_array_free((PangoTabArray *)_ptr);
    }
  }
  return;
}
}
#line 113 "/usr/include/pango-1.0/pango/pango-tabs.h"
__inline static void glib_autoptr_cleanup_PangoTabArray(PangoTabArray **_ptr ) 
{ 


  {
  {
#line 113
  glib_autoptr_clear_PangoTabArray(*_ptr);
  }
  return;
}
}
#line 113 "/usr/include/pango-1.0/pango/pango-tabs.h"
__inline static void glib_listautoptr_cleanup_PangoTabArray(GList **_l ) 
{ 


  {
  {
#line 113
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& pango_tab_array_free)));
  }
  return;
}
}
#line 113 "/usr/include/pango-1.0/pango/pango-tabs.h"
__inline static void glib_slistautoptr_cleanup_PangoTabArray(GSList **_l ) 
{ 


  {
  {
#line 113
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& pango_tab_array_free)));
  }
  return;
}
}
#line 113 "/usr/include/pango-1.0/pango/pango-tabs.h"
__inline static void glib_queueautoptr_cleanup_PangoTabArray(GQueue **_q ) 
{ 


  {
#line 113
  if (*_q) {
    {
#line 113
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& pango_tab_array_free)));
    }
  }
  return;
}
}
#line 148 "/usr/include/pango-1.0/pango/pango-layout.h"
extern GType pango_layout_get_type(void) ;
#line 150
extern PangoLayout *pango_layout_new(PangoContext *context ) ;
#line 152
extern PangoLayout *pango_layout_copy(PangoLayout *src ) ;
#line 155
extern PangoContext *pango_layout_get_context(PangoLayout *layout ) ;
#line 158
extern void pango_layout_set_attributes(PangoLayout *layout , PangoAttrList *attrs ) ;
#line 161
extern PangoAttrList *pango_layout_get_attributes(PangoLayout *layout ) ;
#line 164
extern void pango_layout_set_text(PangoLayout *layout , char const   *text , int length ) ;
#line 168
extern char const   *pango_layout_get_text(PangoLayout *layout ) ;
#line 171
extern gint pango_layout_get_character_count(PangoLayout *layout ) ;
#line 174
extern void pango_layout_set_markup(PangoLayout *layout , char const   *markup , int length ) ;
#line 179
extern void pango_layout_set_markup_with_accel(PangoLayout *layout , char const   *markup ,
                                               int length , gunichar accel_marker ,
                                               gunichar *accel_char ) ;
#line 186
extern void pango_layout_set_font_description(PangoLayout *layout , PangoFontDescription *desc ) ;
#line 190
extern PangoFontDescription *pango_layout_get_font_description(PangoLayout *layout ) ;
#line 193
extern void pango_layout_set_width(PangoLayout *layout , int width ) ;
#line 196
extern int pango_layout_get_width(PangoLayout *layout ) ;
#line 198
extern void pango_layout_set_height(PangoLayout *layout , int height ) ;
#line 201
extern int pango_layout_get_height(PangoLayout *layout ) ;
#line 203
extern void pango_layout_set_wrap(PangoLayout *layout , PangoWrapMode wrap ) ;
#line 206
extern PangoWrapMode pango_layout_get_wrap(PangoLayout *layout ) ;
#line 208
extern gboolean pango_layout_is_wrapped(PangoLayout *layout ) ;
#line 210
extern void pango_layout_set_indent(PangoLayout *layout , int indent ) ;
#line 213
extern int pango_layout_get_indent(PangoLayout *layout ) ;
#line 215
extern void pango_layout_set_spacing(PangoLayout *layout , int spacing ) ;
#line 218
extern int pango_layout_get_spacing(PangoLayout *layout ) ;
#line 220
extern void pango_layout_set_line_spacing(PangoLayout *layout , float factor ) ;
#line 223
extern float pango_layout_get_line_spacing(PangoLayout *layout ) ;
#line 225
extern void pango_layout_set_justify(PangoLayout *layout , gboolean justify ) ;
#line 228
extern gboolean pango_layout_get_justify(PangoLayout *layout ) ;
#line 230
extern void pango_layout_set_justify_last_line(PangoLayout *layout , gboolean justify ) ;
#line 233
extern gboolean pango_layout_get_justify_last_line(PangoLayout *layout ) ;
#line 235
extern void pango_layout_set_auto_dir(PangoLayout *layout , gboolean auto_dir ) ;
#line 238
extern gboolean pango_layout_get_auto_dir(PangoLayout *layout ) ;
#line 240
extern void pango_layout_set_alignment(PangoLayout *layout , PangoAlignment alignment ) ;
#line 243
extern PangoAlignment pango_layout_get_alignment(PangoLayout *layout ) ;
#line 246
extern void pango_layout_set_tabs(PangoLayout *layout , PangoTabArray *tabs ) ;
#line 249
extern PangoTabArray *pango_layout_get_tabs(PangoLayout *layout ) ;
#line 252
extern void pango_layout_set_single_paragraph_mode(PangoLayout *layout , gboolean setting ) ;
#line 255
extern gboolean pango_layout_get_single_paragraph_mode(PangoLayout *layout ) ;
#line 258
extern void pango_layout_set_ellipsize(PangoLayout *layout , PangoEllipsizeMode ellipsize ) ;
#line 261
extern PangoEllipsizeMode pango_layout_get_ellipsize(PangoLayout *layout ) ;
#line 263
extern gboolean pango_layout_is_ellipsized(PangoLayout *layout ) ;
#line 266
extern int pango_layout_get_unknown_glyphs_count(PangoLayout *layout ) ;
#line 269
extern PangoDirection pango_layout_get_direction(PangoLayout *layout , int index ) ;
#line 273
extern void pango_layout_context_changed(PangoLayout *layout ) ;
#line 275
extern guint pango_layout_get_serial(PangoLayout *layout ) ;
#line 278
extern void pango_layout_get_log_attrs(PangoLayout *layout , PangoLogAttr **attrs ,
                                       gint *n_attrs ) ;
#line 283
extern PangoLogAttr *pango_layout_get_log_attrs_readonly(PangoLayout *layout , gint *n_attrs ) ;
#line 287
extern void pango_layout_index_to_pos(PangoLayout *layout , int index_ , PangoRectangle *pos ) ;
#line 291
extern void pango_layout_index_to_line_x(PangoLayout *layout , int index_ , gboolean trailing ,
                                         int *line , int *x_pos ) ;
#line 297
extern void pango_layout_get_cursor_pos(PangoLayout *layout , int index_ , PangoRectangle *strong_pos ,
                                        PangoRectangle *weak_pos ) ;
#line 303
extern void pango_layout_get_caret_pos(PangoLayout *layout , int index_ , PangoRectangle *strong_pos ,
                                       PangoRectangle *weak_pos ) ;
#line 309
extern void pango_layout_move_cursor_visually(PangoLayout *layout , gboolean strong ,
                                              int old_index , int old_trailing , int direction ,
                                              int *new_index , int *new_trailing ) ;
#line 317
extern gboolean pango_layout_xy_to_index(PangoLayout *layout , int x , int y , int *index_ ,
                                         int *trailing ) ;
#line 323
extern void pango_layout_get_extents(PangoLayout *layout , PangoRectangle *ink_rect ,
                                     PangoRectangle *logical_rect ) ;
#line 327
extern void pango_layout_get_pixel_extents(PangoLayout *layout , PangoRectangle *ink_rect ,
                                           PangoRectangle *logical_rect ) ;
#line 331
extern void pango_layout_get_size(PangoLayout *layout , int *width , int *height ) ;
#line 335
extern void pango_layout_get_pixel_size(PangoLayout *layout , int *width , int *height ) ;
#line 339
extern int pango_layout_get_baseline(PangoLayout *layout ) ;
#line 342
extern int pango_layout_get_line_count(PangoLayout *layout ) ;
#line 344
extern PangoLayoutLine *pango_layout_get_line(PangoLayout *layout , int line ) ;
#line 347
extern PangoLayoutLine *pango_layout_get_line_readonly(PangoLayout *layout , int line ) ;
#line 350
extern GSList *pango_layout_get_lines(PangoLayout *layout ) ;
#line 352
extern GSList *pango_layout_get_lines_readonly(PangoLayout *layout ) ;
#line 373
extern GBytes *pango_layout_serialize(PangoLayout *layout , PangoLayoutSerializeFlags flags ) ;
#line 377
extern gboolean pango_layout_write_to_file(PangoLayout *layout , PangoLayoutSerializeFlags flags ,
                                           char const   *filename , GError **error ) ;
#line 404
extern GQuark pango_layout_deserialize_error_quark(void) ;
#line 424
extern PangoLayout *pango_layout_deserialize(PangoContext *context , GBytes *bytes ,
                                             PangoLayoutDeserializeFlags flags , GError **error ) ;
#line 433
extern GType pango_layout_line_get_type(void) ;
#line 436
extern PangoLayoutLine *pango_layout_line_ref(PangoLayoutLine *line ) ;
#line 438
extern void pango_layout_line_unref(PangoLayoutLine *line ) ;
#line 441
extern int pango_layout_line_get_start_index(PangoLayoutLine *line ) ;
#line 443
extern int pango_layout_line_get_length(PangoLayoutLine *line ) ;
#line 445
extern gboolean pango_layout_line_is_paragraph_start(PangoLayoutLine *line ) ;
#line 447
extern PangoDirection pango_layout_line_get_resolved_direction(PangoLayoutLine *line ) ;
#line 450
extern gboolean pango_layout_line_x_to_index(PangoLayoutLine *line , int x_pos , int *index_ ,
                                             int *trailing ) ;
#line 455
extern void pango_layout_line_index_to_x(PangoLayoutLine *line , int index_ , gboolean trailing ,
                                         int *x_pos ) ;
#line 460
extern void pango_layout_line_get_x_ranges(PangoLayoutLine *line , int start_index ,
                                           int end_index , int **ranges , int *n_ranges ) ;
#line 466
extern void pango_layout_line_get_extents(PangoLayoutLine *line , PangoRectangle *ink_rect ,
                                          PangoRectangle *logical_rect ) ;
#line 470
extern void pango_layout_line_get_height(PangoLayoutLine *line , int *height ) ;
#line 474
extern void pango_layout_line_get_pixel_extents(PangoLayoutLine *layout_line , PangoRectangle *ink_rect ,
                                                PangoRectangle *logical_rect ) ;
#line 483
extern GType pango_layout_iter_get_type(void) ;
#line 486
extern PangoLayoutIter *pango_layout_get_iter(PangoLayout *layout ) ;
#line 488
extern PangoLayoutIter *pango_layout_iter_copy(PangoLayoutIter *iter ) ;
#line 490
extern void pango_layout_iter_free(PangoLayoutIter *iter ) ;
#line 493
extern int pango_layout_iter_get_index(PangoLayoutIter *iter ) ;
#line 495
extern PangoLayoutRun *pango_layout_iter_get_run(PangoLayoutIter *iter ) ;
#line 497
extern PangoLayoutRun *pango_layout_iter_get_run_readonly(PangoLayoutIter *iter ) ;
#line 499
extern PangoLayoutLine *pango_layout_iter_get_line(PangoLayoutIter *iter ) ;
#line 501
extern PangoLayoutLine *pango_layout_iter_get_line_readonly(PangoLayoutIter *iter ) ;
#line 503
extern gboolean pango_layout_iter_at_last_line(PangoLayoutIter *iter ) ;
#line 505
extern PangoLayout *pango_layout_iter_get_layout(PangoLayoutIter *iter ) ;
#line 508
extern gboolean pango_layout_iter_next_char(PangoLayoutIter *iter ) ;
#line 510
extern gboolean pango_layout_iter_next_cluster(PangoLayoutIter *iter ) ;
#line 512
extern gboolean pango_layout_iter_next_run(PangoLayoutIter *iter ) ;
#line 514
extern gboolean pango_layout_iter_next_line(PangoLayoutIter *iter ) ;
#line 517
extern void pango_layout_iter_get_char_extents(PangoLayoutIter *iter , PangoRectangle *logical_rect ) ;
#line 520
extern void pango_layout_iter_get_cluster_extents(PangoLayoutIter *iter , PangoRectangle *ink_rect ,
                                                  PangoRectangle *logical_rect ) ;
#line 524
extern void pango_layout_iter_get_run_extents(PangoLayoutIter *iter , PangoRectangle *ink_rect ,
                                              PangoRectangle *logical_rect ) ;
#line 528
extern void pango_layout_iter_get_line_extents(PangoLayoutIter *iter , PangoRectangle *ink_rect ,
                                               PangoRectangle *logical_rect ) ;
#line 535
extern void pango_layout_iter_get_line_yrange(PangoLayoutIter *iter , int *y0_ , int *y1_ ) ;
#line 539
extern void pango_layout_iter_get_layout_extents(PangoLayoutIter *iter , PangoRectangle *ink_rect ,
                                                 PangoRectangle *logical_rect ) ;
#line 543
extern int pango_layout_iter_get_baseline(PangoLayoutIter *iter ) ;
#line 545
extern int pango_layout_iter_get_run_baseline(PangoLayoutIter *iter ) ;
#line 548 "/usr/include/pango-1.0/pango/pango-layout.h"
__inline static void glib_autoptr_clear_PangoLayout(PangoLayout *_ptr ) 
{ 


  {
#line 548
  if (_ptr) {
    {
#line 548
    g_object_unref((PangoLayout *)_ptr);
    }
  }
  return;
}
}
#line 548 "/usr/include/pango-1.0/pango/pango-layout.h"
__inline static void glib_autoptr_cleanup_PangoLayout(PangoLayout **_ptr ) 
{ 


  {
  {
#line 548
  glib_autoptr_clear_PangoLayout(*_ptr);
  }
  return;
}
}
#line 549 "/usr/include/pango-1.0/pango/pango-layout.h"
__inline static void glib_autoptr_clear_PangoLayoutIter(PangoLayoutIter *_ptr ) 
{ 


  {
#line 549
  if (_ptr) {
    {
#line 549
    pango_layout_iter_free((PangoLayoutIter *)_ptr);
    }
  }
  return;
}
}
#line 549 "/usr/include/pango-1.0/pango/pango-layout.h"
__inline static void glib_autoptr_cleanup_PangoLayoutIter(PangoLayoutIter **_ptr ) 
{ 


  {
  {
#line 549
  glib_autoptr_clear_PangoLayoutIter(*_ptr);
  }
  return;
}
}
#line 549 "/usr/include/pango-1.0/pango/pango-layout.h"
__inline static void glib_listautoptr_cleanup_PangoLayoutIter(GList **_l ) 
{ 


  {
  {
#line 549
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& pango_layout_iter_free)));
  }
  return;
}
}
#line 549 "/usr/include/pango-1.0/pango/pango-layout.h"
__inline static void glib_slistautoptr_cleanup_PangoLayoutIter(GSList **_l ) 
{ 


  {
  {
#line 549
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& pango_layout_iter_free)));
  }
  return;
}
}
#line 549 "/usr/include/pango-1.0/pango/pango-layout.h"
__inline static void glib_queueautoptr_cleanup_PangoLayoutIter(GQueue **_q ) 
{ 


  {
#line 549
  if (*_q) {
    {
#line 549
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& pango_layout_iter_free)));
    }
  }
  return;
}
}
#line 31 "/usr/include/pango-1.0/pango/pango-markup.h"
extern GMarkupParseContext *pango_markup_parser_new(gunichar accel_marker ) ;
#line 34
extern gboolean pango_markup_parser_finish(GMarkupParseContext *context , PangoAttrList **attr_list ,
                                           char **text , gunichar *accel_char , GError **error ) ;
#line 41
extern gboolean pango_parse_markup(char const   *markup_text , int length , gunichar accel_marker ,
                                   PangoAttrList **attr_list , char **text , gunichar *accel_char ,
                                   GError **error ) ;
#line 198 "/usr/include/pango-1.0/pango/pango-renderer.h"
extern GType pango_renderer_get_type(void) ;
#line 201
extern void pango_renderer_draw_layout(PangoRenderer *renderer , PangoLayout *layout ,
                                       int x , int y ) ;
#line 206
extern void pango_renderer_draw_layout_line(PangoRenderer *renderer , PangoLayoutLine *line ,
                                            int x , int y ) ;
#line 211
extern void pango_renderer_draw_glyphs(PangoRenderer *renderer , PangoFont *font ,
                                       PangoGlyphString *glyphs , int x , int y ) ;
#line 217
extern void pango_renderer_draw_glyph_item(PangoRenderer *renderer , char const   *text ,
                                           PangoGlyphItem *glyph_item , int x , int y ) ;
#line 223
extern void pango_renderer_draw_rectangle(PangoRenderer *renderer , PangoRenderPart part ,
                                          int x , int y , int width , int height ) ;
#line 230
extern void pango_renderer_draw_error_underline(PangoRenderer *renderer , int x ,
                                                int y , int width , int height ) ;
#line 236
extern void pango_renderer_draw_trapezoid(PangoRenderer *renderer , PangoRenderPart part ,
                                          double y1_ , double x11 , double x21 , double y2 ,
                                          double x12 , double x22 ) ;
#line 245
extern void pango_renderer_draw_glyph(PangoRenderer *renderer , PangoFont *font ,
                                      PangoGlyph glyph , double x , double y ) ;
#line 252
extern void pango_renderer_activate(PangoRenderer *renderer ) ;
#line 254
extern void pango_renderer_deactivate(PangoRenderer *renderer ) ;
#line 257
extern void pango_renderer_part_changed(PangoRenderer *renderer , PangoRenderPart part ) ;
#line 261
extern void pango_renderer_set_color(PangoRenderer *renderer , PangoRenderPart part ,
                                     PangoColor *color ) ;
#line 265
extern PangoColor *pango_renderer_get_color(PangoRenderer *renderer , PangoRenderPart part ) ;
#line 269
extern void pango_renderer_set_alpha(PangoRenderer *renderer , PangoRenderPart part ,
                                     guint16 alpha ) ;
#line 273
extern guint16 pango_renderer_get_alpha(PangoRenderer *renderer , PangoRenderPart part ) ;
#line 277
extern void pango_renderer_set_matrix(PangoRenderer *renderer , PangoMatrix *matrix ) ;
#line 280
extern PangoMatrix *pango_renderer_get_matrix(PangoRenderer *renderer ) ;
#line 283
extern PangoLayout *pango_renderer_get_layout(PangoRenderer *renderer ) ;
#line 285
extern PangoLayoutLine *pango_renderer_get_layout_line(PangoRenderer *renderer ) ;
#line 32 "/usr/include/pango-1.0/pango/pango-utils.h"
extern char **pango_split_file_list(char const   *str ) ;
#line 35
extern char *pango_trim_string(char const   *str ) ;
#line 37
extern gint pango_read_line(FILE *stream , GString *str ) ;
#line 40
extern gboolean pango_skip_space(char const   **pos ) ;
#line 42
extern gboolean pango_scan_word(char const   **pos , GString *out ) ;
#line 45
extern gboolean pango_scan_string(char const   **pos , GString *out ) ;
#line 48
extern gboolean pango_scan_int(char const   **pos , int *out ) ;
#line 52
extern gboolean pango_parse_enum(GType type , char const   *str , int *value , gboolean warn ,
                                 char **possible_values ) ;
#line 66
extern gboolean pango_parse_style(char const   *str , PangoStyle *style , gboolean warn ) ;
#line 70
extern gboolean pango_parse_variant(char const   *str , PangoVariant *variant , gboolean warn ) ;
#line 74
extern gboolean pango_parse_weight(char const   *str , PangoWeight *weight , gboolean warn ) ;
#line 78
extern gboolean pango_parse_stretch(char const   *str , PangoStretch *stretch , gboolean warn ) ;
#line 86
extern void pango_quantize_line_geometry(int *thickness , int *position ) ;
#line 92
extern guint8 *pango_log2vis_get_embedding_levels(gchar *text , int length , PangoDirection *pbase_dir ) ;
#line 100
extern gboolean pango_is_zero_width(gunichar ch ) ;
#line 103
extern void pango_find_paragraph_boundary(char const   *text , int length , int *paragraph_delimiter_index ,
                                          int *next_paragraph_start ) ;
#line 173
extern int pango_version(void) ;
#line 177
extern char const   *pango_version_string(void) ;
#line 181
extern char const   *pango_version_check(int required_major , int required_minor ,
                                         int required_micro ) ;
#line 89 "/usr/include/gtk-2.0/gdk/gdkcolor.h"
GType gdk_colormap_get_type(void) ;
#line 91
GdkColormap *gdk_colormap_new(GdkVisual *visual , gboolean allocate ) ;
#line 95
GdkColormap *gdk_colormap_ref(GdkColormap *cmap ) ;
#line 96
void gdk_colormap_unref(GdkColormap *cmap ) ;
#line 100
GdkColormap *gdk_colormap_get_system(void) ;
#line 103
GdkScreen *gdk_colormap_get_screen(GdkColormap *cmap ) ;
#line 106
gint gdk_colormap_get_system_size(void) ;
#line 111
void gdk_colormap_change(GdkColormap *colormap , gint ncolors ) ;
#line 115
gint gdk_colormap_alloc_colors(GdkColormap *colormap , GdkColor *colors , gint n_colors ,
                               gboolean writeable , gboolean best_match , gboolean *success ) ;
#line 121
gboolean gdk_colormap_alloc_color(GdkColormap *colormap , GdkColor *color , gboolean writeable ,
                                  gboolean best_match ) ;
#line 125
void gdk_colormap_free_colors(GdkColormap *colormap , GdkColor *colors , gint n_colors ) ;
#line 128
void gdk_colormap_query_color(GdkColormap *colormap , gulong pixel , GdkColor *result ) ;
#line 132
GdkVisual *gdk_colormap_get_visual(GdkColormap *colormap ) ;
#line 134
GdkColor *gdk_color_copy(GdkColor *color ) ;
#line 135
void gdk_color_free(GdkColor *color ) ;
#line 136
gboolean gdk_color_parse(gchar *spec , GdkColor *color ) ;
#line 138
guint gdk_color_hash(GdkColor *colora ) ;
#line 139
gboolean gdk_color_equal(GdkColor *colora , GdkColor *colorb ) ;
#line 141
gchar *gdk_color_to_string(GdkColor *color ) ;
#line 143
GType gdk_color_get_type(void) ;
#line 147
void gdk_colors_store(GdkColormap *colormap , GdkColor *colors , gint ncolors ) ;
#line 150
gint gdk_color_white(GdkColormap *colormap , GdkColor *color ) ;
#line 152
gint gdk_color_black(GdkColormap *colormap , GdkColor *color ) ;
#line 154
gint gdk_color_alloc(GdkColormap *colormap , GdkColor *color ) ;
#line 156
gint gdk_color_change(GdkColormap *colormap , GdkColor *color ) ;
#line 162
gint gdk_colors_alloc(GdkColormap *colormap , gboolean contiguous , gulong *planes ,
                      gint nplanes , gulong *pixels , gint npixels ) ;
#line 168
void gdk_colors_free(GdkColormap *colormap , gulong *pixels , gint npixels , gulong planes ) ;
#line 106 "/usr/include/gtk-2.0/gdk/gdkdnd.h"
GType gdk_drag_context_get_type(void) ;
#line 108
GdkDragContext *gdk_drag_context_new(void) ;
#line 111
GList *gdk_drag_context_list_targets(GdkDragContext *context ) ;
#line 112
GdkDragAction gdk_drag_context_get_actions(GdkDragContext *context ) ;
#line 113
GdkDragAction gdk_drag_context_get_suggested_action(GdkDragContext *context ) ;
#line 114
GdkDragAction gdk_drag_context_get_selected_action(GdkDragContext *context ) ;
#line 116
GdkWindow *gdk_drag_context_get_source_window(GdkDragContext *context ) ;
#line 117
GdkWindow *gdk_drag_context_get_dest_window(GdkDragContext *context ) ;
#line 118
GdkDragProtocol gdk_drag_context_get_protocol(GdkDragContext *context ) ;
#line 122
void gdk_drag_context_ref(GdkDragContext *context ) ;
#line 123
void gdk_drag_context_unref(GdkDragContext *context ) ;
#line 128
void gdk_drag_status(GdkDragContext *context , GdkDragAction action , guint32 time_ ) ;
#line 131
void gdk_drop_reply(GdkDragContext *context , gboolean ok , guint32 time_ ) ;
#line 134
void gdk_drop_finish(GdkDragContext *context , gboolean success , guint32 time_ ) ;
#line 137
GdkAtom gdk_drag_get_selection(GdkDragContext *context ) ;
#line 141
GdkDragContext *gdk_drag_begin(GdkWindow *window , GList *targets ) ;
#line 144
GdkNativeWindow gdk_drag_get_protocol_for_display(GdkDisplay *display , GdkNativeWindow xid ,
                                                  GdkDragProtocol *protocol ) ;
#line 148
void gdk_drag_find_window_for_screen(GdkDragContext *context , GdkWindow *drag_window ,
                                     GdkScreen *screen , gint x_root , gint y_root ,
                                     GdkWindow **dest_window , GdkDragProtocol *protocol ) ;
#line 158
GdkNativeWindow gdk_drag_get_protocol(GdkNativeWindow xid , GdkDragProtocol *protocol ) ;
#line 161
void gdk_drag_find_window(GdkDragContext *context , GdkWindow *drag_window , gint x_root ,
                          gint y_root , GdkWindow **dest_window , GdkDragProtocol *protocol ) ;
#line 170
gboolean gdk_drag_motion(GdkDragContext *context , GdkWindow *dest_window , GdkDragProtocol protocol ,
                         gint x_root , gint y_root , GdkDragAction suggested_action ,
                         GdkDragAction possible_actions , guint32 time_ ) ;
#line 178
void gdk_drag_drop(GdkDragContext *context , guint32 time_ ) ;
#line 180
void gdk_drag_abort(GdkDragContext *context , guint32 time_ ) ;
#line 182
gboolean gdk_drag_drop_succeeded(GdkDragContext *context ) ;
#line 126 "/usr/include/gtk-2.0/gdk/gdkinput.h"
GType gdk_device_get_type(void) ;
#line 130
GList *gdk_devices_list(void) ;
#line 133
gchar *gdk_device_get_name(GdkDevice *device ) ;
#line 134
GdkInputSource gdk_device_get_source(GdkDevice *device ) ;
#line 135
GdkInputMode gdk_device_get_mode(GdkDevice *device ) ;
#line 136
gboolean gdk_device_get_has_cursor(GdkDevice *device ) ;
#line 138
void gdk_device_get_key(GdkDevice *device , guint index , guint *keyval , GdkModifierType *modifiers ) ;
#line 142
GdkAxisUse gdk_device_get_axis_use(GdkDevice *device , guint index ) ;
#line 144
gint gdk_device_get_n_keys(GdkDevice *device ) ;
#line 145
gint gdk_device_get_n_axes(GdkDevice *device ) ;
#line 148
void gdk_device_set_source(GdkDevice *device , GdkInputSource source ) ;
#line 151
gboolean gdk_device_set_mode(GdkDevice *device , GdkInputMode mode ) ;
#line 154
void gdk_device_set_key(GdkDevice *device , guint index_ , guint keyval , GdkModifierType modifiers ) ;
#line 159
void gdk_device_set_axis_use(GdkDevice *device , guint index_ , GdkAxisUse use ) ;
#line 163
void gdk_device_get_state(GdkDevice *device , GdkWindow *window , gdouble *axes ,
                          GdkModifierType *mask ) ;
#line 168
gboolean gdk_device_get_history(GdkDevice *device , GdkWindow *window , guint32 start ,
                                guint32 stop , GdkTimeCoord ***events , gint *n_events ) ;
#line 175
void gdk_device_free_history(GdkTimeCoord **events , gint n_events ) ;
#line 177
gboolean gdk_device_get_axis(GdkDevice *device , gdouble *axes , GdkAxisUse use ,
                             gdouble *value ) ;
#line 182
void gdk_input_set_extension_events(GdkWindow *window , gint mask , GdkExtensionMode mode ) ;
#line 187
GdkDevice *gdk_device_get_core_pointer(void) ;
#line 516 "/usr/include/gtk-2.0/gdk/gdkevents.h"
GType gdk_event_get_type(void) ;
#line 518
gboolean gdk_events_pending(void) ;
#line 519
GdkEvent *gdk_event_get(void) ;
#line 521
GdkEvent *gdk_event_peek(void) ;
#line 523
GdkEvent *gdk_event_get_graphics_expose(GdkWindow *window ) ;
#line 525
void gdk_event_put(GdkEvent *event ) ;
#line 527
GdkEvent *gdk_event_new(GdkEventType type ) ;
#line 528
GdkEvent *gdk_event_copy(GdkEvent *event ) ;
#line 529
void gdk_event_free(GdkEvent *event ) ;
#line 531
guint32 gdk_event_get_time(GdkEvent *event ) ;
#line 532
gboolean gdk_event_get_state(GdkEvent *event , GdkModifierType *state ) ;
#line 534
gboolean gdk_event_get_coords(GdkEvent *event , gdouble *x_win , gdouble *y_win ) ;
#line 537
gboolean gdk_event_get_root_coords(GdkEvent *event , gdouble *x_root , gdouble *y_root ) ;
#line 540
gboolean gdk_event_get_axis(GdkEvent *event , GdkAxisUse axis_use , gdouble *value ) ;
#line 543
void gdk_event_request_motions(GdkEventMotion *event ) ;
#line 544
void gdk_event_handler_set(GdkEventFunc func , gpointer data , GDestroyNotify notify ) ;
#line 548
void gdk_event_set_screen(GdkEvent *event , GdkScreen *screen ) ;
#line 550
GdkScreen *gdk_event_get_screen(GdkEvent *event ) ;
#line 552
void gdk_set_show_events(gboolean show_events ) ;
#line 553
gboolean gdk_get_show_events(void) ;
#line 556
void gdk_add_client_message_filter(GdkAtom message_type , GdkFilterFunc func , gpointer data ) ;
#line 560
gboolean gdk_setting_get(gchar *name , GValue *value ) ;
#line 141 "/usr/include/gtk-2.0/gdk/gdkdisplay.h"
GType gdk_display_get_type(void) ;
#line 142
GdkDisplay *gdk_display_open(gchar *display_name ) ;
#line 144
gchar *gdk_display_get_name(GdkDisplay *display ) ;
#line 146
gint gdk_display_get_n_screens(GdkDisplay *display ) ;
#line 147
GdkScreen *gdk_display_get_screen(GdkDisplay *display , gint screen_num ) ;
#line 149
GdkScreen *gdk_display_get_default_screen(GdkDisplay *display ) ;
#line 150
void gdk_display_pointer_ungrab(GdkDisplay *display , guint32 time_ ) ;
#line 152
void gdk_display_keyboard_ungrab(GdkDisplay *display , guint32 time_ ) ;
#line 154
gboolean gdk_display_pointer_is_grabbed(GdkDisplay *display ) ;
#line 155
void gdk_display_beep(GdkDisplay *display ) ;
#line 156
void gdk_display_sync(GdkDisplay *display ) ;
#line 157
void gdk_display_flush(GdkDisplay *display ) ;
#line 159
void gdk_display_close(GdkDisplay *display ) ;
#line 160
gboolean gdk_display_is_closed(GdkDisplay *display ) ;
#line 162
GList *gdk_display_list_devices(GdkDisplay *display ) ;
#line 164
GdkEvent *gdk_display_get_event(GdkDisplay *display ) ;
#line 165
GdkEvent *gdk_display_peek_event(GdkDisplay *display ) ;
#line 166
void gdk_display_put_event(GdkDisplay *display , GdkEvent *event ) ;
#line 169
void gdk_display_add_client_message_filter(GdkDisplay *display , GdkAtom message_type ,
                                           GdkFilterFunc func , gpointer data ) ;
#line 174
void gdk_display_set_double_click_time(GdkDisplay *display , guint msec ) ;
#line 176
void gdk_display_set_double_click_distance(GdkDisplay *display , guint distance ) ;
#line 179
GdkDisplay *gdk_display_get_default(void) ;
#line 181
GdkDevice *gdk_display_get_core_pointer(GdkDisplay *display ) ;
#line 183
void gdk_display_get_pointer(GdkDisplay *display , GdkScreen **screen , gint *x ,
                             gint *y , GdkModifierType *mask ) ;
#line 188
GdkWindow *gdk_display_get_window_at_pointer(GdkDisplay *display , gint *win_x , gint *win_y ) ;
#line 191
void gdk_display_warp_pointer(GdkDisplay *display , GdkScreen *screen , gint x , gint y ) ;
#line 197
GdkDisplayPointerHooks *gdk_display_set_pointer_hooks(GdkDisplay *display , GdkDisplayPointerHooks *new_hooks ) ;
#line 201
GdkDisplay *gdk_display_open_default_libgtk_only(void) ;
#line 203
gboolean gdk_display_supports_cursor_alpha(GdkDisplay *display ) ;
#line 204
gboolean gdk_display_supports_cursor_color(GdkDisplay *display ) ;
#line 205
guint gdk_display_get_default_cursor_size(GdkDisplay *display ) ;
#line 206
void gdk_display_get_maximal_cursor_size(GdkDisplay *display , guint *width , guint *height ) ;
#line 210
GdkWindow *gdk_display_get_default_group(GdkDisplay *display ) ;
#line 212
gboolean gdk_display_supports_selection_notification(GdkDisplay *display ) ;
#line 213
gboolean gdk_display_request_selection_notification(GdkDisplay *display , GdkAtom selection ) ;
#line 216
gboolean gdk_display_supports_clipboard_persistence(GdkDisplay *display ) ;
#line 217
void gdk_display_store_clipboard(GdkDisplay *display , GdkWindow *clipboard_window ,
                                 guint32 time_ , GdkAtom *targets , gint n_targets ) ;
#line 223
gboolean gdk_display_supports_shapes(GdkDisplay *display ) ;
#line 224
gboolean gdk_display_supports_input_shapes(GdkDisplay *display ) ;
#line 225
gboolean gdk_display_supports_composite(GdkDisplay *display ) ;
#line 69 "/usr/include/gtk-2.0/gdk/gdkscreen.h"
GType gdk_screen_get_type(void) ;
#line 70
GdkColormap *gdk_screen_get_default_colormap(GdkScreen *screen ) ;
#line 71
void gdk_screen_set_default_colormap(GdkScreen *screen , GdkColormap *colormap ) ;
#line 73
GdkColormap *gdk_screen_get_system_colormap(GdkScreen *screen ) ;
#line 74
GdkVisual *gdk_screen_get_system_visual(GdkScreen *screen ) ;
#line 75
GdkColormap *gdk_screen_get_rgb_colormap(GdkScreen *screen ) ;
#line 76
GdkVisual *gdk_screen_get_rgb_visual(GdkScreen *screen ) ;
#line 77
GdkColormap *gdk_screen_get_rgba_colormap(GdkScreen *screen ) ;
#line 78
GdkVisual *gdk_screen_get_rgba_visual(GdkScreen *screen ) ;
#line 79
gboolean gdk_screen_is_composited(GdkScreen *screen ) ;
#line 81
GdkWindow *gdk_screen_get_root_window(GdkScreen *screen ) ;
#line 82
GdkDisplay *gdk_screen_get_display(GdkScreen *screen ) ;
#line 83
gint gdk_screen_get_number(GdkScreen *screen ) ;
#line 84
gint gdk_screen_get_width(GdkScreen *screen ) ;
#line 85
gint gdk_screen_get_height(GdkScreen *screen ) ;
#line 86
gint gdk_screen_get_width_mm(GdkScreen *screen ) ;
#line 87
gint gdk_screen_get_height_mm(GdkScreen *screen ) ;
#line 89
GList *gdk_screen_list_visuals(GdkScreen *screen ) ;
#line 90
GList *gdk_screen_get_toplevel_windows(GdkScreen *screen ) ;
#line 91
gchar *gdk_screen_make_display_name(GdkScreen *screen ) ;
#line 93
gint gdk_screen_get_n_monitors(GdkScreen *screen ) ;
#line 94
gint gdk_screen_get_primary_monitor(GdkScreen *screen ) ;
#line 95
void gdk_screen_get_monitor_geometry(GdkScreen *screen , gint monitor_num , GdkRectangle *dest ) ;
#line 98
gint gdk_screen_get_monitor_at_point(GdkScreen *screen , gint x , gint y ) ;
#line 101
gint gdk_screen_get_monitor_at_window(GdkScreen *screen , GdkWindow *window ) ;
#line 103
gint gdk_screen_get_monitor_width_mm(GdkScreen *screen , gint monitor_num ) ;
#line 105
gint gdk_screen_get_monitor_height_mm(GdkScreen *screen , gint monitor_num ) ;
#line 107
gchar *gdk_screen_get_monitor_plug_name(GdkScreen *screen , gint monitor_num ) ;
#line 110
void gdk_screen_broadcast_client_message(GdkScreen *screen , GdkEvent *event ) ;
#line 113
GdkScreen *gdk_screen_get_default(void) ;
#line 115
gboolean gdk_screen_get_setting(GdkScreen *screen , gchar *name , GValue *value ) ;
#line 119
void gdk_screen_set_font_options(GdkScreen *screen , cairo_font_options_t *options ) ;
#line 121
cairo_font_options_t *gdk_screen_get_font_options(GdkScreen *screen ) ;
#line 123
void gdk_screen_set_resolution(GdkScreen *screen , gdouble dpi ) ;
#line 125
gdouble gdk_screen_get_resolution(GdkScreen *screen ) ;
#line 127
GdkWindow *gdk_screen_get_active_window(GdkScreen *screen ) ;
#line 128
GList *gdk_screen_get_window_stack(GdkScreen *screen ) ;
#line 58 "/usr/include/gtk-2.0/gdk/gdkapplaunchcontext.h"
GType gdk_app_launch_context_get_type(void) ;
#line 60
GdkAppLaunchContext *gdk_app_launch_context_new(void) ;
#line 61
void gdk_app_launch_context_set_display(GdkAppLaunchContext *context , GdkDisplay *display ) ;
#line 63
void gdk_app_launch_context_set_screen(GdkAppLaunchContext *context , GdkScreen *screen ) ;
#line 65
void gdk_app_launch_context_set_desktop(GdkAppLaunchContext *context , gint desktop ) ;
#line 67
void gdk_app_launch_context_set_timestamp(GdkAppLaunchContext *context , guint32 timestamp ) ;
#line 69
void gdk_app_launch_context_set_icon(GdkAppLaunchContext *context , GIcon *icon ) ;
#line 71
void gdk_app_launch_context_set_icon_name(GdkAppLaunchContext *context , char const   *icon_name ) ;
#line 57 "/usr/include/gtk-2.0/gdk/gdkrgb.h"
void gdk_rgb_init(void) ;
#line 59
gulong gdk_rgb_xpixel_from_rgb(guint32 rgb ) ;
#line 60
void gdk_rgb_gc_set_foreground(GdkGC *gc , guint32 rgb ) ;
#line 62
void gdk_rgb_gc_set_background(GdkGC *gc , guint32 rgb ) ;
#line 66
void gdk_rgb_find_color(GdkColormap *colormap , GdkColor *color ) ;
#line 69
void gdk_draw_rgb_image(GdkDrawable *drawable , GdkGC *gc , gint x , gint y , gint width ,
                        gint height , GdkRgbDither dith , guchar *rgb_buf , gint rowstride ) ;
#line 78
void gdk_draw_rgb_image_dithalign(GdkDrawable *drawable , GdkGC *gc , gint x , gint y ,
                                  gint width , gint height , GdkRgbDither dith , guchar *rgb_buf ,
                                  gint rowstride , gint xdith , gint ydith ) ;
#line 89
void gdk_draw_rgb_32_image(GdkDrawable *drawable , GdkGC *gc , gint x , gint y , gint width ,
                           gint height , GdkRgbDither dith , guchar *buf , gint rowstride ) ;
#line 98
void gdk_draw_rgb_32_image_dithalign(GdkDrawable *drawable , GdkGC *gc , gint x ,
                                     gint y , gint width , gint height , GdkRgbDither dith ,
                                     guchar *buf , gint rowstride , gint xdith , gint ydith ) ;
#line 109
void gdk_draw_gray_image(GdkDrawable *drawable , GdkGC *gc , gint x , gint y , gint width ,
                         gint height , GdkRgbDither dith , guchar *buf , gint rowstride ) ;
#line 118
void gdk_draw_indexed_image(GdkDrawable *drawable , GdkGC *gc , gint x , gint y ,
                            gint width , gint height , GdkRgbDither dith , guchar *buf ,
                            gint rowstride , GdkRgbCmap *cmap ) ;
#line 128
GdkRgbCmap *gdk_rgb_cmap_new(guint32 *colors , gint n_colors ) ;
#line 130
void gdk_rgb_cmap_free(GdkRgbCmap *cmap ) ;
#line 132
void gdk_rgb_set_verbose(gboolean verbose ) ;
#line 135
void gdk_rgb_set_install(gboolean install ) ;
#line 136
void gdk_rgb_set_min_colors(gint min_colors ) ;
#line 139
GdkColormap *gdk_rgb_get_colormap(void) ;
#line 140
GdkVisual *gdk_rgb_get_visual(void) ;
#line 141
gboolean gdk_rgb_ditherable(void) ;
#line 142
gboolean gdk_rgb_colormap_ditherable(GdkColormap *cmap ) ;
#line 110 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-features.h"
extern guint gdk_pixbuf_major_version ;
#line 111
extern guint gdk_pixbuf_minor_version ;
#line 112
extern guint gdk_pixbuf_micro_version ;
#line 113
extern char const   *gdk_pixbuf_version ;
#line 155 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h"
extern GQuark gdk_pixbuf_error_quark(void) ;
#line 160
extern GType gdk_pixbuf_get_type(void) ;
#line 166
extern GdkPixbuf *gdk_pixbuf_ref(GdkPixbuf *pixbuf ) ;
#line 168
extern void gdk_pixbuf_unref(GdkPixbuf *pixbuf ) ;
#line 174
extern GdkColorspace gdk_pixbuf_get_colorspace(GdkPixbuf *pixbuf ) ;
#line 176
extern int gdk_pixbuf_get_n_channels(GdkPixbuf *pixbuf ) ;
#line 178
extern gboolean gdk_pixbuf_get_has_alpha(GdkPixbuf *pixbuf ) ;
#line 180
extern int gdk_pixbuf_get_bits_per_sample(GdkPixbuf *pixbuf ) ;
#line 182
extern guchar *gdk_pixbuf_get_pixels(GdkPixbuf *pixbuf ) ;
#line 184
extern int gdk_pixbuf_get_width(GdkPixbuf *pixbuf ) ;
#line 186
extern int gdk_pixbuf_get_height(GdkPixbuf *pixbuf ) ;
#line 188
extern int gdk_pixbuf_get_rowstride(GdkPixbuf *pixbuf ) ;
#line 190
extern gsize gdk_pixbuf_get_byte_length(GdkPixbuf *pixbuf ) ;
#line 193
extern guchar *gdk_pixbuf_get_pixels_with_length(GdkPixbuf *pixbuf , guint *length ) ;
#line 197
extern guint8 *gdk_pixbuf_read_pixels(GdkPixbuf *pixbuf ) ;
#line 199
extern GBytes *gdk_pixbuf_read_pixel_bytes(GdkPixbuf *pixbuf ) ;
#line 206
extern GdkPixbuf *gdk_pixbuf_new(GdkColorspace colorspace , gboolean has_alpha , int bits_per_sample ,
                                 int width , int height ) ;
#line 210
extern gint gdk_pixbuf_calculate_rowstride(GdkColorspace colorspace , gboolean has_alpha ,
                                           int bits_per_sample , int width , int height ) ;
#line 218
extern GdkPixbuf *gdk_pixbuf_copy(GdkPixbuf *pixbuf ) ;
#line 222
extern GdkPixbuf *gdk_pixbuf_new_subpixbuf(GdkPixbuf *src_pixbuf , int src_x , int src_y ,
                                           int width , int height ) ;
#line 252
extern GdkPixbuf *gdk_pixbuf_new_from_file(char const   *filename , GError **error ) ;
#line 255
extern GdkPixbuf *gdk_pixbuf_new_from_file_at_size(char const   *filename , int width ,
                                                   int height , GError **error ) ;
#line 260
extern GdkPixbuf *gdk_pixbuf_new_from_file_at_scale(char const   *filename , int width ,
                                                    int height , gboolean preserve_aspect_ratio ,
                                                    GError **error ) ;
#line 266
extern GdkPixbuf *gdk_pixbuf_new_from_resource(char const   *resource_path , GError **error ) ;
#line 269
extern GdkPixbuf *gdk_pixbuf_new_from_resource_at_scale(char const   *resource_path ,
                                                        int width , int height , gboolean preserve_aspect_ratio ,
                                                        GError **error ) ;
#line 276
extern GdkPixbuf *gdk_pixbuf_new_from_data(guchar *data , GdkColorspace colorspace ,
                                           gboolean has_alpha , int bits_per_sample ,
                                           int width , int height , int rowstride ,
                                           GdkPixbufDestroyNotify destroy_fn , gpointer destroy_fn_data ) ;
#line 286
extern GdkPixbuf *gdk_pixbuf_new_from_bytes(GBytes *data , GdkColorspace colorspace ,
                                            gboolean has_alpha , int bits_per_sample ,
                                            int width , int height , int rowstride ) ;
#line 294
extern GdkPixbuf *gdk_pixbuf_new_from_xpm_data(char const   **data ) ;
#line 298
extern GdkPixbuf *gdk_pixbuf_new_from_inline(gint data_length , guint8 *data , gboolean copy_pixels ,
                                             GError **error ) ;
#line 306
extern void gdk_pixbuf_fill(GdkPixbuf *pixbuf , guint32 pixel ) ;
#line 319
extern gboolean gdk_pixbuf_save(GdkPixbuf *pixbuf , char const   *filename , char const   *type ,
                                GError **error  , ...) ;
#line 326
extern gboolean gdk_pixbuf_savev(GdkPixbuf *pixbuf , char const   *filename , char const   *type ,
                                 char **option_keys , char **option_values , GError **error ) ;
#line 373
extern gboolean gdk_pixbuf_save_to_callback(GdkPixbuf *pixbuf , GdkPixbufSaveFunc save_func ,
                                            gpointer user_data , char const   *type ,
                                            GError **error  , ...) ;
#line 381
extern gboolean gdk_pixbuf_save_to_callbackv(GdkPixbuf *pixbuf , GdkPixbufSaveFunc save_func ,
                                             gpointer user_data , char const   *type ,
                                             char **option_keys , char **option_values ,
                                             GError **error ) ;
#line 392
extern gboolean gdk_pixbuf_save_to_buffer(GdkPixbuf *pixbuf , gchar **buffer , gsize *buffer_size ,
                                          char const   *type , GError **error  , ...) ;
#line 400
extern gboolean gdk_pixbuf_save_to_bufferv(GdkPixbuf *pixbuf , gchar **buffer , gsize *buffer_size ,
                                           char const   *type , char **option_keys ,
                                           char **option_values , GError **error ) ;
#line 409
extern GdkPixbuf *gdk_pixbuf_new_from_stream(GInputStream *stream , GCancellable *cancellable ,
                                             GError **error ) ;
#line 414
extern void gdk_pixbuf_new_from_stream_async(GInputStream *stream , GCancellable *cancellable ,
                                             GAsyncReadyCallback callback , gpointer user_data ) ;
#line 420
extern GdkPixbuf *gdk_pixbuf_new_from_stream_finish(GAsyncResult *async_result , GError **error ) ;
#line 424
extern GdkPixbuf *gdk_pixbuf_new_from_stream_at_scale(GInputStream *stream , gint width ,
                                                      gint height , gboolean preserve_aspect_ratio ,
                                                      GCancellable *cancellable ,
                                                      GError **error ) ;
#line 432
extern void gdk_pixbuf_new_from_stream_at_scale_async(GInputStream *stream , gint width ,
                                                      gint height , gboolean preserve_aspect_ratio ,
                                                      GCancellable *cancellable ,
                                                      GAsyncReadyCallback callback ,
                                                      gpointer user_data ) ;
#line 441
extern gboolean gdk_pixbuf_save_to_stream(GdkPixbuf *pixbuf , GOutputStream *stream ,
                                          char const   *type , GCancellable *cancellable ,
                                          GError **error  , ...) ;
#line 449
extern void gdk_pixbuf_save_to_stream_async(GdkPixbuf *pixbuf , GOutputStream *stream ,
                                            gchar *type , GCancellable *cancellable ,
                                            GAsyncReadyCallback callback , gpointer user_data 
                                            , ...) ;
#line 458
extern gboolean gdk_pixbuf_save_to_stream_finish(GAsyncResult *async_result , GError **error ) ;
#line 462
extern void gdk_pixbuf_save_to_streamv_async(GdkPixbuf *pixbuf , GOutputStream *stream ,
                                             gchar *type , gchar **option_keys , gchar **option_values ,
                                             GCancellable *cancellable , GAsyncReadyCallback callback ,
                                             gpointer user_data ) ;
#line 472
extern gboolean gdk_pixbuf_save_to_streamv(GdkPixbuf *pixbuf , GOutputStream *stream ,
                                           char const   *type , char **option_keys ,
                                           char **option_values , GCancellable *cancellable ,
                                           GError **error ) ;
#line 482
extern GdkPixbuf *gdk_pixbuf_add_alpha(GdkPixbuf *pixbuf , gboolean substitute_color ,
                                       guchar r , guchar g , guchar b ) ;
#line 487
extern void gdk_pixbuf_copy_area(GdkPixbuf *src_pixbuf , int src_x , int src_y , int width ,
                                 int height , GdkPixbuf *dest_pixbuf , int dest_x ,
                                 int dest_y ) ;
#line 495
extern void gdk_pixbuf_saturate_and_pixelate(GdkPixbuf *src , GdkPixbuf *dest , gfloat saturation ,
                                             gboolean pixelate ) ;
#line 502
extern GdkPixbuf *gdk_pixbuf_apply_embedded_orientation(GdkPixbuf *src ) ;
#line 506
extern gboolean gdk_pixbuf_set_option(GdkPixbuf *pixbuf , gchar *key , gchar *value ) ;
#line 510
extern gchar *gdk_pixbuf_get_option(GdkPixbuf *pixbuf , gchar *key ) ;
#line 513
extern gboolean gdk_pixbuf_remove_option(GdkPixbuf *pixbuf , gchar *key ) ;
#line 516
extern GHashTable *gdk_pixbuf_get_options(GdkPixbuf *pixbuf ) ;
#line 518
extern gboolean gdk_pixbuf_copy_options(GdkPixbuf *src_pixbuf , GdkPixbuf *dest_pixbuf ) ;
#line 99 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-transform.h"
extern void gdk_pixbuf_scale(GdkPixbuf *src , GdkPixbuf *dest , int dest_x , int dest_y ,
                             int dest_width , int dest_height , double offset_x ,
                             double offset_y , double scale_x , double scale_y , GdkInterpType interp_type ) ;
#line 111
extern void gdk_pixbuf_composite(GdkPixbuf *src , GdkPixbuf *dest , int dest_x , int dest_y ,
                                 int dest_width , int dest_height , double offset_x ,
                                 double offset_y , double scale_x , double scale_y ,
                                 GdkInterpType interp_type , int overall_alpha ) ;
#line 124
extern void gdk_pixbuf_composite_color(GdkPixbuf *src , GdkPixbuf *dest , int dest_x ,
                                       int dest_y , int dest_width , int dest_height ,
                                       double offset_x , double offset_y , double scale_x ,
                                       double scale_y , GdkInterpType interp_type ,
                                       int overall_alpha , int check_x , int check_y ,
                                       int check_size , guint32 color1 , guint32 color2 ) ;
#line 143
extern GdkPixbuf *gdk_pixbuf_scale_simple(GdkPixbuf *src , int dest_width , int dest_height ,
                                          GdkInterpType interp_type ) ;
#line 149
extern GdkPixbuf *gdk_pixbuf_composite_color_simple(GdkPixbuf *src , int dest_width ,
                                                    int dest_height , GdkInterpType interp_type ,
                                                    int overall_alpha , int check_size ,
                                                    guint32 color1 , guint32 color2 ) ;
#line 159
extern GdkPixbuf *gdk_pixbuf_rotate_simple(GdkPixbuf *src , GdkPixbufRotation angle ) ;
#line 162
extern GdkPixbuf *gdk_pixbuf_flip(GdkPixbuf *src , gboolean horizontal ) ;
#line 53 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-animation.h"
extern GType gdk_pixbuf_animation_get_type(void) ;
#line 63
extern GdkPixbufAnimation *gdk_pixbuf_animation_new_from_file(char const   *filename ,
                                                              GError **error ) ;
#line 66
extern GdkPixbufAnimation *gdk_pixbuf_animation_new_from_stream(GInputStream *stream ,
                                                                GCancellable *cancellable ,
                                                                GError **error ) ;
#line 70
extern void gdk_pixbuf_animation_new_from_stream_async(GInputStream *stream , GCancellable *cancellable ,
                                                       GAsyncReadyCallback callback ,
                                                       gpointer user_data ) ;
#line 75
extern GdkPixbufAnimation *gdk_pixbuf_animation_new_from_stream_finish(GAsyncResult *async_result ,
                                                                       GError **error ) ;
#line 78
extern GdkPixbufAnimation *gdk_pixbuf_animation_new_from_resource(char const   *resource_path ,
                                                                  GError **error ) ;
#line 84
extern GdkPixbufAnimation *gdk_pixbuf_animation_ref(GdkPixbufAnimation *animation ) ;
#line 86
extern void gdk_pixbuf_animation_unref(GdkPixbufAnimation *animation ) ;
#line 90
extern int gdk_pixbuf_animation_get_width(GdkPixbufAnimation *animation ) ;
#line 92
extern int gdk_pixbuf_animation_get_height(GdkPixbufAnimation *animation ) ;
#line 94
extern gboolean gdk_pixbuf_animation_is_static_image(GdkPixbufAnimation *animation ) ;
#line 96
extern GdkPixbuf *gdk_pixbuf_animation_get_static_image(GdkPixbufAnimation *animation ) ;
#line 100
extern GdkPixbufAnimationIter *gdk_pixbuf_animation_get_iter(GdkPixbufAnimation *animation ,
                                                             GTimeVal *start_time ) ;
#line 105
extern GType gdk_pixbuf_animation_iter_get_type(void) ;
#line 107
extern int gdk_pixbuf_animation_iter_get_delay_time(GdkPixbufAnimationIter *iter ) ;
#line 109
extern GdkPixbuf *gdk_pixbuf_animation_iter_get_pixbuf(GdkPixbufAnimationIter *iter ) ;
#line 111
extern gboolean gdk_pixbuf_animation_iter_on_currently_loading_frame(GdkPixbufAnimationIter *iter ) ;
#line 114
extern gboolean gdk_pixbuf_animation_iter_advance(GdkPixbufAnimationIter *iter , GTimeVal *current_time ) ;
#line 50 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-simple-anim.h"
extern GType gdk_pixbuf_simple_anim_get_type(void) ;
#line 52
extern GType gdk_pixbuf_simple_anim_iter_get_type(void) ;
#line 55
extern GdkPixbufSimpleAnim *gdk_pixbuf_simple_anim_new(gint width , gint height ,
                                                       gfloat rate ) ;
#line 59
extern void gdk_pixbuf_simple_anim_add_frame(GdkPixbufSimpleAnim *animation , GdkPixbuf *pixbuf ) ;
#line 62
extern void gdk_pixbuf_simple_anim_set_loop(GdkPixbufSimpleAnim *animation , gboolean loop ) ;
#line 65
extern gboolean gdk_pixbuf_simple_anim_get_loop(GdkPixbufSimpleAnim *animation ) ;
#line 45 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-io.h"
extern gboolean gdk_pixbuf_init_modules(char const   *path , GError **error ) ;
#line 49
extern GType gdk_pixbuf_format_get_type(void) ;
#line 52
extern GSList *gdk_pixbuf_get_formats(void) ;
#line 54
extern gchar *gdk_pixbuf_format_get_name(GdkPixbufFormat *format ) ;
#line 56
extern gchar *gdk_pixbuf_format_get_description(GdkPixbufFormat *format ) ;
#line 58
extern gchar **gdk_pixbuf_format_get_mime_types(GdkPixbufFormat *format ) ;
#line 60
extern gchar **gdk_pixbuf_format_get_extensions(GdkPixbufFormat *format ) ;
#line 62
extern gboolean gdk_pixbuf_format_is_save_option_supported(GdkPixbufFormat *format ,
                                                           gchar *option_key ) ;
#line 65
extern gboolean gdk_pixbuf_format_is_writable(GdkPixbufFormat *format ) ;
#line 67
extern gboolean gdk_pixbuf_format_is_scalable(GdkPixbufFormat *format ) ;
#line 69
extern gboolean gdk_pixbuf_format_is_disabled(GdkPixbufFormat *format ) ;
#line 71
extern void gdk_pixbuf_format_set_disabled(GdkPixbufFormat *format , gboolean disabled ) ;
#line 74
extern gchar *gdk_pixbuf_format_get_license(GdkPixbufFormat *format ) ;
#line 77
extern GdkPixbufFormat *gdk_pixbuf_get_file_info(gchar *filename , gint *width , gint *height ) ;
#line 81
extern void gdk_pixbuf_get_file_info_async(gchar *filename , GCancellable *cancellable ,
                                           GAsyncReadyCallback callback , gpointer user_data ) ;
#line 86
extern GdkPixbufFormat *gdk_pixbuf_get_file_info_finish(GAsyncResult *async_result ,
                                                        gint *width , gint *height ,
                                                        GError **error ) ;
#line 92
extern GdkPixbufFormat *gdk_pixbuf_format_copy(GdkPixbufFormat *format ) ;
#line 94
extern void gdk_pixbuf_format_free(GdkPixbufFormat *format ) ;
#line 77 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-loader.h"
extern GType gdk_pixbuf_loader_get_type(void) ;
#line 79
extern GdkPixbufLoader *gdk_pixbuf_loader_new(void) ;
#line 81
extern GdkPixbufLoader *gdk_pixbuf_loader_new_with_type(char const   *image_type ,
                                                        GError **error ) ;
#line 84
extern GdkPixbufLoader *gdk_pixbuf_loader_new_with_mime_type(char const   *mime_type ,
                                                             GError **error ) ;
#line 87
extern void gdk_pixbuf_loader_set_size(GdkPixbufLoader *loader , int width , int height ) ;
#line 91
extern gboolean gdk_pixbuf_loader_write(GdkPixbufLoader *loader , guchar *buf , gsize count ,
                                        GError **error ) ;
#line 96
extern gboolean gdk_pixbuf_loader_write_bytes(GdkPixbufLoader *loader , GBytes *buffer ,
                                              GError **error ) ;
#line 100
extern GdkPixbuf *gdk_pixbuf_loader_get_pixbuf(GdkPixbufLoader *loader ) ;
#line 102
extern GdkPixbufAnimation *gdk_pixbuf_loader_get_animation(GdkPixbufLoader *loader ) ;
#line 104
extern gboolean gdk_pixbuf_loader_close(GdkPixbufLoader *loader , GError **error ) ;
#line 107
extern GdkPixbufFormat *gdk_pixbuf_loader_get_format(GdkPixbufLoader *loader ) ;
#line 19 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-enum-types.h"
extern GType gdk_pixbuf_alpha_mode_get_type(void) ;
#line 22
extern GType gdk_colorspace_get_type(void) ;
#line 25
extern GType gdk_pixbuf_error_get_type(void) ;
#line 30
extern GType gdk_interp_type_get_type(void) ;
#line 33
extern GType gdk_pixbuf_rotation_get_type(void) ;
#line 29 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
__inline static void glib_autoptr_clear_GdkPixbuf(GdkPixbuf *_ptr ) 
{ 


  {
#line 29
  if (_ptr) {
    {
#line 29
    g_object_unref((GdkPixbuf *)_ptr);
    }
  }
  return;
}
}
#line 29 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
__inline static void glib_autoptr_cleanup_GdkPixbuf(GdkPixbuf **_ptr ) 
{ 


  {
  {
#line 29
  glib_autoptr_clear_GdkPixbuf(*_ptr);
  }
  return;
}
}
#line 30 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
__inline static void glib_autoptr_clear_GdkPixbufAnimation(GdkPixbufAnimation *_ptr ) 
{ 


  {
#line 30
  if (_ptr) {
    {
#line 30
    g_object_unref((GdkPixbufAnimation *)_ptr);
    }
  }
  return;
}
}
#line 30 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
__inline static void glib_autoptr_cleanup_GdkPixbufAnimation(GdkPixbufAnimation **_ptr ) 
{ 


  {
  {
#line 30
  glib_autoptr_clear_GdkPixbufAnimation(*_ptr);
  }
  return;
}
}
#line 31 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
__inline static void glib_autoptr_clear_GdkPixbufAnimationIter(GdkPixbufAnimationIter *_ptr ) 
{ 


  {
#line 31
  if (_ptr) {
    {
#line 31
    g_object_unref((GdkPixbufAnimationIter *)_ptr);
    }
  }
  return;
}
}
#line 31 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
__inline static void glib_autoptr_cleanup_GdkPixbufAnimationIter(GdkPixbufAnimationIter **_ptr ) 
{ 


  {
  {
#line 31
  glib_autoptr_clear_GdkPixbufAnimationIter(*_ptr);
  }
  return;
}
}
#line 32 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
__inline static void glib_autoptr_clear_GdkPixbufLoader(GdkPixbufLoader *_ptr ) 
{ 


  {
#line 32
  if (_ptr) {
    {
#line 32
    g_object_unref((GdkPixbufLoader *)_ptr);
    }
  }
  return;
}
}
#line 32 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
__inline static void glib_autoptr_cleanup_GdkPixbufLoader(GdkPixbufLoader **_ptr ) 
{ 


  {
  {
#line 32
  glib_autoptr_clear_GdkPixbufLoader(*_ptr);
  }
  return;
}
}
#line 33 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
__inline static void glib_autoptr_clear_GdkPixbufSimpleAnim(GdkPixbufSimpleAnim *_ptr ) 
{ 


  {
#line 33
  if (_ptr) {
    {
#line 33
    g_object_unref((GdkPixbufSimpleAnim *)_ptr);
    }
  }
  return;
}
}
#line 33 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
__inline static void glib_autoptr_cleanup_GdkPixbufSimpleAnim(GdkPixbufSimpleAnim **_ptr ) 
{ 


  {
  {
#line 33
  glib_autoptr_clear_GdkPixbufSimpleAnim(*_ptr);
  }
  return;
}
}
#line 43 "/usr/include/gtk-2.0/gdk/gdkpixbuf.h"
void gdk_pixbuf_render_threshold_alpha(GdkPixbuf *pixbuf , GdkBitmap *bitmap , int src_x ,
                                       int src_y , int dest_x , int dest_y , int width ,
                                       int height , int alpha_threshold ) ;
#line 53
void gdk_pixbuf_render_to_drawable(GdkPixbuf *pixbuf , GdkDrawable *drawable , GdkGC *gc ,
                                   int src_x , int src_y , int dest_x , int dest_y ,
                                   int width , int height , GdkRgbDither dither ,
                                   int x_dither , int y_dither ) ;
#line 65
void gdk_pixbuf_render_to_drawable_alpha(GdkPixbuf *pixbuf , GdkDrawable *drawable ,
                                         int src_x , int src_y , int dest_x , int dest_y ,
                                         int width , int height , GdkPixbufAlphaMode alpha_mode ,
                                         int alpha_threshold , GdkRgbDither dither ,
                                         int x_dither , int y_dither ) ;
#line 79
void gdk_pixbuf_render_pixmap_and_mask_for_colormap(GdkPixbuf *pixbuf , GdkColormap *colormap ,
                                                    GdkPixmap **pixmap_return , GdkBitmap **mask_return ,
                                                    int alpha_threshold ) ;
#line 85
void gdk_pixbuf_render_pixmap_and_mask(GdkPixbuf *pixbuf , GdkPixmap **pixmap_return ,
                                       GdkBitmap **mask_return , int alpha_threshold ) ;
#line 93
GdkPixbuf *gdk_pixbuf_get_from_drawable(GdkPixbuf *dest , GdkDrawable *src , GdkColormap *cmap ,
                                        int src_x , int src_y , int dest_x , int dest_y ,
                                        int width , int height ) ;
#line 103
GdkPixbuf *gdk_pixbuf_get_from_image(GdkPixbuf *dest , GdkImage *src , GdkColormap *cmap ,
                                     int src_x , int src_y , int dest_x , int dest_y ,
                                     int width , int height ) ;
#line 103 "/usr/include/pango-1.0/pango/pangocairo.h"
extern GType pango_cairo_font_map_get_type(void) ;
#line 106
extern PangoFontMap *pango_cairo_font_map_new(void) ;
#line 108
extern PangoFontMap *pango_cairo_font_map_new_for_font_type(cairo_font_type_t fonttype ) ;
#line 110
extern PangoFontMap *pango_cairo_font_map_get_default(void) ;
#line 112
extern void pango_cairo_font_map_set_default(PangoCairoFontMap *fontmap ) ;
#line 114
extern cairo_font_type_t pango_cairo_font_map_get_font_type(PangoCairoFontMap *fontmap ) ;
#line 117
extern void pango_cairo_font_map_set_resolution(PangoCairoFontMap *fontmap , double dpi ) ;
#line 120
extern double pango_cairo_font_map_get_resolution(PangoCairoFontMap *fontmap ) ;
#line 123
extern PangoContext *pango_cairo_font_map_create_context(PangoCairoFontMap *fontmap ) ;
#line 130
extern GType pango_cairo_font_get_type(void) ;
#line 133
extern cairo_scaled_font_t *pango_cairo_font_get_scaled_font(PangoCairoFont *font ) ;
#line 138
extern void pango_cairo_update_context(cairo_t *cr , PangoContext *context ) ;
#line 142
extern void pango_cairo_context_set_font_options(PangoContext *context , cairo_font_options_t *options ) ;
#line 145
extern cairo_font_options_t *pango_cairo_context_get_font_options(PangoContext *context ) ;
#line 148
extern void pango_cairo_context_set_resolution(PangoContext *context , double dpi ) ;
#line 151
extern double pango_cairo_context_get_resolution(PangoContext *context ) ;
#line 154
extern void pango_cairo_context_set_shape_renderer(PangoContext *context , PangoCairoShapeRendererFunc func ,
                                                   gpointer data , GDestroyNotify dnotify ) ;
#line 159
extern PangoCairoShapeRendererFunc pango_cairo_context_get_shape_renderer(PangoContext *context ,
                                                                          gpointer *data ) ;
#line 165
extern PangoContext *pango_cairo_create_context(cairo_t *cr ) ;
#line 167
extern PangoLayout *pango_cairo_create_layout(cairo_t *cr ) ;
#line 169
extern void pango_cairo_update_layout(cairo_t *cr , PangoLayout *layout ) ;
#line 176
extern void pango_cairo_show_glyph_string(cairo_t *cr , PangoFont *font , PangoGlyphString *glyphs ) ;
#line 180
extern void pango_cairo_show_glyph_item(cairo_t *cr , char const   *text , PangoGlyphItem *glyph_item ) ;
#line 184
extern void pango_cairo_show_layout_line(cairo_t *cr , PangoLayoutLine *line ) ;
#line 187
extern void pango_cairo_show_layout(cairo_t *cr , PangoLayout *layout ) ;
#line 191
extern void pango_cairo_show_error_underline(cairo_t *cr , double x , double y , double width ,
                                             double height ) ;
#line 201
extern void pango_cairo_glyph_string_path(cairo_t *cr , PangoFont *font , PangoGlyphString *glyphs ) ;
#line 205
extern void pango_cairo_layout_line_path(cairo_t *cr , PangoLayoutLine *line ) ;
#line 208
extern void pango_cairo_layout_path(cairo_t *cr , PangoLayout *layout ) ;
#line 212
extern void pango_cairo_error_underline_path(cairo_t *cr , double x , double y , double width ,
                                             double height ) ;
#line 33 "/usr/include/gtk-2.0/gdk/gdkcairo.h"
cairo_t *gdk_cairo_create(GdkDrawable *drawable ) ;
#line 34
void gdk_cairo_reset_clip(cairo_t *cr , GdkDrawable *drawable ) ;
#line 37
void gdk_cairo_set_source_color(cairo_t *cr , GdkColor *color ) ;
#line 39
void gdk_cairo_set_source_pixbuf(cairo_t *cr , GdkPixbuf *pixbuf , double pixbuf_x ,
                                 double pixbuf_y ) ;
#line 43
void gdk_cairo_set_source_pixmap(cairo_t *cr , GdkPixmap *pixmap , double pixmap_x ,
                                 double pixmap_y ) ;
#line 47
void gdk_cairo_set_source_window(cairo_t *cr , GdkWindow *window , double x , double y ) ;
#line 52
void gdk_cairo_rectangle(cairo_t *cr , GdkRectangle *rectangle ) ;
#line 54
void gdk_cairo_region(cairo_t *cr , GdkRegion *region ) ;
#line 137 "/usr/include/gtk-2.0/gdk/gdkcursor.h"
GType gdk_cursor_get_type(void) ;
#line 139
GdkCursor *gdk_cursor_new_for_display(GdkDisplay *display , GdkCursorType cursor_type ) ;
#line 142
GdkCursor *gdk_cursor_new(GdkCursorType cursor_type ) ;
#line 144
GdkCursor *gdk_cursor_new_from_pixmap(GdkPixmap *source , GdkPixmap *mask , GdkColor *fg ,
                                      GdkColor *bg , gint x , gint y ) ;
#line 150
GdkCursor *gdk_cursor_new_from_pixbuf(GdkDisplay *display , GdkPixbuf *pixbuf , gint x ,
                                      gint y ) ;
#line 154
GdkDisplay *gdk_cursor_get_display(GdkCursor *cursor ) ;
#line 155
GdkCursor *gdk_cursor_ref(GdkCursor *cursor ) ;
#line 156
void gdk_cursor_unref(GdkCursor *cursor ) ;
#line 157
GdkCursor *gdk_cursor_new_from_name(GdkDisplay *display , gchar *name ) ;
#line 159
GdkPixbuf *gdk_cursor_get_image(GdkCursor *cursor ) ;
#line 160
GdkCursorType gdk_cursor_get_cursor_type(GdkCursor *cursor ) ;
#line 57 "/usr/include/gtk-2.0/gdk/gdkdisplaymanager.h"
GType gdk_display_manager_get_type(void) ;
#line 59
GdkDisplayManager *gdk_display_manager_get(void) ;
#line 60
GdkDisplay *gdk_display_manager_get_default_display(GdkDisplayManager *display_manager ) ;
#line 61
void gdk_display_manager_set_default_display(GdkDisplayManager *display_manager ,
                                             GdkDisplay *display ) ;
#line 63
GSList *gdk_display_manager_list_displays(GdkDisplayManager *display_manager ) ;
#line 224 "/usr/include/gtk-2.0/gdk/gdkgc.h"
GType gdk_gc_get_type(void) ;
#line 225
GdkGC *gdk_gc_new(GdkDrawable *drawable ) ;
#line 226
GdkGC *gdk_gc_new_with_values(GdkDrawable *drawable , GdkGCValues *values , GdkGCValuesMask values_mask ) ;
#line 230
GdkGC *gdk_gc_ref(GdkGC *gc ) ;
#line 231
void gdk_gc_unref(GdkGC *gc ) ;
#line 233
void gdk_gc_get_values(GdkGC *gc , GdkGCValues *values ) ;
#line 235
void gdk_gc_set_values(GdkGC *gc , GdkGCValues *values , GdkGCValuesMask values_mask ) ;
#line 238
void gdk_gc_set_foreground(GdkGC *gc , GdkColor *color ) ;
#line 240
void gdk_gc_set_background(GdkGC *gc , GdkColor *color ) ;
#line 242
void gdk_gc_set_font(GdkGC *gc , GdkFont *font ) ;
#line 244
void gdk_gc_set_function(GdkGC *gc , GdkFunction function ) ;
#line 246
void gdk_gc_set_fill(GdkGC *gc , GdkFill fill ) ;
#line 248
void gdk_gc_set_tile(GdkGC *gc , GdkPixmap *tile ) ;
#line 250
void gdk_gc_set_stipple(GdkGC *gc , GdkPixmap *stipple ) ;
#line 252
void gdk_gc_set_ts_origin(GdkGC *gc , gint x , gint y ) ;
#line 255
void gdk_gc_set_clip_origin(GdkGC *gc , gint x , gint y ) ;
#line 258
void gdk_gc_set_clip_mask(GdkGC *gc , GdkBitmap *mask ) ;
#line 260
void gdk_gc_set_clip_rectangle(GdkGC *gc , GdkRectangle *rectangle ) ;
#line 262
void gdk_gc_set_clip_region(GdkGC *gc , GdkRegion *region ) ;
#line 264
void gdk_gc_set_subwindow(GdkGC *gc , GdkSubwindowMode mode ) ;
#line 266
void gdk_gc_set_exposures(GdkGC *gc , gboolean exposures ) ;
#line 268
void gdk_gc_set_line_attributes(GdkGC *gc , gint line_width , GdkLineStyle line_style ,
                                GdkCapStyle cap_style , GdkJoinStyle join_style ) ;
#line 273
void gdk_gc_set_dashes(GdkGC *gc , gint dash_offset , gint8 dash_list[] , gint n ) ;
#line 277
void gdk_gc_offset(GdkGC *gc , gint x_offset , gint y_offset ) ;
#line 280
void gdk_gc_copy(GdkGC *dst_gc , GdkGC *src_gc ) ;
#line 284
void gdk_gc_set_colormap(GdkGC *gc , GdkColormap *colormap ) ;
#line 286
GdkColormap *gdk_gc_get_colormap(GdkGC *gc ) ;
#line 287
void gdk_gc_set_rgb_fg_color(GdkGC *gc , GdkColor *color ) ;
#line 289
void gdk_gc_set_rgb_bg_color(GdkGC *gc , GdkColor *color ) ;
#line 291
GdkScreen *gdk_gc_get_screen(GdkGC *gc ) ;
#line 239 "/usr/include/gtk-2.0/gdk/gdkdrawable.h"
GType gdk_drawable_get_type(void) ;
#line 245
void gdk_drawable_set_data(GdkDrawable *drawable , gchar *key , gpointer data , GDestroyNotify destroy_func ) ;
#line 249
gpointer gdk_drawable_get_data(GdkDrawable *drawable , gchar *key ) ;
#line 253
void gdk_drawable_set_colormap(GdkDrawable *drawable , GdkColormap *colormap ) ;
#line 255
GdkColormap *gdk_drawable_get_colormap(GdkDrawable *drawable ) ;
#line 256
gint gdk_drawable_get_depth(GdkDrawable *drawable ) ;
#line 259
void gdk_drawable_get_size(GdkDrawable *drawable , gint *width , gint *height ) ;
#line 262
GdkVisual *gdk_drawable_get_visual(GdkDrawable *drawable ) ;
#line 263
GdkScreen *gdk_drawable_get_screen(GdkDrawable *drawable ) ;
#line 264
GdkDisplay *gdk_drawable_get_display(GdkDrawable *drawable ) ;
#line 268
GdkDrawable *gdk_drawable_ref(GdkDrawable *drawable ) ;
#line 269
void gdk_drawable_unref(GdkDrawable *drawable ) ;
#line 275
void gdk_draw_point(GdkDrawable *drawable , GdkGC *gc , gint x , gint y ) ;
#line 279
void gdk_draw_line(GdkDrawable *drawable , GdkGC *gc , gint x1_ , gint y1_ , gint x2_ ,
                   gint y2_ ) ;
#line 285
void gdk_draw_rectangle(GdkDrawable *drawable , GdkGC *gc , gboolean filled , gint x ,
                        gint y , gint width , gint height ) ;
#line 292
void gdk_draw_arc(GdkDrawable *drawable , GdkGC *gc , gboolean filled , gint x , gint y ,
                  gint width , gint height , gint angle1 , gint angle2 ) ;
#line 301
void gdk_draw_polygon(GdkDrawable *drawable , GdkGC *gc , gboolean filled , GdkPoint *points ,
                      gint n_points ) ;
#line 306
void gdk_draw_string(GdkDrawable *drawable , GdkFont *font , GdkGC *gc , gint x ,
                     gint y , gchar *string ) ;
#line 312
void gdk_draw_text(GdkDrawable *drawable , GdkFont *font , GdkGC *gc , gint x , gint y ,
                   gchar *text , gint text_length ) ;
#line 319
void gdk_draw_text_wc(GdkDrawable *drawable , GdkFont *font , GdkGC *gc , gint x ,
                      gint y , GdkWChar *text , gint text_length ) ;
#line 326
void gdk_draw_drawable(GdkDrawable *drawable , GdkGC *gc , GdkDrawable *src , gint xsrc ,
                       gint ysrc , gint xdest , gint ydest , gint width , gint height ) ;
#line 335
void gdk_draw_image(GdkDrawable *drawable , GdkGC *gc , GdkImage *image , gint xsrc ,
                    gint ysrc , gint xdest , gint ydest , gint width , gint height ) ;
#line 344
void gdk_draw_points(GdkDrawable *drawable , GdkGC *gc , GdkPoint *points , gint n_points ) ;
#line 348
void gdk_draw_segments(GdkDrawable *drawable , GdkGC *gc , GdkSegment *segs , gint n_segs ) ;
#line 352
void gdk_draw_lines(GdkDrawable *drawable , GdkGC *gc , GdkPoint *points , gint n_points ) ;
#line 356
void gdk_draw_pixbuf(GdkDrawable *drawable , GdkGC *gc , GdkPixbuf *pixbuf , gint src_x ,
                     gint src_y , gint dest_x , gint dest_y , gint width , gint height ,
                     GdkRgbDither dither , gint x_dither , gint y_dither ) ;
#line 369
void gdk_draw_glyphs(GdkDrawable *drawable , GdkGC *gc , PangoFont *font , gint x ,
                     gint y , PangoGlyphString *glyphs ) ;
#line 375
void gdk_draw_layout_line(GdkDrawable *drawable , GdkGC *gc , gint x , gint y , PangoLayoutLine *line ) ;
#line 380
void gdk_draw_layout(GdkDrawable *drawable , GdkGC *gc , gint x , gint y , PangoLayout *layout ) ;
#line 386
void gdk_draw_layout_line_with_colors(GdkDrawable *drawable , GdkGC *gc , gint x ,
                                      gint y , PangoLayoutLine *line , GdkColor *foreground ,
                                      GdkColor *background ) ;
#line 393
void gdk_draw_layout_with_colors(GdkDrawable *drawable , GdkGC *gc , gint x , gint y ,
                                 PangoLayout *layout , GdkColor *foreground , GdkColor *background ) ;
#line 401
void gdk_draw_glyphs_transformed(GdkDrawable *drawable , GdkGC *gc , PangoMatrix *matrix ,
                                 PangoFont *font , gint x , gint y , PangoGlyphString *glyphs ) ;
#line 408
void gdk_draw_trapezoids(GdkDrawable *drawable , GdkGC *gc , GdkTrapezoid *trapezoids ,
                         gint n_trapezoids ) ;
#line 416
GdkImage *gdk_drawable_get_image(GdkDrawable *drawable , gint x , gint y , gint width ,
                                 gint height ) ;
#line 421
GdkImage *gdk_drawable_copy_to_image(GdkDrawable *drawable , GdkImage *image , gint src_x ,
                                     gint src_y , gint dest_x , gint dest_y , gint width ,
                                     gint height ) ;
#line 431
GdkRegion *gdk_drawable_get_clip_region(GdkDrawable *drawable ) ;
#line 432
GdkRegion *gdk_drawable_get_visible_region(GdkDrawable *drawable ) ;
#line 16 "/usr/include/gtk-2.0/gdk/gdkenumtypes.h"
GType gdk_cursor_type_get_type(void) ;
#line 20
GType gdk_drag_action_get_type(void) ;
#line 22
GType gdk_drag_protocol_get_type(void) ;
#line 26
GType gdk_filter_return_get_type(void) ;
#line 28
GType gdk_event_type_get_type(void) ;
#line 30
GType gdk_event_mask_get_type(void) ;
#line 32
GType gdk_visibility_state_get_type(void) ;
#line 34
GType gdk_scroll_direction_get_type(void) ;
#line 36
GType gdk_notify_type_get_type(void) ;
#line 38
GType gdk_crossing_mode_get_type(void) ;
#line 40
GType gdk_property_state_get_type(void) ;
#line 42
GType gdk_window_state_get_type(void) ;
#line 44
GType gdk_setting_action_get_type(void) ;
#line 46
GType gdk_owner_change_get_type(void) ;
#line 50
GType gdk_font_type_get_type(void) ;
#line 54
GType gdk_cap_style_get_type(void) ;
#line 56
GType gdk_fill_get_type(void) ;
#line 58
GType gdk_function_get_type(void) ;
#line 60
GType gdk_join_style_get_type(void) ;
#line 62
GType gdk_line_style_get_type(void) ;
#line 64
GType gdk_subwindow_mode_get_type(void) ;
#line 66
GType gdk_gc_values_mask_get_type(void) ;
#line 70
GType gdk_image_type_get_type(void) ;
#line 74
GType gdk_extension_mode_get_type(void) ;
#line 76
GType gdk_input_source_get_type(void) ;
#line 78
GType gdk_input_mode_get_type(void) ;
#line 80
GType gdk_axis_use_get_type(void) ;
#line 84
GType gdk_prop_mode_get_type(void) ;
#line 88
GType gdk_fill_rule_get_type(void) ;
#line 90
GType gdk_overlap_type_get_type(void) ;
#line 94
GType gdk_rgb_dither_get_type(void) ;
#line 98
GType gdk_byte_order_get_type(void) ;
#line 100
GType gdk_modifier_type_get_type(void) ;
#line 102
GType gdk_input_condition_get_type(void) ;
#line 104
GType gdk_status_get_type(void) ;
#line 106
GType gdk_grab_status_get_type(void) ;
#line 110
GType gdk_visual_type_get_type(void) ;
#line 114
GType gdk_window_class_get_type(void) ;
#line 116
GType gdk_window_type_get_type(void) ;
#line 118
GType gdk_window_attributes_type_get_type(void) ;
#line 120
GType gdk_window_hints_get_type(void) ;
#line 122
GType gdk_window_type_hint_get_type(void) ;
#line 124
GType gdk_wm_decoration_get_type(void) ;
#line 126
GType gdk_wm_function_get_type(void) ;
#line 128
GType gdk_gravity_get_type(void) ;
#line 130
GType gdk_window_edge_get_type(void) ;
#line 56 "/usr/include/gtk-2.0/gdk/gdkfont.h"
GType gdk_font_get_type(void) ;
#line 58
GdkFont *gdk_font_ref(GdkFont *font ) ;
#line 59
void gdk_font_unref(GdkFont *font ) ;
#line 60
gint gdk_font_id(GdkFont *font ) ;
#line 61
gboolean gdk_font_equal(GdkFont *fonta , GdkFont *fontb ) ;
#line 64
GdkFont *gdk_font_load_for_display(GdkDisplay *display , gchar *font_name ) ;
#line 66
GdkFont *gdk_fontset_load_for_display(GdkDisplay *display , gchar *fontset_name ) ;
#line 68
GdkFont *gdk_font_from_description_for_display(GdkDisplay *display , PangoFontDescription *font_desc ) ;
#line 74
GdkFont *gdk_font_load(gchar *font_name ) ;
#line 75
GdkFont *gdk_fontset_load(gchar *fontset_name ) ;
#line 76
GdkFont *gdk_font_from_description(PangoFontDescription *font_desc ) ;
#line 79
gint gdk_string_width(GdkFont *font , gchar *string ) ;
#line 81
gint gdk_text_width(GdkFont *font , gchar *text , gint text_length ) ;
#line 84
gint gdk_text_width_wc(GdkFont *font , GdkWChar *text , gint text_length ) ;
#line 87
gint gdk_char_width(GdkFont *font , gchar character ) ;
#line 89
gint gdk_char_width_wc(GdkFont *font , GdkWChar character ) ;
#line 91
gint gdk_string_measure(GdkFont *font , gchar *string ) ;
#line 93
gint gdk_text_measure(GdkFont *font , gchar *text , gint text_length ) ;
#line 96
gint gdk_char_measure(GdkFont *font , gchar character ) ;
#line 98
gint gdk_string_height(GdkFont *font , gchar *string ) ;
#line 100
gint gdk_text_height(GdkFont *font , gchar *text , gint text_length ) ;
#line 103
gint gdk_char_height(GdkFont *font , gchar character ) ;
#line 106
void gdk_text_extents(GdkFont *font , gchar *text , gint text_length , gint *lbearing ,
                      gint *rbearing , gint *width , gint *ascent , gint *descent ) ;
#line 114
void gdk_text_extents_wc(GdkFont *font , GdkWChar *text , gint text_length , gint *lbearing ,
                         gint *rbearing , gint *width , gint *ascent , gint *descent ) ;
#line 122
void gdk_string_extents(GdkFont *font , gchar *string , gint *lbearing , gint *rbearing ,
                        gint *width , gint *ascent , gint *descent ) ;
#line 130
GdkDisplay *gdk_font_get_display(GdkFont *font ) ;
#line 93 "/usr/include/gtk-2.0/gdk/gdkimage.h"
GType gdk_image_get_type(void) ;
#line 96
GdkImage *gdk_image_new(GdkImageType type , GdkVisual *visual , gint width , gint height ) ;
#line 101
GdkImage *gdk_image_get(GdkDrawable *drawable , gint x , gint y , gint width , gint height ) ;
#line 107
GdkImage *gdk_image_ref(GdkImage *image ) ;
#line 108
void gdk_image_unref(GdkImage *image ) ;
#line 110
void gdk_image_put_pixel(GdkImage *image , gint x , gint y , guint32 pixel ) ;
#line 114
guint32 gdk_image_get_pixel(GdkImage *image , gint x , gint y ) ;
#line 118
void gdk_image_set_colormap(GdkImage *image , GdkColormap *colormap ) ;
#line 120
GdkColormap *gdk_image_get_colormap(GdkImage *image ) ;
#line 122
GdkImageType gdk_image_get_image_type(GdkImage *image ) ;
#line 123
GdkVisual *gdk_image_get_visual(GdkImage *image ) ;
#line 124
GdkByteOrder gdk_image_get_byte_order(GdkImage *image ) ;
#line 125
gint gdk_image_get_width(GdkImage *image ) ;
#line 126
gint gdk_image_get_height(GdkImage *image ) ;
#line 127
guint16 gdk_image_get_depth(GdkImage *image ) ;
#line 128
guint16 gdk_image_get_bytes_per_pixel(GdkImage *image ) ;
#line 129
guint16 gdk_image_get_bytes_per_line(GdkImage *image ) ;
#line 130
guint16 gdk_image_get_bits_per_pixel(GdkImage *image ) ;
#line 131
gpointer gdk_image_get_pixels(GdkImage *image ) ;
#line 81 "/usr/include/gtk-2.0/gdk/gdkkeys.h"
GType gdk_keymap_get_type(void) ;
#line 84
GdkKeymap *gdk_keymap_get_default(void) ;
#line 86
GdkKeymap *gdk_keymap_get_for_display(GdkDisplay *display ) ;
#line 89
guint gdk_keymap_lookup_key(GdkKeymap *keymap , GdkKeymapKey *key ) ;
#line 91
gboolean gdk_keymap_translate_keyboard_state(GdkKeymap *keymap , guint hardware_keycode ,
                                             GdkModifierType state , gint group ,
                                             guint *keyval , gint *effective_group ,
                                             gint *level , GdkModifierType *consumed_modifiers ) ;
#line 99
gboolean gdk_keymap_get_entries_for_keyval(GdkKeymap *keymap , guint keyval , GdkKeymapKey **keys ,
                                           gint *n_keys ) ;
#line 103
gboolean gdk_keymap_get_entries_for_keycode(GdkKeymap *keymap , guint hardware_keycode ,
                                            GdkKeymapKey **keys , guint **keyvals ,
                                            gint *n_entries ) ;
#line 108
PangoDirection gdk_keymap_get_direction(GdkKeymap *keymap ) ;
#line 109
gboolean gdk_keymap_have_bidi_layouts(GdkKeymap *keymap ) ;
#line 110
gboolean gdk_keymap_get_caps_lock_state(GdkKeymap *keymap ) ;
#line 111
void gdk_keymap_add_virtual_modifiers(GdkKeymap *keymap , GdkModifierType *state ) ;
#line 113
gboolean gdk_keymap_map_virtual_modifiers(GdkKeymap *keymap , GdkModifierType *state ) ;
#line 118
gchar *gdk_keyval_name(guint keyval ) ;
#line 119
guint gdk_keyval_from_name(gchar *keyval_name ) ;
#line 120
void gdk_keyval_convert_case(guint symbol , guint *lower , guint *upper ) ;
#line 123
guint gdk_keyval_to_upper(guint keyval ) ;
#line 124
guint gdk_keyval_to_lower(guint keyval ) ;
#line 125
gboolean gdk_keyval_is_upper(guint keyval ) ;
#line 126
gboolean gdk_keyval_is_lower(guint keyval ) ;
#line 128
guint32 gdk_keyval_to_unicode(guint keyval ) ;
#line 129
guint gdk_unicode_to_keyval(guint32 wc ) ;
#line 89 "/usr/include/gtk-2.0/gdk/gdkpango.h"
GType gdk_pango_renderer_get_type(void) ;
#line 91
PangoRenderer *gdk_pango_renderer_new(GdkScreen *screen ) ;
#line 92
PangoRenderer *gdk_pango_renderer_get_default(GdkScreen *screen ) ;
#line 94
void gdk_pango_renderer_set_drawable(GdkPangoRenderer *gdk_renderer , GdkDrawable *drawable ) ;
#line 96
void gdk_pango_renderer_set_gc(GdkPangoRenderer *gdk_renderer , GdkGC *gc ) ;
#line 98
void gdk_pango_renderer_set_stipple(GdkPangoRenderer *gdk_renderer , PangoRenderPart part ,
                                    GdkBitmap *stipple ) ;
#line 101
void gdk_pango_renderer_set_override_color(GdkPangoRenderer *gdk_renderer , PangoRenderPart part ,
                                           GdkColor *color ) ;
#line 107
PangoContext *gdk_pango_context_get_for_screen(GdkScreen *screen ) ;
#line 109
PangoContext *gdk_pango_context_get(void) ;
#line 112
void gdk_pango_context_set_colormap(PangoContext *context , GdkColormap *colormap ) ;
#line 123
GdkRegion *gdk_pango_layout_line_get_clip_region(PangoLayoutLine *line , gint x_origin ,
                                                 gint y_origin , gint *index_ranges ,
                                                 gint n_ranges ) ;
#line 128
GdkRegion *gdk_pango_layout_get_clip_region(PangoLayout *layout , gint x_origin ,
                                            gint y_origin , gint *index_ranges , gint n_ranges ) ;
#line 160
PangoAttribute *gdk_pango_attr_stipple_new(GdkBitmap *stipple ) ;
#line 161
PangoAttribute *gdk_pango_attr_embossed_new(gboolean embossed ) ;
#line 162
PangoAttribute *gdk_pango_attr_emboss_color_new(GdkColor *color ) ;
#line 65 "/usr/include/gtk-2.0/gdk/gdkpixmap.h"
GType gdk_pixmap_get_type(void) ;
#line 69
GdkPixmap *gdk_pixmap_new(GdkDrawable *drawable , gint width , gint height , gint depth ) ;
#line 74
GdkBitmap *gdk_bitmap_create_from_data(GdkDrawable *drawable , gchar *data , gint width ,
                                       gint height ) ;
#line 78
GdkPixmap *gdk_pixmap_create_from_data(GdkDrawable *drawable , gchar *data , gint width ,
                                       gint height , gint depth , GdkColor *fg , GdkColor *bg ) ;
#line 86
GdkPixmap *gdk_pixmap_create_from_xpm(GdkDrawable *drawable , GdkBitmap **mask , GdkColor *transparent_color ,
                                      gchar *filename ) ;
#line 90
GdkPixmap *gdk_pixmap_colormap_create_from_xpm(GdkDrawable *drawable , GdkColormap *colormap ,
                                               GdkBitmap **mask , GdkColor *transparent_color ,
                                               gchar *filename ) ;
#line 95
GdkPixmap *gdk_pixmap_create_from_xpm_d(GdkDrawable *drawable , GdkBitmap **mask ,
                                        GdkColor *transparent_color , gchar **data ) ;
#line 99
GdkPixmap *gdk_pixmap_colormap_create_from_xpm_d(GdkDrawable *drawable , GdkColormap *colormap ,
                                                 GdkBitmap **mask , GdkColor *transparent_color ,
                                                 gchar **data ) ;
#line 106
void gdk_pixmap_get_size(GdkPixmap *pixmap , gint *width , gint *height ) ;
#line 113
GdkPixmap *gdk_pixmap_foreign_new(GdkNativeWindow anid ) ;
#line 114
GdkPixmap *gdk_pixmap_lookup(GdkNativeWindow anid ) ;
#line 117
GdkPixmap *gdk_pixmap_foreign_new_for_display(GdkDisplay *display , GdkNativeWindow anid ) ;
#line 119
GdkPixmap *gdk_pixmap_lookup_for_display(GdkDisplay *display , GdkNativeWindow anid ) ;
#line 121
GdkPixmap *gdk_pixmap_foreign_new_for_screen(GdkScreen *screen , GdkNativeWindow anid ,
                                             gint width , gint height , gint depth ) ;
#line 45 "/usr/include/gtk-2.0/gdk/gdkproperty.h"
GdkAtom gdk_atom_intern(gchar *atom_name , gboolean only_if_exists ) ;
#line 47
GdkAtom gdk_atom_intern_static_string(gchar *atom_name ) ;
#line 48
gchar *gdk_atom_name(GdkAtom atom ) ;
#line 50
gboolean gdk_property_get(GdkWindow *window , GdkAtom property , GdkAtom type , gulong offset ,
                          gulong length , gint pdelete , GdkAtom *actual_property_type ,
                          gint *actual_format , gint *actual_length , guchar **data ) ;
#line 60
void gdk_property_change(GdkWindow *window , GdkAtom property , GdkAtom type , gint format ,
                         GdkPropMode mode , guchar *data , gint nelements ) ;
#line 67
void gdk_property_delete(GdkWindow *window , GdkAtom property ) ;
#line 71
gint gdk_text_property_to_text_list(GdkAtom encoding , gint format , guchar *text ,
                                    gint length , gchar ***list ) ;
#line 76
gboolean gdk_utf8_to_compound_text(gchar *str , GdkAtom *encoding , gint *format ,
                                   guchar **ctext , gint *length ) ;
#line 81
gint gdk_string_to_compound_text(gchar *str , GdkAtom *encoding , gint *format , guchar **ctext ,
                                 gint *length ) ;
#line 86
gint gdk_text_property_to_utf8_list(GdkAtom encoding , gint format , guchar *text ,
                                    gint length , gchar ***list ) ;
#line 94
gint gdk_text_property_to_utf8_list_for_display(GdkDisplay *display , GdkAtom encoding ,
                                                gint format , guchar *text , gint length ,
                                                gchar ***list ) ;
#line 101
gchar *gdk_utf8_to_string_target(gchar *str ) ;
#line 103
gint gdk_text_property_to_text_list_for_display(GdkDisplay *display , GdkAtom encoding ,
                                                gint format , guchar *text , gint length ,
                                                gchar ***list ) ;
#line 109
gint gdk_string_to_compound_text_for_display(GdkDisplay *display , gchar *str , GdkAtom *encoding ,
                                             gint *format , guchar **ctext , gint *length ) ;
#line 115
gboolean gdk_utf8_to_compound_text_for_display(GdkDisplay *display , gchar *str ,
                                               GdkAtom *encoding , gint *format ,
                                               guchar **ctext , gint *length ) ;
#line 122
void gdk_free_text_list(gchar **list ) ;
#line 123
void gdk_free_compound_text(guchar *ctext ) ;
#line 67 "/usr/include/gtk-2.0/gdk/gdkregion.h"
GdkRegion *gdk_region_new(void) ;
#line 69
GdkRegion *gdk_region_polygon(GdkPoint *points , gint n_points , GdkFillRule fill_rule ) ;
#line 73
GdkRegion *gdk_region_copy(GdkRegion *region ) ;
#line 74
GdkRegion *gdk_region_rectangle(GdkRectangle *rectangle ) ;
#line 75
void gdk_region_destroy(GdkRegion *region ) ;
#line 77
void gdk_region_get_clipbox(GdkRegion *region , GdkRectangle *rectangle ) ;
#line 79
void gdk_region_get_rectangles(GdkRegion *region , GdkRectangle **rectangles , gint *n_rectangles ) ;
#line 83
gboolean gdk_region_empty(GdkRegion *region ) ;
#line 84
gboolean gdk_region_equal(GdkRegion *region1 , GdkRegion *region2 ) ;
#line 87
gboolean gdk_region_rect_equal(GdkRegion *region , GdkRectangle *rectangle ) ;
#line 90
gboolean gdk_region_point_in(GdkRegion *region , int x , int y ) ;
#line 93
GdkOverlapType gdk_region_rect_in(GdkRegion *region , GdkRectangle *rectangle ) ;
#line 96
void gdk_region_offset(GdkRegion *region , gint dx , gint dy ) ;
#line 100
void gdk_region_shrink(GdkRegion *region , gint dx , gint dy ) ;
#line 104
void gdk_region_union_with_rect(GdkRegion *region , GdkRectangle *rect ) ;
#line 106
void gdk_region_intersect(GdkRegion *source1 , GdkRegion *source2 ) ;
#line 108
void gdk_region_union(GdkRegion *source1 , GdkRegion *source2 ) ;
#line 110
void gdk_region_subtract(GdkRegion *source1 , GdkRegion *source2 ) ;
#line 112
void gdk_region_xor(GdkRegion *source1 , GdkRegion *source2 ) ;
#line 116
void gdk_region_spans_intersect_foreach(GdkRegion *region , GdkSpan *spans , int n_spans ,
                                        gboolean sorted , GdkSpanFunc function , gpointer data ) ;
#line 70 "/usr/include/gtk-2.0/gdk/gdkselection.h"
gboolean gdk_selection_owner_set(GdkWindow *owner , GdkAtom selection , guint32 time_ ,
                                 gboolean send_event ) ;
#line 74
GdkWindow *gdk_selection_owner_get(GdkAtom selection ) ;
#line 77
gboolean gdk_selection_owner_set_for_display(GdkDisplay *display , GdkWindow *owner ,
                                             GdkAtom selection , guint32 time_ , gboolean send_event ) ;
#line 82
GdkWindow *gdk_selection_owner_get_for_display(GdkDisplay *display , GdkAtom selection ) ;
#line 85
void gdk_selection_convert(GdkWindow *requestor , GdkAtom selection , GdkAtom target ,
                           guint32 time_ ) ;
#line 89
gint gdk_selection_property_get(GdkWindow *requestor , guchar **data , GdkAtom *prop_type ,
                                gint *prop_format ) ;
#line 95
void gdk_selection_send_notify(GdkNativeWindow requestor , GdkAtom selection , GdkAtom target ,
                               GdkAtom property , guint32 time_ ) ;
#line 102
void gdk_selection_send_notify_for_display(GdkDisplay *display , GdkNativeWindow requestor ,
                                           GdkAtom selection , GdkAtom target , GdkAtom property ,
                                           guint32 time_ ) ;
#line 34 "/usr/include/gtk-2.0/gdk/gdkspawn.h"
gboolean gdk_spawn_on_screen(GdkScreen *screen , gchar *working_directory , gchar **argv ,
                             gchar **envp , GSpawnFlags flags , GSpawnChildSetupFunc child_setup ,
                             gpointer user_data , gint *child_pid , GError **error ) ;
#line 44
gboolean gdk_spawn_on_screen_with_pipes(GdkScreen *screen , gchar *working_directory ,
                                        gchar **argv , gchar **envp , GSpawnFlags flags ,
                                        GSpawnChildSetupFunc child_setup , gpointer user_data ,
                                        gint *child_pid , gint *standard_input , gint *standard_output ,
                                        gint *standard_error , GError **error ) ;
#line 57
gboolean gdk_spawn_command_line_on_screen(GdkScreen *screen , gchar *command_line ,
                                          GError **error ) ;
#line 331 "/usr/include/gtk-2.0/gdk/gdkwindow.h"
GType gdk_window_object_get_type(void) ;
#line 332
GdkWindow *gdk_window_new(GdkWindow *parent , GdkWindowAttr *attributes , gint attributes_mask ) ;
#line 335
void gdk_window_destroy(GdkWindow *window ) ;
#line 336
GdkWindowType gdk_window_get_window_type(GdkWindow *window ) ;
#line 337
gboolean gdk_window_is_destroyed(GdkWindow *window ) ;
#line 339
GdkScreen *gdk_window_get_screen(GdkWindow *window ) ;
#line 340
GdkDisplay *gdk_window_get_display(GdkWindow *window ) ;
#line 341
GdkVisual *gdk_window_get_visual(GdkWindow *window ) ;
#line 342
int gdk_window_get_width(GdkWindow *window ) ;
#line 343
int gdk_window_get_height(GdkWindow *window ) ;
#line 345
GdkWindow *gdk_window_at_pointer(gint *win_x , gint *win_y ) ;
#line 347
void gdk_window_show(GdkWindow *window ) ;
#line 348
void gdk_window_hide(GdkWindow *window ) ;
#line 349
void gdk_window_withdraw(GdkWindow *window ) ;
#line 350
void gdk_window_show_unraised(GdkWindow *window ) ;
#line 351
void gdk_window_move(GdkWindow *window , gint x , gint y ) ;
#line 354
void gdk_window_resize(GdkWindow *window , gint width , gint height ) ;
#line 357
void gdk_window_move_resize(GdkWindow *window , gint x , gint y , gint width , gint height ) ;
#line 362
void gdk_window_reparent(GdkWindow *window , GdkWindow *new_parent , gint x , gint y ) ;
#line 366
void gdk_window_clear(GdkWindow *window ) ;
#line 367
void gdk_window_clear_area(GdkWindow *window , gint x , gint y , gint width , gint height ) ;
#line 372
void gdk_window_clear_area_e(GdkWindow *window , gint x , gint y , gint width , gint height ) ;
#line 377
void gdk_window_raise(GdkWindow *window ) ;
#line 378
void gdk_window_lower(GdkWindow *window ) ;
#line 379
void gdk_window_restack(GdkWindow *window , GdkWindow *sibling , gboolean above ) ;
#line 382
void gdk_window_focus(GdkWindow *window , guint32 timestamp ) ;
#line 384
void gdk_window_set_user_data(GdkWindow *window , gpointer user_data ) ;
#line 386
void gdk_window_set_override_redirect(GdkWindow *window , gboolean override_redirect ) ;
#line 388
gboolean gdk_window_get_accept_focus(GdkWindow *window ) ;
#line 389
void gdk_window_set_accept_focus(GdkWindow *window , gboolean accept_focus ) ;
#line 391
gboolean gdk_window_get_focus_on_map(GdkWindow *window ) ;
#line 392
void gdk_window_set_focus_on_map(GdkWindow *window , gboolean focus_on_map ) ;
#line 394
void gdk_window_add_filter(GdkWindow *window , GdkFilterFunc function , gpointer data ) ;
#line 397
void gdk_window_remove_filter(GdkWindow *window , GdkFilterFunc function , gpointer data ) ;
#line 400
void gdk_window_scroll(GdkWindow *window , gint dx , gint dy ) ;
#line 403
void gdk_window_move_region(GdkWindow *window , GdkRegion *region , gint dx , gint dy ) ;
#line 407
gboolean gdk_window_ensure_native(GdkWindow *window ) ;
#line 415
void gdk_window_shape_combine_mask(GdkWindow *window , GdkBitmap *mask , gint x ,
                                   gint y ) ;
#line 419
void gdk_window_shape_combine_region(GdkWindow *window , GdkRegion *shape_region ,
                                     gint offset_x , gint offset_y ) ;
#line 431
void gdk_window_set_child_shapes(GdkWindow *window ) ;
#line 433
gboolean gdk_window_get_composited(GdkWindow *window ) ;
#line 434
void gdk_window_set_composited(GdkWindow *window , gboolean composited ) ;
#line 444
void gdk_window_merge_child_shapes(GdkWindow *window ) ;
#line 446
void gdk_window_input_shape_combine_mask(GdkWindow *window , GdkBitmap *mask , gint x ,
                                         gint y ) ;
#line 450
void gdk_window_input_shape_combine_region(GdkWindow *window , GdkRegion *shape_region ,
                                           gint offset_x , gint offset_y ) ;
#line 454
void gdk_window_set_child_input_shapes(GdkWindow *window ) ;
#line 455
void gdk_window_merge_child_input_shapes(GdkWindow *window ) ;
#line 464
gboolean gdk_window_is_visible(GdkWindow *window ) ;
#line 465
gboolean gdk_window_is_viewable(GdkWindow *window ) ;
#line 466
gboolean gdk_window_is_input_only(GdkWindow *window ) ;
#line 467
gboolean gdk_window_is_shaped(GdkWindow *window ) ;
#line 469
GdkWindowState gdk_window_get_state(GdkWindow *window ) ;
#line 474
gboolean gdk_window_set_static_gravities(GdkWindow *window , gboolean use_static ) ;
#line 480
GdkWindow *gdk_window_foreign_new(GdkNativeWindow anid ) ;
#line 481
GdkWindow *gdk_window_lookup(GdkNativeWindow anid ) ;
#line 483
GdkWindow *gdk_window_foreign_new_for_display(GdkDisplay *display , GdkNativeWindow anid ) ;
#line 485
GdkWindow *gdk_window_lookup_for_display(GdkDisplay *display , GdkNativeWindow anid ) ;
#line 492
gboolean gdk_window_has_native(GdkWindow *window ) ;
#line 494
void gdk_window_set_hints(GdkWindow *window , gint x , gint y , gint min_width , gint min_height ,
                          gint max_width , gint max_height , gint flags ) ;
#line 503
void gdk_window_set_type_hint(GdkWindow *window , GdkWindowTypeHint hint ) ;
#line 505
GdkWindowTypeHint gdk_window_get_type_hint(GdkWindow *window ) ;
#line 507
gboolean gdk_window_get_modal_hint(GdkWindow *window ) ;
#line 508
void gdk_window_set_modal_hint(GdkWindow *window , gboolean modal ) ;
#line 511
void gdk_window_set_skip_taskbar_hint(GdkWindow *window , gboolean skips_taskbar ) ;
#line 513
void gdk_window_set_skip_pager_hint(GdkWindow *window , gboolean skips_pager ) ;
#line 515
void gdk_window_set_urgency_hint(GdkWindow *window , gboolean urgent ) ;
#line 518
void gdk_window_set_geometry_hints(GdkWindow *window , GdkGeometry *geometry , GdkWindowHints geom_mask ) ;
#line 522
void gdk_set_sm_client_id(gchar *sm_client_id ) ;
#line 525
void gdk_window_begin_paint_rect(GdkWindow *window , GdkRectangle *rectangle ) ;
#line 527
void gdk_window_begin_paint_region(GdkWindow *window , GdkRegion *region ) ;
#line 529
void gdk_window_end_paint(GdkWindow *window ) ;
#line 530
void gdk_window_flush(GdkWindow *window ) ;
#line 532
void gdk_window_set_title(GdkWindow *window , gchar *title ) ;
#line 534
void gdk_window_set_role(GdkWindow *window , gchar *role ) ;
#line 536
void gdk_window_set_startup_id(GdkWindow *window , gchar *startup_id ) ;
#line 538
void gdk_window_set_transient_for(GdkWindow *window , GdkWindow *parent ) ;
#line 540
void gdk_window_set_background(GdkWindow *window , GdkColor *color ) ;
#line 542
void gdk_window_set_back_pixmap(GdkWindow *window , GdkPixmap *pixmap , gboolean parent_relative ) ;
#line 545
cairo_pattern_t *gdk_window_get_background_pattern(GdkWindow *window ) ;
#line 547
void gdk_window_set_cursor(GdkWindow *window , GdkCursor *cursor ) ;
#line 549
GdkCursor *gdk_window_get_cursor(GdkWindow *window ) ;
#line 550
void gdk_window_get_user_data(GdkWindow *window , gpointer *data ) ;
#line 552
void gdk_window_get_geometry(GdkWindow *window , gint *x , gint *y , gint *width ,
                             gint *height , gint *depth ) ;
#line 558
void gdk_window_get_position(GdkWindow *window , gint *x , gint *y ) ;
#line 561
gint gdk_window_get_origin(GdkWindow *window , gint *x , gint *y ) ;
#line 564
void gdk_window_get_root_coords(GdkWindow *window , gint x , gint y , gint *root_x ,
                                gint *root_y ) ;
#line 569
void gdk_window_coords_to_parent(GdkWindow *window , gdouble x , gdouble y , gdouble *parent_x ,
                                 gdouble *parent_y ) ;
#line 574
void gdk_window_coords_from_parent(GdkWindow *window , gdouble parent_x , gdouble parent_y ,
                                   gdouble *x , gdouble *y ) ;
#line 582
gboolean gdk_window_get_deskrelative_origin(GdkWindow *window , gint *x , gint *y ) ;
#line 587
void gdk_window_get_root_origin(GdkWindow *window , gint *x , gint *y ) ;
#line 590
void gdk_window_get_frame_extents(GdkWindow *window , GdkRectangle *rect ) ;
#line 592
GdkWindow *gdk_window_get_pointer(GdkWindow *window , gint *x , gint *y , GdkModifierType *mask ) ;
#line 596
GdkWindow *gdk_window_get_parent(GdkWindow *window ) ;
#line 597
GdkWindow *gdk_window_get_toplevel(GdkWindow *window ) ;
#line 599
GdkWindow *gdk_window_get_effective_parent(GdkWindow *window ) ;
#line 600
GdkWindow *gdk_window_get_effective_toplevel(GdkWindow *window ) ;
#line 602
GList *gdk_window_get_children(GdkWindow *window ) ;
#line 603
GList *gdk_window_peek_children(GdkWindow *window ) ;
#line 604
GdkEventMask gdk_window_get_events(GdkWindow *window ) ;
#line 605
void gdk_window_set_events(GdkWindow *window , GdkEventMask event_mask ) ;
#line 608
void gdk_window_set_icon_list(GdkWindow *window , GList *pixbufs ) ;
#line 610
void gdk_window_set_icon(GdkWindow *window , GdkWindow *icon_window , GdkPixmap *pixmap ,
                         GdkBitmap *mask ) ;
#line 614
void gdk_window_set_icon_name(GdkWindow *window , gchar *name ) ;
#line 616
void gdk_window_set_group(GdkWindow *window , GdkWindow *leader ) ;
#line 618
GdkWindow *gdk_window_get_group(GdkWindow *window ) ;
#line 619
void gdk_window_set_decorations(GdkWindow *window , GdkWMDecoration decorations ) ;
#line 621
gboolean gdk_window_get_decorations(GdkWindow *window , GdkWMDecoration *decorations ) ;
#line 623
void gdk_window_set_functions(GdkWindow *window , GdkWMFunction functions ) ;
#line 626
GList *gdk_window_get_toplevels(void) ;
#line 630
cairo_surface_t *gdk_window_create_similar_surface(GdkWindow *window , cairo_content_t content ,
                                                   int width , int height ) ;
#line 635
void gdk_window_beep(GdkWindow *window ) ;
#line 636
void gdk_window_iconify(GdkWindow *window ) ;
#line 637
void gdk_window_deiconify(GdkWindow *window ) ;
#line 638
void gdk_window_stick(GdkWindow *window ) ;
#line 639
void gdk_window_unstick(GdkWindow *window ) ;
#line 640
void gdk_window_maximize(GdkWindow *window ) ;
#line 641
void gdk_window_unmaximize(GdkWindow *window ) ;
#line 642
void gdk_window_fullscreen(GdkWindow *window ) ;
#line 643
void gdk_window_unfullscreen(GdkWindow *window ) ;
#line 644
void gdk_window_set_keep_above(GdkWindow *window , gboolean setting ) ;
#line 646
void gdk_window_set_keep_below(GdkWindow *window , gboolean setting ) ;
#line 648
void gdk_window_set_opacity(GdkWindow *window , gdouble opacity ) ;
#line 650
void gdk_window_register_dnd(GdkWindow *window ) ;
#line 652
void gdk_window_begin_resize_drag(GdkWindow *window , GdkWindowEdge edge , gint button ,
                                  gint root_x , gint root_y , guint32 timestamp ) ;
#line 658
void gdk_window_begin_move_drag(GdkWindow *window , gint button , gint root_x , gint root_y ,
                                guint32 timestamp ) ;
#line 665
void gdk_window_invalidate_rect(GdkWindow *window , GdkRectangle *rect , gboolean invalidate_children ) ;
#line 668
void gdk_window_invalidate_region(GdkWindow *window , GdkRegion *region , gboolean invalidate_children ) ;
#line 671
void gdk_window_invalidate_maybe_recurse(GdkWindow *window , GdkRegion *region , gboolean (*child_func)(GdkWindow * ,
                                                                                                        gpointer  ) ,
                                         gpointer user_data ) ;
#line 675
GdkRegion *gdk_window_get_update_area(GdkWindow *window ) ;
#line 677
void gdk_window_freeze_updates(GdkWindow *window ) ;
#line 678
void gdk_window_thaw_updates(GdkWindow *window ) ;
#line 680
void gdk_window_freeze_toplevel_updates_libgtk_only(GdkWindow *window ) ;
#line 681
void gdk_window_thaw_toplevel_updates_libgtk_only(GdkWindow *window ) ;
#line 683
void gdk_window_process_all_updates(void) ;
#line 684
void gdk_window_process_updates(GdkWindow *window , gboolean update_children ) ;
#line 688
void gdk_window_set_debug_updates(gboolean setting ) ;
#line 690
void gdk_window_constrain_size(GdkGeometry *geometry , guint flags , gint width ,
                               gint height , gint *new_width , gint *new_height ) ;
#line 697
void gdk_window_get_internal_paint_info(GdkWindow *window , GdkDrawable **real_drawable ,
                                        gint *x_offset , gint *y_offset ) ;
#line 702
void gdk_window_enable_synchronized_configure(GdkWindow *window ) ;
#line 703
void gdk_window_configure_finished(GdkWindow *window ) ;
#line 705
GdkWindow *gdk_get_default_root_window(void) ;
#line 708
GdkPixmap *gdk_offscreen_window_get_pixmap(GdkWindow *window ) ;
#line 709
void gdk_offscreen_window_set_embedder(GdkWindow *window , GdkWindow *embedder ) ;
#line 711
GdkWindow *gdk_offscreen_window_get_embedder(GdkWindow *window ) ;
#line 712
void gdk_window_geometry_changed(GdkWindow *window ) ;
#line 714
void gdk_window_redirect_to_drawable(GdkWindow *window , GdkDrawable *drawable , gint src_x ,
                                     gint src_y , gint dest_x , gint dest_y , gint width ,
                                     gint height ) ;
#line 722
void gdk_window_remove_redirection(GdkWindow *window ) ;
#line 726
GdkPointerHooks *gdk_set_pointer_hooks(GdkPointerHooks *new_hooks ) ;
#line 33 "/usr/include/gtk-2.0/gdk/gdktestutils.h"
void gdk_test_render_sync(GdkWindow *window ) ;
#line 34
gboolean gdk_test_simulate_key(GdkWindow *window , gint x , gint y , guint keyval ,
                               GdkModifierType modifiers , GdkEventType key_pressrelease ) ;
#line 40
gboolean gdk_test_simulate_button(GdkWindow *window , gint x , gint y , guint button ,
                                  GdkModifierType modifiers , GdkEventType button_pressrelease ) ;
#line 100 "/usr/include/gtk-2.0/gdk/gdkvisual.h"
GType gdk_visual_get_type(void) ;
#line 103
gint gdk_visual_get_best_depth(void) ;
#line 104
GdkVisualType gdk_visual_get_best_type(void) ;
#line 105
GdkVisual *gdk_visual_get_system(void) ;
#line 106
GdkVisual *gdk_visual_get_best(void) ;
#line 107
GdkVisual *gdk_visual_get_best_with_depth(gint depth ) ;
#line 108
GdkVisual *gdk_visual_get_best_with_type(GdkVisualType visual_type ) ;
#line 109
GdkVisual *gdk_visual_get_best_with_both(gint depth , GdkVisualType visual_type ) ;
#line 112
void gdk_query_depths(gint **depths , gint *count ) ;
#line 114
void gdk_query_visual_types(GdkVisualType **visual_types , gint *count ) ;
#line 117
GList *gdk_list_visuals(void) ;
#line 120
GdkScreen *gdk_visual_get_screen(GdkVisual *visual ) ;
#line 122
GdkVisualType gdk_visual_get_visual_type(GdkVisual *visual ) ;
#line 123
gint gdk_visual_get_depth(GdkVisual *visual ) ;
#line 124
GdkByteOrder gdk_visual_get_byte_order(GdkVisual *visual ) ;
#line 125
gint gdk_visual_get_colormap_size(GdkVisual *visual ) ;
#line 126
gint gdk_visual_get_bits_per_rgb(GdkVisual *visual ) ;
#line 127
void gdk_visual_get_red_pixel_details(GdkVisual *visual , guint32 *mask , gint *shift ,
                                      gint *precision ) ;
#line 131
void gdk_visual_get_green_pixel_details(GdkVisual *visual , guint32 *mask , gint *shift ,
                                        gint *precision ) ;
#line 135
void gdk_visual_get_blue_pixel_details(GdkVisual *visual , guint32 *mask , gint *shift ,
                                       gint *precision ) ;
#line 69 "/usr/include/gtk-2.0/gdk/gdk.h"
void gdk_parse_args(gint *argc , gchar ***argv ) ;
#line 71
void gdk_init(gint *argc , gchar ***argv ) ;
#line 73
gboolean gdk_init_check(gint *argc , gchar ***argv ) ;
#line 75
void gdk_add_option_entries_libgtk_only(GOptionGroup *group ) ;
#line 76
void gdk_pre_parse_libgtk_only(void) ;
#line 79
void gdk_exit(gint error_code ) ;
#line 80
gchar *gdk_set_locale(void) ;
#line 83
char const   *gdk_get_program_class(void) ;
#line 84
void gdk_set_program_class(char const   *program_class ) ;
#line 88
void gdk_error_trap_push(void) ;
#line 89
gint gdk_error_trap_pop(void) ;
#line 92
void gdk_set_use_xshm(gboolean use_xshm ) ;
#line 93
gboolean gdk_get_use_xshm(void) ;
#line 96
gchar *gdk_get_display(void) ;
#line 97
gchar *gdk_get_display_arg_name(void) ;
#line 100
gint gdk_input_add_full(gint source , GdkInputCondition condition , GdkInputFunction function ,
                        gpointer data , GDestroyNotify destroy ) ;
#line 105
gint gdk_input_add(gint source , GdkInputCondition condition , GdkInputFunction function ,
                   gpointer data ) ;
#line 109
void gdk_input_remove(gint tag ) ;
#line 112
GdkGrabStatus gdk_pointer_grab(GdkWindow *window , gboolean owner_events , GdkEventMask event_mask ,
                               GdkWindow *confine_to , GdkCursor *cursor , guint32 time_ ) ;
#line 118
GdkGrabStatus gdk_keyboard_grab(GdkWindow *window , gboolean owner_events , guint32 time_ ) ;
#line 122
gboolean gdk_pointer_grab_info_libgtk_only(GdkDisplay *display , GdkWindow **grab_window ,
                                           gboolean *owner_events ) ;
#line 125
gboolean gdk_keyboard_grab_info_libgtk_only(GdkDisplay *display , GdkWindow **grab_window ,
                                            gboolean *owner_events ) ;
#line 130
void gdk_pointer_ungrab(guint32 time_ ) ;
#line 131
void gdk_keyboard_ungrab(guint32 time_ ) ;
#line 132
gboolean gdk_pointer_is_grabbed(void) ;
#line 134
gint gdk_screen_width(void) ;
#line 135
gint gdk_screen_height(void) ;
#line 137
gint gdk_screen_width_mm(void) ;
#line 138
gint gdk_screen_height_mm(void) ;
#line 140
void gdk_beep(void) ;
#line 143
void gdk_flush(void) ;
#line 146
void gdk_set_double_click_time(guint msec ) ;
#line 151
gboolean gdk_rectangle_intersect(GdkRectangle *src1 , GdkRectangle *src2 , GdkRectangle *dest ) ;
#line 154
void gdk_rectangle_union(GdkRectangle *src1 , GdkRectangle *src2 , GdkRectangle *dest ) ;
#line 158
GType gdk_rectangle_get_type(void) ;
#line 165
gchar *gdk_wcstombs(GdkWChar *src ) ;
#line 166
gint gdk_mbstowcs(GdkWChar *dest , gchar *src , gint dest_max ) ;
#line 173
gboolean gdk_event_send_client_message(GdkEvent *event , GdkNativeWindow winid ) ;
#line 175
void gdk_event_send_clientmessage_toall(GdkEvent *event ) ;
#line 177
gboolean gdk_event_send_client_message_for_display(GdkDisplay *display , GdkEvent *event ,
                                                   GdkNativeWindow winid ) ;
#line 181
void gdk_notify_startup_complete(void) ;
#line 183
void gdk_notify_startup_complete_with_id(gchar *startup_id ) ;
#line 189
extern GMutex *gdk_threads_mutex ;
#line 192
extern GCallback gdk_threads_lock ;
#line 193
extern GCallback gdk_threads_unlock ;
#line 195
void gdk_threads_enter(void) ;
#line 196
void gdk_threads_leave(void) ;
#line 197
void gdk_threads_init(void) ;
#line 198
void gdk_threads_set_lock_functions(GCallback enter_fn , GCallback leave_fn ) ;
#line 201
guint gdk_threads_add_idle_full(gint priority , GSourceFunc function , gpointer data ,
                                GDestroyNotify notify ) ;
#line 205
guint gdk_threads_add_idle(GSourceFunc function , gpointer data ) ;
#line 207
guint gdk_threads_add_timeout_full(gint priority , guint interval , GSourceFunc function ,
                                   gpointer data , GDestroyNotify notify ) ;
#line 212
guint gdk_threads_add_timeout(guint interval , GSourceFunc function , gpointer data ) ;
#line 215
guint gdk_threads_add_timeout_seconds_full(gint priority , guint interval , GSourceFunc function ,
                                           gpointer data , GDestroyNotify notify ) ;
#line 220
guint gdk_threads_add_timeout_seconds(guint interval , GSourceFunc function , gpointer data ) ;
#line 122 "/usr/include/gtk-2.0/gtk/gtkaccelgroup.h"
GType gtk_accel_group_get_type(void) ;
#line 123
GtkAccelGroup *gtk_accel_group_new(void) ;
#line 124
gboolean gtk_accel_group_get_is_locked(GtkAccelGroup *accel_group ) ;
#line 126
GdkModifierType gtk_accel_group_get_modifier_mask(GtkAccelGroup *accel_group ) ;
#line 127
void gtk_accel_group_lock(GtkAccelGroup *accel_group ) ;
#line 128
void gtk_accel_group_unlock(GtkAccelGroup *accel_group ) ;
#line 129
void gtk_accel_group_connect(GtkAccelGroup *accel_group , guint accel_key , GdkModifierType accel_mods ,
                             GtkAccelFlags accel_flags , GClosure *closure ) ;
#line 134
void gtk_accel_group_connect_by_path(GtkAccelGroup *accel_group , gchar *accel_path ,
                                     GClosure *closure ) ;
#line 137
gboolean gtk_accel_group_disconnect(GtkAccelGroup *accel_group , GClosure *closure ) ;
#line 139
gboolean gtk_accel_group_disconnect_key(GtkAccelGroup *accel_group , guint accel_key ,
                                        GdkModifierType accel_mods ) ;
#line 142
gboolean gtk_accel_group_activate(GtkAccelGroup *accel_group , GQuark accel_quark ,
                                  GObject *acceleratable , guint accel_key , GdkModifierType accel_mods ) ;
#line 150
void _gtk_accel_group_attach(GtkAccelGroup *accel_group , GObject *object ) ;
#line 152
void _gtk_accel_group_detach(GtkAccelGroup *accel_group , GObject *object ) ;
#line 154
gboolean gtk_accel_groups_activate(GObject *object , guint accel_key , GdkModifierType accel_mods ) ;
#line 157
GSList *gtk_accel_groups_from_object(GObject *object ) ;
#line 158
GtkAccelKey *gtk_accel_group_find(GtkAccelGroup *accel_group , GtkAccelGroupFindFunc find_func ,
                                  gpointer data ) ;
#line 161
GtkAccelGroup *gtk_accel_group_from_accel_closure(GClosure *closure ) ;
#line 165
gboolean gtk_accelerator_valid(guint keyval , GdkModifierType modifiers ) ;
#line 167
void gtk_accelerator_parse(gchar *accelerator , guint *accelerator_key , GdkModifierType *accelerator_mods ) ;
#line 170
gchar *gtk_accelerator_name(guint accelerator_key , GdkModifierType accelerator_mods ) ;
#line 172
gchar *gtk_accelerator_get_label(guint accelerator_key , GdkModifierType accelerator_mods ) ;
#line 174
void gtk_accelerator_set_default_mod_mask(GdkModifierType default_mod_mask ) ;
#line 175
guint gtk_accelerator_get_default_mod_mask(void) ;
#line 179
GtkAccelGroupEntry *gtk_accel_group_query(GtkAccelGroup *accel_group , guint accel_key ,
                                          GdkModifierType accel_mods , guint *n_entries ) ;
#line 184
void _gtk_accel_group_reconnect(GtkAccelGroup *accel_group , GQuark accel_path_quark ) ;
#line 16 "/usr/include/gtk-2.0/gtk/gtktypebuiltins.h"
GType gtk_accel_flags_get_type(void) ;
#line 20
GType gtk_assistant_page_type_get_type(void) ;
#line 24
GType gtk_builder_error_get_type(void) ;
#line 28
GType gtk_calendar_display_options_get_type(void) ;
#line 32
GType gtk_cell_renderer_state_get_type(void) ;
#line 34
GType gtk_cell_renderer_mode_get_type(void) ;
#line 38
GType gtk_cell_renderer_accel_mode_get_type(void) ;
#line 42
GType gtk_cell_type_get_type(void) ;
#line 44
GType gtk_clist_drag_pos_get_type(void) ;
#line 46
GType gtk_button_action_get_type(void) ;
#line 50
GType gtk_ctree_pos_get_type(void) ;
#line 52
GType gtk_ctree_line_style_get_type(void) ;
#line 54
GType gtk_ctree_expander_style_get_type(void) ;
#line 56
GType gtk_ctree_expansion_type_get_type(void) ;
#line 60
GType gtk_debug_flag_get_type(void) ;
#line 64
GType gtk_dialog_flags_get_type(void) ;
#line 66
GType gtk_response_type_get_type(void) ;
#line 70
GType gtk_dest_defaults_get_type(void) ;
#line 72
GType gtk_target_flags_get_type(void) ;
#line 76
GType gtk_entry_icon_position_get_type(void) ;
#line 80
GType gtk_anchor_type_get_type(void) ;
#line 82
GType gtk_arrow_placement_get_type(void) ;
#line 84
GType gtk_arrow_type_get_type(void) ;
#line 86
GType gtk_attach_options_get_type(void) ;
#line 88
GType gtk_button_box_style_get_type(void) ;
#line 90
GType gtk_curve_type_get_type(void) ;
#line 92
GType gtk_delete_type_get_type(void) ;
#line 94
GType gtk_direction_type_get_type(void) ;
#line 96
GType gtk_expander_style_get_type(void) ;
#line 98
GType gtk_icon_size_get_type(void) ;
#line 100
GType gtk_sensitivity_type_get_type(void) ;
#line 102
GType gtk_side_type_get_type(void) ;
#line 104
GType gtk_text_direction_get_type(void) ;
#line 106
GType gtk_justification_get_type(void) ;
#line 108
GType gtk_match_type_get_type(void) ;
#line 110
GType gtk_menu_direction_type_get_type(void) ;
#line 112
GType gtk_message_type_get_type(void) ;
#line 114
GType gtk_metric_type_get_type(void) ;
#line 116
GType gtk_movement_step_get_type(void) ;
#line 118
GType gtk_scroll_step_get_type(void) ;
#line 120
GType gtk_orientation_get_type(void) ;
#line 122
GType gtk_corner_type_get_type(void) ;
#line 124
GType gtk_pack_type_get_type(void) ;
#line 126
GType gtk_path_priority_type_get_type(void) ;
#line 128
GType gtk_path_type_get_type(void) ;
#line 130
GType gtk_policy_type_get_type(void) ;
#line 132
GType gtk_position_type_get_type(void) ;
#line 134
GType gtk_preview_type_get_type(void) ;
#line 136
GType gtk_relief_style_get_type(void) ;
#line 138
GType gtk_resize_mode_get_type(void) ;
#line 140
GType gtk_signal_run_type_get_type(void) ;
#line 142
GType gtk_scroll_type_get_type(void) ;
#line 144
GType gtk_selection_mode_get_type(void) ;
#line 146
GType gtk_shadow_type_get_type(void) ;
#line 148
GType gtk_state_type_get_type(void) ;
#line 150
GType gtk_submenu_direction_get_type(void) ;
#line 152
GType gtk_submenu_placement_get_type(void) ;
#line 154
GType gtk_toolbar_style_get_type(void) ;
#line 156
GType gtk_update_type_get_type(void) ;
#line 158
GType gtk_visibility_get_type(void) ;
#line 160
GType gtk_window_position_get_type(void) ;
#line 162
GType gtk_window_type_get_type(void) ;
#line 164
GType gtk_wrap_mode_get_type(void) ;
#line 166
GType gtk_sort_type_get_type(void) ;
#line 168
GType gtk_im_preedit_style_get_type(void) ;
#line 170
GType gtk_im_status_style_get_type(void) ;
#line 172
GType gtk_pack_direction_get_type(void) ;
#line 174
GType gtk_print_pages_get_type(void) ;
#line 176
GType gtk_page_set_get_type(void) ;
#line 178
GType gtk_number_up_layout_get_type(void) ;
#line 180
GType gtk_page_orientation_get_type(void) ;
#line 182
GType gtk_print_quality_get_type(void) ;
#line 184
GType gtk_print_duplex_get_type(void) ;
#line 186
GType gtk_unit_get_type(void) ;
#line 188
GType gtk_tree_view_grid_lines_get_type(void) ;
#line 190
GType gtk_drag_result_get_type(void) ;
#line 194
GType gtk_file_chooser_action_get_type(void) ;
#line 196
GType gtk_file_chooser_confirmation_get_type(void) ;
#line 198
GType gtk_file_chooser_error_get_type(void) ;
#line 202
GType gtk_file_filter_flags_get_type(void) ;
#line 206
GType gtk_icon_lookup_flags_get_type(void) ;
#line 208
GType gtk_icon_theme_error_get_type(void) ;
#line 212
GType gtk_icon_view_drop_position_get_type(void) ;
#line 216
GType gtk_image_type_get_type(void) ;
#line 220
GType gtk_buttons_type_get_type(void) ;
#line 224
GType gtk_notebook_tab_get_type(void) ;
#line 228
GType gtk_object_flags_get_type(void) ;
#line 230
GType gtk_arg_flags_get_type(void) ;
#line 234
GType gtk_print_status_get_type(void) ;
#line 236
GType gtk_print_operation_result_get_type(void) ;
#line 238
GType gtk_print_operation_action_get_type(void) ;
#line 240
GType gtk_print_error_get_type(void) ;
#line 244
GType gtk_private_flags_get_type(void) ;
#line 248
GType gtk_progress_bar_style_get_type(void) ;
#line 250
GType gtk_progress_bar_orientation_get_type(void) ;
#line 254
GType gtk_rc_flags_get_type(void) ;
#line 256
GType gtk_rc_token_type_get_type(void) ;
#line 260
GType gtk_recent_sort_type_get_type(void) ;
#line 262
GType gtk_recent_chooser_error_get_type(void) ;
#line 266
GType gtk_recent_filter_flags_get_type(void) ;
#line 270
GType gtk_recent_manager_error_get_type(void) ;
#line 274
GType gtk_size_group_mode_get_type(void) ;
#line 278
GType gtk_spin_button_update_policy_get_type(void) ;
#line 280
GType gtk_spin_type_get_type(void) ;
#line 284
GType gtk_text_buffer_target_info_get_type(void) ;
#line 288
GType gtk_text_search_flags_get_type(void) ;
#line 292
GType gtk_text_window_type_get_type(void) ;
#line 296
GType gtk_toolbar_child_type_get_type(void) ;
#line 298
GType gtk_toolbar_space_style_get_type(void) ;
#line 302
GType gtk_tool_palette_drag_targets_get_type(void) ;
#line 306
GType gtk_tree_view_mode_get_type(void) ;
#line 310
GType gtk_tree_model_flags_get_type(void) ;
#line 314
GType gtk_tree_view_drop_position_get_type(void) ;
#line 318
GType gtk_tree_view_column_sizing_get_type(void) ;
#line 322
GType gtk_ui_manager_item_type_get_type(void) ;
#line 326
GType gtk_widget_flags_get_type(void) ;
#line 328
GType gtk_widget_help_type_get_type(void) ;
#line 42 "/usr/include/gtk-2.0/gtk/gtktypeutils.h"
GType gtk_identifier_get_type(void) ;
#line 236
void gtk_type_init(GTypeDebugFlags debug_flags ) ;
#line 237
GtkType gtk_type_unique(GtkType parent_type , GtkTypeInfo *gtkinfo ) ;
#line 239
gpointer gtk_type_class(GtkType type ) ;
#line 240
gpointer gtk_type_new(GtkType type ) ;
#line 253
GtkEnumValue *gtk_type_enum_get_values(GtkType enum_type ) ;
#line 254
GtkFlagValue *gtk_type_flags_get_values(GtkType flags_type ) ;
#line 255
GtkEnumValue *gtk_type_enum_find_value(GtkType enum_type , gchar *value_name ) ;
#line 257
GtkFlagValue *gtk_type_flags_find_value(GtkType flags_type , gchar *value_name ) ;
#line 75 "/usr/include/gtk-2.0/gtk/gtkdebug.h"
extern guint gtk_debug_flags ;
#line 146 "/usr/include/gtk-2.0/gtk/gtkobject.h"
GType gtk_object_get_type(void) ;
#line 149
void gtk_object_sink(GtkObject *object ) ;
#line 151
void gtk_object_destroy(GtkObject *object ) ;
#line 157
GtkObject *gtk_object_new(GType type , gchar *first_property_name  , ...) ;
#line 160
GtkObject *gtk_object_ref(GtkObject *object ) ;
#line 161
void gtk_object_unref(GtkObject *object ) ;
#line 162
void gtk_object_weakref(GtkObject *object , GDestroyNotify notify , gpointer data ) ;
#line 165
void gtk_object_weakunref(GtkObject *object , GDestroyNotify notify , gpointer data ) ;
#line 181
void gtk_object_set_data(GtkObject *object , gchar *key , gpointer data ) ;
#line 184
void gtk_object_set_data_full(GtkObject *object , gchar *key , gpointer data , GDestroyNotify destroy ) ;
#line 188
void gtk_object_remove_data(GtkObject *object , gchar *key ) ;
#line 190
gpointer gtk_object_get_data(GtkObject *object , gchar *key ) ;
#line 192
void gtk_object_remove_no_notify(GtkObject *object , gchar *key ) ;
#line 200
void gtk_object_set_user_data(GtkObject *object , gpointer data ) ;
#line 202
gpointer gtk_object_get_user_data(GtkObject *object ) ;
#line 208
void gtk_object_set_data_by_id(GtkObject *object , GQuark data_id , gpointer data ) ;
#line 211
void gtk_object_set_data_by_id_full(GtkObject *object , GQuark data_id , gpointer data ,
                                    GDestroyNotify destroy ) ;
#line 215
gpointer gtk_object_get_data_by_id(GtkObject *object , GQuark data_id ) ;
#line 217
void gtk_object_remove_data_by_id(GtkObject *object , GQuark data_id ) ;
#line 219
void gtk_object_remove_no_notify_by_id(GtkObject *object , GQuark key_id ) ;
#line 235
void gtk_object_get(GtkObject *object , gchar *first_property_name  , ...) ;
#line 238
void gtk_object_set(GtkObject *object , gchar *first_property_name  , ...) ;
#line 241
void gtk_object_add_arg_type(gchar *arg_name , GType arg_type , guint arg_flags ,
                             guint arg_id ) ;
#line 78 "/usr/include/gtk-2.0/gtk/gtkadjustment.h"
GType gtk_adjustment_get_type(void) ;
#line 79
GtkObject *gtk_adjustment_new(gdouble value , gdouble lower , gdouble upper , gdouble step_increment ,
                              gdouble page_increment , gdouble page_size ) ;
#line 86
void gtk_adjustment_changed(GtkAdjustment *adjustment ) ;
#line 87
void gtk_adjustment_value_changed(GtkAdjustment *adjustment ) ;
#line 88
void gtk_adjustment_clamp_page(GtkAdjustment *adjustment , gdouble lower , gdouble upper ) ;
#line 92
gdouble gtk_adjustment_get_value(GtkAdjustment *adjustment ) ;
#line 93
void gtk_adjustment_set_value(GtkAdjustment *adjustment , gdouble value ) ;
#line 95
gdouble gtk_adjustment_get_lower(GtkAdjustment *adjustment ) ;
#line 96
void gtk_adjustment_set_lower(GtkAdjustment *adjustment , gdouble lower ) ;
#line 98
gdouble gtk_adjustment_get_upper(GtkAdjustment *adjustment ) ;
#line 99
void gtk_adjustment_set_upper(GtkAdjustment *adjustment , gdouble upper ) ;
#line 101
gdouble gtk_adjustment_get_step_increment(GtkAdjustment *adjustment ) ;
#line 102
void gtk_adjustment_set_step_increment(GtkAdjustment *adjustment , gdouble step_increment ) ;
#line 104
gdouble gtk_adjustment_get_page_increment(GtkAdjustment *adjustment ) ;
#line 105
void gtk_adjustment_set_page_increment(GtkAdjustment *adjustment , gdouble page_increment ) ;
#line 107
gdouble gtk_adjustment_get_page_size(GtkAdjustment *adjustment ) ;
#line 108
void gtk_adjustment_set_page_size(GtkAdjustment *adjustment , gdouble page_size ) ;
#line 111
void gtk_adjustment_configure(GtkAdjustment *adjustment , gdouble value , gdouble lower ,
                              gdouble upper , gdouble step_increment , gdouble page_increment ,
                              gdouble page_size ) ;
#line 440 "/usr/include/gtk-2.0/gtk/gtkstyle.h"
GType gtk_style_get_type(void) ;
#line 441
GtkStyle *gtk_style_new(void) ;
#line 442
GtkStyle *gtk_style_copy(GtkStyle *style ) ;
#line 443
GtkStyle *gtk_style_attach(GtkStyle *style , GdkWindow *window ) ;
#line 445
void gtk_style_detach(GtkStyle *style ) ;
#line 448
GtkStyle *gtk_style_ref(GtkStyle *style ) ;
#line 449
void gtk_style_unref(GtkStyle *style ) ;
#line 451
GdkFont *gtk_style_get_font(GtkStyle *style ) ;
#line 452
void gtk_style_set_font(GtkStyle *style , GdkFont *font ) ;
#line 456
void gtk_style_set_background(GtkStyle *style , GdkWindow *window , GtkStateType state_type ) ;
#line 459
void gtk_style_apply_default_background(GtkStyle *style , GdkWindow *window , gboolean set_bg ,
                                        GtkStateType state_type , GdkRectangle *area ,
                                        gint x , gint y , gint width , gint height ) ;
#line 469
GtkIconSet *gtk_style_lookup_icon_set(GtkStyle *style , gchar *stock_id ) ;
#line 471
gboolean gtk_style_lookup_color(GtkStyle *style , gchar *color_name , GdkColor *color ) ;
#line 475
GdkPixbuf *gtk_style_render_icon(GtkStyle *style , GtkIconSource *source , GtkTextDirection direction ,
                                 GtkStateType state , GtkIconSize size , GtkWidget *widget ,
                                 gchar *detail ) ;
#line 484
void gtk_draw_hline(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                    gint x1 , gint x2 , gint y ) ;
#line 490
void gtk_draw_vline(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                    gint y1_ , gint y2_ , gint x ) ;
#line 496
void gtk_draw_shadow(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                     GtkShadowType shadow_type , gint x , gint y , gint width , gint height ) ;
#line 504
void gtk_draw_polygon(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                      GtkShadowType shadow_type , GdkPoint *points , gint npoints ,
                      gboolean fill ) ;
#line 511
void gtk_draw_arrow(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                    GtkShadowType shadow_type , GtkArrowType arrow_type , gboolean fill ,
                    gint x , gint y , gint width , gint height ) ;
#line 521
void gtk_draw_diamond(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                      GtkShadowType shadow_type , gint x , gint y , gint width , gint height ) ;
#line 529
void gtk_draw_box(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                  GtkShadowType shadow_type , gint x , gint y , gint width , gint height ) ;
#line 537
void gtk_draw_flat_box(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                       GtkShadowType shadow_type , gint x , gint y , gint width ,
                       gint height ) ;
#line 545
void gtk_draw_check(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                    GtkShadowType shadow_type , gint x , gint y , gint width , gint height ) ;
#line 553
void gtk_draw_option(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                     GtkShadowType shadow_type , gint x , gint y , gint width , gint height ) ;
#line 561
void gtk_draw_tab(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                  GtkShadowType shadow_type , gint x , gint y , gint width , gint height ) ;
#line 569
void gtk_draw_shadow_gap(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                         GtkShadowType shadow_type , gint x , gint y , gint width ,
                         gint height , GtkPositionType gap_side , gint gap_x , gint gap_width ) ;
#line 580
void gtk_draw_box_gap(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                      GtkShadowType shadow_type , gint x , gint y , gint width , gint height ,
                      GtkPositionType gap_side , gint gap_x , gint gap_width ) ;
#line 591
void gtk_draw_extension(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                        GtkShadowType shadow_type , gint x , gint y , gint width ,
                        gint height , GtkPositionType gap_side ) ;
#line 600
void gtk_draw_focus(GtkStyle *style , GdkWindow *window , gint x , gint y , gint width ,
                    gint height ) ;
#line 606
void gtk_draw_slider(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                     GtkShadowType shadow_type , gint x , gint y , gint width , gint height ,
                     GtkOrientation orientation ) ;
#line 615
void gtk_draw_handle(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                     GtkShadowType shadow_type , gint x , gint y , gint width , gint height ,
                     GtkOrientation orientation ) ;
#line 624
void gtk_draw_expander(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                       gint x , gint y , GtkExpanderStyle expander_style ) ;
#line 630
void gtk_draw_layout(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                     gboolean use_text , gint x , gint y , PangoLayout *layout ) ;
#line 637
void gtk_draw_resize_grip(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                          GdkWindowEdge edge , gint x , gint y , gint width , gint height ) ;
#line 647
void gtk_paint_hline(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                     GdkRectangle *area , GtkWidget *widget , gchar *detail , gint x1 ,
                     gint x2 , gint y ) ;
#line 656
void gtk_paint_vline(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                     GdkRectangle *area , GtkWidget *widget , gchar *detail , gint y1_ ,
                     gint y2_ , gint x ) ;
#line 665
void gtk_paint_shadow(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                      GtkShadowType shadow_type , GdkRectangle *area , GtkWidget *widget ,
                      gchar *detail , gint x , gint y , gint width , gint height ) ;
#line 676
void gtk_paint_polygon(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                       GtkShadowType shadow_type , GdkRectangle *area , GtkWidget *widget ,
                       gchar *detail , GdkPoint *points , gint n_points , gboolean fill ) ;
#line 686
void gtk_paint_arrow(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                     GtkShadowType shadow_type , GdkRectangle *area , GtkWidget *widget ,
                     gchar *detail , GtkArrowType arrow_type , gboolean fill , gint x ,
                     gint y , gint width , gint height ) ;
#line 699
void gtk_paint_diamond(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                       GtkShadowType shadow_type , GdkRectangle *area , GtkWidget *widget ,
                       gchar *detail , gint x , gint y , gint width , gint height ) ;
#line 710
void gtk_paint_box(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                   GtkShadowType shadow_type , GdkRectangle *area , GtkWidget *widget ,
                   gchar *detail , gint x , gint y , gint width , gint height ) ;
#line 721
void gtk_paint_flat_box(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                        GtkShadowType shadow_type , GdkRectangle *area , GtkWidget *widget ,
                        gchar *detail , gint x , gint y , gint width , gint height ) ;
#line 732
void gtk_paint_check(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                     GtkShadowType shadow_type , GdkRectangle *area , GtkWidget *widget ,
                     gchar *detail , gint x , gint y , gint width , gint height ) ;
#line 743
void gtk_paint_option(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                      GtkShadowType shadow_type , GdkRectangle *area , GtkWidget *widget ,
                      gchar *detail , gint x , gint y , gint width , gint height ) ;
#line 754
void gtk_paint_tab(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                   GtkShadowType shadow_type , GdkRectangle *area , GtkWidget *widget ,
                   gchar *detail , gint x , gint y , gint width , gint height ) ;
#line 765
void gtk_paint_shadow_gap(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                          GtkShadowType shadow_type , GdkRectangle *area , GtkWidget *widget ,
                          gchar *detail , gint x , gint y , gint width , gint height ,
                          GtkPositionType gap_side , gint gap_x , gint gap_width ) ;
#line 779
void gtk_paint_box_gap(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                       GtkShadowType shadow_type , GdkRectangle *area , GtkWidget *widget ,
                       gchar *detail , gint x , gint y , gint width , gint height ,
                       GtkPositionType gap_side , gint gap_x , gint gap_width ) ;
#line 793
void gtk_paint_extension(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                         GtkShadowType shadow_type , GdkRectangle *area , GtkWidget *widget ,
                         gchar *detail , gint x , gint y , gint width , gint height ,
                         GtkPositionType gap_side ) ;
#line 805
void gtk_paint_focus(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                     GdkRectangle *area , GtkWidget *widget , gchar *detail , gint x ,
                     gint y , gint width , gint height ) ;
#line 815
void gtk_paint_slider(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                      GtkShadowType shadow_type , GdkRectangle *area , GtkWidget *widget ,
                      gchar *detail , gint x , gint y , gint width , gint height ,
                      GtkOrientation orientation ) ;
#line 827
void gtk_paint_handle(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                      GtkShadowType shadow_type , GdkRectangle *area , GtkWidget *widget ,
                      gchar *detail , gint x , gint y , gint width , gint height ,
                      GtkOrientation orientation ) ;
#line 839
void gtk_paint_expander(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                        GdkRectangle *area , GtkWidget *widget , gchar *detail , gint x ,
                        gint y , GtkExpanderStyle expander_style ) ;
#line 848
void gtk_paint_layout(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                      gboolean use_text , GdkRectangle *area , GtkWidget *widget ,
                      gchar *detail , gint x , gint y , PangoLayout *layout ) ;
#line 858
void gtk_paint_resize_grip(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                           GdkRectangle *area , GtkWidget *widget , gchar *detail ,
                           GdkWindowEdge edge , gint x , gint y , gint width , gint height ) ;
#line 869
void gtk_paint_spinner(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                       GdkRectangle *area , GtkWidget *widget , gchar *detail , guint step ,
                       gint x , gint y , gint width , gint height ) ;
#line 881
GType gtk_border_get_type(void) ;
#line 882
GtkBorder *gtk_border_new(void) ;
#line 883
GtkBorder *gtk_border_copy(GtkBorder *border_ ) ;
#line 884
void gtk_border_free(GtkBorder *border_ ) ;
#line 886
void gtk_style_get_style_property(GtkStyle *style , GType widget_type , gchar *property_name ,
                                  GValue *value ) ;
#line 890
void gtk_style_get_valist(GtkStyle *style , GType widget_type , gchar *first_property_name ,
                          va_list var_args ) ;
#line 894
void gtk_style_get(GtkStyle *style , GType widget_type , gchar *first_property_name 
                   , ...) ;
#line 900
GValue *_gtk_style_peek_property_value(GtkStyle *style , GType widget_type , GParamSpec *pspec ,
                                       GtkRcPropertyParser parser ) ;
#line 905
void _gtk_style_init_for_settings(GtkStyle *style , GtkSettings *settings ) ;
#line 908
void _gtk_style_shade(GdkColor *a , GdkColor *b , gdouble k ) ;
#line 915
void gtk_draw_string(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                     gint x , gint y , gchar *string ) ;
#line 921
void gtk_paint_string(GtkStyle *style , GdkWindow *window , GtkStateType state_type ,
                      GdkRectangle *area , GtkWidget *widget , gchar *detail , gint x ,
                      gint y , gchar *string ) ;
#line 932
void gtk_draw_insertion_cursor(GtkWidget *widget , GdkDrawable *drawable , GdkRectangle *area ,
                               GdkRectangle *location , gboolean is_primary , GtkTextDirection direction ,
                               gboolean draw_arrow ) ;
#line 939
GdkGC *_gtk_widget_get_cursor_gc(GtkWidget *widget ) ;
#line 940
void _gtk_widget_get_cursor_color(GtkWidget *widget , GdkColor *color ) ;
#line 133 "/usr/include/gtk-2.0/gtk/gtkrc.h"
void _gtk_rc_init(void) ;
#line 134
GSList *_gtk_rc_parse_widget_class_path(gchar *pattern ) ;
#line 135
void _gtk_rc_free_widget_class_path(GSList *list ) ;
#line 136
gboolean _gtk_rc_match_widget_class(GSList *list , gint length , gchar *path , gchar *path_reversed ) ;
#line 141
void gtk_rc_add_default_file(gchar *filename ) ;
#line 142
void gtk_rc_set_default_files(gchar **filenames ) ;
#line 143
gchar **gtk_rc_get_default_files(void) ;
#line 144
GtkStyle *gtk_rc_get_style(GtkWidget *widget ) ;
#line 145
GtkStyle *gtk_rc_get_style_by_paths(GtkSettings *settings , char const   *widget_path ,
                                    char const   *class_path , GType type ) ;
#line 150
gboolean gtk_rc_reparse_all_for_settings(GtkSettings *settings , gboolean force_load ) ;
#line 152
void gtk_rc_reset_styles(GtkSettings *settings ) ;
#line 154
gchar *gtk_rc_find_pixmap_in_path(GtkSettings *settings , GScanner *scanner , gchar *pixmap_file ) ;
#line 158
void gtk_rc_parse(gchar *filename ) ;
#line 159
void gtk_rc_parse_string(gchar *rc_string ) ;
#line 160
gboolean gtk_rc_reparse_all(void) ;
#line 163
void gtk_rc_add_widget_name_style(GtkRcStyle *rc_style , gchar *pattern ) ;
#line 165
void gtk_rc_add_widget_class_style(GtkRcStyle *rc_style , gchar *pattern ) ;
#line 167
void gtk_rc_add_class_style(GtkRcStyle *rc_style , gchar *pattern ) ;
#line 172
GType gtk_rc_style_get_type(void) ;
#line 173
GtkRcStyle *gtk_rc_style_new(void) ;
#line 174
GtkRcStyle *gtk_rc_style_copy(GtkRcStyle *orig ) ;
#line 177
void gtk_rc_style_ref(GtkRcStyle *rc_style ) ;
#line 178
void gtk_rc_style_unref(GtkRcStyle *rc_style ) ;
#line 181
gchar *gtk_rc_find_module_in_path(gchar *module_file ) ;
#line 182
gchar *gtk_rc_get_theme_dir(void) ;
#line 183
gchar *gtk_rc_get_module_dir(void) ;
#line 184
gchar *gtk_rc_get_im_module_path(void) ;
#line 185
gchar *gtk_rc_get_im_module_file(void) ;
#line 231
GScanner *gtk_rc_scanner_new(void) ;
#line 232
guint gtk_rc_parse_color(GScanner *scanner , GdkColor *color ) ;
#line 234
guint gtk_rc_parse_color_full(GScanner *scanner , GtkRcStyle *style , GdkColor *color ) ;
#line 237
guint gtk_rc_parse_state(GScanner *scanner , GtkStateType *state ) ;
#line 239
guint gtk_rc_parse_priority(GScanner *scanner , GtkPathPriorityType *priority ) ;
#line 255
GtkRcProperty *_gtk_rc_style_lookup_rc_property(GtkRcStyle *rc_style , GQuark type_name ,
                                                GQuark property_name ) ;
#line 258
void _gtk_rc_style_set_rc_property(GtkRcStyle *rc_style , GtkRcProperty *property ) ;
#line 260
void _gtk_rc_style_unset_rc_property(GtkRcStyle *rc_style , GQuark type_name , GQuark property_name ) ;
#line 264
GSList *_gtk_rc_style_get_color_hashes(GtkRcStyle *rc_style ) ;
#line 266
gchar *_gtk_rc_context_get_default_font_name(GtkSettings *settings ) ;
#line 267
void _gtk_rc_context_destroy(GtkSettings *settings ) ;
#line 78 "/usr/include/gtk-2.0/gtk/gtksettings.h"
GType gtk_settings_get_type(void) ;
#line 80
GtkSettings *gtk_settings_get_default(void) ;
#line 82
GtkSettings *gtk_settings_get_for_screen(GdkScreen *screen ) ;
#line 84
void gtk_settings_install_property(GParamSpec *pspec ) ;
#line 85
void gtk_settings_install_property_parser(GParamSpec *pspec , GtkRcPropertyParser parser ) ;
#line 89
gboolean gtk_rc_property_parse_color(GParamSpec *pspec , GString *gstring , GValue *property_value ) ;
#line 92
gboolean gtk_rc_property_parse_enum(GParamSpec *pspec , GString *gstring , GValue *property_value ) ;
#line 95
gboolean gtk_rc_property_parse_flags(GParamSpec *pspec , GString *gstring , GValue *property_value ) ;
#line 98
gboolean gtk_rc_property_parse_requisition(GParamSpec *pspec , GString *gstring ,
                                           GValue *property_value ) ;
#line 101
gboolean gtk_rc_property_parse_border(GParamSpec *pspec , GString *gstring , GValue *property_value ) ;
#line 106
void gtk_settings_set_property_value(GtkSettings *settings , gchar *name , GtkSettingsValue *svalue ) ;
#line 109
void gtk_settings_set_string_property(GtkSettings *settings , gchar *name , gchar *v_string ,
                                      gchar *origin ) ;
#line 113
void gtk_settings_set_long_property(GtkSettings *settings , gchar *name , glong v_long ,
                                    gchar *origin ) ;
#line 117
void gtk_settings_set_double_property(GtkSettings *settings , gchar *name , gdouble v_double ,
                                      gchar *origin ) ;
#line 124
void _gtk_settings_set_property_value_from_rc(GtkSettings *settings , gchar *name ,
                                              GtkSettingsValue *svalue ) ;
#line 127
void _gtk_settings_reset_rc_values(GtkSettings *settings ) ;
#line 129
void _gtk_settings_handle_event(GdkEventSetting *event ) ;
#line 130
GtkRcPropertyParser _gtk_rc_property_parser_from_type(GType type ) ;
#line 131
gboolean _gtk_settings_parse_convert(GtkRcPropertyParser parser , GValue *src_value ,
                                     GParamSpec *pspec , GValue *dest_value ) ;
#line 428 "/usr/include/atk-1.0/atk/atkversion.h"
extern guint atk_get_major_version(void) ;
#line 430
extern guint atk_get_minor_version(void) ;
#line 432
extern guint atk_get_micro_version(void) ;
#line 434
extern guint atk_get_binary_age(void) ;
#line 436
extern guint atk_get_interface_age(void) ;
#line 199 "/usr/include/atk-1.0/atk/atkstate.h"
extern AtkStateType atk_state_type_register(gchar *name ) ;
#line 202
extern gchar *atk_state_type_get_name(AtkStateType type ) ;
#line 204
extern AtkStateType atk_state_type_for_name(gchar *name ) ;
#line 685 "/usr/include/atk-1.0/atk/atkobject.h"
extern GType atk_object_get_type(void) ;
#line 702
extern GType atk_implementor_get_type(void) ;
#line 704
extern AtkObject *atk_implementor_ref_accessible(AtkImplementor *implementor ) ;
#line 711
extern gchar *atk_object_get_name(AtkObject *accessible ) ;
#line 713
extern gchar *atk_object_get_description(AtkObject *accessible ) ;
#line 715
extern AtkObject *atk_object_get_parent(AtkObject *accessible ) ;
#line 717
extern AtkObject *atk_object_peek_parent(AtkObject *accessible ) ;
#line 719
extern gint atk_object_get_n_accessible_children(AtkObject *accessible ) ;
#line 721
extern AtkObject *atk_object_ref_accessible_child(AtkObject *accessible , gint i ) ;
#line 724
extern AtkRelationSet *atk_object_ref_relation_set(AtkObject *accessible ) ;
#line 726
extern AtkRole atk_object_get_role(AtkObject *accessible ) ;
#line 729
extern AtkLayer atk_object_get_layer(AtkObject *accessible ) ;
#line 731
extern gint atk_object_get_mdi_zorder(AtkObject *accessible ) ;
#line 734
extern AtkAttributeSet *atk_object_get_attributes(AtkObject *accessible ) ;
#line 736
extern AtkStateSet *atk_object_ref_state_set(AtkObject *accessible ) ;
#line 738
extern gint atk_object_get_index_in_parent(AtkObject *accessible ) ;
#line 740
extern void atk_object_set_name(AtkObject *accessible , gchar *name ) ;
#line 743
extern void atk_object_set_description(AtkObject *accessible , gchar *description ) ;
#line 746
extern void atk_object_set_parent(AtkObject *accessible , AtkObject *parent ) ;
#line 749
extern void atk_object_set_role(AtkObject *accessible , AtkRole role ) ;
#line 754
extern guint atk_object_connect_property_change_handler(AtkObject *accessible , AtkPropertyChangeHandler *handler ) ;
#line 757
extern void atk_object_remove_property_change_handler(AtkObject *accessible , guint handler_id ) ;
#line 761
extern void atk_object_notify_state_change(AtkObject *accessible , AtkState state ,
                                           gboolean value ) ;
#line 765
extern void atk_object_initialize(AtkObject *accessible , gpointer data ) ;
#line 769
extern gchar *atk_role_get_name(AtkRole role ) ;
#line 771
extern AtkRole atk_role_for_name(gchar *name ) ;
#line 776
extern gboolean atk_object_add_relationship(AtkObject *object , AtkRelationType relationship ,
                                            AtkObject *target ) ;
#line 780
extern gboolean atk_object_remove_relationship(AtkObject *object , AtkRelationType relationship ,
                                               AtkObject *target ) ;
#line 784
extern gchar *atk_role_get_localized_name(AtkRole role ) ;
#line 786
extern AtkRole atk_role_register(gchar *name ) ;
#line 788
extern gchar *atk_object_get_object_locale(AtkObject *accessible ) ;
#line 791
extern gchar *atk_object_get_accessible_id(AtkObject *accessible ) ;
#line 794
extern void atk_object_set_accessible_id(AtkObject *accessible , gchar *name ) ;
#line 85 "/usr/include/atk-1.0/atk/atkaction.h"
extern GType atk_action_get_type(void) ;
#line 99
extern gboolean atk_action_do_action(AtkAction *action , gint i ) ;
#line 102
extern gint atk_action_get_n_actions(AtkAction *action ) ;
#line 104
extern gchar *atk_action_get_description(AtkAction *action , gint i ) ;
#line 107
extern gchar *atk_action_get_name(AtkAction *action , gint i ) ;
#line 110
extern gchar *atk_action_get_keybinding(AtkAction *action , gint i ) ;
#line 113
extern gboolean atk_action_set_description(AtkAction *action , gint i , gchar *desc ) ;
#line 119
extern gchar *atk_action_get_localized_name(AtkAction *action , gint i ) ;
#line 174 "/usr/include/atk-1.0/atk/atkutil.h"
extern GType atk_util_get_type(void) ;
#line 194
extern guint atk_add_focus_tracker(AtkEventListener focus_tracker ) ;
#line 196
extern void atk_remove_focus_tracker(guint tracker_id ) ;
#line 198
extern void atk_focus_tracker_init(AtkEventListenerInit init ) ;
#line 200
extern void atk_focus_tracker_notify(AtkObject *object ) ;
#line 202
extern guint atk_add_global_event_listener(GSignalEmissionHook listener , gchar *event_type ) ;
#line 205
extern void atk_remove_global_event_listener(guint listener_id ) ;
#line 207
extern guint atk_add_key_event_listener(AtkKeySnoopFunc listener , gpointer data ) ;
#line 209
extern void atk_remove_key_event_listener(guint listener_id ) ;
#line 212
extern AtkObject *atk_get_root(void) ;
#line 214
extern AtkObject *atk_get_focus_object(void) ;
#line 217
extern gchar *atk_get_toolkit_name(void) ;
#line 219
extern gchar *atk_get_toolkit_version(void) ;
#line 221
extern gchar *atk_get_version(void) ;
#line 111 "/usr/include/atk-1.0/atk/atkcomponent.h"
extern GType atk_rectangle_get_type(void) ;
#line 225
extern GType atk_component_get_type(void) ;
#line 229
extern guint atk_component_add_focus_handler(AtkComponent *component , AtkFocusHandler handler ) ;
#line 232
extern gboolean atk_component_contains(AtkComponent *component , gint x , gint y ,
                                       AtkCoordType coord_type ) ;
#line 237
extern AtkObject *atk_component_ref_accessible_at_point(AtkComponent *component ,
                                                        gint x , gint y , AtkCoordType coord_type ) ;
#line 242
extern void atk_component_get_extents(AtkComponent *component , gint *x , gint *y ,
                                      gint *width , gint *height , AtkCoordType coord_type ) ;
#line 249
extern void atk_component_get_position(AtkComponent *component , gint *x , gint *y ,
                                       AtkCoordType coord_type ) ;
#line 254
extern void atk_component_get_size(AtkComponent *component , gint *width , gint *height ) ;
#line 258
extern AtkLayer atk_component_get_layer(AtkComponent *component ) ;
#line 260
extern gint atk_component_get_mdi_zorder(AtkComponent *component ) ;
#line 262
extern gboolean atk_component_grab_focus(AtkComponent *component ) ;
#line 264
extern void atk_component_remove_focus_handler(AtkComponent *component , guint handler_id ) ;
#line 267
extern gboolean atk_component_set_extents(AtkComponent *component , gint x , gint y ,
                                          gint width , gint height , AtkCoordType coord_type ) ;
#line 274
extern gboolean atk_component_set_position(AtkComponent *component , gint x , gint y ,
                                           AtkCoordType coord_type ) ;
#line 279
extern gboolean atk_component_set_size(AtkComponent *component , gint width , gint height ) ;
#line 283
extern gdouble atk_component_get_alpha(AtkComponent *component ) ;
#line 286
extern gboolean atk_component_scroll_to(AtkComponent *component , AtkScrollType type ) ;
#line 290
extern gboolean atk_component_scroll_to_point(AtkComponent *component , AtkCoordType coords ,
                                              gint x , gint y ) ;
#line 86 "/usr/include/atk-1.0/atk/atkdocument.h"
extern GType atk_document_get_type(void) ;
#line 89
extern gchar *atk_document_get_document_type(AtkDocument *document ) ;
#line 92
extern gpointer atk_document_get_document(AtkDocument *document ) ;
#line 95
extern gchar *atk_document_get_locale(AtkDocument *document ) ;
#line 98
extern AtkAttributeSet *atk_document_get_attributes(AtkDocument *document ) ;
#line 100
extern gchar *atk_document_get_attribute_value(AtkDocument *document , gchar *attribute_name ) ;
#line 103
extern gboolean atk_document_set_attribute_value(AtkDocument *document , gchar *attribute_name ,
                                                 gchar *attribute_value ) ;
#line 107
extern gint atk_document_get_current_page_number(AtkDocument *document ) ;
#line 109
extern gint atk_document_get_page_count(AtkDocument *document ) ;
#line 104 "/usr/include/atk-1.0/atk/atktext.h"
extern AtkTextAttribute atk_text_attribute_register(gchar *name ) ;
#line 216
extern GType atk_text_range_get_type(void) ;
#line 363
extern GType atk_text_get_type(void) ;
#line 374
extern gchar *atk_text_get_text(AtkText *text , gint start_offset , gint end_offset ) ;
#line 378
extern gunichar atk_text_get_character_at_offset(AtkText *text , gint offset ) ;
#line 381
extern gchar *atk_text_get_text_after_offset(AtkText *text , gint offset , AtkTextBoundary boundary_type ,
                                             gint *start_offset , gint *end_offset ) ;
#line 387
extern gchar *atk_text_get_text_at_offset(AtkText *text , gint offset , AtkTextBoundary boundary_type ,
                                          gint *start_offset , gint *end_offset ) ;
#line 393
extern gchar *atk_text_get_text_before_offset(AtkText *text , gint offset , AtkTextBoundary boundary_type ,
                                              gint *start_offset , gint *end_offset ) ;
#line 399
extern gchar *atk_text_get_string_at_offset(AtkText *text , gint offset , AtkTextGranularity granularity ,
                                            gint *start_offset , gint *end_offset ) ;
#line 405
extern gint atk_text_get_caret_offset(AtkText *text ) ;
#line 407
extern void atk_text_get_character_extents(AtkText *text , gint offset , gint *x ,
                                           gint *y , gint *width , gint *height ,
                                           AtkCoordType coords ) ;
#line 415
extern AtkAttributeSet *atk_text_get_run_attributes(AtkText *text , gint offset ,
                                                    gint *start_offset , gint *end_offset ) ;
#line 420
extern AtkAttributeSet *atk_text_get_default_attributes(AtkText *text ) ;
#line 422
extern gint atk_text_get_character_count(AtkText *text ) ;
#line 424
extern gint atk_text_get_offset_at_point(AtkText *text , gint x , gint y , AtkCoordType coords ) ;
#line 429
extern gint atk_text_get_n_selections(AtkText *text ) ;
#line 431
extern gchar *atk_text_get_selection(AtkText *text , gint selection_num , gint *start_offset ,
                                     gint *end_offset ) ;
#line 436
extern gboolean atk_text_add_selection(AtkText *text , gint start_offset , gint end_offset ) ;
#line 440
extern gboolean atk_text_remove_selection(AtkText *text , gint selection_num ) ;
#line 443
extern gboolean atk_text_set_selection(AtkText *text , gint selection_num , gint start_offset ,
                                       gint end_offset ) ;
#line 448
extern gboolean atk_text_set_caret_offset(AtkText *text , gint offset ) ;
#line 451
extern void atk_text_get_range_extents(AtkText *text , gint start_offset , gint end_offset ,
                                       AtkCoordType coord_type , AtkTextRectangle *rect ) ;
#line 458
extern AtkTextRange **atk_text_get_bounded_ranges(AtkText *text , AtkTextRectangle *rect ,
                                                  AtkCoordType coord_type , AtkTextClipType x_clip_type ,
                                                  AtkTextClipType y_clip_type ) ;
#line 464
extern void atk_text_free_ranges(AtkTextRange **ranges ) ;
#line 466
extern void atk_attribute_set_free(AtkAttributeSet *attrib_set ) ;
#line 468
extern gchar *atk_text_attribute_get_name(AtkTextAttribute attr ) ;
#line 470
extern AtkTextAttribute atk_text_attribute_for_name(gchar *name ) ;
#line 472
extern gchar *atk_text_attribute_get_value(AtkTextAttribute attr , gint index_ ) ;
#line 476
extern gboolean atk_text_scroll_substring_to(AtkText *text , gint start_offset , gint end_offset ,
                                             AtkScrollType type ) ;
#line 482
extern gboolean atk_text_scroll_substring_to_point(AtkText *text , gint start_offset ,
                                                   gint end_offset , AtkCoordType coords ,
                                                   gint x , gint y ) ;
#line 75 "/usr/include/atk-1.0/atk/atkeditabletext.h"
extern GType atk_editable_text_get_type(void) ;
#line 79
extern gboolean atk_editable_text_set_run_attributes(AtkEditableText *text , AtkAttributeSet *attrib_set ,
                                                     gint start_offset , gint end_offset ) ;
#line 84
extern void atk_editable_text_set_text_contents(AtkEditableText *text , gchar *string ) ;
#line 87
extern void atk_editable_text_insert_text(AtkEditableText *text , gchar *string ,
                                          gint length , gint *position ) ;
#line 92
extern void atk_editable_text_copy_text(AtkEditableText *text , gint start_pos , gint end_pos ) ;
#line 96
extern void atk_editable_text_cut_text(AtkEditableText *text , gint start_pos , gint end_pos ) ;
#line 100
extern void atk_editable_text_delete_text(AtkEditableText *text , gint start_pos ,
                                          gint end_pos ) ;
#line 104
extern void atk_editable_text_paste_text(AtkEditableText *text , gint position ) ;
#line 18 "/usr/include/atk-1.0/atk/atk-enum-types.h"
extern GType atk_scroll_type_get_type(void) ;
#line 23
extern GType atk_hyperlink_state_flags_get_type(void) ;
#line 28
extern GType atk_role_get_type(void) ;
#line 31
extern GType atk_layer_get_type(void) ;
#line 36
extern GType atk_relation_type_get_type(void) ;
#line 41
extern GType atk_state_type_get_type(void) ;
#line 46
extern GType atk_text_attribute_get_type(void) ;
#line 49
extern GType atk_text_boundary_get_type(void) ;
#line 52
extern GType atk_text_granularity_get_type(void) ;
#line 55
extern GType atk_text_clip_type_get_type(void) ;
#line 60
extern GType atk_key_event_type_get_type(void) ;
#line 63
extern GType atk_coord_type_get_type(void) ;
#line 68
extern GType atk_value_type_get_type(void) ;
#line 51 "/usr/include/atk-1.0/atk/atkgobjectaccessible.h"
extern GType atk_gobject_accessible_get_type(void) ;
#line 62
extern AtkObject *atk_gobject_accessible_for_object(GObject *obj ) ;
#line 64
extern GObject *atk_gobject_accessible_get_object(AtkGObjectAccessible *obj ) ;
#line 84 "/usr/include/atk-1.0/atk/atkhyperlink.h"
extern GType atk_hyperlink_get_type(void) ;
#line 87
extern gchar *atk_hyperlink_get_uri(AtkHyperlink *link_ , gint i ) ;
#line 91
extern AtkObject *atk_hyperlink_get_object(AtkHyperlink *link_ , gint i ) ;
#line 95
extern gint atk_hyperlink_get_end_index(AtkHyperlink *link_ ) ;
#line 98
extern gint atk_hyperlink_get_start_index(AtkHyperlink *link_ ) ;
#line 101
extern gboolean atk_hyperlink_is_valid(AtkHyperlink *link_ ) ;
#line 104
extern gboolean atk_hyperlink_is_inline(AtkHyperlink *link_ ) ;
#line 107
extern gint atk_hyperlink_get_n_anchors(AtkHyperlink *link_ ) ;
#line 110
extern gboolean atk_hyperlink_is_selected_link(AtkHyperlink *link_ ) ;
#line 61 "/usr/include/atk-1.0/atk/atkhyperlinkimpl.h"
extern GType atk_hyperlink_impl_get_type(void) ;
#line 64
extern AtkHyperlink *atk_hyperlink_impl_get_hyperlink(AtkHyperlinkImpl *impl ) ;
#line 65 "/usr/include/atk-1.0/atk/atkhypertext.h"
extern GType atk_hypertext_get_type(void) ;
#line 68
extern AtkHyperlink *atk_hypertext_get_link(AtkHypertext *hypertext , gint link_index ) ;
#line 71
extern gint atk_hypertext_get_n_links(AtkHypertext *hypertext ) ;
#line 73
extern gint atk_hypertext_get_link_index(AtkHypertext *hypertext , gint char_index ) ;
#line 66 "/usr/include/atk-1.0/atk/atkimage.h"
extern GType atk_image_get_type(void) ;
#line 69
extern gchar *atk_image_get_image_description(AtkImage *image ) ;
#line 72
extern void atk_image_get_image_size(AtkImage *image , gint *width , gint *height ) ;
#line 77
extern gboolean atk_image_set_image_description(AtkImage *image , gchar *description ) ;
#line 80
extern void atk_image_get_image_position(AtkImage *image , gint *x , gint *y , AtkCoordType coord_type ) ;
#line 86
extern gchar *atk_image_get_image_locale(AtkImage *image ) ;
#line 47 "/usr/include/atk-1.0/atk/atknoopobject.h"
extern GType atk_no_op_object_get_type(void) ;
#line 55
extern AtkObject *atk_no_op_object_new(GObject *obj ) ;
#line 60 "/usr/include/atk-1.0/atk/atkobjectfactory.h"
extern GType atk_object_factory_get_type(void) ;
#line 64
extern AtkObject *atk_object_factory_create_accessible(AtkObjectFactory *factory ,
                                                       GObject *obj ) ;
#line 66
extern void atk_object_factory_invalidate(AtkObjectFactory *factory ) ;
#line 68
extern GType atk_object_factory_get_accessible_type(AtkObjectFactory *factory ) ;
#line 52 "/usr/include/atk-1.0/atk/atknoopobjectfactory.h"
extern GType atk_no_op_object_factory_get_type(void) ;
#line 55
extern AtkObjectFactory *atk_no_op_object_factory_new(void) ;
#line 47 "/usr/include/atk-1.0/atk/atkplug.h"
extern GType atk_plug_get_type(void) ;
#line 60
extern AtkObject *atk_plug_new(void) ;
#line 62
extern void atk_plug_set_child(AtkPlug *plug , AtkObject *child ) ;
#line 64
extern gchar *atk_plug_get_id(AtkPlug *plug ) ;
#line 39 "/usr/include/atk-1.0/atk/atkrange.h"
extern GType atk_range_get_type(void) ;
#line 42
extern AtkRange *atk_range_copy(AtkRange *src ) ;
#line 44
extern void atk_range_free(AtkRange *range ) ;
#line 47
extern gdouble atk_range_get_lower_limit(AtkRange *range ) ;
#line 49
extern gdouble atk_range_get_upper_limit(AtkRange *range ) ;
#line 51
extern gchar *atk_range_get_description(AtkRange *range ) ;
#line 53
extern AtkRange *atk_range_new(gdouble lower_limit , gdouble upper_limit , gchar *description ) ;
#line 56 "/usr/include/atk-1.0/atk/atkregistry.h"
extern GType atk_registry_get_type(void) ;
#line 58
extern void atk_registry_set_factory_type(AtkRegistry *registry , GType type , GType factory_type ) ;
#line 62
extern GType atk_registry_get_factory_type(AtkRegistry *registry , GType type ) ;
#line 65
extern AtkObjectFactory *atk_registry_get_factory(AtkRegistry *registry , GType type ) ;
#line 69
extern AtkRegistry *atk_get_default_registry(void) ;
#line 63 "/usr/include/atk-1.0/atk/atkrelation.h"
extern GType atk_relation_get_type(void) ;
#line 66
extern AtkRelationType atk_relation_type_register(gchar *name ) ;
#line 68
extern gchar *atk_relation_type_get_name(AtkRelationType type ) ;
#line 70
extern AtkRelationType atk_relation_type_for_name(gchar *name ) ;
#line 77
extern AtkRelation *atk_relation_new(AtkObject **targets , gint n_targets , AtkRelationType relationship ) ;
#line 84
extern AtkRelationType atk_relation_get_relation_type(AtkRelation *relation ) ;
#line 89
extern GPtrArray *atk_relation_get_target(AtkRelation *relation ) ;
#line 91
extern void atk_relation_add_target(AtkRelation *relation , AtkObject *target ) ;
#line 94
extern gboolean atk_relation_remove_target(AtkRelation *relation , AtkObject *target ) ;
#line 59 "/usr/include/atk-1.0/atk/atkrelationset.h"
extern GType atk_relation_set_get_type(void) ;
#line 62
extern AtkRelationSet *atk_relation_set_new(void) ;
#line 64
extern gboolean atk_relation_set_contains(AtkRelationSet *set , AtkRelationType relationship ) ;
#line 67
extern gboolean atk_relation_set_contains_target(AtkRelationSet *set , AtkRelationType relationship ,
                                                 AtkObject *target ) ;
#line 71
extern void atk_relation_set_remove(AtkRelationSet *set , AtkRelation *relation ) ;
#line 74
extern void atk_relation_set_add(AtkRelationSet *set , AtkRelation *relation ) ;
#line 77
extern gint atk_relation_set_get_n_relations(AtkRelationSet *set ) ;
#line 79
extern AtkRelation *atk_relation_set_get_relation(AtkRelationSet *set , gint i ) ;
#line 82
extern AtkRelation *atk_relation_set_get_relation_by_type(AtkRelationSet *set , AtkRelationType relationship ) ;
#line 85
extern void atk_relation_set_add_relation_by_type(AtkRelationSet *set , AtkRelationType relationship ,
                                                  AtkObject *target ) ;
#line 71 "/usr/include/atk-1.0/atk/atkselection.h"
extern GType atk_selection_get_type(void) ;
#line 74
extern gboolean atk_selection_add_selection(AtkSelection *selection , gint i ) ;
#line 78
extern gboolean atk_selection_clear_selection(AtkSelection *selection ) ;
#line 81
extern AtkObject *atk_selection_ref_selection(AtkSelection *selection , gint i ) ;
#line 85
extern gint atk_selection_get_selection_count(AtkSelection *selection ) ;
#line 88
extern gboolean atk_selection_is_child_selected(AtkSelection *selection , gint i ) ;
#line 92
extern gboolean atk_selection_remove_selection(AtkSelection *selection , gint i ) ;
#line 96
extern gboolean atk_selection_select_all_selection(AtkSelection *selection ) ;
#line 50 "/usr/include/atk-1.0/atk/atksocket.h"
extern GType atk_socket_get_type(void) ;
#line 63
extern AtkObject *atk_socket_new(void) ;
#line 65
extern void atk_socket_embed(AtkSocket *obj , gchar *plug_id ) ;
#line 67
extern gboolean atk_socket_is_occupied(AtkSocket *obj ) ;
#line 55 "/usr/include/atk-1.0/atk/atkstateset.h"
extern GType atk_state_set_get_type(void) ;
#line 58
extern AtkStateSet *atk_state_set_new(void) ;
#line 60
extern gboolean atk_state_set_is_empty(AtkStateSet *set ) ;
#line 62
extern gboolean atk_state_set_add_state(AtkStateSet *set , AtkStateType type ) ;
#line 65
extern void atk_state_set_add_states(AtkStateSet *set , AtkStateType *types , gint n_types ) ;
#line 69
extern void atk_state_set_clear_states(AtkStateSet *set ) ;
#line 71
extern gboolean atk_state_set_contains_state(AtkStateSet *set , AtkStateType type ) ;
#line 74
extern gboolean atk_state_set_contains_states(AtkStateSet *set , AtkStateType *types ,
                                              gint n_types ) ;
#line 78
extern gboolean atk_state_set_remove_state(AtkStateSet *set , AtkStateType type ) ;
#line 81
extern AtkStateSet *atk_state_set_and_sets(AtkStateSet *set , AtkStateSet *compare_set ) ;
#line 84
extern AtkStateSet *atk_state_set_or_sets(AtkStateSet *set , AtkStateSet *compare_set ) ;
#line 87
extern AtkStateSet *atk_state_set_xor_sets(AtkStateSet *set , AtkStateSet *compare_set ) ;
#line 92 "/usr/include/atk-1.0/atk/atkstreamablecontent.h"
extern GType atk_streamable_content_get_type(void) ;
#line 95
extern gint atk_streamable_content_get_n_mime_types(AtkStreamableContent *streamable ) ;
#line 98
extern gchar *atk_streamable_content_get_mime_type(AtkStreamableContent *streamable ,
                                                   gint i ) ;
#line 101
extern GIOChannel *atk_streamable_content_get_stream(AtkStreamableContent *streamable ,
                                                     gchar *mime_type ) ;
#line 105
extern gchar *atk_streamable_content_get_uri(AtkStreamableContent *streamable , gchar *mime_type ) ;
#line 132 "/usr/include/atk-1.0/atk/atktable.h"
extern GType atk_table_get_type(void) ;
#line 135
extern AtkObject *atk_table_ref_at(AtkTable *table , gint row , gint column ) ;
#line 139
extern gint atk_table_get_index_at(AtkTable *table , gint row , gint column ) ;
#line 143
extern gint atk_table_get_column_at_index(AtkTable *table , gint index_ ) ;
#line 146
extern gint atk_table_get_row_at_index(AtkTable *table , gint index_ ) ;
#line 149
extern gint atk_table_get_n_columns(AtkTable *table ) ;
#line 151
extern gint atk_table_get_n_rows(AtkTable *table ) ;
#line 153
extern gint atk_table_get_column_extent_at(AtkTable *table , gint row , gint column ) ;
#line 157
extern gint atk_table_get_row_extent_at(AtkTable *table , gint row , gint column ) ;
#line 162
extern AtkObject *atk_table_get_caption(AtkTable *table ) ;
#line 164
extern gchar *atk_table_get_column_description(AtkTable *table , gint column ) ;
#line 168
extern AtkObject *atk_table_get_column_header(AtkTable *table , gint column ) ;
#line 171
extern gchar *atk_table_get_row_description(AtkTable *table , gint row ) ;
#line 174
extern AtkObject *atk_table_get_row_header(AtkTable *table , gint row ) ;
#line 177
extern AtkObject *atk_table_get_summary(AtkTable *table ) ;
#line 179
extern void atk_table_set_caption(AtkTable *table , AtkObject *caption ) ;
#line 182
extern void atk_table_set_column_description(AtkTable *table , gint column , gchar *description ) ;
#line 187
extern void atk_table_set_column_header(AtkTable *table , gint column , AtkObject *header ) ;
#line 191
extern void atk_table_set_row_description(AtkTable *table , gint row , gchar *description ) ;
#line 195
extern void atk_table_set_row_header(AtkTable *table , gint row , AtkObject *header ) ;
#line 199
extern void atk_table_set_summary(AtkTable *table , AtkObject *accessible ) ;
#line 202
extern gint atk_table_get_selected_columns(AtkTable *table , gint **selected ) ;
#line 205
extern gint atk_table_get_selected_rows(AtkTable *table , gint **selected ) ;
#line 208
extern gboolean atk_table_is_column_selected(AtkTable *table , gint column ) ;
#line 211
extern gboolean atk_table_is_row_selected(AtkTable *table , gint row ) ;
#line 214
extern gboolean atk_table_is_selected(AtkTable *table , gint row , gint column ) ;
#line 218
extern gboolean atk_table_add_row_selection(AtkTable *table , gint row ) ;
#line 221
extern gboolean atk_table_remove_row_selection(AtkTable *table , gint row ) ;
#line 224
extern gboolean atk_table_add_column_selection(AtkTable *table , gint column ) ;
#line 227
extern gboolean atk_table_remove_column_selection(AtkTable *table , gint column ) ;
#line 85 "/usr/include/atk-1.0/atk/atktablecell.h"
extern GType atk_table_cell_get_type(void) ;
#line 88
extern gint atk_table_cell_get_column_span(AtkTableCell *cell ) ;
#line 90
extern GPtrArray *atk_table_cell_get_column_header_cells(AtkTableCell *cell ) ;
#line 92
extern gboolean atk_table_cell_get_position(AtkTableCell *cell , gint *row , gint *column ) ;
#line 96
extern gint atk_table_cell_get_row_span(AtkTableCell *cell ) ;
#line 98
extern GPtrArray *atk_table_cell_get_row_header_cells(AtkTableCell *cell ) ;
#line 100
extern gboolean atk_table_cell_get_row_column_span(AtkTableCell *cell , gint *row ,
                                                   gint *column , gint *row_span ,
                                                   gint *column_span ) ;
#line 106
extern AtkObject *atk_table_cell_get_table(AtkTableCell *cell ) ;
#line 81 "/usr/include/atk-1.0/atk/atkmisc.h"
extern AtkMisc *atk_misc_instance ;
#line 101
extern GType atk_misc_get_type(void) ;
#line 104
extern void atk_misc_threads_enter(AtkMisc *misc ) ;
#line 106
extern void atk_misc_threads_leave(AtkMisc *misc ) ;
#line 108
extern AtkMisc *atk_misc_get_instance(void) ;
#line 123 "/usr/include/atk-1.0/atk/atkvalue.h"
extern GType atk_value_get_type(void) ;
#line 126
extern void atk_value_get_current_value(AtkValue *obj , GValue *value ) ;
#line 130
extern void atk_value_get_maximum_value(AtkValue *obj , GValue *value ) ;
#line 133
extern void atk_value_get_minimum_value(AtkValue *obj , GValue *value ) ;
#line 136
extern gboolean atk_value_set_current_value(AtkValue *obj , GValue *value ) ;
#line 139
extern void atk_value_get_minimum_increment(AtkValue *obj , GValue *value ) ;
#line 143
extern void atk_value_get_value_and_text(AtkValue *obj , gdouble *value , gchar **text ) ;
#line 147
extern AtkRange *atk_value_get_range(AtkValue *obj ) ;
#line 149
extern gdouble atk_value_get_increment(AtkValue *obj ) ;
#line 151
extern GSList *atk_value_get_sub_ranges(AtkValue *obj ) ;
#line 153
extern void atk_value_set_value(AtkValue *obj , gdouble new_value ) ;
#line 157
extern gchar *atk_value_type_get_name(AtkValueType value_type ) ;
#line 159
extern gchar *atk_value_type_get_localized_name(AtkValueType value_type ) ;
#line 50 "/usr/include/atk-1.0/atk/atkwindow.h"
extern GType atk_window_get_type(void) ;
#line 833 "/usr/include/gtk-2.0/gtk/gtkwidget.h"
GType gtk_widget_get_type(void) ;
#line 834
GtkWidget *gtk_widget_new(GType type , gchar *first_property_name  , ...) ;
#line 837
void gtk_widget_destroy(GtkWidget *widget ) ;
#line 838
void gtk_widget_destroyed(GtkWidget *widget , GtkWidget **widget_pointer ) ;
#line 841
GtkWidget *gtk_widget_ref(GtkWidget *widget ) ;
#line 842
void gtk_widget_unref(GtkWidget *widget ) ;
#line 843
void gtk_widget_set(GtkWidget *widget , gchar *first_property_name  , ...) ;
#line 848
void gtk_widget_hide_all(GtkWidget *widget ) ;
#line 850
void gtk_widget_unparent(GtkWidget *widget ) ;
#line 851
void gtk_widget_show(GtkWidget *widget ) ;
#line 852
void gtk_widget_show_now(GtkWidget *widget ) ;
#line 853
void gtk_widget_hide(GtkWidget *widget ) ;
#line 854
void gtk_widget_show_all(GtkWidget *widget ) ;
#line 855
void gtk_widget_set_no_show_all(GtkWidget *widget , gboolean no_show_all ) ;
#line 857
gboolean gtk_widget_get_no_show_all(GtkWidget *widget ) ;
#line 858
void gtk_widget_map(GtkWidget *widget ) ;
#line 859
void gtk_widget_unmap(GtkWidget *widget ) ;
#line 860
void gtk_widget_realize(GtkWidget *widget ) ;
#line 861
void gtk_widget_unrealize(GtkWidget *widget ) ;
#line 864
void gtk_widget_queue_draw(GtkWidget *widget ) ;
#line 865
void gtk_widget_queue_draw_area(GtkWidget *widget , gint x , gint y , gint width ,
                                gint height ) ;
#line 871
void gtk_widget_queue_clear(GtkWidget *widget ) ;
#line 872
void gtk_widget_queue_clear_area(GtkWidget *widget , gint x , gint y , gint width ,
                                 gint height ) ;
#line 880
void gtk_widget_queue_resize(GtkWidget *widget ) ;
#line 881
void gtk_widget_queue_resize_no_redraw(GtkWidget *widget ) ;
#line 883
void gtk_widget_draw(GtkWidget *widget , GdkRectangle *area ) ;
#line 886
void gtk_widget_size_request(GtkWidget *widget , GtkRequisition *requisition ) ;
#line 888
void gtk_widget_size_allocate(GtkWidget *widget , GtkAllocation *allocation ) ;
#line 890
void gtk_widget_get_child_requisition(GtkWidget *widget , GtkRequisition *requisition ) ;
#line 892
void gtk_widget_add_accelerator(GtkWidget *widget , gchar *accel_signal , GtkAccelGroup *accel_group ,
                                guint accel_key , GdkModifierType accel_mods , GtkAccelFlags accel_flags ) ;
#line 898
gboolean gtk_widget_remove_accelerator(GtkWidget *widget , GtkAccelGroup *accel_group ,
                                       guint accel_key , GdkModifierType accel_mods ) ;
#line 902
void gtk_widget_set_accel_path(GtkWidget *widget , gchar *accel_path , GtkAccelGroup *accel_group ) ;
#line 905
gchar *_gtk_widget_get_accel_path(GtkWidget *widget , gboolean *locked ) ;
#line 907
GList *gtk_widget_list_accel_closures(GtkWidget *widget ) ;
#line 908
gboolean gtk_widget_can_activate_accel(GtkWidget *widget , guint signal_id ) ;
#line 910
gboolean gtk_widget_mnemonic_activate(GtkWidget *widget , gboolean group_cycling ) ;
#line 912
gboolean gtk_widget_event(GtkWidget *widget , GdkEvent *event ) ;
#line 914
gint gtk_widget_send_expose(GtkWidget *widget , GdkEvent *event ) ;
#line 916
gboolean gtk_widget_send_focus_change(GtkWidget *widget , GdkEvent *event ) ;
#line 919
gboolean gtk_widget_activate(GtkWidget *widget ) ;
#line 920
gboolean gtk_widget_set_scroll_adjustments(GtkWidget *widget , GtkAdjustment *hadjustment ,
                                           GtkAdjustment *vadjustment ) ;
#line 924
void gtk_widget_reparent(GtkWidget *widget , GtkWidget *new_parent ) ;
#line 926
gboolean gtk_widget_intersect(GtkWidget *widget , GdkRectangle *area , GdkRectangle *intersection ) ;
#line 929
GdkRegion *gtk_widget_region_intersect(GtkWidget *widget , GdkRegion *region ) ;
#line 932
void gtk_widget_freeze_child_notify(GtkWidget *widget ) ;
#line 933
void gtk_widget_child_notify(GtkWidget *widget , gchar *child_property ) ;
#line 935
void gtk_widget_thaw_child_notify(GtkWidget *widget ) ;
#line 937
void gtk_widget_set_can_focus(GtkWidget *widget , gboolean can_focus ) ;
#line 939
gboolean gtk_widget_get_can_focus(GtkWidget *widget ) ;
#line 940
gboolean gtk_widget_has_focus(GtkWidget *widget ) ;
#line 941
gboolean gtk_widget_is_focus(GtkWidget *widget ) ;
#line 942
void gtk_widget_grab_focus(GtkWidget *widget ) ;
#line 944
void gtk_widget_set_can_default(GtkWidget *widget , gboolean can_default ) ;
#line 946
gboolean gtk_widget_get_can_default(GtkWidget *widget ) ;
#line 947
gboolean gtk_widget_has_default(GtkWidget *widget ) ;
#line 948
void gtk_widget_grab_default(GtkWidget *widget ) ;
#line 950
void gtk_widget_set_receives_default(GtkWidget *widget , gboolean receives_default ) ;
#line 952
gboolean gtk_widget_get_receives_default(GtkWidget *widget ) ;
#line 954
gboolean gtk_widget_has_grab(GtkWidget *widget ) ;
#line 956
void gtk_widget_set_name(GtkWidget *widget , gchar *name ) ;
#line 958
gchar *gtk_widget_get_name(GtkWidget *widget ) ;
#line 960
void gtk_widget_set_state(GtkWidget *widget , GtkStateType state ) ;
#line 962
GtkStateType gtk_widget_get_state(GtkWidget *widget ) ;
#line 964
void gtk_widget_set_sensitive(GtkWidget *widget , gboolean sensitive ) ;
#line 966
gboolean gtk_widget_get_sensitive(GtkWidget *widget ) ;
#line 967
gboolean gtk_widget_is_sensitive(GtkWidget *widget ) ;
#line 969
void gtk_widget_set_visible(GtkWidget *widget , gboolean visible ) ;
#line 971
gboolean gtk_widget_get_visible(GtkWidget *widget ) ;
#line 973
void gtk_widget_set_has_window(GtkWidget *widget , gboolean has_window ) ;
#line 975
gboolean gtk_widget_get_has_window(GtkWidget *widget ) ;
#line 977
gboolean gtk_widget_is_toplevel(GtkWidget *widget ) ;
#line 978
gboolean gtk_widget_is_drawable(GtkWidget *widget ) ;
#line 979
void gtk_widget_set_realized(GtkWidget *widget , gboolean realized ) ;
#line 981
gboolean gtk_widget_get_realized(GtkWidget *widget ) ;
#line 982
void gtk_widget_set_mapped(GtkWidget *widget , gboolean mapped ) ;
#line 984
gboolean gtk_widget_get_mapped(GtkWidget *widget ) ;
#line 986
void gtk_widget_set_app_paintable(GtkWidget *widget , gboolean app_paintable ) ;
#line 988
gboolean gtk_widget_get_app_paintable(GtkWidget *widget ) ;
#line 990
void gtk_widget_set_double_buffered(GtkWidget *widget , gboolean double_buffered ) ;
#line 992
gboolean gtk_widget_get_double_buffered(GtkWidget *widget ) ;
#line 994
void gtk_widget_set_redraw_on_allocate(GtkWidget *widget , gboolean redraw_on_allocate ) ;
#line 997
void gtk_widget_set_parent(GtkWidget *widget , GtkWidget *parent ) ;
#line 999
GtkWidget *gtk_widget_get_parent(GtkWidget *widget ) ;
#line 1001
void gtk_widget_set_parent_window(GtkWidget *widget , GdkWindow *parent_window ) ;
#line 1003
GdkWindow *gtk_widget_get_parent_window(GtkWidget *widget ) ;
#line 1005
void gtk_widget_set_child_visible(GtkWidget *widget , gboolean is_visible ) ;
#line 1007
gboolean gtk_widget_get_child_visible(GtkWidget *widget ) ;
#line 1009
void gtk_widget_set_window(GtkWidget *widget , GdkWindow *window ) ;
#line 1011
GdkWindow *gtk_widget_get_window(GtkWidget *widget ) ;
#line 1013
void gtk_widget_get_allocation(GtkWidget *widget , GtkAllocation *allocation ) ;
#line 1015
void gtk_widget_set_allocation(GtkWidget *widget , GtkAllocation *allocation ) ;
#line 1018
void gtk_widget_get_requisition(GtkWidget *widget , GtkRequisition *requisition ) ;
#line 1021
gboolean gtk_widget_child_focus(GtkWidget *widget , GtkDirectionType direction ) ;
#line 1023
gboolean gtk_widget_keynav_failed(GtkWidget *widget , GtkDirectionType direction ) ;
#line 1025
void gtk_widget_error_bell(GtkWidget *widget ) ;
#line 1027
void gtk_widget_set_size_request(GtkWidget *widget , gint width , gint height ) ;
#line 1030
void gtk_widget_get_size_request(GtkWidget *widget , gint *width , gint *height ) ;
#line 1034
void gtk_widget_set_uposition(GtkWidget *widget , gint x , gint y ) ;
#line 1037
void gtk_widget_set_usize(GtkWidget *widget , gint width , gint height ) ;
#line 1042
void gtk_widget_set_events(GtkWidget *widget , gint events ) ;
#line 1044
void gtk_widget_add_events(GtkWidget *widget , gint events ) ;
#line 1046
void gtk_widget_set_extension_events(GtkWidget *widget , GdkExtensionMode mode ) ;
#line 1049
GdkExtensionMode gtk_widget_get_extension_events(GtkWidget *widget ) ;
#line 1050
GtkWidget *gtk_widget_get_toplevel(GtkWidget *widget ) ;
#line 1051
GtkWidget *gtk_widget_get_ancestor(GtkWidget *widget , GType widget_type ) ;
#line 1053
GdkColormap *gtk_widget_get_colormap(GtkWidget *widget ) ;
#line 1054
GdkVisual *gtk_widget_get_visual(GtkWidget *widget ) ;
#line 1056
GdkScreen *gtk_widget_get_screen(GtkWidget *widget ) ;
#line 1057
gboolean gtk_widget_has_screen(GtkWidget *widget ) ;
#line 1058
GdkDisplay *gtk_widget_get_display(GtkWidget *widget ) ;
#line 1059
GdkWindow *gtk_widget_get_root_window(GtkWidget *widget ) ;
#line 1060
GtkSettings *gtk_widget_get_settings(GtkWidget *widget ) ;
#line 1061
GtkClipboard *gtk_widget_get_clipboard(GtkWidget *widget , GdkAtom selection ) ;
#line 1063
GdkPixmap *gtk_widget_get_snapshot(GtkWidget *widget , GdkRectangle *clip_rect ) ;
#line 1103
AtkObject *gtk_widget_get_accessible(GtkWidget *widget ) ;
#line 1111
void gtk_widget_set_colormap(GtkWidget *widget , GdkColormap *colormap ) ;
#line 1114
gint gtk_widget_get_events(GtkWidget *widget ) ;
#line 1115
void gtk_widget_get_pointer(GtkWidget *widget , gint *x , gint *y ) ;
#line 1119
gboolean gtk_widget_is_ancestor(GtkWidget *widget , GtkWidget *ancestor ) ;
#line 1122
gboolean gtk_widget_translate_coordinates(GtkWidget *src_widget , GtkWidget *dest_widget ,
                                          gint src_x , gint src_y , gint *dest_x ,
                                          gint *dest_y ) ;
#line 1131
gboolean gtk_widget_hide_on_delete(GtkWidget *widget ) ;
#line 1135
void gtk_widget_style_attach(GtkWidget *style ) ;
#line 1137
gboolean gtk_widget_has_rc_style(GtkWidget *widget ) ;
#line 1138
void gtk_widget_set_style(GtkWidget *widget , GtkStyle *style ) ;
#line 1140
void gtk_widget_ensure_style(GtkWidget *widget ) ;
#line 1141
GtkStyle *gtk_widget_get_style(GtkWidget *widget ) ;
#line 1143
void gtk_widget_modify_style(GtkWidget *widget , GtkRcStyle *style ) ;
#line 1145
GtkRcStyle *gtk_widget_get_modifier_style(GtkWidget *widget ) ;
#line 1146
void gtk_widget_modify_fg(GtkWidget *widget , GtkStateType state , GdkColor *color ) ;
#line 1149
void gtk_widget_modify_bg(GtkWidget *widget , GtkStateType state , GdkColor *color ) ;
#line 1152
void gtk_widget_modify_text(GtkWidget *widget , GtkStateType state , GdkColor *color ) ;
#line 1155
void gtk_widget_modify_base(GtkWidget *widget , GtkStateType state , GdkColor *color ) ;
#line 1158
void gtk_widget_modify_cursor(GtkWidget *widget , GdkColor *primary , GdkColor *secondary ) ;
#line 1161
void gtk_widget_modify_font(GtkWidget *widget , PangoFontDescription *font_desc ) ;
#line 1187
PangoContext *gtk_widget_create_pango_context(GtkWidget *widget ) ;
#line 1188
PangoContext *gtk_widget_get_pango_context(GtkWidget *widget ) ;
#line 1189
PangoLayout *gtk_widget_create_pango_layout(GtkWidget *widget , gchar *text ) ;
#line 1192
GdkPixbuf *gtk_widget_render_icon(GtkWidget *widget , gchar *stock_id , GtkIconSize size ,
                                  gchar *detail ) ;
#line 1200
void gtk_widget_set_composite_name(GtkWidget *widget , gchar *name ) ;
#line 1202
gchar *gtk_widget_get_composite_name(GtkWidget *widget ) ;
#line 1205
void gtk_widget_reset_rc_styles(GtkWidget *widget ) ;
#line 1211
void gtk_widget_push_colormap(GdkColormap *cmap ) ;
#line 1212
void gtk_widget_push_composite_child(void) ;
#line 1213
void gtk_widget_pop_composite_child(void) ;
#line 1214
void gtk_widget_pop_colormap(void) ;
#line 1218
void gtk_widget_class_install_style_property(GtkWidgetClass *klass , GParamSpec *pspec ) ;
#line 1220
void gtk_widget_class_install_style_property_parser(GtkWidgetClass *klass , GParamSpec *pspec ,
                                                    GtkRcPropertyParser parser ) ;
#line 1223
GParamSpec *gtk_widget_class_find_style_property(GtkWidgetClass *klass , gchar *property_name ) ;
#line 1225
GParamSpec **gtk_widget_class_list_style_properties(GtkWidgetClass *klass , guint *n_properties ) ;
#line 1227
void gtk_widget_style_get_property(GtkWidget *widget , gchar *property_name , GValue *value ) ;
#line 1230
void gtk_widget_style_get_valist(GtkWidget *widget , gchar *first_property_name ,
                                 va_list var_args ) ;
#line 1233
void gtk_widget_style_get(GtkWidget *widget , gchar *first_property_name  , ...) ;
#line 1240
void gtk_widget_set_default_colormap(GdkColormap *colormap ) ;
#line 1241
GtkStyle *gtk_widget_get_default_style(void) ;
#line 1243
GdkColormap *gtk_widget_get_default_colormap(void) ;
#line 1244
GdkVisual *gtk_widget_get_default_visual(void) ;
#line 1250
void gtk_widget_set_direction(GtkWidget *widget , GtkTextDirection dir ) ;
#line 1252
GtkTextDirection gtk_widget_get_direction(GtkWidget *widget ) ;
#line 1254
void gtk_widget_set_default_direction(GtkTextDirection dir ) ;
#line 1255
GtkTextDirection gtk_widget_get_default_direction(void) ;
#line 1258
gboolean gtk_widget_is_composited(GtkWidget *widget ) ;
#line 1262
void gtk_widget_shape_combine_mask(GtkWidget *widget , GdkBitmap *shape_mask , gint offset_x ,
                                   gint offset_y ) ;
#line 1266
void gtk_widget_input_shape_combine_mask(GtkWidget *widget , GdkBitmap *shape_mask ,
                                         gint offset_x , gint offset_y ) ;
#line 1273
void gtk_widget_reset_shapes(GtkWidget *widget ) ;
#line 1279
void gtk_widget_path(GtkWidget *widget , guint *path_length , gchar **path , gchar **path_reversed ) ;
#line 1283
void gtk_widget_class_path(GtkWidget *widget , guint *path_length , gchar **path ,
                           gchar **path_reversed ) ;
#line 1288
GList *gtk_widget_list_mnemonic_labels(GtkWidget *widget ) ;
#line 1289
void gtk_widget_add_mnemonic_label(GtkWidget *widget , GtkWidget *label ) ;
#line 1291
void gtk_widget_remove_mnemonic_label(GtkWidget *widget , GtkWidget *label ) ;
#line 1294
void gtk_widget_set_tooltip_window(GtkWidget *widget , GtkWindow *custom_window ) ;
#line 1296
GtkWindow *gtk_widget_get_tooltip_window(GtkWidget *widget ) ;
#line 1297
void gtk_widget_trigger_tooltip_query(GtkWidget *widget ) ;
#line 1298
void gtk_widget_set_tooltip_text(GtkWidget *widget , gchar *text ) ;
#line 1300
gchar *gtk_widget_get_tooltip_text(GtkWidget *widget ) ;
#line 1301
void gtk_widget_set_tooltip_markup(GtkWidget *widget , gchar *markup ) ;
#line 1303
gchar *gtk_widget_get_tooltip_markup(GtkWidget *widget ) ;
#line 1304
void gtk_widget_set_has_tooltip(GtkWidget *widget , gboolean has_tooltip ) ;
#line 1306
gboolean gtk_widget_get_has_tooltip(GtkWidget *widget ) ;
#line 1308
GType gtk_requisition_get_type(void) ;
#line 1309
GtkRequisition *gtk_requisition_copy(GtkRequisition *requisition ) ;
#line 1310
void gtk_requisition_free(GtkRequisition *requisition ) ;
#line 1317
void _gtk_widget_set_has_default(GtkWidget *widget , gboolean has_default ) ;
#line 1319
void _gtk_widget_set_has_grab(GtkWidget *widget , gboolean has_grab ) ;
#line 1321
void _gtk_widget_set_is_toplevel(GtkWidget *widget , gboolean is_toplevel ) ;
#line 1324
void _gtk_widget_grab_notify(GtkWidget *widget , gboolean was_grabbed ) ;
#line 1327
GtkWidgetAuxInfo *_gtk_widget_get_aux_info(GtkWidget *widget , gboolean create ) ;
#line 1329
void _gtk_widget_propagate_hierarchy_changed(GtkWidget *widget , GtkWidget *previous_toplevel ) ;
#line 1331
void _gtk_widget_propagate_screen_changed(GtkWidget *widget , GdkScreen *previous_screen ) ;
#line 1333
void _gtk_widget_propagate_composited_changed(GtkWidget *widget ) ;
#line 1335
void _gtk_widget_set_pointer_window(GtkWidget *widget , GdkWindow *pointer_window ) ;
#line 1337
GdkWindow *_gtk_widget_get_pointer_window(GtkWidget *widget ) ;
#line 1338
gboolean _gtk_widget_is_pointer_widget(GtkWidget *widget ) ;
#line 1339
void _gtk_widget_synthesize_crossing(GtkWidget *from , GtkWidget *to , GdkCrossingMode mode ) ;
#line 1343
GdkColormap *_gtk_widget_peek_colormap(void) ;
#line 1345
void _gtk_widget_buildable_finish_accelerator(GtkWidget *widget , GtkWidget *toplevel ,
                                              gpointer user_data ) ;
#line 1349
void ubuntu_gtk_widget_set_has_grab(GtkWidget *widget , gboolean has_grab ) ;
#line 107 "/usr/include/gtk-2.0/gtk/gtkcontainer.h"
GType gtk_container_get_type(void) ;
#line 108
void gtk_container_set_border_width(GtkContainer *container , guint border_width ) ;
#line 110
guint gtk_container_get_border_width(GtkContainer *container ) ;
#line 111
void gtk_container_add(GtkContainer *container , GtkWidget *widget ) ;
#line 113
void gtk_container_remove(GtkContainer *container , GtkWidget *widget ) ;
#line 116
void gtk_container_set_resize_mode(GtkContainer *container , GtkResizeMode resize_mode ) ;
#line 118
GtkResizeMode gtk_container_get_resize_mode(GtkContainer *container ) ;
#line 120
void gtk_container_check_resize(GtkContainer *container ) ;
#line 122
void gtk_container_foreach(GtkContainer *container , GtkCallback callback , gpointer callback_data ) ;
#line 126
void gtk_container_foreach_full(GtkContainer *container , GtkCallback callback , GtkCallbackMarshal marshal ,
                                gpointer callback_data , GDestroyNotify notify ) ;
#line 133
GList *gtk_container_get_children(GtkContainer *container ) ;
#line 139
void gtk_container_propagate_expose(GtkContainer *container , GtkWidget *child , GdkEventExpose *event ) ;
#line 143
void gtk_container_set_focus_chain(GtkContainer *container , GList *focusable_widgets ) ;
#line 145
gboolean gtk_container_get_focus_chain(GtkContainer *container , GList **focusable_widgets ) ;
#line 147
void gtk_container_unset_focus_chain(GtkContainer *container ) ;
#line 151
void gtk_container_set_reallocate_redraws(GtkContainer *container , gboolean needs_redraws ) ;
#line 153
void gtk_container_set_focus_child(GtkContainer *container , GtkWidget *child ) ;
#line 156
GtkWidget *gtk_container_get_focus_child(GtkContainer *container ) ;
#line 157
void gtk_container_set_focus_vadjustment(GtkContainer *container , GtkAdjustment *adjustment ) ;
#line 159
GtkAdjustment *gtk_container_get_focus_vadjustment(GtkContainer *container ) ;
#line 160
void gtk_container_set_focus_hadjustment(GtkContainer *container , GtkAdjustment *adjustment ) ;
#line 162
GtkAdjustment *gtk_container_get_focus_hadjustment(GtkContainer *container ) ;
#line 164
void gtk_container_resize_children(GtkContainer *container ) ;
#line 166
GType gtk_container_child_type(GtkContainer *container ) ;
#line 169
void gtk_container_class_install_child_property(GtkContainerClass *cclass , guint property_id ,
                                                GParamSpec *pspec ) ;
#line 172
GParamSpec *gtk_container_class_find_child_property(GObjectClass *cclass , gchar *property_name ) ;
#line 174
GParamSpec **gtk_container_class_list_child_properties(GObjectClass *cclass , guint *n_properties ) ;
#line 176
void gtk_container_add_with_properties(GtkContainer *container , GtkWidget *widget ,
                                       gchar *first_prop_name  , ...) ;
#line 180
void gtk_container_child_set(GtkContainer *container , GtkWidget *child , gchar *first_prop_name 
                             , ...) ;
#line 184
void gtk_container_child_get(GtkContainer *container , GtkWidget *child , gchar *first_prop_name 
                             , ...) ;
#line 188
void gtk_container_child_set_valist(GtkContainer *container , GtkWidget *child , gchar *first_property_name ,
                                    va_list var_args ) ;
#line 192
void gtk_container_child_get_valist(GtkContainer *container , GtkWidget *child , gchar *first_property_name ,
                                    va_list var_args ) ;
#line 196
void gtk_container_child_set_property(GtkContainer *container , GtkWidget *child ,
                                      gchar *property_name , GValue *value ) ;
#line 200
void gtk_container_child_get_property(GtkContainer *container , GtkWidget *child ,
                                      gchar *property_name , GValue *value ) ;
#line 209
void gtk_container_forall(GtkContainer *container , GtkCallback callback , gpointer callback_data ) ;
#line 214
void _gtk_container_queue_resize(GtkContainer *container ) ;
#line 215
void _gtk_container_clear_resize_widgets(GtkContainer *container ) ;
#line 216
gchar *_gtk_container_child_composite_name(GtkContainer *container , GtkWidget *child ) ;
#line 218
void _gtk_container_dequeue_resize_handler(GtkContainer *container ) ;
#line 219
GList *_gtk_container_focus_sort(GtkContainer *container , GList *children , GtkDirectionType direction ,
                                 GtkWidget *old_focus ) ;
#line 64 "/usr/include/gtk-2.0/gtk/gtkbin.h"
GType gtk_bin_get_type(void) ;
#line 66
GtkWidget *gtk_bin_get_child(GtkBin *bin ) ;
#line 178 "/usr/include/gtk-2.0/gtk/gtkwindow.h"
GType gtk_window_get_type(void) ;
#line 179
GtkWidget *gtk_window_new(GtkWindowType type ) ;
#line 180
void gtk_window_set_title(GtkWindow *window , gchar *title ) ;
#line 182
gchar *gtk_window_get_title(GtkWindow *window ) ;
#line 183
void gtk_window_set_wmclass(GtkWindow *window , gchar *wmclass_name , gchar *wmclass_class ) ;
#line 186
void gtk_window_set_role(GtkWindow *window , gchar *role ) ;
#line 188
void gtk_window_set_startup_id(GtkWindow *window , gchar *startup_id ) ;
#line 190
gchar *gtk_window_get_role(GtkWindow *window ) ;
#line 191
void gtk_window_add_accel_group(GtkWindow *window , GtkAccelGroup *accel_group ) ;
#line 193
void gtk_window_remove_accel_group(GtkWindow *window , GtkAccelGroup *accel_group ) ;
#line 195
void gtk_window_set_position(GtkWindow *window , GtkWindowPosition position ) ;
#line 197
gboolean gtk_window_activate_focus(GtkWindow *window ) ;
#line 198
void gtk_window_set_focus(GtkWindow *window , GtkWidget *focus ) ;
#line 200
GtkWidget *gtk_window_get_focus(GtkWindow *window ) ;
#line 201
void gtk_window_set_default(GtkWindow *window , GtkWidget *default_widget ) ;
#line 203
GtkWidget *gtk_window_get_default_widget(GtkWindow *window ) ;
#line 204
gboolean gtk_window_activate_default(GtkWindow *window ) ;
#line 206
void gtk_window_set_transient_for(GtkWindow *window , GtkWindow *parent ) ;
#line 208
GtkWindow *gtk_window_get_transient_for(GtkWindow *window ) ;
#line 209
void gtk_window_set_opacity(GtkWindow *window , gdouble opacity ) ;
#line 211
gdouble gtk_window_get_opacity(GtkWindow *window ) ;
#line 212
void gtk_window_set_type_hint(GtkWindow *window , GdkWindowTypeHint hint ) ;
#line 214
GdkWindowTypeHint gtk_window_get_type_hint(GtkWindow *window ) ;
#line 215
void gtk_window_set_skip_taskbar_hint(GtkWindow *window , gboolean setting ) ;
#line 217
gboolean gtk_window_get_skip_taskbar_hint(GtkWindow *window ) ;
#line 218
void gtk_window_set_skip_pager_hint(GtkWindow *window , gboolean setting ) ;
#line 220
gboolean gtk_window_get_skip_pager_hint(GtkWindow *window ) ;
#line 221
void gtk_window_set_urgency_hint(GtkWindow *window , gboolean setting ) ;
#line 223
gboolean gtk_window_get_urgency_hint(GtkWindow *window ) ;
#line 224
void gtk_window_set_accept_focus(GtkWindow *window , gboolean setting ) ;
#line 226
gboolean gtk_window_get_accept_focus(GtkWindow *window ) ;
#line 227
void gtk_window_set_focus_on_map(GtkWindow *window , gboolean setting ) ;
#line 229
gboolean gtk_window_get_focus_on_map(GtkWindow *window ) ;
#line 230
void gtk_window_set_destroy_with_parent(GtkWindow *window , gboolean setting ) ;
#line 232
gboolean gtk_window_get_destroy_with_parent(GtkWindow *window ) ;
#line 233
void gtk_window_set_mnemonics_visible(GtkWindow *window , gboolean setting ) ;
#line 235
gboolean gtk_window_get_mnemonics_visible(GtkWindow *window ) ;
#line 237
void gtk_window_set_resizable(GtkWindow *window , gboolean resizable ) ;
#line 239
gboolean gtk_window_get_resizable(GtkWindow *window ) ;
#line 241
void gtk_window_set_gravity(GtkWindow *window , GdkGravity gravity ) ;
#line 243
GdkGravity gtk_window_get_gravity(GtkWindow *window ) ;
#line 246
void gtk_window_set_geometry_hints(GtkWindow *window , GtkWidget *geometry_widget ,
                                   GdkGeometry *geometry , GdkWindowHints geom_mask ) ;
#line 251
void gtk_window_set_screen(GtkWindow *window , GdkScreen *screen ) ;
#line 253
GdkScreen *gtk_window_get_screen(GtkWindow *window ) ;
#line 255
gboolean gtk_window_is_active(GtkWindow *window ) ;
#line 256
gboolean gtk_window_has_toplevel_focus(GtkWindow *window ) ;
#line 261
void gtk_window_set_has_frame(GtkWindow *window , gboolean setting ) ;
#line 263
gboolean gtk_window_get_has_frame(GtkWindow *window ) ;
#line 264
void gtk_window_set_frame_dimensions(GtkWindow *window , gint left , gint top , gint right ,
                                     gint bottom ) ;
#line 269
void gtk_window_get_frame_dimensions(GtkWindow *window , gint *left , gint *top ,
                                     gint *right , gint *bottom ) ;
#line 275
void gtk_window_set_decorated(GtkWindow *window , gboolean setting ) ;
#line 277
gboolean gtk_window_get_decorated(GtkWindow *window ) ;
#line 278
void gtk_window_set_deletable(GtkWindow *window , gboolean setting ) ;
#line 280
gboolean gtk_window_get_deletable(GtkWindow *window ) ;
#line 282
void gtk_window_set_icon_list(GtkWindow *window , GList *list ) ;
#line 284
GList *gtk_window_get_icon_list(GtkWindow *window ) ;
#line 285
void gtk_window_set_icon(GtkWindow *window , GdkPixbuf *icon ) ;
#line 287
void gtk_window_set_icon_name(GtkWindow *window , gchar *name ) ;
#line 289
gboolean gtk_window_set_icon_from_file(GtkWindow *window , gchar *filename , GError **err ) ;
#line 292
GdkPixbuf *gtk_window_get_icon(GtkWindow *window ) ;
#line 294
gchar *gtk_window_get_icon_name(GtkWindow *window ) ;
#line 295
void gtk_window_set_default_icon_list(GList *list ) ;
#line 296
GList *gtk_window_get_default_icon_list(void) ;
#line 297
void gtk_window_set_default_icon(GdkPixbuf *icon ) ;
#line 298
void gtk_window_set_default_icon_name(gchar *name ) ;
#line 300
gchar *gtk_window_get_default_icon_name(void) ;
#line 301
gboolean gtk_window_set_default_icon_from_file(gchar *filename , GError **err ) ;
#line 304
void gtk_window_set_auto_startup_notification(gboolean setting ) ;
#line 307
void gtk_window_set_modal(GtkWindow *window , gboolean modal ) ;
#line 309
gboolean gtk_window_get_modal(GtkWindow *window ) ;
#line 310
GList *gtk_window_list_toplevels(void) ;
#line 312
void gtk_window_add_mnemonic(GtkWindow *window , guint keyval , GtkWidget *target ) ;
#line 315
void gtk_window_remove_mnemonic(GtkWindow *window , guint keyval , GtkWidget *target ) ;
#line 318
gboolean gtk_window_mnemonic_activate(GtkWindow *window , guint keyval , GdkModifierType modifier ) ;
#line 321
void gtk_window_set_mnemonic_modifier(GtkWindow *window , GdkModifierType modifier ) ;
#line 323
GdkModifierType gtk_window_get_mnemonic_modifier(GtkWindow *window ) ;
#line 325
gboolean gtk_window_activate_key(GtkWindow *window , GdkEventKey *event ) ;
#line 327
gboolean gtk_window_propagate_key_event(GtkWindow *window , GdkEventKey *event ) ;
#line 330
void gtk_window_present(GtkWindow *window ) ;
#line 331
void gtk_window_present_with_time(GtkWindow *window , guint32 timestamp ) ;
#line 333
void gtk_window_iconify(GtkWindow *window ) ;
#line 334
void gtk_window_deiconify(GtkWindow *window ) ;
#line 335
void gtk_window_stick(GtkWindow *window ) ;
#line 336
void gtk_window_unstick(GtkWindow *window ) ;
#line 337
void gtk_window_maximize(GtkWindow *window ) ;
#line 338
void gtk_window_unmaximize(GtkWindow *window ) ;
#line 339
void gtk_window_fullscreen(GtkWindow *window ) ;
#line 340
void gtk_window_unfullscreen(GtkWindow *window ) ;
#line 341
void gtk_window_set_keep_above(GtkWindow *window , gboolean setting ) ;
#line 342
void gtk_window_set_keep_below(GtkWindow *window , gboolean setting ) ;
#line 344
void gtk_window_begin_resize_drag(GtkWindow *window , GdkWindowEdge edge , gint button ,
                                  gint root_x , gint root_y , guint32 timestamp ) ;
#line 350
void gtk_window_begin_move_drag(GtkWindow *window , gint button , gint root_x , gint root_y ,
                                guint32 timestamp ) ;
#line 357
void gtk_window_set_policy(GtkWindow *window , gint allow_shrink , gint allow_grow ,
                           gint auto_shrink ) ;
#line 367
void gtk_window_set_default_size(GtkWindow *window , gint width , gint height ) ;
#line 370
void gtk_window_get_default_size(GtkWindow *window , gint *width , gint *height ) ;
#line 373
void gtk_window_resize(GtkWindow *window , gint width , gint height ) ;
#line 376
void gtk_window_get_size(GtkWindow *window , gint *width , gint *height ) ;
#line 379
void gtk_window_move(GtkWindow *window , gint x , gint y ) ;
#line 382
void gtk_window_get_position(GtkWindow *window , gint *root_x , gint *root_y ) ;
#line 385
gboolean gtk_window_parse_geometry(GtkWindow *window , gchar *geometry ) ;
#line 387
GtkWindowGroup *gtk_window_get_group(GtkWindow *window ) ;
#line 388
gboolean gtk_window_has_group(GtkWindow *window ) ;
#line 391
void gtk_window_reshow_with_initial_size(GtkWindow *window ) ;
#line 393
GtkWindowType gtk_window_get_window_type(GtkWindow *window ) ;
#line 397
GType gtk_window_group_get_type(void) ;
#line 399
GtkWindowGroup *gtk_window_group_new(void) ;
#line 400
void gtk_window_group_add_window(GtkWindowGroup *window_group , GtkWindow *window ) ;
#line 402
void gtk_window_group_remove_window(GtkWindowGroup *window_group , GtkWindow *window ) ;
#line 404
GList *gtk_window_group_list_windows(GtkWindowGroup *window_group ) ;
#line 408
void _gtk_window_internal_set_focus(GtkWindow *window , GtkWidget *focus ) ;
#line 410
void gtk_window_remove_embedded_xid(GtkWindow *window , GdkNativeWindow xid ) ;
#line 412
void gtk_window_add_embedded_xid(GtkWindow *window , GdkNativeWindow xid ) ;
#line 414
void _gtk_window_reposition(GtkWindow *window , gint x , gint y ) ;
#line 417
void _gtk_window_constrain_size(GtkWindow *window , gint width , gint height , gint *new_width ,
                                gint *new_height ) ;
#line 422
GtkWidget *gtk_window_group_get_current_grab(GtkWindowGroup *window_group ) ;
#line 424
void _gtk_window_set_has_toplevel_focus(GtkWindow *window , gboolean has_toplevel_focus ) ;
#line 426
void _gtk_window_unset_focus_and_default(GtkWindow *window , GtkWidget *widget ) ;
#line 429
void _gtk_window_set_is_active(GtkWindow *window , gboolean is_active ) ;
#line 432
void _gtk_window_set_is_toplevel(GtkWindow *window , gboolean is_toplevel ) ;
#line 441
void _gtk_window_keys_foreach(GtkWindow *window , GtkWindowKeysForeachFunc func ,
                              gpointer func_data ) ;
#line 446
gboolean _gtk_window_query_nonaccels(GtkWindow *window , guint accel_key , GdkModifierType accel_mods ) ;
#line 127 "/usr/include/gtk-2.0/gtk/gtkdialog.h"
GType gtk_dialog_get_type(void) ;
#line 128
GtkWidget *gtk_dialog_new(void) ;
#line 130
GtkWidget *gtk_dialog_new_with_buttons(gchar *title , GtkWindow *parent , GtkDialogFlags flags ,
                                       gchar *first_button_text  , ...) ;
#line 136
void gtk_dialog_add_action_widget(GtkDialog *dialog , GtkWidget *child , gint response_id ) ;
#line 139
GtkWidget *gtk_dialog_add_button(GtkDialog *dialog , gchar *button_text , gint response_id ) ;
#line 142
void gtk_dialog_add_buttons(GtkDialog *dialog , gchar *first_button_text  , ...) ;
#line 146
void gtk_dialog_set_response_sensitive(GtkDialog *dialog , gint response_id , gboolean setting ) ;
#line 149
void gtk_dialog_set_default_response(GtkDialog *dialog , gint response_id ) ;
#line 151
GtkWidget *gtk_dialog_get_widget_for_response(GtkDialog *dialog , gint response_id ) ;
#line 153
gint gtk_dialog_get_response_for_widget(GtkDialog *dialog , GtkWidget *widget ) ;
#line 157
void gtk_dialog_set_has_separator(GtkDialog *dialog , gboolean setting ) ;
#line 159
gboolean gtk_dialog_get_has_separator(GtkDialog *dialog ) ;
#line 162
gboolean gtk_alternative_dialog_button_order(GdkScreen *screen ) ;
#line 163
void gtk_dialog_set_alternative_button_order(GtkDialog *dialog , gint first_response_id 
                                             , ...) ;
#line 166
void gtk_dialog_set_alternative_button_order_from_array(GtkDialog *dialog , gint n_params ,
                                                        gint *new_order ) ;
#line 171
void gtk_dialog_response(GtkDialog *dialog , gint response_id ) ;
#line 175
gint gtk_dialog_run(GtkDialog *dialog ) ;
#line 177
GtkWidget *gtk_dialog_get_action_area(GtkDialog *dialog ) ;
#line 178
GtkWidget *gtk_dialog_get_content_area(GtkDialog *dialog ) ;
#line 181
void _gtk_dialog_set_ignore_separator(GtkDialog *dialog , gboolean ignore_separator ) ;
#line 73 "/usr/include/gtk-2.0/gtk/gtkaboutdialog.h"
GType gtk_about_dialog_get_type(void) ;
#line 74
GtkWidget *gtk_about_dialog_new(void) ;
#line 75
void gtk_show_about_dialog(GtkWindow *parent , gchar *first_property_name  , ...) ;
#line 80
gchar *gtk_about_dialog_get_name(GtkAboutDialog *about ) ;
#line 81
void gtk_about_dialog_set_name(GtkAboutDialog *about , gchar *name ) ;
#line 84
gchar *gtk_about_dialog_get_program_name(GtkAboutDialog *about ) ;
#line 85
void gtk_about_dialog_set_program_name(GtkAboutDialog *about , gchar *name ) ;
#line 87
gchar *gtk_about_dialog_get_version(GtkAboutDialog *about ) ;
#line 88
void gtk_about_dialog_set_version(GtkAboutDialog *about , gchar *version ) ;
#line 90
gchar *gtk_about_dialog_get_copyright(GtkAboutDialog *about ) ;
#line 91
void gtk_about_dialog_set_copyright(GtkAboutDialog *about , gchar *copyright ) ;
#line 93
gchar *gtk_about_dialog_get_comments(GtkAboutDialog *about ) ;
#line 94
void gtk_about_dialog_set_comments(GtkAboutDialog *about , gchar *comments ) ;
#line 96
gchar *gtk_about_dialog_get_license(GtkAboutDialog *about ) ;
#line 97
void gtk_about_dialog_set_license(GtkAboutDialog *about , gchar *license ) ;
#line 100
gboolean gtk_about_dialog_get_wrap_license(GtkAboutDialog *about ) ;
#line 101
void gtk_about_dialog_set_wrap_license(GtkAboutDialog *about , gboolean wrap_license ) ;
#line 104
gchar *gtk_about_dialog_get_website(GtkAboutDialog *about ) ;
#line 105
void gtk_about_dialog_set_website(GtkAboutDialog *about , gchar *website ) ;
#line 107
gchar *gtk_about_dialog_get_website_label(GtkAboutDialog *about ) ;
#line 108
void gtk_about_dialog_set_website_label(GtkAboutDialog *about , gchar *website_label ) ;
#line 110
gchar * const  *gtk_about_dialog_get_authors(GtkAboutDialog *about ) ;
#line 111
void gtk_about_dialog_set_authors(GtkAboutDialog *about , gchar **authors ) ;
#line 113
gchar * const  *gtk_about_dialog_get_documenters(GtkAboutDialog *about ) ;
#line 114
void gtk_about_dialog_set_documenters(GtkAboutDialog *about , gchar **documenters ) ;
#line 116
gchar * const  *gtk_about_dialog_get_artists(GtkAboutDialog *about ) ;
#line 117
void gtk_about_dialog_set_artists(GtkAboutDialog *about , gchar **artists ) ;
#line 119
gchar *gtk_about_dialog_get_translator_credits(GtkAboutDialog *about ) ;
#line 120
void gtk_about_dialog_set_translator_credits(GtkAboutDialog *about , gchar *translator_credits ) ;
#line 122
GdkPixbuf *gtk_about_dialog_get_logo(GtkAboutDialog *about ) ;
#line 123
void gtk_about_dialog_set_logo(GtkAboutDialog *about , GdkPixbuf *logo ) ;
#line 125
gchar *gtk_about_dialog_get_logo_icon_name(GtkAboutDialog *about ) ;
#line 126
void gtk_about_dialog_set_logo_icon_name(GtkAboutDialog *about , gchar *icon_name ) ;
#line 145
GtkAboutDialogActivateLinkFunc gtk_about_dialog_set_email_hook(GtkAboutDialogActivateLinkFunc func ,
                                                               gpointer data , GDestroyNotify destroy ) ;
#line 148
GtkAboutDialogActivateLinkFunc gtk_about_dialog_set_url_hook(GtkAboutDialogActivateLinkFunc func ,
                                                             gpointer data , GDestroyNotify destroy ) ;
#line 68 "/usr/include/gtk-2.0/gtk/gtkmisc.h"
GType gtk_misc_get_type(void) ;
#line 69
void gtk_misc_set_alignment(GtkMisc *misc , gfloat xalign , gfloat yalign ) ;
#line 72
void gtk_misc_get_alignment(GtkMisc *misc , gfloat *xalign , gfloat *yalign ) ;
#line 75
void gtk_misc_set_padding(GtkMisc *misc , gint xpad , gint ypad ) ;
#line 78
void gtk_misc_get_padding(GtkMisc *misc , gint *xpad , gint *ypad ) ;
#line 100 "/usr/include/gtk-2.0/gtk/gtkmenushell.h"
GType gtk_menu_shell_get_type(void) ;
#line 101
void gtk_menu_shell_append(GtkMenuShell *menu_shell , GtkWidget *child ) ;
#line 103
void gtk_menu_shell_prepend(GtkMenuShell *menu_shell , GtkWidget *child ) ;
#line 105
void gtk_menu_shell_insert(GtkMenuShell *menu_shell , GtkWidget *child , gint position ) ;
#line 108
void gtk_menu_shell_deactivate(GtkMenuShell *menu_shell ) ;
#line 109
void gtk_menu_shell_select_item(GtkMenuShell *menu_shell , GtkWidget *menu_item ) ;
#line 111
void gtk_menu_shell_deselect(GtkMenuShell *menu_shell ) ;
#line 112
void gtk_menu_shell_activate_item(GtkMenuShell *menu_shell , GtkWidget *menu_item ,
                                  gboolean force_deactivate ) ;
#line 115
void gtk_menu_shell_select_first(GtkMenuShell *menu_shell , gboolean search_sensitive ) ;
#line 117
void _gtk_menu_shell_select_last(GtkMenuShell *menu_shell , gboolean search_sensitive ) ;
#line 119
gint _gtk_menu_shell_get_popup_delay(GtkMenuShell *menu_shell ) ;
#line 120
void gtk_menu_shell_cancel(GtkMenuShell *menu_shell ) ;
#line 122
void _gtk_menu_shell_add_mnemonic(GtkMenuShell *menu_shell , guint keyval , GtkWidget *target ) ;
#line 125
void _gtk_menu_shell_remove_mnemonic(GtkMenuShell *menu_shell , guint keyval , GtkWidget *target ) ;
#line 129
gboolean gtk_menu_shell_get_take_focus(GtkMenuShell *menu_shell ) ;
#line 130
void gtk_menu_shell_set_take_focus(GtkMenuShell *menu_shell , gboolean take_focus ) ;
#line 133
void _gtk_menu_shell_update_mnemonics(GtkMenuShell *menu_shell ) ;
#line 134
void _gtk_menu_shell_set_keyboard_mode(GtkMenuShell *menu_shell , gboolean keyboard_mode ) ;
#line 136
gboolean _gtk_menu_shell_get_keyboard_mode(GtkMenuShell *menu_shell ) ;
#line 125 "/usr/include/gtk-2.0/gtk/gtkmenu.h"
GType gtk_menu_get_type(void) ;
#line 126
GtkWidget *gtk_menu_new(void) ;
#line 129
void gtk_menu_popup(GtkMenu *menu , GtkWidget *parent_menu_shell , GtkWidget *parent_menu_item ,
                    GtkMenuPositionFunc func , gpointer data , guint button , guint32 activate_time ) ;
#line 140
void gtk_menu_reposition(GtkMenu *menu ) ;
#line 142
void gtk_menu_popdown(GtkMenu *menu ) ;
#line 147
GtkWidget *gtk_menu_get_active(GtkMenu *menu ) ;
#line 148
void gtk_menu_set_active(GtkMenu *menu , guint index_ ) ;
#line 154
void gtk_menu_set_accel_group(GtkMenu *menu , GtkAccelGroup *accel_group ) ;
#line 156
GtkAccelGroup *gtk_menu_get_accel_group(GtkMenu *menu ) ;
#line 157
void gtk_menu_set_accel_path(GtkMenu *menu , gchar *accel_path ) ;
#line 159
gchar *gtk_menu_get_accel_path(GtkMenu *menu ) ;
#line 165
void gtk_menu_attach_to_widget(GtkMenu *menu , GtkWidget *attach_widget , GtkMenuDetachFunc detacher ) ;
#line 168
void gtk_menu_detach(GtkMenu *menu ) ;
#line 174
GtkWidget *gtk_menu_get_attach_widget(GtkMenu *menu ) ;
#line 176
void gtk_menu_set_tearoff_state(GtkMenu *menu , gboolean torn_off ) ;
#line 178
gboolean gtk_menu_get_tearoff_state(GtkMenu *menu ) ;
#line 183
void gtk_menu_set_title(GtkMenu *menu , gchar *title ) ;
#line 185
gchar *gtk_menu_get_title(GtkMenu *menu ) ;
#line 187
void gtk_menu_reorder_child(GtkMenu *menu , GtkWidget *child , gint position ) ;
#line 191
void gtk_menu_set_screen(GtkMenu *menu , GdkScreen *screen ) ;
#line 194
void gtk_menu_attach(GtkMenu *menu , GtkWidget *child , guint left_attach , guint right_attach ,
                     guint top_attach , guint bottom_attach ) ;
#line 201
void gtk_menu_set_monitor(GtkMenu *menu , gint monitor_num ) ;
#line 203
gint gtk_menu_get_monitor(GtkMenu *menu ) ;
#line 204
GList *gtk_menu_get_for_attach_widget(GtkWidget *widget ) ;
#line 212
void gtk_menu_set_reserve_toggle_size(GtkMenu *menu , gboolean reserve_toggle_size ) ;
#line 214
gboolean gtk_menu_get_reserve_toggle_size(GtkMenu *menu ) ;
#line 109 "/usr/include/gtk-2.0/gtk/gtklabel.h"
GType gtk_label_get_type(void) ;
#line 110
GtkWidget *gtk_label_new(gchar *str ) ;
#line 111
GtkWidget *gtk_label_new_with_mnemonic(gchar *str ) ;
#line 112
void gtk_label_set_text(GtkLabel *label , gchar *str ) ;
#line 114
gchar *gtk_label_get_text(GtkLabel *label ) ;
#line 115
void gtk_label_set_attributes(GtkLabel *label , PangoAttrList *attrs ) ;
#line 117
PangoAttrList *gtk_label_get_attributes(GtkLabel *label ) ;
#line 118
void gtk_label_set_label(GtkLabel *label , gchar *str ) ;
#line 120
gchar *gtk_label_get_label(GtkLabel *label ) ;
#line 121
void gtk_label_set_markup(GtkLabel *label , gchar *str ) ;
#line 123
void gtk_label_set_use_markup(GtkLabel *label , gboolean setting ) ;
#line 125
gboolean gtk_label_get_use_markup(GtkLabel *label ) ;
#line 126
void gtk_label_set_use_underline(GtkLabel *label , gboolean setting ) ;
#line 128
gboolean gtk_label_get_use_underline(GtkLabel *label ) ;
#line 130
void gtk_label_set_markup_with_mnemonic(GtkLabel *label , gchar *str ) ;
#line 132
guint gtk_label_get_mnemonic_keyval(GtkLabel *label ) ;
#line 133
void gtk_label_set_mnemonic_widget(GtkLabel *label , GtkWidget *widget ) ;
#line 135
GtkWidget *gtk_label_get_mnemonic_widget(GtkLabel *label ) ;
#line 136
void gtk_label_set_text_with_mnemonic(GtkLabel *label , gchar *str ) ;
#line 138
void gtk_label_set_justify(GtkLabel *label , GtkJustification jtype ) ;
#line 140
GtkJustification gtk_label_get_justify(GtkLabel *label ) ;
#line 141
void gtk_label_set_ellipsize(GtkLabel *label , PangoEllipsizeMode mode ) ;
#line 143
PangoEllipsizeMode gtk_label_get_ellipsize(GtkLabel *label ) ;
#line 144
void gtk_label_set_width_chars(GtkLabel *label , gint n_chars ) ;
#line 146
gint gtk_label_get_width_chars(GtkLabel *label ) ;
#line 147
void gtk_label_set_max_width_chars(GtkLabel *label , gint n_chars ) ;
#line 149
gint gtk_label_get_max_width_chars(GtkLabel *label ) ;
#line 150
void gtk_label_set_pattern(GtkLabel *label , gchar *pattern ) ;
#line 152
void gtk_label_set_line_wrap(GtkLabel *label , gboolean wrap ) ;
#line 154
gboolean gtk_label_get_line_wrap(GtkLabel *label ) ;
#line 155
void gtk_label_set_line_wrap_mode(GtkLabel *label , PangoWrapMode wrap_mode ) ;
#line 157
PangoWrapMode gtk_label_get_line_wrap_mode(GtkLabel *label ) ;
#line 158
void gtk_label_set_selectable(GtkLabel *label , gboolean setting ) ;
#line 160
gboolean gtk_label_get_selectable(GtkLabel *label ) ;
#line 161
void gtk_label_set_angle(GtkLabel *label , gdouble angle ) ;
#line 163
gdouble gtk_label_get_angle(GtkLabel *label ) ;
#line 164
void gtk_label_select_region(GtkLabel *label , gint start_offset , gint end_offset ) ;
#line 167
gboolean gtk_label_get_selection_bounds(GtkLabel *label , gint *start , gint *end ) ;
#line 171
PangoLayout *gtk_label_get_layout(GtkLabel *label ) ;
#line 172
void gtk_label_get_layout_offsets(GtkLabel *label , gint *x , gint *y ) ;
#line 176
void gtk_label_set_single_line_mode(GtkLabel *label , gboolean single_line_mode ) ;
#line 178
gboolean gtk_label_get_single_line_mode(GtkLabel *label ) ;
#line 180
gchar *gtk_label_get_current_uri(GtkLabel *label ) ;
#line 181
void gtk_label_set_track_visited_links(GtkLabel *label , gboolean track_links ) ;
#line 183
gboolean gtk_label_get_track_visited_links(GtkLabel *label ) ;
#line 188
void gtk_label_get(GtkLabel *label , gchar **str ) ;
#line 195
guint gtk_label_parse_uline(GtkLabel *label , gchar *string ) ;
#line 202
void _gtk_label_mnemonics_visible_apply_recursively(GtkWidget *widget , gboolean mnemonics_visible ) ;
#line 97 "/usr/include/gtk-2.0/gtk/gtkaccellabel.h"
GType gtk_accel_label_get_type(void) ;
#line 98
GtkWidget *gtk_accel_label_new(gchar *string ) ;
#line 99
GtkWidget *gtk_accel_label_get_accel_widget(GtkAccelLabel *accel_label ) ;
#line 100
guint gtk_accel_label_get_accel_width(GtkAccelLabel *accel_label ) ;
#line 101
void gtk_accel_label_set_accel_widget(GtkAccelLabel *accel_label , GtkWidget *accel_widget ) ;
#line 103
void gtk_accel_label_set_accel_closure(GtkAccelLabel *accel_label , GClosure *accel_closure ) ;
#line 105
gboolean gtk_accel_label_refetch(GtkAccelLabel *accel_label ) ;
#line 108
gchar *_gtk_accel_label_class_get_accelerator_label(GtkAccelLabelClass *klass , guint accelerator_key ,
                                                    GdkModifierType accelerator_mods ) ;
#line 59 "/usr/include/gtk-2.0/gtk/gtkaccelmap.h"
void gtk_accel_map_add_entry(gchar *accel_path , guint accel_key , GdkModifierType accel_mods ) ;
#line 62
gboolean gtk_accel_map_lookup_entry(gchar *accel_path , GtkAccelKey *key ) ;
#line 64
gboolean gtk_accel_map_change_entry(gchar *accel_path , guint accel_key , GdkModifierType accel_mods ,
                                    gboolean replace ) ;
#line 68
void gtk_accel_map_load(gchar *file_name ) ;
#line 69
void gtk_accel_map_save(gchar *file_name ) ;
#line 70
void gtk_accel_map_foreach(gpointer data , GtkAccelMapForeach foreach_func ) ;
#line 72
void gtk_accel_map_load_fd(gint fd ) ;
#line 73
void gtk_accel_map_load_scanner(GScanner *scanner ) ;
#line 74
void gtk_accel_map_save_fd(gint fd ) ;
#line 76
void gtk_accel_map_lock_path(gchar *accel_path ) ;
#line 77
void gtk_accel_map_unlock_path(gchar *accel_path ) ;
#line 80
void gtk_accel_map_add_filter(gchar *filter_pattern ) ;
#line 81
void gtk_accel_map_foreach_unfiltered(gpointer data , GtkAccelMapForeach foreach_func ) ;
#line 85
GType gtk_accel_map_get_type(void) ;
#line 86
GtkAccelMap *gtk_accel_map_get(void) ;
#line 90
void _gtk_accel_map_init(void) ;
#line 92
void _gtk_accel_map_add_group(gchar *accel_path , GtkAccelGroup *accel_group ) ;
#line 94
void _gtk_accel_map_remove_group(gchar *accel_path , GtkAccelGroup *accel_group ) ;
#line 96
gboolean _gtk_accel_path_is_valid(gchar *accel_path ) ;
#line 69 "/usr/include/gtk-2.0/gtk/gtkaccessible.h"
GType gtk_accessible_get_type(void) ;
#line 71
void gtk_accessible_set_widget(GtkAccessible *accessible , GtkWidget *widget ) ;
#line 73
GtkWidget *gtk_accessible_get_widget(GtkAccessible *accessible ) ;
#line 74
void gtk_accessible_connect_widget_destroyed(GtkAccessible *accessible ) ;
#line 88 "/usr/include/gtk-2.0/gtk/gtkaction.h"
GType gtk_action_get_type(void) ;
#line 89
GtkAction *gtk_action_new(gchar *name , gchar *label , gchar *tooltip , gchar *stock_id ) ;
#line 93
gchar *gtk_action_get_name(GtkAction *action ) ;
#line 94
gboolean gtk_action_is_sensitive(GtkAction *action ) ;
#line 95
gboolean gtk_action_get_sensitive(GtkAction *action ) ;
#line 96
void gtk_action_set_sensitive(GtkAction *action , gboolean sensitive ) ;
#line 98
gboolean gtk_action_is_visible(GtkAction *action ) ;
#line 99
gboolean gtk_action_get_visible(GtkAction *action ) ;
#line 100
void gtk_action_set_visible(GtkAction *action , gboolean visible ) ;
#line 102
void gtk_action_activate(GtkAction *action ) ;
#line 103
GtkWidget *gtk_action_create_icon(GtkAction *action , GtkIconSize icon_size ) ;
#line 105
GtkWidget *gtk_action_create_menu_item(GtkAction *action ) ;
#line 106
GtkWidget *gtk_action_create_tool_item(GtkAction *action ) ;
#line 107
GtkWidget *gtk_action_create_menu(GtkAction *action ) ;
#line 108
GSList *gtk_action_get_proxies(GtkAction *action ) ;
#line 109
void gtk_action_connect_accelerator(GtkAction *action ) ;
#line 110
void gtk_action_disconnect_accelerator(GtkAction *action ) ;
#line 111
gchar *gtk_action_get_accel_path(GtkAction *action ) ;
#line 112
GClosure *gtk_action_get_accel_closure(GtkAction *action ) ;
#line 115
GtkAction *gtk_widget_get_action(GtkWidget *widget ) ;
#line 116
void gtk_action_connect_proxy(GtkAction *action , GtkWidget *proxy ) ;
#line 118
void gtk_action_disconnect_proxy(GtkAction *action , GtkWidget *proxy ) ;
#line 120
void gtk_action_block_activate_from(GtkAction *action , GtkWidget *proxy ) ;
#line 122
void gtk_action_unblock_activate_from(GtkAction *action , GtkWidget *proxy ) ;
#line 125
void gtk_action_block_activate(GtkAction *action ) ;
#line 126
void gtk_action_unblock_activate(GtkAction *action ) ;
#line 129
void _gtk_action_add_to_proxy_list(GtkAction *action , GtkWidget *proxy ) ;
#line 131
void _gtk_action_remove_from_proxy_list(GtkAction *action , GtkWidget *proxy ) ;
#line 135
void _gtk_action_emit_activate(GtkAction *action ) ;
#line 138
void gtk_action_set_accel_path(GtkAction *action , gchar *accel_path ) ;
#line 140
void gtk_action_set_accel_group(GtkAction *action , GtkAccelGroup *accel_group ) ;
#line 142
void _gtk_action_sync_menu_visible(GtkAction *action , GtkWidget *proxy , gboolean empty ) ;
#line 146
void gtk_action_set_label(GtkAction *action , gchar *label ) ;
#line 148
gchar *gtk_action_get_label(GtkAction *action ) ;
#line 149
void gtk_action_set_short_label(GtkAction *action , gchar *short_label ) ;
#line 151
gchar *gtk_action_get_short_label(GtkAction *action ) ;
#line 152
void gtk_action_set_tooltip(GtkAction *action , gchar *tooltip ) ;
#line 154
gchar *gtk_action_get_tooltip(GtkAction *action ) ;
#line 155
void gtk_action_set_stock_id(GtkAction *action , gchar *stock_id ) ;
#line 157
gchar *gtk_action_get_stock_id(GtkAction *action ) ;
#line 158
void gtk_action_set_gicon(GtkAction *action , GIcon *icon ) ;
#line 160
GIcon *gtk_action_get_gicon(GtkAction *action ) ;
#line 161
void gtk_action_set_icon_name(GtkAction *action , gchar *icon_name ) ;
#line 163
gchar *gtk_action_get_icon_name(GtkAction *action ) ;
#line 164
void gtk_action_set_visible_horizontal(GtkAction *action , gboolean visible_horizontal ) ;
#line 166
gboolean gtk_action_get_visible_horizontal(GtkAction *action ) ;
#line 167
void gtk_action_set_visible_vertical(GtkAction *action , gboolean visible_vertical ) ;
#line 169
gboolean gtk_action_get_visible_vertical(GtkAction *action ) ;
#line 170
void gtk_action_set_is_important(GtkAction *action , gboolean is_important ) ;
#line 172
gboolean gtk_action_get_is_important(GtkAction *action ) ;
#line 173
void gtk_action_set_always_show_image(GtkAction *action , gboolean always_show ) ;
#line 175
gboolean gtk_action_get_always_show_image(GtkAction *action ) ;
#line 111 "/usr/include/gtk-2.0/gtk/gtkactiongroup.h"
GType gtk_action_group_get_type(void) ;
#line 112
GtkActionGroup *gtk_action_group_new(gchar *name ) ;
#line 113
gchar *gtk_action_group_get_name(GtkActionGroup *action_group ) ;
#line 114
gboolean gtk_action_group_get_sensitive(GtkActionGroup *action_group ) ;
#line 115
void gtk_action_group_set_sensitive(GtkActionGroup *action_group , gboolean sensitive ) ;
#line 117
gboolean gtk_action_group_get_visible(GtkActionGroup *action_group ) ;
#line 118
void gtk_action_group_set_visible(GtkActionGroup *action_group , gboolean visible ) ;
#line 120
GtkAction *gtk_action_group_get_action(GtkActionGroup *action_group , gchar *action_name ) ;
#line 122
GList *gtk_action_group_list_actions(GtkActionGroup *action_group ) ;
#line 123
void gtk_action_group_add_action(GtkActionGroup *action_group , GtkAction *action ) ;
#line 125
void gtk_action_group_add_action_with_accel(GtkActionGroup *action_group , GtkAction *action ,
                                            gchar *accelerator ) ;
#line 128
void gtk_action_group_remove_action(GtkActionGroup *action_group , GtkAction *action ) ;
#line 130
void gtk_action_group_add_actions(GtkActionGroup *action_group , GtkActionEntry *entries ,
                                  guint n_entries , gpointer user_data ) ;
#line 134
void gtk_action_group_add_toggle_actions(GtkActionGroup *action_group , GtkToggleActionEntry *entries ,
                                         guint n_entries , gpointer user_data ) ;
#line 138
void gtk_action_group_add_radio_actions(GtkActionGroup *action_group , GtkRadioActionEntry *entries ,
                                        guint n_entries , gint value , GCallback on_change ,
                                        gpointer user_data ) ;
#line 144
void gtk_action_group_add_actions_full(GtkActionGroup *action_group , GtkActionEntry *entries ,
                                       guint n_entries , gpointer user_data , GDestroyNotify destroy ) ;
#line 149
void gtk_action_group_add_toggle_actions_full(GtkActionGroup *action_group , GtkToggleActionEntry *entries ,
                                              guint n_entries , gpointer user_data ,
                                              GDestroyNotify destroy ) ;
#line 154
void gtk_action_group_add_radio_actions_full(GtkActionGroup *action_group , GtkRadioActionEntry *entries ,
                                             guint n_entries , gint value , GCallback on_change ,
                                             gpointer user_data , GDestroyNotify destroy ) ;
#line 161
void gtk_action_group_set_translate_func(GtkActionGroup *action_group , GtkTranslateFunc func ,
                                         gpointer data , GDestroyNotify notify ) ;
#line 165
void gtk_action_group_set_translation_domain(GtkActionGroup *action_group , gchar *domain ) ;
#line 167
gchar *gtk_action_group_translate_string(GtkActionGroup *action_group , gchar *string ) ;
#line 171
void _gtk_action_group_emit_connect_proxy(GtkActionGroup *action_group , GtkAction *action ,
                                          GtkWidget *proxy ) ;
#line 174
void _gtk_action_group_emit_disconnect_proxy(GtkActionGroup *action_group , GtkAction *action ,
                                             GtkWidget *proxy ) ;
#line 177
void _gtk_action_group_emit_pre_activate(GtkActionGroup *action_group , GtkAction *action ) ;
#line 179
void _gtk_action_group_emit_post_activate(GtkActionGroup *action_group , GtkAction *action ) ;
#line 69 "/usr/include/gtk-2.0/gtk/gtkactivatable.h"
GType gtk_activatable_get_type(void) ;
#line 71
void gtk_activatable_sync_action_properties(GtkActivatable *activatable , GtkAction *action ) ;
#line 74
void gtk_activatable_set_related_action(GtkActivatable *activatable , GtkAction *action ) ;
#line 76
GtkAction *gtk_activatable_get_related_action(GtkActivatable *activatable ) ;
#line 78
void gtk_activatable_set_use_action_appearance(GtkActivatable *activatable , gboolean use_appearance ) ;
#line 80
gboolean gtk_activatable_get_use_action_appearance(GtkActivatable *activatable ) ;
#line 83
void gtk_activatable_do_set_related_action(GtkActivatable *activatable , GtkAction *action ) ;
#line 68 "/usr/include/gtk-2.0/gtk/gtkalignment.h"
GType gtk_alignment_get_type(void) ;
#line 69
GtkWidget *gtk_alignment_new(gfloat xalign , gfloat yalign , gfloat xscale , gfloat yscale ) ;
#line 73
void gtk_alignment_set(GtkAlignment *alignment , gfloat xalign , gfloat yalign , gfloat xscale ,
                       gfloat yscale ) ;
#line 79
void gtk_alignment_set_padding(GtkAlignment *alignment , guint padding_top , guint padding_bottom ,
                               guint padding_left , guint padding_right ) ;
#line 85
void gtk_alignment_get_padding(GtkAlignment *alignment , guint *padding_top , guint *padding_bottom ,
                               guint *padding_left , guint *padding_right ) ;
#line 66 "/usr/include/gtk-2.0/gtk/gtkarrow.h"
GType gtk_arrow_get_type(void) ;
#line 67
GtkWidget *gtk_arrow_new(GtkArrowType arrow_type , GtkShadowType shadow_type ) ;
#line 69
void gtk_arrow_set(GtkArrow *arrow , GtkArrowType arrow_type , GtkShadowType shadow_type ) ;
#line 72 "/usr/include/gtk-2.0/gtk/gtkframe.h"
GType gtk_frame_get_type(void) ;
#line 73
GtkWidget *gtk_frame_new(gchar *label ) ;
#line 75
void gtk_frame_set_label(GtkFrame *frame , gchar *label ) ;
#line 77
gchar *gtk_frame_get_label(GtkFrame *frame ) ;
#line 79
void gtk_frame_set_label_widget(GtkFrame *frame , GtkWidget *label_widget ) ;
#line 81
GtkWidget *gtk_frame_get_label_widget(GtkFrame *frame ) ;
#line 82
void gtk_frame_set_label_align(GtkFrame *frame , gfloat xalign , gfloat yalign ) ;
#line 85
void gtk_frame_get_label_align(GtkFrame *frame , gfloat *xalign , gfloat *yalign ) ;
#line 88
void gtk_frame_set_shadow_type(GtkFrame *frame , GtkShadowType type ) ;
#line 90
GtkShadowType gtk_frame_get_shadow_type(GtkFrame *frame ) ;
#line 69 "/usr/include/gtk-2.0/gtk/gtkaspectframe.h"
GType gtk_aspect_frame_get_type(void) ;
#line 70
GtkWidget *gtk_aspect_frame_new(gchar *label , gfloat xalign , gfloat yalign , gfloat ratio ,
                                gboolean obey_child ) ;
#line 75
void gtk_aspect_frame_set(GtkAspectFrame *aspect_frame , gfloat xalign , gfloat yalign ,
                          gfloat ratio , gboolean obey_child ) ;
#line 122 "/usr/include/gtk-2.0/gtk/gtkassistant.h"
GType gtk_assistant_get_type(void) ;
#line 123
GtkWidget *gtk_assistant_new(void) ;
#line 124
gint gtk_assistant_get_current_page(GtkAssistant *assistant ) ;
#line 125
void gtk_assistant_set_current_page(GtkAssistant *assistant , gint page_num ) ;
#line 127
gint gtk_assistant_get_n_pages(GtkAssistant *assistant ) ;
#line 128
GtkWidget *gtk_assistant_get_nth_page(GtkAssistant *assistant , gint page_num ) ;
#line 130
gint gtk_assistant_prepend_page(GtkAssistant *assistant , GtkWidget *page ) ;
#line 132
gint gtk_assistant_append_page(GtkAssistant *assistant , GtkWidget *page ) ;
#line 134
gint gtk_assistant_insert_page(GtkAssistant *assistant , GtkWidget *page , gint position ) ;
#line 137
void gtk_assistant_set_forward_page_func(GtkAssistant *assistant , GtkAssistantPageFunc page_func ,
                                         gpointer data , GDestroyNotify destroy ) ;
#line 141
void gtk_assistant_set_page_type(GtkAssistant *assistant , GtkWidget *page , GtkAssistantPageType type ) ;
#line 144
GtkAssistantPageType gtk_assistant_get_page_type(GtkAssistant *assistant , GtkWidget *page ) ;
#line 146
void gtk_assistant_set_page_title(GtkAssistant *assistant , GtkWidget *page , gchar *title ) ;
#line 149
gchar *gtk_assistant_get_page_title(GtkAssistant *assistant , GtkWidget *page ) ;
#line 151
void gtk_assistant_set_page_header_image(GtkAssistant *assistant , GtkWidget *page ,
                                         GdkPixbuf *pixbuf ) ;
#line 154
GdkPixbuf *gtk_assistant_get_page_header_image(GtkAssistant *assistant , GtkWidget *page ) ;
#line 156
void gtk_assistant_set_page_side_image(GtkAssistant *assistant , GtkWidget *page ,
                                       GdkPixbuf *pixbuf ) ;
#line 159
GdkPixbuf *gtk_assistant_get_page_side_image(GtkAssistant *assistant , GtkWidget *page ) ;
#line 161
void gtk_assistant_set_page_complete(GtkAssistant *assistant , GtkWidget *page , gboolean complete ) ;
#line 164
gboolean gtk_assistant_get_page_complete(GtkAssistant *assistant , GtkWidget *page ) ;
#line 166
void gtk_assistant_add_action_widget(GtkAssistant *assistant , GtkWidget *child ) ;
#line 168
void gtk_assistant_remove_action_widget(GtkAssistant *assistant , GtkWidget *child ) ;
#line 171
void gtk_assistant_update_buttons_state(GtkAssistant *assistant ) ;
#line 172
void gtk_assistant_commit(GtkAssistant *assistant ) ;
#line 104 "/usr/include/gtk-2.0/gtk/gtkbox.h"
GType gtk_box_get_type(void) ;
#line 105
GtkWidget *_gtk_box_new(GtkOrientation orientation , gboolean homogeneous , gint spacing ) ;
#line 109
void gtk_box_pack_start(GtkBox *box , GtkWidget *child , gboolean expand , gboolean fill ,
                        guint padding ) ;
#line 114
void gtk_box_pack_end(GtkBox *box , GtkWidget *child , gboolean expand , gboolean fill ,
                      guint padding ) ;
#line 121
void gtk_box_pack_start_defaults(GtkBox *box , GtkWidget *widget ) ;
#line 123
void gtk_box_pack_end_defaults(GtkBox *box , GtkWidget *widget ) ;
#line 127
void gtk_box_set_homogeneous(GtkBox *box , gboolean homogeneous ) ;
#line 129
gboolean gtk_box_get_homogeneous(GtkBox *box ) ;
#line 130
void gtk_box_set_spacing(GtkBox *box , gint spacing ) ;
#line 132
gint gtk_box_get_spacing(GtkBox *box ) ;
#line 134
void gtk_box_reorder_child(GtkBox *box , GtkWidget *child , gint position ) ;
#line 138
void gtk_box_query_child_packing(GtkBox *box , GtkWidget *child , gboolean *expand ,
                                 gboolean *fill , guint *padding , GtkPackType *pack_type ) ;
#line 144
void gtk_box_set_child_packing(GtkBox *box , GtkWidget *child , gboolean expand ,
                               gboolean fill , guint padding , GtkPackType pack_type ) ;
#line 152
void _gtk_box_set_old_defaults(GtkBox *box ) ;
#line 153
gboolean _gtk_box_get_spacing_set(GtkBox *box ) ;
#line 154
void _gtk_box_set_spacing_set(GtkBox *box , gboolean spacing_set ) ;
#line 68 "/usr/include/gtk-2.0/gtk/gtkbbox.h"
GType gtk_button_box_get_type(void) ;
#line 70
GtkButtonBoxStyle gtk_button_box_get_layout(GtkButtonBox *widget ) ;
#line 71
void gtk_button_box_set_layout(GtkButtonBox *widget , GtkButtonBoxStyle layout_style ) ;
#line 73
gboolean gtk_button_box_get_child_secondary(GtkButtonBox *widget , GtkWidget *child ) ;
#line 75
void gtk_button_box_set_child_secondary(GtkButtonBox *widget , GtkWidget *child ,
                                        gboolean is_secondary ) ;
#line 83
void gtk_button_box_set_child_size(GtkButtonBox *widget , gint min_width , gint min_height ) ;
#line 86
void gtk_button_box_set_child_ipadding(GtkButtonBox *widget , gint ipad_x , gint ipad_y ) ;
#line 89
void gtk_button_box_get_child_size(GtkButtonBox *widget , gint *min_width , gint *min_height ) ;
#line 92
void gtk_button_box_get_child_ipadding(GtkButtonBox *widget , gint *ipad_x , gint *ipad_y ) ;
#line 98
void _gtk_button_box_child_requisition(GtkWidget *widget , int *nvis_children , int *nvis_secondaries ,
                                       int *width , int *height ) ;
#line 101 "/usr/include/gtk-2.0/gtk/gtkbindings.h"
GtkBindingSet *gtk_binding_set_new(gchar *set_name ) ;
#line 102
GtkBindingSet *gtk_binding_set_by_class(gpointer object_class ) ;
#line 103
GtkBindingSet *gtk_binding_set_find(gchar *set_name ) ;
#line 104
gboolean gtk_bindings_activate(GtkObject *object , guint keyval , GdkModifierType modifiers ) ;
#line 107
gboolean gtk_bindings_activate_event(GtkObject *object , GdkEventKey *event ) ;
#line 109
gboolean gtk_binding_set_activate(GtkBindingSet *binding_set , guint keyval , GdkModifierType modifiers ,
                                  GtkObject *object ) ;
#line 116
void gtk_binding_entry_clear(GtkBindingSet *binding_set , guint keyval , GdkModifierType modifiers ) ;
#line 119
guint gtk_binding_parse_binding(GScanner *scanner ) ;
#line 122
void gtk_binding_entry_skip(GtkBindingSet *binding_set , guint keyval , GdkModifierType modifiers ) ;
#line 125
void gtk_binding_entry_add_signal(GtkBindingSet *binding_set , guint keyval , GdkModifierType modifiers ,
                                  gchar *signal_name , guint n_args  , ...) ;
#line 131
void gtk_binding_entry_add_signall(GtkBindingSet *binding_set , guint keyval , GdkModifierType modifiers ,
                                   gchar *signal_name , GSList *binding_args ) ;
#line 136
void gtk_binding_entry_remove(GtkBindingSet *binding_set , guint keyval , GdkModifierType modifiers ) ;
#line 140
void gtk_binding_set_add_path(GtkBindingSet *binding_set , GtkPathType path_type ,
                              gchar *path_pattern , GtkPathPriorityType priority ) ;
#line 148
guint _gtk_binding_parse_binding(GScanner *scanner ) ;
#line 149
void _gtk_binding_reset_parsed(void) ;
#line 150
void _gtk_binding_entry_add_signall(GtkBindingSet *binding_set , guint keyval , GdkModifierType modifiers ,
                                    gchar *signal_name , GSList *binding_args ) ;
#line 59 "/usr/include/gtk-2.0/gtk/gtkbuilder.h"
GQuark gtk_builder_error_quark(void) ;
#line 94
GType gtk_builder_get_type(void) ;
#line 95
GtkBuilder *gtk_builder_new(void) ;
#line 97
guint gtk_builder_add_from_file(GtkBuilder *builder , gchar *filename , GError **error ) ;
#line 100
guint gtk_builder_add_from_string(GtkBuilder *builder , gchar *buffer , gsize length ,
                                  GError **error ) ;
#line 104
guint gtk_builder_add_objects_from_file(GtkBuilder *builder , gchar *filename , gchar **object_ids ,
                                        GError **error ) ;
#line 108
guint gtk_builder_add_objects_from_string(GtkBuilder *builder , gchar *buffer , gsize length ,
                                          gchar **object_ids , GError **error ) ;
#line 113
GObject *gtk_builder_get_object(GtkBuilder *builder , gchar *name ) ;
#line 115
GSList *gtk_builder_get_objects(GtkBuilder *builder ) ;
#line 116
void gtk_builder_connect_signals(GtkBuilder *builder , gpointer user_data ) ;
#line 118
void gtk_builder_connect_signals_full(GtkBuilder *builder , GtkBuilderConnectFunc func ,
                                      gpointer user_data ) ;
#line 121
void gtk_builder_set_translation_domain(GtkBuilder *builder , gchar *domain ) ;
#line 123
gchar *gtk_builder_get_translation_domain(GtkBuilder *builder ) ;
#line 124
GType gtk_builder_get_type_from_name(GtkBuilder *builder , char const   *type_name ) ;
#line 127
gboolean gtk_builder_value_from_string(GtkBuilder *builder , GParamSpec *pspec , gchar *string ,
                                       GValue *value , GError **error ) ;
#line 132
gboolean gtk_builder_value_from_string_type(GtkBuilder *builder , GType type , gchar *string ,
                                            GValue *value , GError **error ) ;
#line 136 "/usr/include/gtk-2.0/gtk/gtkbuildable.h"
GType gtk_buildable_get_type(void) ;
#line 138
void gtk_buildable_set_name(GtkBuildable *buildable , gchar *name ) ;
#line 140
gchar *gtk_buildable_get_name(GtkBuildable *buildable ) ;
#line 141
void gtk_buildable_add_child(GtkBuildable *buildable , GtkBuilder *builder , GObject *child ,
                             gchar *type ) ;
#line 145
void gtk_buildable_set_buildable_property(GtkBuildable *buildable , GtkBuilder *builder ,
                                          gchar *name , GValue *value ) ;
#line 149
GObject *gtk_buildable_construct_child(GtkBuildable *buildable , GtkBuilder *builder ,
                                       gchar *name ) ;
#line 152
gboolean gtk_buildable_custom_tag_start(GtkBuildable *buildable , GtkBuilder *builder ,
                                        GObject *child , gchar *tagname , GMarkupParser *parser ,
                                        gpointer *data ) ;
#line 158
void gtk_buildable_custom_tag_end(GtkBuildable *buildable , GtkBuilder *builder ,
                                  GObject *child , gchar *tagname , gpointer *data ) ;
#line 163
void gtk_buildable_custom_finished(GtkBuildable *buildable , GtkBuilder *builder ,
                                   GObject *child , gchar *tagname , gpointer data ) ;
#line 168
void gtk_buildable_parser_finished(GtkBuildable *buildable , GtkBuilder *builder ) ;
#line 170
GObject *gtk_buildable_get_internal_child(GtkBuildable *buildable , GtkBuilder *builder ,
                                          gchar *childname ) ;
#line 190 "/usr/include/gtk-2.0/gtk/gtkimage.h"
GType gtk_image_get_type(void) ;
#line 192
GtkWidget *gtk_image_new(void) ;
#line 193
GtkWidget *gtk_image_new_from_pixmap(GdkPixmap *pixmap , GdkBitmap *mask ) ;
#line 195
GtkWidget *gtk_image_new_from_image(GdkImage *image , GdkBitmap *mask ) ;
#line 197
GtkWidget *gtk_image_new_from_file(gchar *filename ) ;
#line 198
GtkWidget *gtk_image_new_from_pixbuf(GdkPixbuf *pixbuf ) ;
#line 199
GtkWidget *gtk_image_new_from_stock(gchar *stock_id , GtkIconSize size ) ;
#line 201
GtkWidget *gtk_image_new_from_icon_set(GtkIconSet *icon_set , GtkIconSize size ) ;
#line 203
GtkWidget *gtk_image_new_from_animation(GdkPixbufAnimation *animation ) ;
#line 204
GtkWidget *gtk_image_new_from_icon_name(gchar *icon_name , GtkIconSize size ) ;
#line 206
GtkWidget *gtk_image_new_from_gicon(GIcon *icon , GtkIconSize size ) ;
#line 209
void gtk_image_clear(GtkImage *image ) ;
#line 210
void gtk_image_set_from_pixmap(GtkImage *image , GdkPixmap *pixmap , GdkBitmap *mask ) ;
#line 213
void gtk_image_set_from_image(GtkImage *image , GdkImage *gdk_image , GdkBitmap *mask ) ;
#line 216
void gtk_image_set_from_file(GtkImage *image , gchar *filename ) ;
#line 218
void gtk_image_set_from_pixbuf(GtkImage *image , GdkPixbuf *pixbuf ) ;
#line 220
void gtk_image_set_from_stock(GtkImage *image , gchar *stock_id , GtkIconSize size ) ;
#line 223
void gtk_image_set_from_icon_set(GtkImage *image , GtkIconSet *icon_set , GtkIconSize size ) ;
#line 226
void gtk_image_set_from_animation(GtkImage *image , GdkPixbufAnimation *animation ) ;
#line 228
void gtk_image_set_from_icon_name(GtkImage *image , gchar *icon_name , GtkIconSize size ) ;
#line 231
void gtk_image_set_from_gicon(GtkImage *image , GIcon *icon , GtkIconSize size ) ;
#line 234
void gtk_image_set_pixel_size(GtkImage *image , gint pixel_size ) ;
#line 237
GtkImageType gtk_image_get_storage_type(GtkImage *image ) ;
#line 239
void gtk_image_get_pixmap(GtkImage *image , GdkPixmap **pixmap , GdkBitmap **mask ) ;
#line 242
void gtk_image_get_image(GtkImage *image , GdkImage **gdk_image , GdkBitmap **mask ) ;
#line 245
GdkPixbuf *gtk_image_get_pixbuf(GtkImage *image ) ;
#line 246
void gtk_image_get_stock(GtkImage *image , gchar **stock_id , GtkIconSize *size ) ;
#line 249
void gtk_image_get_icon_set(GtkImage *image , GtkIconSet **icon_set , GtkIconSize *size ) ;
#line 252
GdkPixbufAnimation *gtk_image_get_animation(GtkImage *image ) ;
#line 253
void gtk_image_get_icon_name(GtkImage *image , gchar **icon_name , GtkIconSize *size ) ;
#line 256
void gtk_image_get_gicon(GtkImage *image , GIcon **gicon , GtkIconSize *size ) ;
#line 259
gint gtk_image_get_pixel_size(GtkImage *image ) ;
#line 264
void gtk_image_set(GtkImage *image , GdkImage *val , GdkBitmap *mask ) ;
#line 267
void gtk_image_get(GtkImage *image , GdkImage **val , GdkBitmap **mask ) ;
#line 91 "/usr/include/gtk-2.0/gtk/gtkbutton.h"
GType gtk_button_get_type(void) ;
#line 92
GtkWidget *gtk_button_new(void) ;
#line 93
GtkWidget *gtk_button_new_with_label(gchar *label ) ;
#line 94
GtkWidget *gtk_button_new_from_stock(gchar *stock_id ) ;
#line 95
GtkWidget *gtk_button_new_with_mnemonic(gchar *label ) ;
#line 97
void gtk_button_pressed(GtkButton *button ) ;
#line 98
void gtk_button_released(GtkButton *button ) ;
#line 100
void gtk_button_clicked(GtkButton *button ) ;
#line 102
void gtk_button_enter(GtkButton *button ) ;
#line 103
void gtk_button_leave(GtkButton *button ) ;
#line 106
void gtk_button_set_relief(GtkButton *button , GtkReliefStyle newstyle ) ;
#line 108
GtkReliefStyle gtk_button_get_relief(GtkButton *button ) ;
#line 109
void gtk_button_set_label(GtkButton *button , gchar *label ) ;
#line 111
gchar *gtk_button_get_label(GtkButton *button ) ;
#line 112
void gtk_button_set_use_underline(GtkButton *button , gboolean use_underline ) ;
#line 114
gboolean gtk_button_get_use_underline(GtkButton *button ) ;
#line 115
void gtk_button_set_use_stock(GtkButton *button , gboolean use_stock ) ;
#line 117
gboolean gtk_button_get_use_stock(GtkButton *button ) ;
#line 118
void gtk_button_set_focus_on_click(GtkButton *button , gboolean focus_on_click ) ;
#line 120
gboolean gtk_button_get_focus_on_click(GtkButton *button ) ;
#line 121
void gtk_button_set_alignment(GtkButton *button , gfloat xalign , gfloat yalign ) ;
#line 124
void gtk_button_get_alignment(GtkButton *button , gfloat *xalign , gfloat *yalign ) ;
#line 127
void gtk_button_set_image(GtkButton *button , GtkWidget *image ) ;
#line 129
GtkWidget *gtk_button_get_image(GtkButton *button ) ;
#line 130
void gtk_button_set_image_position(GtkButton *button , GtkPositionType position ) ;
#line 132
GtkPositionType gtk_button_get_image_position(GtkButton *button ) ;
#line 134
GdkWindow *gtk_button_get_event_window(GtkButton *button ) ;
#line 136
void _gtk_button_set_depressed(GtkButton *button , gboolean depressed ) ;
#line 138
void _gtk_button_paint(GtkButton *button , GdkRectangle *area , GtkStateType state_type ,
                       GtkShadowType shadow_type , gchar *main_detail , gchar *default_detail ) ;
#line 12 "/usr/include/gtk-2.0/gtk/gtkmarshal.h"
extern void gtk_marshal_BOOLEAN__VOID(GClosure *closure , GValue *return_value , guint n_param_values ,
                                      GValue *param_values , gpointer invocation_hint ,
                                      gpointer marshal_data ) ;
#line 23
extern void gtk_marshal_BOOLEAN__POINTER(GClosure *closure , GValue *return_value ,
                                         guint n_param_values , GValue *param_values ,
                                         gpointer invocation_hint , gpointer marshal_data ) ;
#line 34
extern void gtk_marshal_BOOLEAN__POINTER_POINTER_INT_INT(GClosure *closure , GValue *return_value ,
                                                         guint n_param_values , GValue *param_values ,
                                                         gpointer invocation_hint ,
                                                         gpointer marshal_data ) ;
#line 45
extern void gtk_marshal_BOOLEAN__POINTER_INT_INT(GClosure *closure , GValue *return_value ,
                                                 guint n_param_values , GValue *param_values ,
                                                 gpointer invocation_hint , gpointer marshal_data ) ;
#line 56
extern void gtk_marshal_BOOLEAN__POINTER_INT_INT_UINT(GClosure *closure , GValue *return_value ,
                                                      guint n_param_values , GValue *param_values ,
                                                      gpointer invocation_hint , gpointer marshal_data ) ;
#line 67
extern void gtk_marshal_BOOLEAN__POINTER_STRING_STRING_POINTER(GClosure *closure ,
                                                               GValue *return_value ,
                                                               guint n_param_values ,
                                                               GValue *param_values ,
                                                               gpointer invocation_hint ,
                                                               gpointer marshal_data ) ;
#line 78
extern void gtk_marshal_ENUM__ENUM(GClosure *closure , GValue *return_value , guint n_param_values ,
                                   GValue *param_values , gpointer invocation_hint ,
                                   gpointer marshal_data ) ;
#line 87
extern void gtk_marshal_INT__POINTER(GClosure *closure , GValue *return_value , guint n_param_values ,
                                     GValue *param_values , gpointer invocation_hint ,
                                     gpointer marshal_data ) ;
#line 96
extern void gtk_marshal_INT__POINTER_CHAR_CHAR(GClosure *closure , GValue *return_value ,
                                               guint n_param_values , GValue *param_values ,
                                               gpointer invocation_hint , gpointer marshal_data ) ;
#line 120
extern void gtk_marshal_VOID__ENUM_FLOAT(GClosure *closure , GValue *return_value ,
                                         guint n_param_values , GValue *param_values ,
                                         gpointer invocation_hint , gpointer marshal_data ) ;
#line 131
extern void gtk_marshal_VOID__ENUM_FLOAT_BOOLEAN(GClosure *closure , GValue *return_value ,
                                                 guint n_param_values , GValue *param_values ,
                                                 gpointer invocation_hint , gpointer marshal_data ) ;
#line 147
extern void gtk_marshal_VOID__INT_INT(GClosure *closure , GValue *return_value , guint n_param_values ,
                                      GValue *param_values , gpointer invocation_hint ,
                                      gpointer marshal_data ) ;
#line 158
extern void gtk_marshal_VOID__INT_INT_POINTER(GClosure *closure , GValue *return_value ,
                                              guint n_param_values , GValue *param_values ,
                                              gpointer invocation_hint , gpointer marshal_data ) ;
#line 184
extern void gtk_marshal_VOID__POINTER_INT(GClosure *closure , GValue *return_value ,
                                          guint n_param_values , GValue *param_values ,
                                          gpointer invocation_hint , gpointer marshal_data ) ;
#line 195
extern void gtk_marshal_VOID__POINTER_POINTER(GClosure *closure , GValue *return_value ,
                                              guint n_param_values , GValue *param_values ,
                                              gpointer invocation_hint , gpointer marshal_data ) ;
#line 206
extern void gtk_marshal_VOID__POINTER_POINTER_POINTER(GClosure *closure , GValue *return_value ,
                                                      guint n_param_values , GValue *param_values ,
                                                      gpointer invocation_hint , gpointer marshal_data ) ;
#line 217
extern void gtk_marshal_VOID__POINTER_STRING_STRING(GClosure *closure , GValue *return_value ,
                                                    guint n_param_values , GValue *param_values ,
                                                    gpointer invocation_hint , gpointer marshal_data ) ;
#line 228
extern void gtk_marshal_VOID__POINTER_UINT(GClosure *closure , GValue *return_value ,
                                           guint n_param_values , GValue *param_values ,
                                           gpointer invocation_hint , gpointer marshal_data ) ;
#line 239
extern void gtk_marshal_VOID__POINTER_UINT_ENUM(GClosure *closure , GValue *return_value ,
                                                guint n_param_values , GValue *param_values ,
                                                gpointer invocation_hint , gpointer marshal_data ) ;
#line 250
extern void gtk_marshal_VOID__POINTER_POINTER_UINT_UINT(GClosure *closure , GValue *return_value ,
                                                        guint n_param_values , GValue *param_values ,
                                                        gpointer invocation_hint ,
                                                        gpointer marshal_data ) ;
#line 261
extern void gtk_marshal_VOID__POINTER_INT_INT_POINTER_UINT_UINT(GClosure *closure ,
                                                                GValue *return_value ,
                                                                guint n_param_values ,
                                                                GValue *param_values ,
                                                                gpointer invocation_hint ,
                                                                gpointer marshal_data ) ;
#line 272
extern void gtk_marshal_VOID__POINTER_UINT_UINT(GClosure *closure , GValue *return_value ,
                                                guint n_param_values , GValue *param_values ,
                                                gpointer invocation_hint , gpointer marshal_data ) ;
#line 288
extern void gtk_marshal_VOID__STRING_INT_POINTER(GClosure *closure , GValue *return_value ,
                                                 guint n_param_values , GValue *param_values ,
                                                 gpointer invocation_hint , gpointer marshal_data ) ;
#line 304
extern void gtk_marshal_VOID__UINT_POINTER_UINT_ENUM_ENUM_POINTER(GClosure *closure ,
                                                                  GValue *return_value ,
                                                                  guint n_param_values ,
                                                                  GValue *param_values ,
                                                                  gpointer invocation_hint ,
                                                                  gpointer marshal_data ) ;
#line 315
extern void gtk_marshal_VOID__UINT_POINTER_UINT_UINT_ENUM(GClosure *closure , GValue *return_value ,
                                                          guint n_param_values , GValue *param_values ,
                                                          gpointer invocation_hint ,
                                                          gpointer marshal_data ) ;
#line 326
extern void gtk_marshal_VOID__UINT_STRING(GClosure *closure , GValue *return_value ,
                                          guint n_param_values , GValue *param_values ,
                                          gpointer invocation_hint , gpointer marshal_data ) ;
#line 94 "/usr/include/gtk-2.0/gtk/gtksignal.h"
guint gtk_signal_newv(gchar *name , GtkSignalRunType signal_flags , GType object_type ,
                      guint function_offset , GSignalCMarshaller marshaller , GType return_val ,
                      guint n_args , GType *args ) ;
#line 102
guint gtk_signal_new(gchar *name , GtkSignalRunType signal_flags , GType object_type ,
                     guint function_offset , GSignalCMarshaller marshaller , GType return_val ,
                     guint n_args  , ...) ;
#line 110
void gtk_signal_emit_stop_by_name(GtkObject *object , gchar *name ) ;
#line 112
void gtk_signal_connect_object_while_alive(GtkObject *object , gchar *name , GCallback func ,
                                           GtkObject *alive_object ) ;
#line 116
void gtk_signal_connect_while_alive(GtkObject *object , gchar *name , GCallback func ,
                                    gpointer func_data , GtkObject *alive_object ) ;
#line 121
gulong gtk_signal_connect_full(GtkObject *object , gchar *name , GCallback func ,
                               GtkCallbackMarshal unsupported , gpointer data , GDestroyNotify destroy_func ,
                               gint object_signal , gint after ) ;
#line 129
void gtk_signal_emitv(GtkObject *object , guint signal_id , GtkArg *args ) ;
#line 132
void gtk_signal_emit(GtkObject *object , guint signal_id  , ...) ;
#line 135
void gtk_signal_emit_by_name(GtkObject *object , gchar *name  , ...) ;
#line 138
void gtk_signal_emitv_by_name(GtkObject *object , gchar *name , GtkArg *args ) ;
#line 141
void gtk_signal_compat_matched(GtkObject *object , GCallback func , gpointer data ,
                               GSignalMatchType match , guint action ) ;
#line 159 "/usr/include/gtk-2.0/gtk/gtkcalendar.h"
GType gtk_calendar_get_type(void) ;
#line 160
GtkWidget *gtk_calendar_new(void) ;
#line 162
gboolean gtk_calendar_select_month(GtkCalendar *calendar , guint month , guint year ) ;
#line 165
void gtk_calendar_select_day(GtkCalendar *calendar , guint day ) ;
#line 168
gboolean gtk_calendar_mark_day(GtkCalendar *calendar , guint day ) ;
#line 170
gboolean gtk_calendar_unmark_day(GtkCalendar *calendar , guint day ) ;
#line 172
void gtk_calendar_clear_marks(GtkCalendar *calendar ) ;
#line 175
void gtk_calendar_set_display_options(GtkCalendar *calendar , GtkCalendarDisplayOptions flags ) ;
#line 178
GtkCalendarDisplayOptions gtk_calendar_get_display_options(GtkCalendar *calendar ) ;
#line 180
void gtk_calendar_display_options(GtkCalendar *calendar , GtkCalendarDisplayOptions flags ) ;
#line 184
void gtk_calendar_get_date(GtkCalendar *calendar , guint *year , guint *month , guint *day ) ;
#line 189
void gtk_calendar_set_detail_func(GtkCalendar *calendar , GtkCalendarDetailFunc func ,
                                  gpointer data , GDestroyNotify destroy ) ;
#line 194
void gtk_calendar_set_detail_width_chars(GtkCalendar *calendar , gint chars ) ;
#line 196
void gtk_calendar_set_detail_height_rows(GtkCalendar *calendar , gint rows ) ;
#line 199
gint gtk_calendar_get_detail_width_chars(GtkCalendar *calendar ) ;
#line 200
gint gtk_calendar_get_detail_height_rows(GtkCalendar *calendar ) ;
#line 203
void gtk_calendar_freeze(GtkCalendar *calendar ) ;
#line 204
void gtk_calendar_thaw(GtkCalendar *calendar ) ;
#line 54 "/usr/include/gtk-2.0/gtk/gtkcelleditable.h"
GType gtk_cell_editable_get_type(void) ;
#line 56
void gtk_cell_editable_start_editing(GtkCellEditable *cell_editable , GdkEvent *event ) ;
#line 58
void gtk_cell_editable_editing_done(GtkCellEditable *cell_editable ) ;
#line 59
void gtk_cell_editable_remove_widget(GtkCellEditable *cell_editable ) ;
#line 125 "/usr/include/gtk-2.0/gtk/gtkcellrenderer.h"
GType gtk_cell_renderer_get_type(void) ;
#line 127
void gtk_cell_renderer_get_size(GtkCellRenderer *cell , GtkWidget *widget , GdkRectangle *cell_area ,
                                gint *x_offset , gint *y_offset , gint *width , gint *height ) ;
#line 134
void gtk_cell_renderer_render(GtkCellRenderer *cell , GdkWindow *window , GtkWidget *widget ,
                              GdkRectangle *background_area , GdkRectangle *cell_area ,
                              GdkRectangle *expose_area , GtkCellRendererState flags ) ;
#line 141
gboolean gtk_cell_renderer_activate(GtkCellRenderer *cell , GdkEvent *event , GtkWidget *widget ,
                                    gchar *path , GdkRectangle *background_area ,
                                    GdkRectangle *cell_area , GtkCellRendererState flags ) ;
#line 148
GtkCellEditable *gtk_cell_renderer_start_editing(GtkCellRenderer *cell , GdkEvent *event ,
                                                 GtkWidget *widget , gchar *path ,
                                                 GdkRectangle *background_area , GdkRectangle *cell_area ,
                                                 GtkCellRendererState flags ) ;
#line 156
void gtk_cell_renderer_set_fixed_size(GtkCellRenderer *cell , gint width , gint height ) ;
#line 159
void gtk_cell_renderer_get_fixed_size(GtkCellRenderer *cell , gint *width , gint *height ) ;
#line 163
void gtk_cell_renderer_set_alignment(GtkCellRenderer *cell , gfloat xalign , gfloat yalign ) ;
#line 166
void gtk_cell_renderer_get_alignment(GtkCellRenderer *cell , gfloat *xalign , gfloat *yalign ) ;
#line 170
void gtk_cell_renderer_set_padding(GtkCellRenderer *cell , gint xpad , gint ypad ) ;
#line 173
void gtk_cell_renderer_get_padding(GtkCellRenderer *cell , gint *xpad , gint *ypad ) ;
#line 177
void gtk_cell_renderer_set_visible(GtkCellRenderer *cell , gboolean visible ) ;
#line 179
gboolean gtk_cell_renderer_get_visible(GtkCellRenderer *cell ) ;
#line 181
void gtk_cell_renderer_set_sensitive(GtkCellRenderer *cell , gboolean sensitive ) ;
#line 183
gboolean gtk_cell_renderer_get_sensitive(GtkCellRenderer *cell ) ;
#line 187
void gtk_cell_renderer_editing_canceled(GtkCellRenderer *cell ) ;
#line 189
void gtk_cell_renderer_stop_editing(GtkCellRenderer *cell , gboolean canceled ) ;
#line 125 "/usr/include/gtk-2.0/gtk/gtktreemodel.h"
GtkTreePath *gtk_tree_path_new(void) ;
#line 126
GtkTreePath *gtk_tree_path_new_from_string(gchar *path ) ;
#line 127
GtkTreePath *gtk_tree_path_new_from_indices(gint first_index  , ...) ;
#line 129
gchar *gtk_tree_path_to_string(GtkTreePath *path ) ;
#line 130
GtkTreePath *gtk_tree_path_new_first(void) ;
#line 131
void gtk_tree_path_append_index(GtkTreePath *path , gint index_ ) ;
#line 133
void gtk_tree_path_prepend_index(GtkTreePath *path , gint index_ ) ;
#line 135
gint gtk_tree_path_get_depth(GtkTreePath *path ) ;
#line 136
gint *gtk_tree_path_get_indices(GtkTreePath *path ) ;
#line 137
gint *gtk_tree_path_get_indices_with_depth(GtkTreePath *path , gint *depth ) ;
#line 139
void gtk_tree_path_free(GtkTreePath *path ) ;
#line 140
GtkTreePath *gtk_tree_path_copy(GtkTreePath *path ) ;
#line 141
GType gtk_tree_path_get_type(void) ;
#line 142
gint gtk_tree_path_compare(GtkTreePath *a , GtkTreePath *b ) ;
#line 144
void gtk_tree_path_next(GtkTreePath *path ) ;
#line 145
gboolean gtk_tree_path_prev(GtkTreePath *path ) ;
#line 146
gboolean gtk_tree_path_up(GtkTreePath *path ) ;
#line 147
void gtk_tree_path_down(GtkTreePath *path ) ;
#line 149
gboolean gtk_tree_path_is_ancestor(GtkTreePath *path , GtkTreePath *descendant ) ;
#line 151
gboolean gtk_tree_path_is_descendant(GtkTreePath *path , GtkTreePath *ancestor ) ;
#line 163
GType gtk_tree_row_reference_get_type(void) ;
#line 164
GtkTreeRowReference *gtk_tree_row_reference_new(GtkTreeModel *model , GtkTreePath *path ) ;
#line 166
GtkTreeRowReference *gtk_tree_row_reference_new_proxy(GObject *proxy , GtkTreeModel *model ,
                                                      GtkTreePath *path ) ;
#line 169
GtkTreePath *gtk_tree_row_reference_get_path(GtkTreeRowReference *reference ) ;
#line 170
GtkTreeModel *gtk_tree_row_reference_get_model(GtkTreeRowReference *reference ) ;
#line 171
gboolean gtk_tree_row_reference_valid(GtkTreeRowReference *reference ) ;
#line 172
GtkTreeRowReference *gtk_tree_row_reference_copy(GtkTreeRowReference *reference ) ;
#line 173
void gtk_tree_row_reference_free(GtkTreeRowReference *reference ) ;
#line 176
void gtk_tree_row_reference_inserted(GObject *proxy , GtkTreePath *path ) ;
#line 178
void gtk_tree_row_reference_deleted(GObject *proxy , GtkTreePath *path ) ;
#line 180
void gtk_tree_row_reference_reordered(GObject *proxy , GtkTreePath *path , GtkTreeIter *iter ,
                                      gint *new_order ) ;
#line 186
GtkTreeIter *gtk_tree_iter_copy(GtkTreeIter *iter ) ;
#line 187
void gtk_tree_iter_free(GtkTreeIter *iter ) ;
#line 188
GType gtk_tree_iter_get_type(void) ;
#line 190
GType gtk_tree_model_get_type(void) ;
#line 191
GtkTreeModelFlags gtk_tree_model_get_flags(GtkTreeModel *tree_model ) ;
#line 192
gint gtk_tree_model_get_n_columns(GtkTreeModel *tree_model ) ;
#line 193
GType gtk_tree_model_get_column_type(GtkTreeModel *tree_model , gint index_ ) ;
#line 198
gboolean gtk_tree_model_get_iter(GtkTreeModel *tree_model , GtkTreeIter *iter , GtkTreePath *path ) ;
#line 201
gboolean gtk_tree_model_get_iter_from_string(GtkTreeModel *tree_model , GtkTreeIter *iter ,
                                             gchar *path_string ) ;
#line 204
gchar *gtk_tree_model_get_string_from_iter(GtkTreeModel *tree_model , GtkTreeIter *iter ) ;
#line 206
gboolean gtk_tree_model_get_iter_first(GtkTreeModel *tree_model , GtkTreeIter *iter ) ;
#line 208
GtkTreePath *gtk_tree_model_get_path(GtkTreeModel *tree_model , GtkTreeIter *iter ) ;
#line 210
void gtk_tree_model_get_value(GtkTreeModel *tree_model , GtkTreeIter *iter , gint column ,
                              GValue *value ) ;
#line 214
gboolean gtk_tree_model_iter_next(GtkTreeModel *tree_model , GtkTreeIter *iter ) ;
#line 216
gboolean gtk_tree_model_iter_children(GtkTreeModel *tree_model , GtkTreeIter *iter ,
                                      GtkTreeIter *parent ) ;
#line 219
gboolean gtk_tree_model_iter_has_child(GtkTreeModel *tree_model , GtkTreeIter *iter ) ;
#line 221
gint gtk_tree_model_iter_n_children(GtkTreeModel *tree_model , GtkTreeIter *iter ) ;
#line 223
gboolean gtk_tree_model_iter_nth_child(GtkTreeModel *tree_model , GtkTreeIter *iter ,
                                       GtkTreeIter *parent , gint n ) ;
#line 227
gboolean gtk_tree_model_iter_parent(GtkTreeModel *tree_model , GtkTreeIter *iter ,
                                    GtkTreeIter *child ) ;
#line 230
void gtk_tree_model_ref_node(GtkTreeModel *tree_model , GtkTreeIter *iter ) ;
#line 232
void gtk_tree_model_unref_node(GtkTreeModel *tree_model , GtkTreeIter *iter ) ;
#line 234
void gtk_tree_model_get(GtkTreeModel *tree_model , GtkTreeIter *iter  , ...) ;
#line 237
void gtk_tree_model_get_valist(GtkTreeModel *tree_model , GtkTreeIter *iter , va_list var_args ) ;
#line 242
void gtk_tree_model_foreach(GtkTreeModel *model , GtkTreeModelForeachFunc func , gpointer user_data ) ;
#line 252
void gtk_tree_model_row_changed(GtkTreeModel *tree_model , GtkTreePath *path , GtkTreeIter *iter ) ;
#line 255
void gtk_tree_model_row_inserted(GtkTreeModel *tree_model , GtkTreePath *path , GtkTreeIter *iter ) ;
#line 258
void gtk_tree_model_row_has_child_toggled(GtkTreeModel *tree_model , GtkTreePath *path ,
                                          GtkTreeIter *iter ) ;
#line 261
void gtk_tree_model_row_deleted(GtkTreeModel *tree_model , GtkTreePath *path ) ;
#line 263
void gtk_tree_model_rows_reordered(GtkTreeModel *tree_model , GtkTreePath *path ,
                                   GtkTreeIter *iter , gint *new_order ) ;
#line 81 "/usr/include/gtk-2.0/gtk/gtktreesortable.h"
GType gtk_tree_sortable_get_type(void) ;
#line 83
void gtk_tree_sortable_sort_column_changed(GtkTreeSortable *sortable ) ;
#line 84
gboolean gtk_tree_sortable_get_sort_column_id(GtkTreeSortable *sortable , gint *sort_column_id ,
                                              GtkSortType *order ) ;
#line 87
void gtk_tree_sortable_set_sort_column_id(GtkTreeSortable *sortable , gint sort_column_id ,
                                          GtkSortType order ) ;
#line 90
void gtk_tree_sortable_set_sort_func(GtkTreeSortable *sortable , gint sort_column_id ,
                                     GtkTreeIterCompareFunc sort_func , gpointer user_data ,
                                     GDestroyNotify destroy ) ;
#line 95
void gtk_tree_sortable_set_default_sort_func(GtkTreeSortable *sortable , GtkTreeIterCompareFunc sort_func ,
                                             gpointer user_data , GDestroyNotify destroy ) ;
#line 99
gboolean gtk_tree_sortable_has_default_sort_func(GtkTreeSortable *sortable ) ;
#line 126 "/usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h"
GType gtk_tree_view_column_get_type(void) ;
#line 127
GtkTreeViewColumn *gtk_tree_view_column_new(void) ;
#line 128
GtkTreeViewColumn *gtk_tree_view_column_new_with_attributes(gchar *title , GtkCellRenderer *cell 
                                                            , ...) ;
#line 131
void gtk_tree_view_column_pack_start(GtkTreeViewColumn *tree_column , GtkCellRenderer *cell ,
                                     gboolean expand ) ;
#line 134
void gtk_tree_view_column_pack_end(GtkTreeViewColumn *tree_column , GtkCellRenderer *cell ,
                                   gboolean expand ) ;
#line 137
void gtk_tree_view_column_clear(GtkTreeViewColumn *tree_column ) ;
#line 139
GList *gtk_tree_view_column_get_cell_renderers(GtkTreeViewColumn *tree_column ) ;
#line 141
void gtk_tree_view_column_add_attribute(GtkTreeViewColumn *tree_column , GtkCellRenderer *cell_renderer ,
                                        gchar *attribute , gint column ) ;
#line 145
void gtk_tree_view_column_set_attributes(GtkTreeViewColumn *tree_column , GtkCellRenderer *cell_renderer 
                                         , ...) ;
#line 148
void gtk_tree_view_column_set_cell_data_func(GtkTreeViewColumn *tree_column , GtkCellRenderer *cell_renderer ,
                                             GtkTreeCellDataFunc func , gpointer func_data ,
                                             GDestroyNotify destroy ) ;
#line 153
void gtk_tree_view_column_clear_attributes(GtkTreeViewColumn *tree_column , GtkCellRenderer *cell_renderer ) ;
#line 155
void gtk_tree_view_column_set_spacing(GtkTreeViewColumn *tree_column , gint spacing ) ;
#line 157
gint gtk_tree_view_column_get_spacing(GtkTreeViewColumn *tree_column ) ;
#line 158
void gtk_tree_view_column_set_visible(GtkTreeViewColumn *tree_column , gboolean visible ) ;
#line 160
gboolean gtk_tree_view_column_get_visible(GtkTreeViewColumn *tree_column ) ;
#line 161
void gtk_tree_view_column_set_resizable(GtkTreeViewColumn *tree_column , gboolean resizable ) ;
#line 163
gboolean gtk_tree_view_column_get_resizable(GtkTreeViewColumn *tree_column ) ;
#line 164
void gtk_tree_view_column_set_sizing(GtkTreeViewColumn *tree_column , GtkTreeViewColumnSizing type ) ;
#line 166
GtkTreeViewColumnSizing gtk_tree_view_column_get_sizing(GtkTreeViewColumn *tree_column ) ;
#line 167
gint gtk_tree_view_column_get_width(GtkTreeViewColumn *tree_column ) ;
#line 168
gint gtk_tree_view_column_get_fixed_width(GtkTreeViewColumn *tree_column ) ;
#line 169
void gtk_tree_view_column_set_fixed_width(GtkTreeViewColumn *tree_column , gint fixed_width ) ;
#line 171
void gtk_tree_view_column_set_min_width(GtkTreeViewColumn *tree_column , gint min_width ) ;
#line 173
gint gtk_tree_view_column_get_min_width(GtkTreeViewColumn *tree_column ) ;
#line 174
void gtk_tree_view_column_set_max_width(GtkTreeViewColumn *tree_column , gint max_width ) ;
#line 176
gint gtk_tree_view_column_get_max_width(GtkTreeViewColumn *tree_column ) ;
#line 177
void gtk_tree_view_column_clicked(GtkTreeViewColumn *tree_column ) ;
#line 183
void gtk_tree_view_column_set_title(GtkTreeViewColumn *tree_column , gchar *title ) ;
#line 185
gchar *gtk_tree_view_column_get_title(GtkTreeViewColumn *tree_column ) ;
#line 186
void gtk_tree_view_column_set_expand(GtkTreeViewColumn *tree_column , gboolean expand ) ;
#line 188
gboolean gtk_tree_view_column_get_expand(GtkTreeViewColumn *tree_column ) ;
#line 189
void gtk_tree_view_column_set_clickable(GtkTreeViewColumn *tree_column , gboolean clickable ) ;
#line 191
gboolean gtk_tree_view_column_get_clickable(GtkTreeViewColumn *tree_column ) ;
#line 192
void gtk_tree_view_column_set_widget(GtkTreeViewColumn *tree_column , GtkWidget *widget ) ;
#line 194
GtkWidget *gtk_tree_view_column_get_widget(GtkTreeViewColumn *tree_column ) ;
#line 195
void gtk_tree_view_column_set_alignment(GtkTreeViewColumn *tree_column , gfloat xalign ) ;
#line 197
gfloat gtk_tree_view_column_get_alignment(GtkTreeViewColumn *tree_column ) ;
#line 198
void gtk_tree_view_column_set_reorderable(GtkTreeViewColumn *tree_column , gboolean reorderable ) ;
#line 200
gboolean gtk_tree_view_column_get_reorderable(GtkTreeViewColumn *tree_column ) ;
#line 207
void gtk_tree_view_column_set_sort_column_id(GtkTreeViewColumn *tree_column , gint sort_column_id ) ;
#line 209
gint gtk_tree_view_column_get_sort_column_id(GtkTreeViewColumn *tree_column ) ;
#line 210
void gtk_tree_view_column_set_sort_indicator(GtkTreeViewColumn *tree_column , gboolean setting ) ;
#line 212
gboolean gtk_tree_view_column_get_sort_indicator(GtkTreeViewColumn *tree_column ) ;
#line 213
void gtk_tree_view_column_set_sort_order(GtkTreeViewColumn *tree_column , GtkSortType order ) ;
#line 215
GtkSortType gtk_tree_view_column_get_sort_order(GtkTreeViewColumn *tree_column ) ;
#line 220
void gtk_tree_view_column_cell_set_cell_data(GtkTreeViewColumn *tree_column , GtkTreeModel *tree_model ,
                                             GtkTreeIter *iter , gboolean is_expander ,
                                             gboolean is_expanded ) ;
#line 225
void gtk_tree_view_column_cell_get_size(GtkTreeViewColumn *tree_column , GdkRectangle *cell_area ,
                                        gint *x_offset , gint *y_offset , gint *width ,
                                        gint *height ) ;
#line 231
gboolean gtk_tree_view_column_cell_is_visible(GtkTreeViewColumn *tree_column ) ;
#line 232
void gtk_tree_view_column_focus_cell(GtkTreeViewColumn *tree_column , GtkCellRenderer *cell ) ;
#line 234
gboolean gtk_tree_view_column_cell_get_position(GtkTreeViewColumn *tree_column , GtkCellRenderer *cell_renderer ,
                                                gint *start_pos , gint *width ) ;
#line 238
void gtk_tree_view_column_queue_resize(GtkTreeViewColumn *tree_column ) ;
#line 239
GtkWidget *gtk_tree_view_column_get_tree_view(GtkTreeViewColumn *tree_column ) ;
#line 78 "/usr/include/gtk-2.0/gtk/gtkcelllayout.h"
GType gtk_cell_layout_get_type(void) ;
#line 79
void gtk_cell_layout_pack_start(GtkCellLayout *cell_layout , GtkCellRenderer *cell ,
                                gboolean expand ) ;
#line 82
void gtk_cell_layout_pack_end(GtkCellLayout *cell_layout , GtkCellRenderer *cell ,
                              gboolean expand ) ;
#line 85
GList *gtk_cell_layout_get_cells(GtkCellLayout *cell_layout ) ;
#line 86
void gtk_cell_layout_clear(GtkCellLayout *cell_layout ) ;
#line 87
void gtk_cell_layout_set_attributes(GtkCellLayout *cell_layout , GtkCellRenderer *cell 
                                    , ...) ;
#line 90
void gtk_cell_layout_add_attribute(GtkCellLayout *cell_layout , GtkCellRenderer *cell ,
                                   gchar *attribute , gint column ) ;
#line 94
void gtk_cell_layout_set_cell_data_func(GtkCellLayout *cell_layout , GtkCellRenderer *cell ,
                                        GtkCellLayoutDataFunc func , gpointer func_data ,
                                        GDestroyNotify destroy ) ;
#line 99
void gtk_cell_layout_clear_attributes(GtkCellLayout *cell_layout , GtkCellRenderer *cell ) ;
#line 101
void gtk_cell_layout_reorder(GtkCellLayout *cell_layout , GtkCellRenderer *cell ,
                             gint position ) ;
#line 104
gboolean _gtk_cell_layout_buildable_custom_tag_start(GtkBuildable *buildable , GtkBuilder *builder ,
                                                     GObject *child , gchar *tagname ,
                                                     GMarkupParser *parser , gpointer *data ) ;
#line 110
void _gtk_cell_layout_buildable_custom_tag_end(GtkBuildable *buildable , GtkBuilder *builder ,
                                               GObject *child , gchar *tagname , gpointer *data ) ;
#line 115
void _gtk_cell_layout_buildable_add_child(GtkBuildable *buildable , GtkBuilder *builder ,
                                          GObject *child , gchar *type ) ;
#line 96 "/usr/include/gtk-2.0/gtk/gtkcellrenderertext.h"
GType gtk_cell_renderer_text_get_type(void) ;
#line 97
GtkCellRenderer *gtk_cell_renderer_text_new(void) ;
#line 99
void gtk_cell_renderer_text_set_fixed_height_from_font(GtkCellRendererText *renderer ,
                                                       gint number_of_rows ) ;
#line 85 "/usr/include/gtk-2.0/gtk/gtkcellrendereraccel.h"
GType gtk_cell_renderer_accel_get_type(void) ;
#line 86
GtkCellRenderer *gtk_cell_renderer_accel_new(void) ;
#line 59 "/usr/include/gtk-2.0/gtk/gtkcellrenderercombo.h"
GType gtk_cell_renderer_combo_get_type(void) ;
#line 60
GtkCellRenderer *gtk_cell_renderer_combo_new(void) ;
#line 64 "/usr/include/gtk-2.0/gtk/gtkcellrendererpixbuf.h"
GType gtk_cell_renderer_pixbuf_get_type(void) ;
#line 65
GtkCellRenderer *gtk_cell_renderer_pixbuf_new(void) ;
#line 69 "/usr/include/gtk-2.0/gtk/gtkcellrendererprogress.h"
GType gtk_cell_renderer_progress_get_type(void) ;
#line 70
GtkCellRenderer *gtk_cell_renderer_progress_new(void) ;
#line 52 "/usr/include/gtk-2.0/gtk/gtkcellrendererspin.h"
GType gtk_cell_renderer_spin_get_type(void) ;
#line 53
GtkCellRenderer *gtk_cell_renderer_spin_new(void) ;
#line 62 "/usr/include/gtk-2.0/gtk/gtkcellrendererspinner.h"
GType gtk_cell_renderer_spinner_get_type(void) ;
#line 63
GtkCellRenderer *gtk_cell_renderer_spinner_new(void) ;
#line 67 "/usr/include/gtk-2.0/gtk/gtkcellrenderertoggle.h"
GType gtk_cell_renderer_toggle_get_type(void) ;
#line 68
GtkCellRenderer *gtk_cell_renderer_toggle_new(void) ;
#line 70
gboolean gtk_cell_renderer_toggle_get_radio(GtkCellRendererToggle *toggle ) ;
#line 71
void gtk_cell_renderer_toggle_set_radio(GtkCellRendererToggle *toggle , gboolean radio ) ;
#line 74
gboolean gtk_cell_renderer_toggle_get_active(GtkCellRendererToggle *toggle ) ;
#line 75
void gtk_cell_renderer_toggle_set_active(GtkCellRendererToggle *toggle , gboolean setting ) ;
#line 78
gboolean gtk_cell_renderer_toggle_get_activatable(GtkCellRendererToggle *toggle ) ;
#line 79
void gtk_cell_renderer_toggle_set_activatable(GtkCellRendererToggle *toggle , gboolean setting ) ;
#line 57 "/usr/include/gtk-2.0/gtk/gtkcellview.h"
GType gtk_cell_view_get_type(void) ;
#line 58
GtkWidget *gtk_cell_view_new(void) ;
#line 59
GtkWidget *gtk_cell_view_new_with_text(gchar *text ) ;
#line 60
GtkWidget *gtk_cell_view_new_with_markup(gchar *markup ) ;
#line 61
GtkWidget *gtk_cell_view_new_with_pixbuf(GdkPixbuf *pixbuf ) ;
#line 63
void gtk_cell_view_set_model(GtkCellView *cell_view , GtkTreeModel *model ) ;
#line 65
GtkTreeModel *gtk_cell_view_get_model(GtkCellView *cell_view ) ;
#line 66
void gtk_cell_view_set_displayed_row(GtkCellView *cell_view , GtkTreePath *path ) ;
#line 68
GtkTreePath *gtk_cell_view_get_displayed_row(GtkCellView *cell_view ) ;
#line 69
gboolean gtk_cell_view_get_size_of_row(GtkCellView *cell_view , GtkTreePath *path ,
                                       GtkRequisition *requisition ) ;
#line 73
void gtk_cell_view_set_background_color(GtkCellView *cell_view , GdkColor *color ) ;
#line 76
GList *gtk_cell_view_get_cell_renderers(GtkCellView *cell_view ) ;
#line 74 "/usr/include/gtk-2.0/gtk/gtktogglebutton.h"
GType gtk_toggle_button_get_type(void) ;
#line 76
GtkWidget *gtk_toggle_button_new(void) ;
#line 77
GtkWidget *gtk_toggle_button_new_with_label(gchar *label ) ;
#line 78
GtkWidget *gtk_toggle_button_new_with_mnemonic(gchar *label ) ;
#line 79
void gtk_toggle_button_set_mode(GtkToggleButton *toggle_button , gboolean draw_indicator ) ;
#line 81
gboolean gtk_toggle_button_get_mode(GtkToggleButton *toggle_button ) ;
#line 82
void gtk_toggle_button_set_active(GtkToggleButton *toggle_button , gboolean is_active ) ;
#line 84
gboolean gtk_toggle_button_get_active(GtkToggleButton *toggle_button ) ;
#line 85
void gtk_toggle_button_toggled(GtkToggleButton *toggle_button ) ;
#line 86
void gtk_toggle_button_set_inconsistent(GtkToggleButton *toggle_button , gboolean setting ) ;
#line 88
gboolean gtk_toggle_button_get_inconsistent(GtkToggleButton *toggle_button ) ;
#line 71 "/usr/include/gtk-2.0/gtk/gtkcheckbutton.h"
GType gtk_check_button_get_type(void) ;
#line 72
GtkWidget *gtk_check_button_new(void) ;
#line 73
GtkWidget *gtk_check_button_new_with_label(gchar *label ) ;
#line 74
GtkWidget *gtk_check_button_new_with_mnemonic(gchar *label ) ;
#line 76
void _gtk_check_button_get_props(GtkCheckButton *check_button , gint *indicator_size ,
                                 gint *indicator_spacing ) ;
#line 72 "/usr/include/gtk-2.0/gtk/gtkitem.h"
GType gtk_item_get_type(void) ;
#line 74
void gtk_item_select(GtkItem *item ) ;
#line 75
void gtk_item_deselect(GtkItem *item ) ;
#line 76
void gtk_item_toggle(GtkItem *item ) ;
#line 99 "/usr/include/gtk-2.0/gtk/gtkmenuitem.h"
GType gtk_menu_item_get_type(void) ;
#line 100
GtkWidget *gtk_menu_item_new(void) ;
#line 101
GtkWidget *gtk_menu_item_new_with_label(gchar *label ) ;
#line 102
GtkWidget *gtk_menu_item_new_with_mnemonic(gchar *label ) ;
#line 103
void gtk_menu_item_set_submenu(GtkMenuItem *menu_item , GtkWidget *submenu ) ;
#line 105
GtkWidget *gtk_menu_item_get_submenu(GtkMenuItem *menu_item ) ;
#line 106
void gtk_menu_item_select(GtkMenuItem *menu_item ) ;
#line 107
void gtk_menu_item_deselect(GtkMenuItem *menu_item ) ;
#line 108
void gtk_menu_item_activate(GtkMenuItem *menu_item ) ;
#line 109
void gtk_menu_item_toggle_size_request(GtkMenuItem *menu_item , gint *requisition ) ;
#line 111
void gtk_menu_item_toggle_size_allocate(GtkMenuItem *menu_item , gint allocation ) ;
#line 113
void gtk_menu_item_set_right_justified(GtkMenuItem *menu_item , gboolean right_justified ) ;
#line 115
gboolean gtk_menu_item_get_right_justified(GtkMenuItem *menu_item ) ;
#line 116
void gtk_menu_item_set_accel_path(GtkMenuItem *menu_item , gchar *accel_path ) ;
#line 118
gchar *gtk_menu_item_get_accel_path(GtkMenuItem *menu_item ) ;
#line 120
void gtk_menu_item_set_label(GtkMenuItem *menu_item , gchar *label ) ;
#line 122
gchar *gtk_menu_item_get_label(GtkMenuItem *menu_item ) ;
#line 124
void gtk_menu_item_set_use_underline(GtkMenuItem *menu_item , gboolean setting ) ;
#line 126
gboolean gtk_menu_item_get_use_underline(GtkMenuItem *menu_item ) ;
#line 129
void _gtk_menu_item_refresh_accel_path(GtkMenuItem *menu_item , gchar *prefix , GtkAccelGroup *accel_group ,
                                       gboolean group_changed ) ;
#line 133
gboolean _gtk_menu_item_is_selectable(GtkWidget *menu_item ) ;
#line 134
void _gtk_menu_item_popup_submenu(GtkWidget *menu_item , gboolean with_delay ) ;
#line 136
void _gtk_menu_item_popdown_submenu(GtkWidget *menu_item ) ;
#line 139
void gtk_menu_item_remove_submenu(GtkMenuItem *menu_item ) ;
#line 77 "/usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h"
GType gtk_check_menu_item_get_type(void) ;
#line 79
GtkWidget *gtk_check_menu_item_new(void) ;
#line 80
GtkWidget *gtk_check_menu_item_new_with_label(gchar *label ) ;
#line 81
GtkWidget *gtk_check_menu_item_new_with_mnemonic(gchar *label ) ;
#line 82
void gtk_check_menu_item_set_active(GtkCheckMenuItem *check_menu_item , gboolean is_active ) ;
#line 84
gboolean gtk_check_menu_item_get_active(GtkCheckMenuItem *check_menu_item ) ;
#line 85
void gtk_check_menu_item_toggled(GtkCheckMenuItem *check_menu_item ) ;
#line 86
void gtk_check_menu_item_set_inconsistent(GtkCheckMenuItem *check_menu_item , gboolean setting ) ;
#line 88
gboolean gtk_check_menu_item_get_inconsistent(GtkCheckMenuItem *check_menu_item ) ;
#line 89
void gtk_check_menu_item_set_draw_as_radio(GtkCheckMenuItem *check_menu_item , gboolean draw_as_radio ) ;
#line 91
gboolean gtk_check_menu_item_get_draw_as_radio(GtkCheckMenuItem *check_menu_item ) ;
#line 95
void gtk_check_menu_item_set_show_toggle(GtkCheckMenuItem *menu_item , gboolean always ) ;
#line 156 "/usr/include/gtk-2.0/gtk/gtktexttag.h"
GType gtk_text_tag_get_type(void) ;
#line 157
GtkTextTag *gtk_text_tag_new(gchar *name ) ;
#line 158
gint gtk_text_tag_get_priority(GtkTextTag *tag ) ;
#line 159
void gtk_text_tag_set_priority(GtkTextTag *tag , gint priority ) ;
#line 161
gboolean gtk_text_tag_event(GtkTextTag *tag , GObject *event_object , GdkEvent *event ,
                            GtkTextIter *iter ) ;
#line 276
GtkTextAttributes *gtk_text_attributes_new(void) ;
#line 277
GtkTextAttributes *gtk_text_attributes_copy(GtkTextAttributes *src ) ;
#line 278
void gtk_text_attributes_copy_values(GtkTextAttributes *src , GtkTextAttributes *dest ) ;
#line 280
void gtk_text_attributes_unref(GtkTextAttributes *values ) ;
#line 281
GtkTextAttributes *gtk_text_attributes_ref(GtkTextAttributes *values ) ;
#line 283
GType gtk_text_attributes_get_type(void) ;
#line 73 "/usr/include/gtk-2.0/gtk/gtktextchild.h"
GType gtk_text_child_anchor_get_type(void) ;
#line 75
GtkTextChildAnchor *gtk_text_child_anchor_new(void) ;
#line 77
GList *gtk_text_child_anchor_get_widgets(GtkTextChildAnchor *anchor ) ;
#line 78
gboolean gtk_text_child_anchor_get_deleted(GtkTextChildAnchor *anchor ) ;
#line 81 "/usr/include/gtk-2.0/gtk/gtktextiter.h"
GtkTextBuffer *gtk_text_iter_get_buffer(GtkTextIter *iter ) ;
#line 87
GtkTextIter *gtk_text_iter_copy(GtkTextIter *iter ) ;
#line 88
void gtk_text_iter_free(GtkTextIter *iter ) ;
#line 90
GType gtk_text_iter_get_type(void) ;
#line 96
gint gtk_text_iter_get_offset(GtkTextIter *iter ) ;
#line 97
gint gtk_text_iter_get_line(GtkTextIter *iter ) ;
#line 98
gint gtk_text_iter_get_line_offset(GtkTextIter *iter ) ;
#line 99
gint gtk_text_iter_get_line_index(GtkTextIter *iter ) ;
#line 101
gint gtk_text_iter_get_visible_line_offset(GtkTextIter *iter ) ;
#line 102
gint gtk_text_iter_get_visible_line_index(GtkTextIter *iter ) ;
#line 108
gunichar gtk_text_iter_get_char(GtkTextIter *iter ) ;
#line 113
gchar *gtk_text_iter_get_slice(GtkTextIter *start , GtkTextIter *end ) ;
#line 117
gchar *gtk_text_iter_get_text(GtkTextIter *start , GtkTextIter *end ) ;
#line 120
gchar *gtk_text_iter_get_visible_slice(GtkTextIter *start , GtkTextIter *end ) ;
#line 122
gchar *gtk_text_iter_get_visible_text(GtkTextIter *start , GtkTextIter *end ) ;
#line 125
GdkPixbuf *gtk_text_iter_get_pixbuf(GtkTextIter *iter ) ;
#line 126
GSList *gtk_text_iter_get_marks(GtkTextIter *iter ) ;
#line 128
GtkTextChildAnchor *gtk_text_iter_get_child_anchor(GtkTextIter *iter ) ;
#line 133
GSList *gtk_text_iter_get_toggled_tags(GtkTextIter *iter , gboolean toggled_on ) ;
#line 136
gboolean gtk_text_iter_begins_tag(GtkTextIter *iter , GtkTextTag *tag ) ;
#line 139
gboolean gtk_text_iter_ends_tag(GtkTextIter *iter , GtkTextTag *tag ) ;
#line 142
gboolean gtk_text_iter_toggles_tag(GtkTextIter *iter , GtkTextTag *tag ) ;
#line 145
gboolean gtk_text_iter_has_tag(GtkTextIter *iter , GtkTextTag *tag ) ;
#line 147
GSList *gtk_text_iter_get_tags(GtkTextIter *iter ) ;
#line 149
gboolean gtk_text_iter_editable(GtkTextIter *iter , gboolean default_setting ) ;
#line 151
gboolean gtk_text_iter_can_insert(GtkTextIter *iter , gboolean default_editability ) ;
#line 154
gboolean gtk_text_iter_starts_word(GtkTextIter *iter ) ;
#line 155
gboolean gtk_text_iter_ends_word(GtkTextIter *iter ) ;
#line 156
gboolean gtk_text_iter_inside_word(GtkTextIter *iter ) ;
#line 157
gboolean gtk_text_iter_starts_sentence(GtkTextIter *iter ) ;
#line 158
gboolean gtk_text_iter_ends_sentence(GtkTextIter *iter ) ;
#line 159
gboolean gtk_text_iter_inside_sentence(GtkTextIter *iter ) ;
#line 160
gboolean gtk_text_iter_starts_line(GtkTextIter *iter ) ;
#line 161
gboolean gtk_text_iter_ends_line(GtkTextIter *iter ) ;
#line 162
gboolean gtk_text_iter_is_cursor_position(GtkTextIter *iter ) ;
#line 164
gint gtk_text_iter_get_chars_in_line(GtkTextIter *iter ) ;
#line 165
gint gtk_text_iter_get_bytes_in_line(GtkTextIter *iter ) ;
#line 167
gboolean gtk_text_iter_get_attributes(GtkTextIter *iter , GtkTextAttributes *values ) ;
#line 169
PangoLanguage *gtk_text_iter_get_language(GtkTextIter *iter ) ;
#line 170
gboolean gtk_text_iter_is_end(GtkTextIter *iter ) ;
#line 171
gboolean gtk_text_iter_is_start(GtkTextIter *iter ) ;
#line 177
gboolean gtk_text_iter_forward_char(GtkTextIter *iter ) ;
#line 178
gboolean gtk_text_iter_backward_char(GtkTextIter *iter ) ;
#line 179
gboolean gtk_text_iter_forward_chars(GtkTextIter *iter , gint count ) ;
#line 181
gboolean gtk_text_iter_backward_chars(GtkTextIter *iter , gint count ) ;
#line 183
gboolean gtk_text_iter_forward_line(GtkTextIter *iter ) ;
#line 184
gboolean gtk_text_iter_backward_line(GtkTextIter *iter ) ;
#line 185
gboolean gtk_text_iter_forward_lines(GtkTextIter *iter , gint count ) ;
#line 187
gboolean gtk_text_iter_backward_lines(GtkTextIter *iter , gint count ) ;
#line 189
gboolean gtk_text_iter_forward_word_end(GtkTextIter *iter ) ;
#line 190
gboolean gtk_text_iter_backward_word_start(GtkTextIter *iter ) ;
#line 191
gboolean gtk_text_iter_forward_word_ends(GtkTextIter *iter , gint count ) ;
#line 193
gboolean gtk_text_iter_backward_word_starts(GtkTextIter *iter , gint count ) ;
#line 196
gboolean gtk_text_iter_forward_visible_line(GtkTextIter *iter ) ;
#line 197
gboolean gtk_text_iter_backward_visible_line(GtkTextIter *iter ) ;
#line 198
gboolean gtk_text_iter_forward_visible_lines(GtkTextIter *iter , gint count ) ;
#line 200
gboolean gtk_text_iter_backward_visible_lines(GtkTextIter *iter , gint count ) ;
#line 203
gboolean gtk_text_iter_forward_visible_word_end(GtkTextIter *iter ) ;
#line 204
gboolean gtk_text_iter_backward_visible_word_start(GtkTextIter *iter ) ;
#line 205
gboolean gtk_text_iter_forward_visible_word_ends(GtkTextIter *iter , gint count ) ;
#line 207
gboolean gtk_text_iter_backward_visible_word_starts(GtkTextIter *iter , gint count ) ;
#line 210
gboolean gtk_text_iter_forward_sentence_end(GtkTextIter *iter ) ;
#line 211
gboolean gtk_text_iter_backward_sentence_start(GtkTextIter *iter ) ;
#line 212
gboolean gtk_text_iter_forward_sentence_ends(GtkTextIter *iter , gint count ) ;
#line 214
gboolean gtk_text_iter_backward_sentence_starts(GtkTextIter *iter , gint count ) ;
#line 221
gboolean gtk_text_iter_forward_cursor_position(GtkTextIter *iter ) ;
#line 222
gboolean gtk_text_iter_backward_cursor_position(GtkTextIter *iter ) ;
#line 223
gboolean gtk_text_iter_forward_cursor_positions(GtkTextIter *iter , gint count ) ;
#line 225
gboolean gtk_text_iter_backward_cursor_positions(GtkTextIter *iter , gint count ) ;
#line 228
gboolean gtk_text_iter_forward_visible_cursor_position(GtkTextIter *iter ) ;
#line 229
gboolean gtk_text_iter_backward_visible_cursor_position(GtkTextIter *iter ) ;
#line 230
gboolean gtk_text_iter_forward_visible_cursor_positions(GtkTextIter *iter , gint count ) ;
#line 232
gboolean gtk_text_iter_backward_visible_cursor_positions(GtkTextIter *iter , gint count ) ;
#line 236
void gtk_text_iter_set_offset(GtkTextIter *iter , gint char_offset ) ;
#line 238
void gtk_text_iter_set_line(GtkTextIter *iter , gint line_number ) ;
#line 240
void gtk_text_iter_set_line_offset(GtkTextIter *iter , gint char_on_line ) ;
#line 242
void gtk_text_iter_set_line_index(GtkTextIter *iter , gint byte_on_line ) ;
#line 244
void gtk_text_iter_forward_to_end(GtkTextIter *iter ) ;
#line 245
gboolean gtk_text_iter_forward_to_line_end(GtkTextIter *iter ) ;
#line 247
void gtk_text_iter_set_visible_line_offset(GtkTextIter *iter , gint char_on_line ) ;
#line 249
void gtk_text_iter_set_visible_line_index(GtkTextIter *iter , gint byte_on_line ) ;
#line 256
gboolean gtk_text_iter_forward_to_tag_toggle(GtkTextIter *iter , GtkTextTag *tag ) ;
#line 259
gboolean gtk_text_iter_backward_to_tag_toggle(GtkTextIter *iter , GtkTextTag *tag ) ;
#line 264
gboolean gtk_text_iter_forward_find_char(GtkTextIter *iter , GtkTextCharPredicate pred ,
                                         gpointer user_data , GtkTextIter *limit ) ;
#line 268
gboolean gtk_text_iter_backward_find_char(GtkTextIter *iter , GtkTextCharPredicate pred ,
                                          gpointer user_data , GtkTextIter *limit ) ;
#line 273
gboolean gtk_text_iter_forward_search(GtkTextIter *iter , gchar *str , GtkTextSearchFlags flags ,
                                      GtkTextIter *match_start , GtkTextIter *match_end ,
                                      GtkTextIter *limit ) ;
#line 280
gboolean gtk_text_iter_backward_search(GtkTextIter *iter , gchar *str , GtkTextSearchFlags flags ,
                                       GtkTextIter *match_start , GtkTextIter *match_end ,
                                       GtkTextIter *limit ) ;
#line 291
gboolean gtk_text_iter_equal(GtkTextIter *lhs , GtkTextIter *rhs ) ;
#line 293
gint gtk_text_iter_compare(GtkTextIter *lhs , GtkTextIter *rhs ) ;
#line 295
gboolean gtk_text_iter_in_range(GtkTextIter *iter , GtkTextIter *start , GtkTextIter *end ) ;
#line 300
void gtk_text_iter_order(GtkTextIter *first , GtkTextIter *second ) ;
#line 93 "/usr/include/gtk-2.0/gtk/gtkselection.h"
GtkTargetList *gtk_target_list_new(GtkTargetEntry *targets , guint ntargets ) ;
#line 95
GtkTargetList *gtk_target_list_ref(GtkTargetList *list ) ;
#line 96
void gtk_target_list_unref(GtkTargetList *list ) ;
#line 97
void gtk_target_list_add(GtkTargetList *list , GdkAtom target , guint flags , guint info ) ;
#line 101
void gtk_target_list_add_text_targets(GtkTargetList *list , guint info ) ;
#line 103
void gtk_target_list_add_rich_text_targets(GtkTargetList *list , guint info , gboolean deserializable ,
                                           GtkTextBuffer *buffer ) ;
#line 107
void gtk_target_list_add_image_targets(GtkTargetList *list , guint info , gboolean writable ) ;
#line 110
void gtk_target_list_add_uri_targets(GtkTargetList *list , guint info ) ;
#line 112
void gtk_target_list_add_table(GtkTargetList *list , GtkTargetEntry *targets , guint ntargets ) ;
#line 115
void gtk_target_list_remove(GtkTargetList *list , GdkAtom target ) ;
#line 117
gboolean gtk_target_list_find(GtkTargetList *list , GdkAtom target , guint *info ) ;
#line 121
GtkTargetEntry *gtk_target_table_new_from_list(GtkTargetList *list , gint *n_targets ) ;
#line 123
void gtk_target_table_free(GtkTargetEntry *targets , gint n_targets ) ;
#line 128
gboolean gtk_selection_owner_set(GtkWidget *widget , GdkAtom selection , guint32 time_ ) ;
#line 131
gboolean gtk_selection_owner_set_for_display(GdkDisplay *display , GtkWidget *widget ,
                                             GdkAtom selection , guint32 time_ ) ;
#line 136
void gtk_selection_add_target(GtkWidget *widget , GdkAtom selection , GdkAtom target ,
                              guint info ) ;
#line 140
void gtk_selection_add_targets(GtkWidget *widget , GdkAtom selection , GtkTargetEntry *targets ,
                               guint ntargets ) ;
#line 144
void gtk_selection_clear_targets(GtkWidget *widget , GdkAtom selection ) ;
#line 146
gboolean gtk_selection_convert(GtkWidget *widget , GdkAtom selection , GdkAtom target ,
                               guint32 time_ ) ;
#line 151
GdkAtom gtk_selection_data_get_selection(GtkSelectionData *selection_data ) ;
#line 152
GdkAtom gtk_selection_data_get_target(GtkSelectionData *selection_data ) ;
#line 153
GdkAtom gtk_selection_data_get_data_type(GtkSelectionData *selection_data ) ;
#line 154
gint gtk_selection_data_get_format(GtkSelectionData *selection_data ) ;
#line 155
guchar *gtk_selection_data_get_data(GtkSelectionData *selection_data ) ;
#line 156
gint gtk_selection_data_get_length(GtkSelectionData *selection_data ) ;
#line 157
GdkDisplay *gtk_selection_data_get_display(GtkSelectionData *selection_data ) ;
#line 159
void gtk_selection_data_set(GtkSelectionData *selection_data , GdkAtom type , gint format ,
                            guchar *data , gint length ) ;
#line 164
gboolean gtk_selection_data_set_text(GtkSelectionData *selection_data , gchar *str ,
                                     gint len ) ;
#line 167
guchar *gtk_selection_data_get_text(GtkSelectionData *selection_data ) ;
#line 168
gboolean gtk_selection_data_set_pixbuf(GtkSelectionData *selection_data , GdkPixbuf *pixbuf ) ;
#line 170
GdkPixbuf *gtk_selection_data_get_pixbuf(GtkSelectionData *selection_data ) ;
#line 171
gboolean gtk_selection_data_set_uris(GtkSelectionData *selection_data , gchar **uris ) ;
#line 173
gchar **gtk_selection_data_get_uris(GtkSelectionData *selection_data ) ;
#line 175
gboolean gtk_selection_data_get_targets(GtkSelectionData *selection_data , GdkAtom **targets ,
                                        gint *n_atoms ) ;
#line 178
gboolean gtk_selection_data_targets_include_text(GtkSelectionData *selection_data ) ;
#line 179
gboolean gtk_selection_data_targets_include_rich_text(GtkSelectionData *selection_data ,
                                                      GtkTextBuffer *buffer ) ;
#line 181
gboolean gtk_selection_data_targets_include_image(GtkSelectionData *selection_data ,
                                                  gboolean writable ) ;
#line 183
gboolean gtk_selection_data_targets_include_uri(GtkSelectionData *selection_data ) ;
#line 184
gboolean gtk_targets_include_text(GdkAtom *targets , gint n_targets ) ;
#line 186
gboolean gtk_targets_include_rich_text(GdkAtom *targets , gint n_targets , GtkTextBuffer *buffer ) ;
#line 189
gboolean gtk_targets_include_image(GdkAtom *targets , gint n_targets , gboolean writable ) ;
#line 192
gboolean gtk_targets_include_uri(GdkAtom *targets , gint n_targets ) ;
#line 197
void gtk_selection_remove_all(GtkWidget *widget ) ;
#line 201
gboolean gtk_selection_clear(GtkWidget *widget , GdkEventSelection *event ) ;
#line 204
gboolean _gtk_selection_request(GtkWidget *widget , GdkEventSelection *event ) ;
#line 206
gboolean _gtk_selection_incr_event(GdkWindow *window , GdkEventProperty *event ) ;
#line 208
gboolean _gtk_selection_notify(GtkWidget *widget , GdkEventSelection *event ) ;
#line 210
gboolean _gtk_selection_property_notify(GtkWidget *widget , GdkEventProperty *event ) ;
#line 213
GType gtk_selection_data_get_type(void) ;
#line 214
GtkSelectionData *gtk_selection_data_copy(GtkSelectionData *data ) ;
#line 215
void gtk_selection_data_free(GtkSelectionData *data ) ;
#line 217
GType gtk_target_list_get_type(void) ;
#line 70 "/usr/include/gtk-2.0/gtk/gtkclipboard.h"
GType gtk_clipboard_get_type(void) ;
#line 72
GtkClipboard *gtk_clipboard_get_for_display(GdkDisplay *display , GdkAtom selection ) ;
#line 75
GtkClipboard *gtk_clipboard_get(GdkAtom selection ) ;
#line 78
GdkDisplay *gtk_clipboard_get_display(GtkClipboard *clipboard ) ;
#line 81
gboolean gtk_clipboard_set_with_data(GtkClipboard *clipboard , GtkTargetEntry *targets ,
                                     guint n_targets , GtkClipboardGetFunc get_func ,
                                     GtkClipboardClearFunc clear_func , gpointer user_data ) ;
#line 87
gboolean gtk_clipboard_set_with_owner(GtkClipboard *clipboard , GtkTargetEntry *targets ,
                                      guint n_targets , GtkClipboardGetFunc get_func ,
                                      GtkClipboardClearFunc clear_func , GObject *owner ) ;
#line 93
GObject *gtk_clipboard_get_owner(GtkClipboard *clipboard ) ;
#line 94
void gtk_clipboard_clear(GtkClipboard *clipboard ) ;
#line 95
void gtk_clipboard_set_text(GtkClipboard *clipboard , gchar *text , gint len ) ;
#line 98
void gtk_clipboard_set_image(GtkClipboard *clipboard , GdkPixbuf *pixbuf ) ;
#line 101
void gtk_clipboard_request_contents(GtkClipboard *clipboard , GdkAtom target , GtkClipboardReceivedFunc callback ,
                                    gpointer user_data ) ;
#line 105
void gtk_clipboard_request_text(GtkClipboard *clipboard , GtkClipboardTextReceivedFunc callback ,
                                gpointer user_data ) ;
#line 108
void gtk_clipboard_request_rich_text(GtkClipboard *clipboard , GtkTextBuffer *buffer ,
                                     GtkClipboardRichTextReceivedFunc callback , gpointer user_data ) ;
#line 112
void gtk_clipboard_request_image(GtkClipboard *clipboard , GtkClipboardImageReceivedFunc callback ,
                                 gpointer user_data ) ;
#line 115
void gtk_clipboard_request_uris(GtkClipboard *clipboard , GtkClipboardURIReceivedFunc callback ,
                                gpointer user_data ) ;
#line 118
void gtk_clipboard_request_targets(GtkClipboard *clipboard , GtkClipboardTargetsReceivedFunc callback ,
                                   gpointer user_data ) ;
#line 122
GtkSelectionData *gtk_clipboard_wait_for_contents(GtkClipboard *clipboard , GdkAtom target ) ;
#line 124
gchar *gtk_clipboard_wait_for_text(GtkClipboard *clipboard ) ;
#line 125
guint8 *gtk_clipboard_wait_for_rich_text(GtkClipboard *clipboard , GtkTextBuffer *buffer ,
                                         GdkAtom *format , gsize *length ) ;
#line 129
GdkPixbuf *gtk_clipboard_wait_for_image(GtkClipboard *clipboard ) ;
#line 130
gchar **gtk_clipboard_wait_for_uris(GtkClipboard *clipboard ) ;
#line 131
gboolean gtk_clipboard_wait_for_targets(GtkClipboard *clipboard , GdkAtom **targets ,
                                        gint *n_targets ) ;
#line 135
gboolean gtk_clipboard_wait_is_text_available(GtkClipboard *clipboard ) ;
#line 136
gboolean gtk_clipboard_wait_is_rich_text_available(GtkClipboard *clipboard , GtkTextBuffer *buffer ) ;
#line 138
gboolean gtk_clipboard_wait_is_image_available(GtkClipboard *clipboard ) ;
#line 139
gboolean gtk_clipboard_wait_is_uris_available(GtkClipboard *clipboard ) ;
#line 140
gboolean gtk_clipboard_wait_is_target_available(GtkClipboard *clipboard , GdkAtom target ) ;
#line 144
void gtk_clipboard_set_can_store(GtkClipboard *clipboard , GtkTargetEntry *targets ,
                                 gint n_targets ) ;
#line 148
void gtk_clipboard_store(GtkClipboard *clipboard ) ;
#line 151
void _gtk_clipboard_handle_event(GdkEventOwnerChange *event ) ;
#line 153
void _gtk_clipboard_store_all(void) ;
#line 83 "/usr/include/gtk-2.0/gtk/gtkcolorbutton.h"
GType gtk_color_button_get_type(void) ;
#line 84
GtkWidget *gtk_color_button_new(void) ;
#line 85
GtkWidget *gtk_color_button_new_with_color(GdkColor *color ) ;
#line 86
void gtk_color_button_set_color(GtkColorButton *color_button , GdkColor *color ) ;
#line 88
void gtk_color_button_set_alpha(GtkColorButton *color_button , guint16 alpha ) ;
#line 90
void gtk_color_button_get_color(GtkColorButton *color_button , GdkColor *color ) ;
#line 92
guint16 gtk_color_button_get_alpha(GtkColorButton *color_button ) ;
#line 93
void gtk_color_button_set_use_alpha(GtkColorButton *color_button , gboolean use_alpha ) ;
#line 95
gboolean gtk_color_button_get_use_alpha(GtkColorButton *color_button ) ;
#line 96
void gtk_color_button_set_title(GtkColorButton *color_button , gchar *title ) ;
#line 98
gchar *gtk_color_button_get_title(GtkColorButton *color_button ) ;
#line 62 "/usr/include/gtk-2.0/gtk/gtkvbox.h"
GType gtk_vbox_get_type(void) ;
#line 63
GtkWidget *gtk_vbox_new(gboolean homogeneous , gint spacing ) ;
#line 82 "/usr/include/gtk-2.0/gtk/gtkcolorsel.h"
GType gtk_color_selection_get_type(void) ;
#line 83
GtkWidget *gtk_color_selection_new(void) ;
#line 84
gboolean gtk_color_selection_get_has_opacity_control(GtkColorSelection *colorsel ) ;
#line 85
void gtk_color_selection_set_has_opacity_control(GtkColorSelection *colorsel , gboolean has_opacity ) ;
#line 87
gboolean gtk_color_selection_get_has_palette(GtkColorSelection *colorsel ) ;
#line 88
void gtk_color_selection_set_has_palette(GtkColorSelection *colorsel , gboolean has_palette ) ;
#line 92
void gtk_color_selection_set_current_color(GtkColorSelection *colorsel , GdkColor *color ) ;
#line 94
void gtk_color_selection_set_current_alpha(GtkColorSelection *colorsel , guint16 alpha ) ;
#line 96
void gtk_color_selection_get_current_color(GtkColorSelection *colorsel , GdkColor *color ) ;
#line 98
guint16 gtk_color_selection_get_current_alpha(GtkColorSelection *colorsel ) ;
#line 99
void gtk_color_selection_set_previous_color(GtkColorSelection *colorsel , GdkColor *color ) ;
#line 101
void gtk_color_selection_set_previous_alpha(GtkColorSelection *colorsel , guint16 alpha ) ;
#line 103
void gtk_color_selection_get_previous_color(GtkColorSelection *colorsel , GdkColor *color ) ;
#line 105
guint16 gtk_color_selection_get_previous_alpha(GtkColorSelection *colorsel ) ;
#line 107
gboolean gtk_color_selection_is_adjusting(GtkColorSelection *colorsel ) ;
#line 109
gboolean gtk_color_selection_palette_from_string(gchar *str , GdkColor **colors ,
                                                 gint *n_colors ) ;
#line 112
gchar *gtk_color_selection_palette_to_string(GdkColor *colors , gint n_colors ) ;
#line 117
GtkColorSelectionChangePaletteFunc gtk_color_selection_set_change_palette_hook(GtkColorSelectionChangePaletteFunc func ) ;
#line 121
GtkColorSelectionChangePaletteWithScreenFunc gtk_color_selection_set_change_palette_with_screen_hook(GtkColorSelectionChangePaletteWithScreenFunc func ) ;
#line 125
void gtk_color_selection_set_color(GtkColorSelection *colorsel , gdouble *color ) ;
#line 127
void gtk_color_selection_get_color(GtkColorSelection *colorsel , gdouble *color ) ;
#line 129
void gtk_color_selection_set_update_policy(GtkColorSelection *colorsel , GtkUpdateType policy ) ;
#line 75 "/usr/include/gtk-2.0/gtk/gtkcolorseldialog.h"
GType gtk_color_selection_dialog_get_type(void) ;
#line 76
GtkWidget *gtk_color_selection_dialog_new(gchar *title ) ;
#line 77
GtkWidget *gtk_color_selection_dialog_get_color_selection(GtkColorSelectionDialog *colorsel ) ;
#line 60 "/usr/include/gtk-2.0/gtk/gtkdnd.h"
void gtk_drag_get_data(GtkWidget *widget , GdkDragContext *context , GdkAtom target ,
                       guint32 time_ ) ;
#line 64
void gtk_drag_finish(GdkDragContext *context , gboolean success , gboolean del , guint32 time_ ) ;
#line 69
GtkWidget *gtk_drag_get_source_widget(GdkDragContext *context ) ;
#line 71
void gtk_drag_highlight(GtkWidget *widget ) ;
#line 72
void gtk_drag_unhighlight(GtkWidget *widget ) ;
#line 74
void gtk_drag_dest_set(GtkWidget *widget , GtkDestDefaults flags , GtkTargetEntry *targets ,
                       gint n_targets , GdkDragAction actions ) ;
#line 80
void gtk_drag_dest_set_proxy(GtkWidget *widget , GdkWindow *proxy_window , GdkDragProtocol protocol ,
                             gboolean use_coordinates ) ;
#line 85
void gtk_drag_dest_unset(GtkWidget *widget ) ;
#line 87
GdkAtom gtk_drag_dest_find_target(GtkWidget *widget , GdkDragContext *context , GtkTargetList *target_list ) ;
#line 90
GtkTargetList *gtk_drag_dest_get_target_list(GtkWidget *widget ) ;
#line 91
void gtk_drag_dest_set_target_list(GtkWidget *widget , GtkTargetList *target_list ) ;
#line 93
void gtk_drag_dest_add_text_targets(GtkWidget *widget ) ;
#line 94
void gtk_drag_dest_add_image_targets(GtkWidget *widget ) ;
#line 95
void gtk_drag_dest_add_uri_targets(GtkWidget *widget ) ;
#line 97
void gtk_drag_dest_set_track_motion(GtkWidget *widget , gboolean track_motion ) ;
#line 99
gboolean gtk_drag_dest_get_track_motion(GtkWidget *widget ) ;
#line 103
void gtk_drag_source_set(GtkWidget *widget , GdkModifierType start_button_mask , GtkTargetEntry *targets ,
                         gint n_targets , GdkDragAction actions ) ;
#line 109
void gtk_drag_source_unset(GtkWidget *widget ) ;
#line 111
GtkTargetList *gtk_drag_source_get_target_list(GtkWidget *widget ) ;
#line 112
void gtk_drag_source_set_target_list(GtkWidget *widget , GtkTargetList *target_list ) ;
#line 114
void gtk_drag_source_add_text_targets(GtkWidget *widget ) ;
#line 115
void gtk_drag_source_add_image_targets(GtkWidget *widget ) ;
#line 116
void gtk_drag_source_add_uri_targets(GtkWidget *widget ) ;
#line 118
void gtk_drag_source_set_icon(GtkWidget *widget , GdkColormap *colormap , GdkPixmap *pixmap ,
                              GdkBitmap *mask ) ;
#line 122
void gtk_drag_source_set_icon_pixbuf(GtkWidget *widget , GdkPixbuf *pixbuf ) ;
#line 124
void gtk_drag_source_set_icon_stock(GtkWidget *widget , gchar *stock_id ) ;
#line 126
void gtk_drag_source_set_icon_name(GtkWidget *widget , gchar *icon_name ) ;
#line 133
GdkDragContext *gtk_drag_begin(GtkWidget *widget , GtkTargetList *targets , GdkDragAction actions ,
                               gint button , GdkEvent *event ) ;
#line 141
void gtk_drag_set_icon_widget(GdkDragContext *context , GtkWidget *widget , gint hot_x ,
                              gint hot_y ) ;
#line 145
void gtk_drag_set_icon_pixmap(GdkDragContext *context , GdkColormap *colormap , GdkPixmap *pixmap ,
                              GdkBitmap *mask , gint hot_x , gint hot_y ) ;
#line 151
void gtk_drag_set_icon_pixbuf(GdkDragContext *context , GdkPixbuf *pixbuf , gint hot_x ,
                              gint hot_y ) ;
#line 155
void gtk_drag_set_icon_stock(GdkDragContext *context , gchar *stock_id , gint hot_x ,
                             gint hot_y ) ;
#line 159
void gtk_drag_set_icon_name(GdkDragContext *context , gchar *icon_name , gint hot_x ,
                            gint hot_y ) ;
#line 164
void gtk_drag_set_icon_default(GdkDragContext *context ) ;
#line 166
gboolean gtk_drag_check_threshold(GtkWidget *widget , gint start_x , gint start_y ,
                                  gint current_x , gint current_y ) ;
#line 173
void _gtk_drag_source_handle_event(GtkWidget *widget , GdkEvent *event ) ;
#line 175
void _gtk_drag_dest_handle_event(GtkWidget *toplevel , GdkEvent *event ) ;
#line 179
void gtk_drag_set_default_icon(GdkColormap *colormap , GdkPixmap *pixmap , GdkBitmap *mask ,
                               gint hot_x , gint hot_y ) ;
#line 87 "/usr/include/gtk-2.0/gtk/gtkeditable.h"
GType gtk_editable_get_type(void) ;
#line 88
void gtk_editable_select_region(GtkEditable *editable , gint start_pos , gint end_pos ) ;
#line 91
gboolean gtk_editable_get_selection_bounds(GtkEditable *editable , gint *start_pos ,
                                           gint *end_pos ) ;
#line 94
void gtk_editable_insert_text(GtkEditable *editable , gchar *new_text , gint new_text_length ,
                              gint *position ) ;
#line 98
void gtk_editable_delete_text(GtkEditable *editable , gint start_pos , gint end_pos ) ;
#line 101
gchar *gtk_editable_get_chars(GtkEditable *editable , gint start_pos , gint end_pos ) ;
#line 104
void gtk_editable_cut_clipboard(GtkEditable *editable ) ;
#line 105
void gtk_editable_copy_clipboard(GtkEditable *editable ) ;
#line 106
void gtk_editable_paste_clipboard(GtkEditable *editable ) ;
#line 107
void gtk_editable_delete_selection(GtkEditable *editable ) ;
#line 108
void gtk_editable_set_position(GtkEditable *editable , gint position ) ;
#line 110
gint gtk_editable_get_position(GtkEditable *editable ) ;
#line 111
void gtk_editable_set_editable(GtkEditable *editable , gboolean is_editable ) ;
#line 113
gboolean gtk_editable_get_editable(GtkEditable *editable ) ;
#line 102 "/usr/include/gtk-2.0/gtk/gtkimcontext.h"
GType gtk_im_context_get_type(void) ;
#line 104
void gtk_im_context_set_client_window(GtkIMContext *context , GdkWindow *window ) ;
#line 106
void gtk_im_context_get_preedit_string(GtkIMContext *context , gchar **str , PangoAttrList **attrs ,
                                       gint *cursor_pos ) ;
#line 110
gboolean gtk_im_context_filter_keypress(GtkIMContext *context , GdkEventKey *event ) ;
#line 112
void gtk_im_context_focus_in(GtkIMContext *context ) ;
#line 113
void gtk_im_context_focus_out(GtkIMContext *context ) ;
#line 114
void gtk_im_context_reset(GtkIMContext *context ) ;
#line 115
void gtk_im_context_set_cursor_location(GtkIMContext *context , GdkRectangle *area ) ;
#line 117
void gtk_im_context_set_use_preedit(GtkIMContext *context , gboolean use_preedit ) ;
#line 119
void gtk_im_context_set_surrounding(GtkIMContext *context , gchar *text , gint len ,
                                    gint cursor_index ) ;
#line 123
gboolean gtk_im_context_get_surrounding(GtkIMContext *context , gchar **text , gint *cursor_index ) ;
#line 126
gboolean gtk_im_context_delete_surrounding(GtkIMContext *context , gint offset , gint n_chars ) ;
#line 93 "/usr/include/gtk-2.0/gtk/gtkentrybuffer.h"
GType gtk_entry_buffer_get_type(void) ;
#line 95
GtkEntryBuffer *gtk_entry_buffer_new(gchar *initial_chars , gint n_initial_chars ) ;
#line 98
gsize gtk_entry_buffer_get_bytes(GtkEntryBuffer *buffer ) ;
#line 100
guint gtk_entry_buffer_get_length(GtkEntryBuffer *buffer ) ;
#line 102
gchar *gtk_entry_buffer_get_text(GtkEntryBuffer *buffer ) ;
#line 104
void gtk_entry_buffer_set_text(GtkEntryBuffer *buffer , gchar *chars , gint n_chars ) ;
#line 108
void gtk_entry_buffer_set_max_length(GtkEntryBuffer *buffer , gint max_length ) ;
#line 111
gint gtk_entry_buffer_get_max_length(GtkEntryBuffer *buffer ) ;
#line 113
guint gtk_entry_buffer_insert_text(GtkEntryBuffer *buffer , guint position , gchar *chars ,
                                   gint n_chars ) ;
#line 118
guint gtk_entry_buffer_delete_text(GtkEntryBuffer *buffer , guint position , gint n_chars ) ;
#line 122
void gtk_entry_buffer_emit_inserted_text(GtkEntryBuffer *buffer , guint position ,
                                         gchar *chars , guint n_chars ) ;
#line 127
void gtk_entry_buffer_emit_deleted_text(GtkEntryBuffer *buffer , guint position ,
                                        guint n_chars ) ;
#line 77 "/usr/include/gtk-2.0/gtk/gtkliststore.h"
GType gtk_list_store_get_type(void) ;
#line 78
GtkListStore *gtk_list_store_new(gint n_columns  , ...) ;
#line 80
GtkListStore *gtk_list_store_newv(gint n_columns , GType *types ) ;
#line 82
void gtk_list_store_set_column_types(GtkListStore *list_store , gint n_columns , GType *types ) ;
#line 88
void gtk_list_store_set_value(GtkListStore *list_store , GtkTreeIter *iter , gint column ,
                              GValue *value ) ;
#line 92
void gtk_list_store_set(GtkListStore *list_store , GtkTreeIter *iter  , ...) ;
#line 95
void gtk_list_store_set_valuesv(GtkListStore *list_store , GtkTreeIter *iter , gint *columns ,
                                GValue *values , gint n_values ) ;
#line 100
void gtk_list_store_set_valist(GtkListStore *list_store , GtkTreeIter *iter , va_list var_args ) ;
#line 103
gboolean gtk_list_store_remove(GtkListStore *list_store , GtkTreeIter *iter ) ;
#line 105
void gtk_list_store_insert(GtkListStore *list_store , GtkTreeIter *iter , gint position ) ;
#line 108
void gtk_list_store_insert_before(GtkListStore *list_store , GtkTreeIter *iter , GtkTreeIter *sibling ) ;
#line 111
void gtk_list_store_insert_after(GtkListStore *list_store , GtkTreeIter *iter , GtkTreeIter *sibling ) ;
#line 114
void gtk_list_store_insert_with_values(GtkListStore *list_store , GtkTreeIter *iter ,
                                       gint position  , ...) ;
#line 118
void gtk_list_store_insert_with_valuesv(GtkListStore *list_store , GtkTreeIter *iter ,
                                        gint position , gint *columns , GValue *values ,
                                        gint n_values ) ;
#line 124
void gtk_list_store_prepend(GtkListStore *list_store , GtkTreeIter *iter ) ;
#line 126
void gtk_list_store_append(GtkListStore *list_store , GtkTreeIter *iter ) ;
#line 128
void gtk_list_store_clear(GtkListStore *list_store ) ;
#line 129
gboolean gtk_list_store_iter_is_valid(GtkListStore *list_store , GtkTreeIter *iter ) ;
#line 131
void gtk_list_store_reorder(GtkListStore *store , gint *new_order ) ;
#line 133
void gtk_list_store_swap(GtkListStore *store , GtkTreeIter *a , GtkTreeIter *b ) ;
#line 136
void gtk_list_store_move_after(GtkListStore *store , GtkTreeIter *iter , GtkTreeIter *position ) ;
#line 139
void gtk_list_store_move_before(GtkListStore *store , GtkTreeIter *iter , GtkTreeIter *position ) ;
#line 73 "/usr/include/gtk-2.0/gtk/gtktreemodelfilter.h"
GType gtk_tree_model_filter_get_type(void) ;
#line 74
GtkTreeModel *gtk_tree_model_filter_new(GtkTreeModel *child_model , GtkTreePath *root ) ;
#line 76
void gtk_tree_model_filter_set_visible_func(GtkTreeModelFilter *filter , GtkTreeModelFilterVisibleFunc func ,
                                            gpointer data , GDestroyNotify destroy ) ;
#line 80
void gtk_tree_model_filter_set_modify_func(GtkTreeModelFilter *filter , gint n_columns ,
                                           GType *types , GtkTreeModelFilterModifyFunc func ,
                                           gpointer data , GDestroyNotify destroy ) ;
#line 86
void gtk_tree_model_filter_set_visible_column(GtkTreeModelFilter *filter , gint column ) ;
#line 89
GtkTreeModel *gtk_tree_model_filter_get_model(GtkTreeModelFilter *filter ) ;
#line 92
gboolean gtk_tree_model_filter_convert_child_iter_to_iter(GtkTreeModelFilter *filter ,
                                                          GtkTreeIter *filter_iter ,
                                                          GtkTreeIter *child_iter ) ;
#line 95
void gtk_tree_model_filter_convert_iter_to_child_iter(GtkTreeModelFilter *filter ,
                                                      GtkTreeIter *child_iter , GtkTreeIter *filter_iter ) ;
#line 98
GtkTreePath *gtk_tree_model_filter_convert_child_path_to_path(GtkTreeModelFilter *filter ,
                                                              GtkTreePath *child_path ) ;
#line 100
GtkTreePath *gtk_tree_model_filter_convert_path_to_child_path(GtkTreeModelFilter *filter ,
                                                              GtkTreePath *filter_path ) ;
#line 104
void gtk_tree_model_filter_refilter(GtkTreeModelFilter *filter ) ;
#line 105
void gtk_tree_model_filter_clear_cache(GtkTreeModelFilter *filter ) ;
#line 80 "/usr/include/gtk-2.0/gtk/gtkentrycompletion.h"
GType gtk_entry_completion_get_type(void) ;
#line 81
GtkEntryCompletion *gtk_entry_completion_new(void) ;
#line 83
GtkWidget *gtk_entry_completion_get_entry(GtkEntryCompletion *completion ) ;
#line 85
void gtk_entry_completion_set_model(GtkEntryCompletion *completion , GtkTreeModel *model ) ;
#line 87
GtkTreeModel *gtk_entry_completion_get_model(GtkEntryCompletion *completion ) ;
#line 89
void gtk_entry_completion_set_match_func(GtkEntryCompletion *completion , GtkEntryCompletionMatchFunc func ,
                                         gpointer func_data , GDestroyNotify func_notify ) ;
#line 93
void gtk_entry_completion_set_minimum_key_length(GtkEntryCompletion *completion ,
                                                 gint length ) ;
#line 95
gint gtk_entry_completion_get_minimum_key_length(GtkEntryCompletion *completion ) ;
#line 96
void gtk_entry_completion_complete(GtkEntryCompletion *completion ) ;
#line 97
void gtk_entry_completion_insert_prefix(GtkEntryCompletion *completion ) ;
#line 99
void gtk_entry_completion_insert_action_text(GtkEntryCompletion *completion , gint index_ ,
                                             gchar *text ) ;
#line 102
void gtk_entry_completion_insert_action_markup(GtkEntryCompletion *completion , gint index_ ,
                                               gchar *markup ) ;
#line 105
void gtk_entry_completion_delete_action(GtkEntryCompletion *completion , gint index_ ) ;
#line 108
void gtk_entry_completion_set_inline_completion(GtkEntryCompletion *completion , gboolean inline_completion ) ;
#line 110
gboolean gtk_entry_completion_get_inline_completion(GtkEntryCompletion *completion ) ;
#line 111
void gtk_entry_completion_set_inline_selection(GtkEntryCompletion *completion , gboolean inline_selection ) ;
#line 113
gboolean gtk_entry_completion_get_inline_selection(GtkEntryCompletion *completion ) ;
#line 114
void gtk_entry_completion_set_popup_completion(GtkEntryCompletion *completion , gboolean popup_completion ) ;
#line 116
gboolean gtk_entry_completion_get_popup_completion(GtkEntryCompletion *completion ) ;
#line 117
void gtk_entry_completion_set_popup_set_width(GtkEntryCompletion *completion , gboolean popup_set_width ) ;
#line 119
gboolean gtk_entry_completion_get_popup_set_width(GtkEntryCompletion *completion ) ;
#line 120
void gtk_entry_completion_set_popup_single_match(GtkEntryCompletion *completion ,
                                                 gboolean popup_single_match ) ;
#line 122
gboolean gtk_entry_completion_get_popup_single_match(GtkEntryCompletion *completion ) ;
#line 124
gchar *gtk_entry_completion_get_completion_prefix(GtkEntryCompletion *completion ) ;
#line 126
void gtk_entry_completion_set_text_column(GtkEntryCompletion *completion , gint column ) ;
#line 128
gint gtk_entry_completion_get_text_column(GtkEntryCompletion *completion ) ;
#line 166 "/usr/include/gtk-2.0/gtk/gtkentry.h"
GType gtk_entry_get_type(void) ;
#line 167
GtkWidget *gtk_entry_new(void) ;
#line 168
GtkWidget *gtk_entry_new_with_buffer(GtkEntryBuffer *buffer ) ;
#line 170
GtkEntryBuffer *gtk_entry_get_buffer(GtkEntry *entry ) ;
#line 171
void gtk_entry_set_buffer(GtkEntry *entry , GtkEntryBuffer *buffer ) ;
#line 174
GdkWindow *gtk_entry_get_text_window(GtkEntry *entry ) ;
#line 176
void gtk_entry_set_visibility(GtkEntry *entry , gboolean visible ) ;
#line 178
gboolean gtk_entry_get_visibility(GtkEntry *entry ) ;
#line 180
void gtk_entry_set_invisible_char(GtkEntry *entry , gunichar ch ) ;
#line 182
gunichar gtk_entry_get_invisible_char(GtkEntry *entry ) ;
#line 183
void gtk_entry_unset_invisible_char(GtkEntry *entry ) ;
#line 185
void gtk_entry_set_has_frame(GtkEntry *entry , gboolean setting ) ;
#line 187
gboolean gtk_entry_get_has_frame(GtkEntry *entry ) ;
#line 189
void gtk_entry_set_inner_border(GtkEntry *entry , GtkBorder *border ) ;
#line 191
GtkBorder *gtk_entry_get_inner_border(GtkEntry *entry ) ;
#line 193
void gtk_entry_set_overwrite_mode(GtkEntry *entry , gboolean overwrite ) ;
#line 195
gboolean gtk_entry_get_overwrite_mode(GtkEntry *entry ) ;
#line 198
void gtk_entry_set_max_length(GtkEntry *entry , gint max ) ;
#line 200
gint gtk_entry_get_max_length(GtkEntry *entry ) ;
#line 201
guint16 gtk_entry_get_text_length(GtkEntry *entry ) ;
#line 203
void gtk_entry_set_activates_default(GtkEntry *entry , gboolean setting ) ;
#line 205
gboolean gtk_entry_get_activates_default(GtkEntry *entry ) ;
#line 207
void gtk_entry_set_width_chars(GtkEntry *entry , gint n_chars ) ;
#line 209
gint gtk_entry_get_width_chars(GtkEntry *entry ) ;
#line 213
void gtk_entry_set_text(GtkEntry *entry , gchar *text ) ;
#line 216
gchar *gtk_entry_get_text(GtkEntry *entry ) ;
#line 218
PangoLayout *gtk_entry_get_layout(GtkEntry *entry ) ;
#line 219
void gtk_entry_get_layout_offsets(GtkEntry *entry , gint *x , gint *y ) ;
#line 222
void gtk_entry_set_alignment(GtkEntry *entry , gfloat xalign ) ;
#line 224
gfloat gtk_entry_get_alignment(GtkEntry *entry ) ;
#line 226
void gtk_entry_set_completion(GtkEntry *entry , GtkEntryCompletion *completion ) ;
#line 228
GtkEntryCompletion *gtk_entry_get_completion(GtkEntry *entry ) ;
#line 230
gint gtk_entry_layout_index_to_text_index(GtkEntry *entry , gint layout_index ) ;
#line 232
gint gtk_entry_text_index_to_layout_index(GtkEntry *entry , gint text_index ) ;
#line 237
void gtk_entry_set_cursor_hadjustment(GtkEntry *entry , GtkAdjustment *adjustment ) ;
#line 239
GtkAdjustment *gtk_entry_get_cursor_hadjustment(GtkEntry *entry ) ;
#line 243
void gtk_entry_set_progress_fraction(GtkEntry *entry , gdouble fraction ) ;
#line 245
gdouble gtk_entry_get_progress_fraction(GtkEntry *entry ) ;
#line 247
void gtk_entry_set_progress_pulse_step(GtkEntry *entry , gdouble fraction ) ;
#line 249
gdouble gtk_entry_get_progress_pulse_step(GtkEntry *entry ) ;
#line 251
void gtk_entry_progress_pulse(GtkEntry *entry ) ;
#line 255
void gtk_entry_set_icon_from_pixbuf(GtkEntry *entry , GtkEntryIconPosition icon_pos ,
                                    GdkPixbuf *pixbuf ) ;
#line 258
void gtk_entry_set_icon_from_stock(GtkEntry *entry , GtkEntryIconPosition icon_pos ,
                                   gchar *stock_id ) ;
#line 261
void gtk_entry_set_icon_from_icon_name(GtkEntry *entry , GtkEntryIconPosition icon_pos ,
                                       gchar *icon_name ) ;
#line 264
void gtk_entry_set_icon_from_gicon(GtkEntry *entry , GtkEntryIconPosition icon_pos ,
                                   GIcon *icon ) ;
#line 267
GtkImageType gtk_entry_get_icon_storage_type(GtkEntry *entry , GtkEntryIconPosition icon_pos ) ;
#line 269
GdkPixbuf *gtk_entry_get_icon_pixbuf(GtkEntry *entry , GtkEntryIconPosition icon_pos ) ;
#line 271
gchar *gtk_entry_get_icon_stock(GtkEntry *entry , GtkEntryIconPosition icon_pos ) ;
#line 273
gchar *gtk_entry_get_icon_name(GtkEntry *entry , GtkEntryIconPosition icon_pos ) ;
#line 275
GIcon *gtk_entry_get_icon_gicon(GtkEntry *entry , GtkEntryIconPosition icon_pos ) ;
#line 277
void gtk_entry_set_icon_activatable(GtkEntry *entry , GtkEntryIconPosition icon_pos ,
                                    gboolean activatable ) ;
#line 280
gboolean gtk_entry_get_icon_activatable(GtkEntry *entry , GtkEntryIconPosition icon_pos ) ;
#line 282
void gtk_entry_set_icon_sensitive(GtkEntry *entry , GtkEntryIconPosition icon_pos ,
                                  gboolean sensitive ) ;
#line 285
gboolean gtk_entry_get_icon_sensitive(GtkEntry *entry , GtkEntryIconPosition icon_pos ) ;
#line 287
gint gtk_entry_get_icon_at_pos(GtkEntry *entry , gint x , gint y ) ;
#line 290
void gtk_entry_set_icon_tooltip_text(GtkEntry *entry , GtkEntryIconPosition icon_pos ,
                                     gchar *tooltip ) ;
#line 293
gchar *gtk_entry_get_icon_tooltip_text(GtkEntry *entry , GtkEntryIconPosition icon_pos ) ;
#line 295
void gtk_entry_set_icon_tooltip_markup(GtkEntry *entry , GtkEntryIconPosition icon_pos ,
                                       gchar *tooltip ) ;
#line 298
gchar *gtk_entry_get_icon_tooltip_markup(GtkEntry *entry , GtkEntryIconPosition icon_pos ) ;
#line 300
void gtk_entry_set_icon_drag_source(GtkEntry *entry , GtkEntryIconPosition icon_pos ,
                                    GtkTargetList *target_list , GdkDragAction actions ) ;
#line 304
gint gtk_entry_get_current_icon_drag_source(GtkEntry *entry ) ;
#line 306
GdkWindow *gtk_entry_get_icon_window(GtkEntry *entry , GtkEntryIconPosition icon_pos ) ;
#line 309
gboolean gtk_entry_im_context_filter_keypress(GtkEntry *entry , GdkEventKey *event ) ;
#line 311
void gtk_entry_reset_im_context(GtkEntry *entry ) ;
#line 318
GtkWidget *gtk_entry_new_with_max_length(gint max ) ;
#line 319
void gtk_entry_append_text(GtkEntry *entry , gchar *text ) ;
#line 321
void gtk_entry_prepend_text(GtkEntry *entry , gchar *text ) ;
#line 323
void gtk_entry_set_position(GtkEntry *entry , gint position ) ;
#line 325
void gtk_entry_select_region(GtkEntry *entry , gint start , gint end ) ;
#line 328
void gtk_entry_set_editable(GtkEntry *entry , gboolean editable ) ;
#line 140 "/usr/include/gtk-2.0/gtk/gtktreeview.h"
GType gtk_tree_view_get_type(void) ;
#line 141
GtkWidget *gtk_tree_view_new(void) ;
#line 142
GtkWidget *gtk_tree_view_new_with_model(GtkTreeModel *model ) ;
#line 145
GtkTreeModel *gtk_tree_view_get_model(GtkTreeView *tree_view ) ;
#line 146
void gtk_tree_view_set_model(GtkTreeView *tree_view , GtkTreeModel *model ) ;
#line 148
GtkTreeSelection *gtk_tree_view_get_selection(GtkTreeView *tree_view ) ;
#line 149
GtkAdjustment *gtk_tree_view_get_hadjustment(GtkTreeView *tree_view ) ;
#line 150
void gtk_tree_view_set_hadjustment(GtkTreeView *tree_view , GtkAdjustment *adjustment ) ;
#line 152
GtkAdjustment *gtk_tree_view_get_vadjustment(GtkTreeView *tree_view ) ;
#line 153
void gtk_tree_view_set_vadjustment(GtkTreeView *tree_view , GtkAdjustment *adjustment ) ;
#line 155
gboolean gtk_tree_view_get_headers_visible(GtkTreeView *tree_view ) ;
#line 156
void gtk_tree_view_set_headers_visible(GtkTreeView *tree_view , gboolean headers_visible ) ;
#line 158
void gtk_tree_view_columns_autosize(GtkTreeView *tree_view ) ;
#line 159
gboolean gtk_tree_view_get_headers_clickable(GtkTreeView *tree_view ) ;
#line 160
void gtk_tree_view_set_headers_clickable(GtkTreeView *tree_view , gboolean setting ) ;
#line 162
void gtk_tree_view_set_rules_hint(GtkTreeView *tree_view , gboolean setting ) ;
#line 164
gboolean gtk_tree_view_get_rules_hint(GtkTreeView *tree_view ) ;
#line 167
gint gtk_tree_view_append_column(GtkTreeView *tree_view , GtkTreeViewColumn *column ) ;
#line 169
gint gtk_tree_view_remove_column(GtkTreeView *tree_view , GtkTreeViewColumn *column ) ;
#line 171
gint gtk_tree_view_insert_column(GtkTreeView *tree_view , GtkTreeViewColumn *column ,
                                 gint position ) ;
#line 174
gint gtk_tree_view_insert_column_with_attributes(GtkTreeView *tree_view , gint position ,
                                                 gchar *title , GtkCellRenderer *cell 
                                                 , ...) ;
#line 179
gint gtk_tree_view_insert_column_with_data_func(GtkTreeView *tree_view , gint position ,
                                                gchar *title , GtkCellRenderer *cell ,
                                                GtkTreeCellDataFunc func , gpointer data ,
                                                GDestroyNotify dnotify ) ;
#line 186
GtkTreeViewColumn *gtk_tree_view_get_column(GtkTreeView *tree_view , gint n ) ;
#line 188
GList *gtk_tree_view_get_columns(GtkTreeView *tree_view ) ;
#line 189
void gtk_tree_view_move_column_after(GtkTreeView *tree_view , GtkTreeViewColumn *column ,
                                     GtkTreeViewColumn *base_column ) ;
#line 192
void gtk_tree_view_set_expander_column(GtkTreeView *tree_view , GtkTreeViewColumn *column ) ;
#line 194
GtkTreeViewColumn *gtk_tree_view_get_expander_column(GtkTreeView *tree_view ) ;
#line 195
void gtk_tree_view_set_column_drag_function(GtkTreeView *tree_view , GtkTreeViewColumnDropFunc func ,
                                            gpointer user_data , GDestroyNotify destroy ) ;
#line 201
void gtk_tree_view_scroll_to_point(GtkTreeView *tree_view , gint tree_x , gint tree_y ) ;
#line 204
void gtk_tree_view_scroll_to_cell(GtkTreeView *tree_view , GtkTreePath *path , GtkTreeViewColumn *column ,
                                  gboolean use_align , gfloat row_align , gfloat col_align ) ;
#line 210
void gtk_tree_view_row_activated(GtkTreeView *tree_view , GtkTreePath *path , GtkTreeViewColumn *column ) ;
#line 213
void gtk_tree_view_expand_all(GtkTreeView *tree_view ) ;
#line 214
void gtk_tree_view_collapse_all(GtkTreeView *tree_view ) ;
#line 215
void gtk_tree_view_expand_to_path(GtkTreeView *tree_view , GtkTreePath *path ) ;
#line 217
gboolean gtk_tree_view_expand_row(GtkTreeView *tree_view , GtkTreePath *path , gboolean open_all ) ;
#line 220
gboolean gtk_tree_view_collapse_row(GtkTreeView *tree_view , GtkTreePath *path ) ;
#line 222
void gtk_tree_view_map_expanded_rows(GtkTreeView *tree_view , GtkTreeViewMappingFunc func ,
                                     gpointer data ) ;
#line 225
gboolean gtk_tree_view_row_expanded(GtkTreeView *tree_view , GtkTreePath *path ) ;
#line 227
void gtk_tree_view_set_reorderable(GtkTreeView *tree_view , gboolean reorderable ) ;
#line 229
gboolean gtk_tree_view_get_reorderable(GtkTreeView *tree_view ) ;
#line 230
void gtk_tree_view_set_cursor(GtkTreeView *tree_view , GtkTreePath *path , GtkTreeViewColumn *focus_column ,
                              gboolean start_editing ) ;
#line 234
void gtk_tree_view_set_cursor_on_cell(GtkTreeView *tree_view , GtkTreePath *path ,
                                      GtkTreeViewColumn *focus_column , GtkCellRenderer *focus_cell ,
                                      gboolean start_editing ) ;
#line 239
void gtk_tree_view_get_cursor(GtkTreeView *tree_view , GtkTreePath **path , GtkTreeViewColumn **focus_column ) ;
#line 245
GdkWindow *gtk_tree_view_get_bin_window(GtkTreeView *tree_view ) ;
#line 246
gboolean gtk_tree_view_get_path_at_pos(GtkTreeView *tree_view , gint x , gint y ,
                                       GtkTreePath **path , GtkTreeViewColumn **column ,
                                       gint *cell_x , gint *cell_y ) ;
#line 253
void gtk_tree_view_get_cell_area(GtkTreeView *tree_view , GtkTreePath *path , GtkTreeViewColumn *column ,
                                 GdkRectangle *rect ) ;
#line 257
void gtk_tree_view_get_background_area(GtkTreeView *tree_view , GtkTreePath *path ,
                                       GtkTreeViewColumn *column , GdkRectangle *rect ) ;
#line 261
void gtk_tree_view_get_visible_rect(GtkTreeView *tree_view , GdkRectangle *visible_rect ) ;
#line 265
void gtk_tree_view_widget_to_tree_coords(GtkTreeView *tree_view , gint wx , gint wy ,
                                         gint *tx , gint *ty ) ;
#line 270
void gtk_tree_view_tree_to_widget_coords(GtkTreeView *tree_view , gint tx , gint ty ,
                                         gint *wx , gint *wy ) ;
#line 276
gboolean gtk_tree_view_get_visible_range(GtkTreeView *tree_view , GtkTreePath **start_path ,
                                         GtkTreePath **end_path ) ;
#line 281
void gtk_tree_view_enable_model_drag_source(GtkTreeView *tree_view , GdkModifierType start_button_mask ,
                                            GtkTargetEntry *targets , gint n_targets ,
                                            GdkDragAction actions ) ;
#line 286
void gtk_tree_view_enable_model_drag_dest(GtkTreeView *tree_view , GtkTargetEntry *targets ,
                                          gint n_targets , GdkDragAction actions ) ;
#line 290
void gtk_tree_view_unset_rows_drag_source(GtkTreeView *tree_view ) ;
#line 291
void gtk_tree_view_unset_rows_drag_dest(GtkTreeView *tree_view ) ;
#line 295
void gtk_tree_view_set_drag_dest_row(GtkTreeView *tree_view , GtkTreePath *path ,
                                     GtkTreeViewDropPosition pos ) ;
#line 298
void gtk_tree_view_get_drag_dest_row(GtkTreeView *tree_view , GtkTreePath **path ,
                                     GtkTreeViewDropPosition *pos ) ;
#line 301
gboolean gtk_tree_view_get_dest_row_at_pos(GtkTreeView *tree_view , gint drag_x ,
                                           gint drag_y , GtkTreePath **path , GtkTreeViewDropPosition *pos ) ;
#line 306
GdkPixmap *gtk_tree_view_create_row_drag_icon(GtkTreeView *tree_view , GtkTreePath *path ) ;
#line 310
void gtk_tree_view_set_enable_search(GtkTreeView *tree_view , gboolean enable_search ) ;
#line 312
gboolean gtk_tree_view_get_enable_search(GtkTreeView *tree_view ) ;
#line 313
gint gtk_tree_view_get_search_column(GtkTreeView *tree_view ) ;
#line 314
void gtk_tree_view_set_search_column(GtkTreeView *tree_view , gint column ) ;
#line 316
GtkTreeViewSearchEqualFunc gtk_tree_view_get_search_equal_func(GtkTreeView *tree_view ) ;
#line 317
void gtk_tree_view_set_search_equal_func(GtkTreeView *tree_view , GtkTreeViewSearchEqualFunc search_equal_func ,
                                         gpointer search_user_data , GDestroyNotify search_destroy ) ;
#line 322
GtkEntry *gtk_tree_view_get_search_entry(GtkTreeView *tree_view ) ;
#line 323
void gtk_tree_view_set_search_entry(GtkTreeView *tree_view , GtkEntry *entry ) ;
#line 325
GtkTreeViewSearchPositionFunc gtk_tree_view_get_search_position_func(GtkTreeView *tree_view ) ;
#line 326
void gtk_tree_view_set_search_position_func(GtkTreeView *tree_view , GtkTreeViewSearchPositionFunc func ,
                                            gpointer data , GDestroyNotify destroy ) ;
#line 332
void gtk_tree_view_convert_widget_to_tree_coords(GtkTreeView *tree_view , gint wx ,
                                                 gint wy , gint *tx , gint *ty ) ;
#line 337
void gtk_tree_view_convert_tree_to_widget_coords(GtkTreeView *tree_view , gint tx ,
                                                 gint ty , gint *wx , gint *wy ) ;
#line 342
void gtk_tree_view_convert_widget_to_bin_window_coords(GtkTreeView *tree_view , gint wx ,
                                                       gint wy , gint *bx , gint *by ) ;
#line 347
void gtk_tree_view_convert_bin_window_to_widget_coords(GtkTreeView *tree_view , gint bx ,
                                                       gint by , gint *wx , gint *wy ) ;
#line 352
void gtk_tree_view_convert_tree_to_bin_window_coords(GtkTreeView *tree_view , gint tx ,
                                                     gint ty , gint *bx , gint *by ) ;
#line 357
void gtk_tree_view_convert_bin_window_to_tree_coords(GtkTreeView *tree_view , gint bx ,
                                                     gint by , gint *tx , gint *ty ) ;
#line 369
void gtk_tree_view_set_destroy_count_func(GtkTreeView *tree_view , GtkTreeDestroyCountFunc func ,
                                          gpointer data , GDestroyNotify destroy ) ;
#line 374
void gtk_tree_view_set_fixed_height_mode(GtkTreeView *tree_view , gboolean enable ) ;
#line 376
gboolean gtk_tree_view_get_fixed_height_mode(GtkTreeView *tree_view ) ;
#line 377
void gtk_tree_view_set_hover_selection(GtkTreeView *tree_view , gboolean hover ) ;
#line 379
gboolean gtk_tree_view_get_hover_selection(GtkTreeView *tree_view ) ;
#line 380
void gtk_tree_view_set_hover_expand(GtkTreeView *tree_view , gboolean expand ) ;
#line 382
gboolean gtk_tree_view_get_hover_expand(GtkTreeView *tree_view ) ;
#line 383
void gtk_tree_view_set_rubber_banding(GtkTreeView *tree_view , gboolean enable ) ;
#line 385
gboolean gtk_tree_view_get_rubber_banding(GtkTreeView *tree_view ) ;
#line 387
gboolean gtk_tree_view_is_rubber_banding_active(GtkTreeView *tree_view ) ;
#line 389
GtkTreeViewRowSeparatorFunc gtk_tree_view_get_row_separator_func(GtkTreeView *tree_view ) ;
#line 390
void gtk_tree_view_set_row_separator_func(GtkTreeView *tree_view , GtkTreeViewRowSeparatorFunc func ,
                                          gpointer data , GDestroyNotify destroy ) ;
#line 395
GtkTreeViewGridLines gtk_tree_view_get_grid_lines(GtkTreeView *tree_view ) ;
#line 396
void gtk_tree_view_set_grid_lines(GtkTreeView *tree_view , GtkTreeViewGridLines grid_lines ) ;
#line 398
gboolean gtk_tree_view_get_enable_tree_lines(GtkTreeView *tree_view ) ;
#line 399
void gtk_tree_view_set_enable_tree_lines(GtkTreeView *tree_view , gboolean enabled ) ;
#line 401
void gtk_tree_view_set_show_expanders(GtkTreeView *tree_view , gboolean enabled ) ;
#line 403
gboolean gtk_tree_view_get_show_expanders(GtkTreeView *tree_view ) ;
#line 404
void gtk_tree_view_set_level_indentation(GtkTreeView *tree_view , gint indentation ) ;
#line 406
gint gtk_tree_view_get_level_indentation(GtkTreeView *tree_view ) ;
#line 409
void gtk_tree_view_set_tooltip_row(GtkTreeView *tree_view , GtkTooltip *tooltip ,
                                   GtkTreePath *path ) ;
#line 412
void gtk_tree_view_set_tooltip_cell(GtkTreeView *tree_view , GtkTooltip *tooltip ,
                                    GtkTreePath *path , GtkTreeViewColumn *column ,
                                    GtkCellRenderer *cell ) ;
#line 417
gboolean gtk_tree_view_get_tooltip_context(GtkTreeView *tree_view , gint *x , gint *y ,
                                           gboolean keyboard_tip , GtkTreeModel **model ,
                                           GtkTreePath **path , GtkTreeIter *iter ) ;
#line 424
void gtk_tree_view_set_tooltip_column(GtkTreeView *tree_view , gint column ) ;
#line 426
gint gtk_tree_view_get_tooltip_column(GtkTreeView *tree_view ) ;
#line 70 "/usr/include/gtk-2.0/gtk/gtkcombobox.h"
GType gtk_combo_box_get_type(void) ;
#line 71
GtkWidget *gtk_combo_box_new(void) ;
#line 72
GtkWidget *gtk_combo_box_new_with_entry(void) ;
#line 73
GtkWidget *gtk_combo_box_new_with_model(GtkTreeModel *model ) ;
#line 74
GtkWidget *gtk_combo_box_new_with_model_and_entry(GtkTreeModel *model ) ;
#line 77
gint gtk_combo_box_get_wrap_width(GtkComboBox *combo_box ) ;
#line 78
void gtk_combo_box_set_wrap_width(GtkComboBox *combo_box , gint width ) ;
#line 80
gint gtk_combo_box_get_row_span_column(GtkComboBox *combo_box ) ;
#line 81
void gtk_combo_box_set_row_span_column(GtkComboBox *combo_box , gint row_span ) ;
#line 83
gint gtk_combo_box_get_column_span_column(GtkComboBox *combo_box ) ;
#line 84
void gtk_combo_box_set_column_span_column(GtkComboBox *combo_box , gint column_span ) ;
#line 87
gboolean gtk_combo_box_get_add_tearoffs(GtkComboBox *combo_box ) ;
#line 88
void gtk_combo_box_set_add_tearoffs(GtkComboBox *combo_box , gboolean add_tearoffs ) ;
#line 91
gchar *gtk_combo_box_get_title(GtkComboBox *combo_box ) ;
#line 92
void gtk_combo_box_set_title(GtkComboBox *combo_box , gchar *title ) ;
#line 95
gboolean gtk_combo_box_get_focus_on_click(GtkComboBox *combo ) ;
#line 96
void gtk_combo_box_set_focus_on_click(GtkComboBox *combo , gboolean focus_on_click ) ;
#line 100
gint gtk_combo_box_get_active(GtkComboBox *combo_box ) ;
#line 101
void gtk_combo_box_set_active(GtkComboBox *combo_box , gint index_ ) ;
#line 103
gboolean gtk_combo_box_get_active_iter(GtkComboBox *combo_box , GtkTreeIter *iter ) ;
#line 105
void gtk_combo_box_set_active_iter(GtkComboBox *combo_box , GtkTreeIter *iter ) ;
#line 109
void gtk_combo_box_set_model(GtkComboBox *combo_box , GtkTreeModel *model ) ;
#line 111
GtkTreeModel *gtk_combo_box_get_model(GtkComboBox *combo_box ) ;
#line 113
GtkTreeViewRowSeparatorFunc gtk_combo_box_get_row_separator_func(GtkComboBox *combo_box ) ;
#line 114
void gtk_combo_box_set_row_separator_func(GtkComboBox *combo_box , GtkTreeViewRowSeparatorFunc func ,
                                          gpointer data , GDestroyNotify destroy ) ;
#line 119
void gtk_combo_box_set_button_sensitivity(GtkComboBox *combo_box , GtkSensitivityType sensitivity ) ;
#line 121
GtkSensitivityType gtk_combo_box_get_button_sensitivity(GtkComboBox *combo_box ) ;
#line 123
gboolean gtk_combo_box_get_has_entry(GtkComboBox *combo_box ) ;
#line 124
void gtk_combo_box_set_entry_text_column(GtkComboBox *combo_box , gint text_column ) ;
#line 126
gint gtk_combo_box_get_entry_text_column(GtkComboBox *combo_box ) ;
#line 131
GtkWidget *gtk_combo_box_new_text(void) ;
#line 132
void gtk_combo_box_append_text(GtkComboBox *combo_box , gchar *text ) ;
#line 134
void gtk_combo_box_insert_text(GtkComboBox *combo_box , gint position , gchar *text ) ;
#line 137
void gtk_combo_box_prepend_text(GtkComboBox *combo_box , gchar *text ) ;
#line 139
void gtk_combo_box_remove_text(GtkComboBox *combo_box , gint position ) ;
#line 141
gchar *gtk_combo_box_get_active_text(GtkComboBox *combo_box ) ;
#line 146
void gtk_combo_box_popup(GtkComboBox *combo_box ) ;
#line 147
void gtk_combo_box_popdown(GtkComboBox *combo_box ) ;
#line 148
AtkObject *gtk_combo_box_get_popup_accessible(GtkComboBox *combo_box ) ;
#line 65 "/usr/include/gtk-2.0/gtk/gtkcomboboxentry.h"
GType gtk_combo_box_entry_get_type(void) ;
#line 66
GtkWidget *gtk_combo_box_entry_new(void) ;
#line 67
GtkWidget *gtk_combo_box_entry_new_with_model(GtkTreeModel *model , gint text_column ) ;
#line 70
void gtk_combo_box_entry_set_text_column(GtkComboBoxEntry *entry_box , gint text_column ) ;
#line 72
gint gtk_combo_box_entry_get_text_column(GtkComboBoxEntry *entry_box ) ;
#line 75
GtkWidget *gtk_combo_box_entry_new_text(void) ;
#line 60 "/usr/include/gtk-2.0/gtk/gtkcomboboxtext.h"
GType gtk_combo_box_text_get_type(void) ;
#line 61
GtkWidget *gtk_combo_box_text_new(void) ;
#line 62
GtkWidget *gtk_combo_box_text_new_with_entry(void) ;
#line 63
void gtk_combo_box_text_append_text(GtkComboBoxText *combo_box , gchar *text ) ;
#line 65
void gtk_combo_box_text_insert_text(GtkComboBoxText *combo_box , gint position , gchar *text ) ;
#line 68
void gtk_combo_box_text_prepend_text(GtkComboBoxText *combo_box , gchar *text ) ;
#line 70
void gtk_combo_box_text_remove(GtkComboBoxText *combo_box , gint position ) ;
#line 72
gchar *gtk_combo_box_text_get_active_text(GtkComboBoxText *combo_box ) ;
#line 70 "/usr/include/gtk-2.0/gtk/gtkdrawingarea.h"
GType gtk_drawing_area_get_type(void) ;
#line 71
GtkWidget *gtk_drawing_area_new(void) ;
#line 74
void gtk_drawing_area_size(GtkDrawingArea *darea , gint width , gint height ) ;
#line 60 "/usr/include/gtk-2.0/gtk/gtkeventbox.h"
GType gtk_event_box_get_type(void) ;
#line 61
GtkWidget *gtk_event_box_new(void) ;
#line 62
gboolean gtk_event_box_get_visible_window(GtkEventBox *event_box ) ;
#line 63
void gtk_event_box_set_visible_window(GtkEventBox *event_box , gboolean visible_window ) ;
#line 65
gboolean gtk_event_box_get_above_child(GtkEventBox *event_box ) ;
#line 66
void gtk_event_box_set_above_child(GtkEventBox *event_box , gboolean above_child ) ;
#line 63 "/usr/include/gtk-2.0/gtk/gtkexpander.h"
GType gtk_expander_get_type(void) ;
#line 65
GtkWidget *gtk_expander_new(gchar *label ) ;
#line 66
GtkWidget *gtk_expander_new_with_mnemonic(gchar *label ) ;
#line 68
void gtk_expander_set_expanded(GtkExpander *expander , gboolean expanded ) ;
#line 70
gboolean gtk_expander_get_expanded(GtkExpander *expander ) ;
#line 73
void gtk_expander_set_spacing(GtkExpander *expander , gint spacing ) ;
#line 75
gint gtk_expander_get_spacing(GtkExpander *expander ) ;
#line 77
void gtk_expander_set_label(GtkExpander *expander , gchar *label ) ;
#line 79
gchar *gtk_expander_get_label(GtkExpander *expander ) ;
#line 81
void gtk_expander_set_use_underline(GtkExpander *expander , gboolean use_underline ) ;
#line 83
gboolean gtk_expander_get_use_underline(GtkExpander *expander ) ;
#line 85
void gtk_expander_set_use_markup(GtkExpander *expander , gboolean use_markup ) ;
#line 87
gboolean gtk_expander_get_use_markup(GtkExpander *expander ) ;
#line 89
void gtk_expander_set_label_widget(GtkExpander *expander , GtkWidget *label_widget ) ;
#line 91
GtkWidget *gtk_expander_get_label_widget(GtkExpander *expander ) ;
#line 92
void gtk_expander_set_label_fill(GtkExpander *expander , gboolean label_fill ) ;
#line 94
gboolean gtk_expander_get_label_fill(GtkExpander *expander ) ;
#line 72 "/usr/include/gtk-2.0/gtk/gtkfixed.h"
GType gtk_fixed_get_type(void) ;
#line 73
GtkWidget *gtk_fixed_new(void) ;
#line 74
void gtk_fixed_put(GtkFixed *fixed , GtkWidget *widget , gint x , gint y ) ;
#line 78
void gtk_fixed_move(GtkFixed *fixed , GtkWidget *widget , gint x , gint y ) ;
#line 83
void gtk_fixed_set_has_window(GtkFixed *fixed , gboolean has_window ) ;
#line 85
gboolean gtk_fixed_get_has_window(GtkFixed *fixed ) ;
#line 59 "/usr/include/gtk-2.0/gtk/gtkfilefilter.h"
GType gtk_file_filter_get_type(void) ;
#line 61
GtkFileFilter *gtk_file_filter_new(void) ;
#line 62
void gtk_file_filter_set_name(GtkFileFilter *filter , gchar *name ) ;
#line 64
gchar *gtk_file_filter_get_name(GtkFileFilter *filter ) ;
#line 66
void gtk_file_filter_add_mime_type(GtkFileFilter *filter , gchar *mime_type ) ;
#line 68
void gtk_file_filter_add_pattern(GtkFileFilter *filter , gchar *pattern ) ;
#line 70
void gtk_file_filter_add_pixbuf_formats(GtkFileFilter *filter ) ;
#line 71
void gtk_file_filter_add_custom(GtkFileFilter *filter , GtkFileFilterFlags needed ,
                                GtkFileFilterFunc func , gpointer data , GDestroyNotify notify ) ;
#line 77
GtkFileFilterFlags gtk_file_filter_get_needed(GtkFileFilter *filter ) ;
#line 78
gboolean gtk_file_filter_filter(GtkFileFilter *filter , GtkFileFilterInfo *filter_info ) ;
#line 88 "/usr/include/gtk-2.0/gtk/gtkfilechooser.h"
GType gtk_file_chooser_get_type(void) ;
#line 116
GQuark gtk_file_chooser_error_quark(void) ;
#line 120
void gtk_file_chooser_set_action(GtkFileChooser *chooser , GtkFileChooserAction action ) ;
#line 122
GtkFileChooserAction gtk_file_chooser_get_action(GtkFileChooser *chooser ) ;
#line 123
void gtk_file_chooser_set_local_only(GtkFileChooser *chooser , gboolean local_only ) ;
#line 125
gboolean gtk_file_chooser_get_local_only(GtkFileChooser *chooser ) ;
#line 126
void gtk_file_chooser_set_select_multiple(GtkFileChooser *chooser , gboolean select_multiple ) ;
#line 128
gboolean gtk_file_chooser_get_select_multiple(GtkFileChooser *chooser ) ;
#line 129
void gtk_file_chooser_set_show_hidden(GtkFileChooser *chooser , gboolean show_hidden ) ;
#line 131
gboolean gtk_file_chooser_get_show_hidden(GtkFileChooser *chooser ) ;
#line 133
void gtk_file_chooser_set_do_overwrite_confirmation(GtkFileChooser *chooser , gboolean do_overwrite_confirmation ) ;
#line 135
gboolean gtk_file_chooser_get_do_overwrite_confirmation(GtkFileChooser *chooser ) ;
#line 137
void gtk_file_chooser_set_create_folders(GtkFileChooser *chooser , gboolean create_folders ) ;
#line 139
gboolean gtk_file_chooser_get_create_folders(GtkFileChooser *chooser ) ;
#line 143
void gtk_file_chooser_set_current_name(GtkFileChooser *chooser , gchar *name ) ;
#line 163
gchar *gtk_file_chooser_get_filename(GtkFileChooser *chooser ) ;
#line 164
gboolean gtk_file_chooser_set_filename(GtkFileChooser *chooser , char const   *filename ) ;
#line 166
gboolean gtk_file_chooser_select_filename(GtkFileChooser *chooser , char const   *filename ) ;
#line 168
void gtk_file_chooser_unselect_filename(GtkFileChooser *chooser , char const   *filename ) ;
#line 170
void gtk_file_chooser_select_all(GtkFileChooser *chooser ) ;
#line 171
void gtk_file_chooser_unselect_all(GtkFileChooser *chooser ) ;
#line 172
GSList *gtk_file_chooser_get_filenames(GtkFileChooser *chooser ) ;
#line 173
gboolean gtk_file_chooser_set_current_folder(GtkFileChooser *chooser , gchar *filename ) ;
#line 175
gchar *gtk_file_chooser_get_current_folder(GtkFileChooser *chooser ) ;
#line 180
gchar *gtk_file_chooser_get_uri(GtkFileChooser *chooser ) ;
#line 181
gboolean gtk_file_chooser_set_uri(GtkFileChooser *chooser , char const   *uri ) ;
#line 183
gboolean gtk_file_chooser_select_uri(GtkFileChooser *chooser , char const   *uri ) ;
#line 185
void gtk_file_chooser_unselect_uri(GtkFileChooser *chooser , char const   *uri ) ;
#line 187
GSList *gtk_file_chooser_get_uris(GtkFileChooser *chooser ) ;
#line 188
gboolean gtk_file_chooser_set_current_folder_uri(GtkFileChooser *chooser , gchar *uri ) ;
#line 190
gchar *gtk_file_chooser_get_current_folder_uri(GtkFileChooser *chooser ) ;
#line 193
GFile *gtk_file_chooser_get_file(GtkFileChooser *chooser ) ;
#line 194
gboolean gtk_file_chooser_set_file(GtkFileChooser *chooser , GFile *file , GError **error ) ;
#line 197
gboolean gtk_file_chooser_select_file(GtkFileChooser *chooser , GFile *file , GError **error ) ;
#line 200
void gtk_file_chooser_unselect_file(GtkFileChooser *chooser , GFile *file ) ;
#line 202
GSList *gtk_file_chooser_get_files(GtkFileChooser *chooser ) ;
#line 203
gboolean gtk_file_chooser_set_current_folder_file(GtkFileChooser *chooser , GFile *file ,
                                                  GError **error ) ;
#line 206
GFile *gtk_file_chooser_get_current_folder_file(GtkFileChooser *chooser ) ;
#line 210
void gtk_file_chooser_set_preview_widget(GtkFileChooser *chooser , GtkWidget *preview_widget ) ;
#line 212
GtkWidget *gtk_file_chooser_get_preview_widget(GtkFileChooser *chooser ) ;
#line 213
void gtk_file_chooser_set_preview_widget_active(GtkFileChooser *chooser , gboolean active ) ;
#line 215
gboolean gtk_file_chooser_get_preview_widget_active(GtkFileChooser *chooser ) ;
#line 216
void gtk_file_chooser_set_use_preview_label(GtkFileChooser *chooser , gboolean use_label ) ;
#line 218
gboolean gtk_file_chooser_get_use_preview_label(GtkFileChooser *chooser ) ;
#line 220
char *gtk_file_chooser_get_preview_filename(GtkFileChooser *chooser ) ;
#line 221
char *gtk_file_chooser_get_preview_uri(GtkFileChooser *chooser ) ;
#line 222
GFile *gtk_file_chooser_get_preview_file(GtkFileChooser *chooser ) ;
#line 226
void gtk_file_chooser_set_extra_widget(GtkFileChooser *chooser , GtkWidget *extra_widget ) ;
#line 228
GtkWidget *gtk_file_chooser_get_extra_widget(GtkFileChooser *chooser ) ;
#line 232
void gtk_file_chooser_add_filter(GtkFileChooser *chooser , GtkFileFilter *filter ) ;
#line 234
void gtk_file_chooser_remove_filter(GtkFileChooser *chooser , GtkFileFilter *filter ) ;
#line 236
GSList *gtk_file_chooser_list_filters(GtkFileChooser *chooser ) ;
#line 240
void gtk_file_chooser_set_filter(GtkFileChooser *chooser , GtkFileFilter *filter ) ;
#line 242
GtkFileFilter *gtk_file_chooser_get_filter(GtkFileChooser *chooser ) ;
#line 246
gboolean gtk_file_chooser_add_shortcut_folder(GtkFileChooser *chooser , char const   *folder ,
                                              GError **error ) ;
#line 249
gboolean gtk_file_chooser_remove_shortcut_folder(GtkFileChooser *chooser , char const   *folder ,
                                                 GError **error ) ;
#line 252
GSList *gtk_file_chooser_list_shortcut_folders(GtkFileChooser *chooser ) ;
#line 254
gboolean gtk_file_chooser_add_shortcut_folder_uri(GtkFileChooser *chooser , char const   *uri ,
                                                  GError **error ) ;
#line 257
gboolean gtk_file_chooser_remove_shortcut_folder_uri(GtkFileChooser *chooser , char const   *uri ,
                                                     GError **error ) ;
#line 260
GSList *gtk_file_chooser_list_shortcut_folder_uris(GtkFileChooser *chooser ) ;
#line 62 "/usr/include/gtk-2.0/gtk/gtkhbox.h"
GType gtk_hbox_get_type(void) ;
#line 63
GtkWidget *gtk_hbox_new(gboolean homogeneous , gint spacing ) ;
#line 69 "/usr/include/gtk-2.0/gtk/gtkfilechooserbutton.h"
GType gtk_file_chooser_button_get_type(void) ;
#line 70
GtkWidget *gtk_file_chooser_button_new(gchar *title , GtkFileChooserAction action ) ;
#line 74
GtkWidget *gtk_file_chooser_button_new_with_backend(gchar *title , GtkFileChooserAction action ,
                                                    gchar *backend ) ;
#line 79
GtkWidget *gtk_file_chooser_button_new_with_dialog(GtkWidget *dialog ) ;
#line 80
gchar *gtk_file_chooser_button_get_title(GtkFileChooserButton *button ) ;
#line 81
void gtk_file_chooser_button_set_title(GtkFileChooserButton *button , gchar *title ) ;
#line 83
gint gtk_file_chooser_button_get_width_chars(GtkFileChooserButton *button ) ;
#line 84
void gtk_file_chooser_button_set_width_chars(GtkFileChooserButton *button , gint n_chars ) ;
#line 86
gboolean gtk_file_chooser_button_get_focus_on_click(GtkFileChooserButton *button ) ;
#line 87
void gtk_file_chooser_button_set_focus_on_click(GtkFileChooserButton *button , gboolean focus_on_click ) ;
#line 56 "/usr/include/gtk-2.0/gtk/gtkfilechooserdialog.h"
GType gtk_file_chooser_dialog_get_type(void) ;
#line 57
GtkWidget *gtk_file_chooser_dialog_new(gchar *title , GtkWindow *parent , GtkFileChooserAction action ,
                                       gchar *first_button_text  , ...) ;
#line 64
GtkWidget *gtk_file_chooser_dialog_new_with_backend(gchar *title , GtkWindow *parent ,
                                                    GtkFileChooserAction action ,
                                                    gchar *backend , gchar *first_button_text 
                                                    , ...) ;
#line 56 "/usr/include/gtk-2.0/gtk/gtkfilechooserwidget.h"
GType gtk_file_chooser_widget_get_type(void) ;
#line 57
GtkWidget *gtk_file_chooser_widget_new(GtkFileChooserAction action ) ;
#line 61
GtkWidget *gtk_file_chooser_widget_new_with_backend(GtkFileChooserAction action ,
                                                    gchar *backend ) ;
#line 74 "/usr/include/gtk-2.0/gtk/gtkfontbutton.h"
GType gtk_font_button_get_type(void) ;
#line 75
GtkWidget *gtk_font_button_new(void) ;
#line 76
GtkWidget *gtk_font_button_new_with_font(gchar *fontname ) ;
#line 78
gchar *gtk_font_button_get_title(GtkFontButton *font_button ) ;
#line 79
void gtk_font_button_set_title(GtkFontButton *font_button , gchar *title ) ;
#line 81
gboolean gtk_font_button_get_use_font(GtkFontButton *font_button ) ;
#line 82
void gtk_font_button_set_use_font(GtkFontButton *font_button , gboolean use_font ) ;
#line 84
gboolean gtk_font_button_get_use_size(GtkFontButton *font_button ) ;
#line 85
void gtk_font_button_set_use_size(GtkFontButton *font_button , gboolean use_size ) ;
#line 87
gchar *gtk_font_button_get_font_name(GtkFontButton *font_button ) ;
#line 88
gboolean gtk_font_button_set_font_name(GtkFontButton *font_button , gchar *fontname ) ;
#line 90
gboolean gtk_font_button_get_show_style(GtkFontButton *font_button ) ;
#line 91
void gtk_font_button_set_show_style(GtkFontButton *font_button , gboolean show_style ) ;
#line 93
gboolean gtk_font_button_get_show_size(GtkFontButton *font_button ) ;
#line 94
void gtk_font_button_set_show_size(GtkFontButton *font_button , gboolean show_size ) ;
#line 145 "/usr/include/gtk-2.0/gtk/gtkfontsel.h"
GType gtk_font_selection_get_type(void) ;
#line 146
GtkWidget *gtk_font_selection_new(void) ;
#line 147
GtkWidget *gtk_font_selection_get_family_list(GtkFontSelection *fontsel ) ;
#line 148
GtkWidget *gtk_font_selection_get_face_list(GtkFontSelection *fontsel ) ;
#line 149
GtkWidget *gtk_font_selection_get_size_entry(GtkFontSelection *fontsel ) ;
#line 150
GtkWidget *gtk_font_selection_get_size_list(GtkFontSelection *fontsel ) ;
#line 151
GtkWidget *gtk_font_selection_get_preview_entry(GtkFontSelection *fontsel ) ;
#line 153
PangoFontFamily *gtk_font_selection_get_family(GtkFontSelection *fontsel ) ;
#line 155
PangoFontFace *gtk_font_selection_get_face(GtkFontSelection *fontsel ) ;
#line 156
gint gtk_font_selection_get_size(GtkFontSelection *fontsel ) ;
#line 157
gchar *gtk_font_selection_get_font_name(GtkFontSelection *fontsel ) ;
#line 160
GdkFont *gtk_font_selection_get_font(GtkFontSelection *fontsel ) ;
#line 163
gboolean gtk_font_selection_set_font_name(GtkFontSelection *fontsel , gchar *fontname ) ;
#line 165
gchar *gtk_font_selection_get_preview_text(GtkFontSelection *fontsel ) ;
#line 166
void gtk_font_selection_set_preview_text(GtkFontSelection *fontsel , gchar *text ) ;
#line 175
GType gtk_font_selection_dialog_get_type(void) ;
#line 176
GtkWidget *gtk_font_selection_dialog_new(gchar *title ) ;
#line 178
GtkWidget *gtk_font_selection_dialog_get_ok_button(GtkFontSelectionDialog *fsd ) ;
#line 180
GtkWidget *gtk_font_selection_dialog_get_apply_button(GtkFontSelectionDialog *fsd ) ;
#line 182
GtkWidget *gtk_font_selection_dialog_get_cancel_button(GtkFontSelectionDialog *fsd ) ;
#line 183
GtkWidget *gtk_font_selection_dialog_get_font_selection(GtkFontSelectionDialog *fsd ) ;
#line 190
gchar *gtk_font_selection_dialog_get_font_name(GtkFontSelectionDialog *fsd ) ;
#line 196
GdkFont *gtk_font_selection_dialog_get_font(GtkFontSelectionDialog *fsd ) ;
#line 203
gboolean gtk_font_selection_dialog_set_font_name(GtkFontSelectionDialog *fsd , gchar *fontname ) ;
#line 209
gchar *gtk_font_selection_dialog_get_preview_text(GtkFontSelectionDialog *fsd ) ;
#line 213
void gtk_font_selection_dialog_set_preview_text(GtkFontSelectionDialog *fsd , gchar *text ) ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkgc.h"
GdkGC *gtk_gc_get(gint depth , GdkColormap *colormap , GdkGCValues *values , GdkGCValuesMask values_mask ) ;
#line 44
void gtk_gc_release(GdkGC *gc ) ;
#line 97 "/usr/include/gtk-2.0/gtk/gtkhandlebox.h"
GType gtk_handle_box_get_type(void) ;
#line 98
GtkWidget *gtk_handle_box_new(void) ;
#line 99
void gtk_handle_box_set_shadow_type(GtkHandleBox *handle_box , GtkShadowType type ) ;
#line 101
GtkShadowType gtk_handle_box_get_shadow_type(GtkHandleBox *handle_box ) ;
#line 102
void gtk_handle_box_set_handle_position(GtkHandleBox *handle_box , GtkPositionType position ) ;
#line 104
GtkPositionType gtk_handle_box_get_handle_position(GtkHandleBox *handle_box ) ;
#line 105
void gtk_handle_box_set_snap_edge(GtkHandleBox *handle_box , GtkPositionType edge ) ;
#line 107
GtkPositionType gtk_handle_box_get_snap_edge(GtkHandleBox *handle_box ) ;
#line 108
gboolean gtk_handle_box_get_child_detached(GtkHandleBox *handle_box ) ;
#line 62 "/usr/include/gtk-2.0/gtk/gtkhbbox.h"
GType gtk_hbutton_box_get_type(void) ;
#line 63
GtkWidget *gtk_hbutton_box_new(void) ;
#line 68
gint gtk_hbutton_box_get_spacing_default(void) ;
#line 69
GtkButtonBoxStyle gtk_hbutton_box_get_layout_default(void) ;
#line 71
void gtk_hbutton_box_set_spacing_default(gint spacing ) ;
#line 72
void gtk_hbutton_box_set_layout_default(GtkButtonBoxStyle layout ) ;
#line 76
GtkButtonBoxStyle _gtk_hbutton_box_get_layout_default(void) ;
#line 109 "/usr/include/gtk-2.0/gtk/gtkpaned.h"
GType gtk_paned_get_type(void) ;
#line 110
void gtk_paned_add1(GtkPaned *paned , GtkWidget *child ) ;
#line 112
void gtk_paned_add2(GtkPaned *paned , GtkWidget *child ) ;
#line 114
void gtk_paned_pack1(GtkPaned *paned , GtkWidget *child , gboolean resize , gboolean shrink ) ;
#line 118
void gtk_paned_pack2(GtkPaned *paned , GtkWidget *child , gboolean resize , gboolean shrink ) ;
#line 123
gint gtk_paned_get_position(GtkPaned *paned ) ;
#line 124
void gtk_paned_set_position(GtkPaned *paned , gint position ) ;
#line 127
GtkWidget *gtk_paned_get_child1(GtkPaned *paned ) ;
#line 128
GtkWidget *gtk_paned_get_child2(GtkPaned *paned ) ;
#line 130
GdkWindow *gtk_paned_get_handle_window(GtkPaned *paned ) ;
#line 134
void gtk_paned_compute_position(GtkPaned *paned , gint allocation , gint child1_req ,
                                gint child2_req ) ;
#line 60 "/usr/include/gtk-2.0/gtk/gtkhpaned.h"
GType gtk_hpaned_get_type(void) ;
#line 61
GtkWidget *gtk_hpaned_new(void) ;
#line 114 "/usr/include/gtk-2.0/gtk/gtkruler.h"
GType gtk_ruler_get_type(void) ;
#line 115
void gtk_ruler_set_metric(GtkRuler *ruler , GtkMetricType metric ) ;
#line 117
GtkMetricType gtk_ruler_get_metric(GtkRuler *ruler ) ;
#line 118
void gtk_ruler_set_range(GtkRuler *ruler , gdouble lower , gdouble upper , gdouble position ,
                         gdouble max_size ) ;
#line 123
void gtk_ruler_get_range(GtkRuler *ruler , gdouble *lower , gdouble *upper , gdouble *position ,
                         gdouble *max_size ) ;
#line 129
void gtk_ruler_draw_ticks(GtkRuler *ruler ) ;
#line 130
void gtk_ruler_draw_pos(GtkRuler *ruler ) ;
#line 75 "/usr/include/gtk-2.0/gtk/gtkhruler.h"
GType gtk_hruler_get_type(void) ;
#line 76
GtkWidget *gtk_hruler_new(void) ;
#line 136 "/usr/include/gtk-2.0/gtk/gtkrange.h"
GType gtk_range_get_type(void) ;
#line 139
void gtk_range_set_update_policy(GtkRange *range , GtkUpdateType policy ) ;
#line 141
GtkUpdateType gtk_range_get_update_policy(GtkRange *range ) ;
#line 144
void gtk_range_set_adjustment(GtkRange *range , GtkAdjustment *adjustment ) ;
#line 146
GtkAdjustment *gtk_range_get_adjustment(GtkRange *range ) ;
#line 148
void gtk_range_set_inverted(GtkRange *range , gboolean setting ) ;
#line 150
gboolean gtk_range_get_inverted(GtkRange *range ) ;
#line 152
void gtk_range_set_flippable(GtkRange *range , gboolean flippable ) ;
#line 154
gboolean gtk_range_get_flippable(GtkRange *range ) ;
#line 156
void gtk_range_set_slider_size_fixed(GtkRange *range , gboolean size_fixed ) ;
#line 158
gboolean gtk_range_get_slider_size_fixed(GtkRange *range ) ;
#line 160
void gtk_range_set_min_slider_size(GtkRange *range , gboolean min_size ) ;
#line 162
gint gtk_range_get_min_slider_size(GtkRange *range ) ;
#line 164
void gtk_range_get_range_rect(GtkRange *range , GdkRectangle *range_rect ) ;
#line 166
void gtk_range_get_slider_range(GtkRange *range , gint *slider_start , gint *slider_end ) ;
#line 170
void gtk_range_set_lower_stepper_sensitivity(GtkRange *range , GtkSensitivityType sensitivity ) ;
#line 172
GtkSensitivityType gtk_range_get_lower_stepper_sensitivity(GtkRange *range ) ;
#line 173
void gtk_range_set_upper_stepper_sensitivity(GtkRange *range , GtkSensitivityType sensitivity ) ;
#line 175
GtkSensitivityType gtk_range_get_upper_stepper_sensitivity(GtkRange *range ) ;
#line 177
void gtk_range_set_increments(GtkRange *range , gdouble step , gdouble page ) ;
#line 180
void gtk_range_set_range(GtkRange *range , gdouble min , gdouble max ) ;
#line 183
void gtk_range_set_value(GtkRange *range , gdouble value ) ;
#line 185
gdouble gtk_range_get_value(GtkRange *range ) ;
#line 187
void gtk_range_set_show_fill_level(GtkRange *range , gboolean show_fill_level ) ;
#line 189
gboolean gtk_range_get_show_fill_level(GtkRange *range ) ;
#line 190
void gtk_range_set_restrict_to_fill_level(GtkRange *range , gboolean restrict_to_fill_level ) ;
#line 192
gboolean gtk_range_get_restrict_to_fill_level(GtkRange *range ) ;
#line 193
void gtk_range_set_fill_level(GtkRange *range , gdouble fill_level ) ;
#line 195
gdouble gtk_range_get_fill_level(GtkRange *range ) ;
#line 196
void gtk_range_set_round_digits(GtkRange *range , gint round_digits ) ;
#line 198
gint gtk_range_get_round_digits(GtkRange *range ) ;
#line 202
gdouble _gtk_range_get_wheel_delta(GtkRange *range , GdkScrollDirection direction ) ;
#line 205
void _gtk_range_set_stop_values(GtkRange *range , gdouble *values , gint n_values ) ;
#line 208
gint _gtk_range_get_stop_positions(GtkRange *range , gint **values ) ;
#line 79 "/usr/include/gtk-2.0/gtk/gtkscale.h"
GType gtk_scale_get_type(void) ;
#line 80
void gtk_scale_set_digits(GtkScale *scale , gint digits ) ;
#line 82
gint gtk_scale_get_digits(GtkScale *scale ) ;
#line 83
void gtk_scale_set_draw_value(GtkScale *scale , gboolean draw_value ) ;
#line 85
gboolean gtk_scale_get_draw_value(GtkScale *scale ) ;
#line 86
void gtk_scale_set_value_pos(GtkScale *scale , GtkPositionType pos ) ;
#line 88
GtkPositionType gtk_scale_get_value_pos(GtkScale *scale ) ;
#line 90
PangoLayout *gtk_scale_get_layout(GtkScale *scale ) ;
#line 91
void gtk_scale_get_layout_offsets(GtkScale *scale , gint *x , gint *y ) ;
#line 95
void gtk_scale_add_mark(GtkScale *scale , gdouble value , GtkPositionType position ,
                        gchar *markup ) ;
#line 99
void gtk_scale_clear_marks(GtkScale *scale ) ;
#line 102
void _gtk_scale_clear_layout(GtkScale *scale ) ;
#line 103
void _gtk_scale_get_value_size(GtkScale *scale , gint *width , gint *height ) ;
#line 106
gchar *_gtk_scale_format_value(GtkScale *scale , gdouble value ) ;
#line 62 "/usr/include/gtk-2.0/gtk/gtkhscale.h"
GType gtk_hscale_get_type(void) ;
#line 63
GtkWidget *gtk_hscale_new(GtkAdjustment *adjustment ) ;
#line 64
GtkWidget *gtk_hscale_new_with_range(gdouble min , gdouble max , gdouble step ) ;
#line 68 "/usr/include/gtk-2.0/gtk/gtkscrollbar.h"
GType gtk_scrollbar_get_type(void) ;
#line 63 "/usr/include/gtk-2.0/gtk/gtkhscrollbar.h"
GType gtk_hscrollbar_get_type(void) ;
#line 64
GtkWidget *gtk_hscrollbar_new(GtkAdjustment *adjustment ) ;
#line 62 "/usr/include/gtk-2.0/gtk/gtkseparator.h"
GType gtk_separator_get_type(void) ;
#line 62 "/usr/include/gtk-2.0/gtk/gtkhseparator.h"
GType gtk_hseparator_get_type(void) ;
#line 63
GtkWidget *gtk_hseparator_new(void) ;
#line 81 "/usr/include/gtk-2.0/gtk/gtkhsv.h"
GType gtk_hsv_get_type(void) ;
#line 82
GtkWidget *gtk_hsv_new(void) ;
#line 83
void gtk_hsv_set_color(GtkHSV *hsv , double h , double s , double v ) ;
#line 87
void gtk_hsv_get_color(GtkHSV *hsv , gdouble *h , gdouble *s , gdouble *v ) ;
#line 91
void gtk_hsv_set_metrics(GtkHSV *hsv , gint size , gint ring_width ) ;
#line 94
void gtk_hsv_get_metrics(GtkHSV *hsv , gint *size , gint *ring_width ) ;
#line 97
gboolean gtk_hsv_is_adjusting(GtkHSV *hsv ) ;
#line 100
void gtk_hsv_to_rgb(gdouble h , gdouble s , gdouble v , gdouble *r , gdouble *g ,
                    gdouble *b ) ;
#line 106
void gtk_rgb_to_hsv(gdouble r , gdouble g , gdouble b , gdouble *h , gdouble *s ,
                    gdouble *v ) ;
#line 74 "/usr/include/gtk-2.0/gtk/gtkiconfactory.h"
GType gtk_icon_factory_get_type(void) ;
#line 75
GtkIconFactory *gtk_icon_factory_new(void) ;
#line 76
void gtk_icon_factory_add(GtkIconFactory *factory , gchar *stock_id , GtkIconSet *icon_set ) ;
#line 79
GtkIconSet *gtk_icon_factory_lookup(GtkIconFactory *factory , gchar *stock_id ) ;
#line 84
void gtk_icon_factory_add_default(GtkIconFactory *factory ) ;
#line 85
void gtk_icon_factory_remove_default(GtkIconFactory *factory ) ;
#line 86
GtkIconSet *gtk_icon_factory_lookup_default(gchar *stock_id ) ;
#line 100
gboolean gtk_icon_size_lookup(GtkIconSize size , gint *width , gint *height ) ;
#line 104
gboolean gtk_icon_size_lookup_for_settings(GtkSettings *settings , GtkIconSize size ,
                                           gint *width , gint *height ) ;
#line 109
GtkIconSize gtk_icon_size_register(gchar *name , gint width , gint height ) ;
#line 112
void gtk_icon_size_register_alias(gchar *alias , GtkIconSize target ) ;
#line 114
GtkIconSize gtk_icon_size_from_name(gchar *name ) ;
#line 115
gchar *gtk_icon_size_get_name(GtkIconSize size ) ;
#line 119
GType gtk_icon_set_get_type(void) ;
#line 120
GtkIconSet *gtk_icon_set_new(void) ;
#line 121
GtkIconSet *gtk_icon_set_new_from_pixbuf(GdkPixbuf *pixbuf ) ;
#line 123
GtkIconSet *gtk_icon_set_ref(GtkIconSet *icon_set ) ;
#line 124
void gtk_icon_set_unref(GtkIconSet *icon_set ) ;
#line 125
GtkIconSet *gtk_icon_set_copy(GtkIconSet *icon_set ) ;
#line 130
GdkPixbuf *gtk_icon_set_render_icon(GtkIconSet *icon_set , GtkStyle *style , GtkTextDirection direction ,
                                    GtkStateType state , GtkIconSize size , GtkWidget *widget ,
                                    char const   *detail ) ;
#line 139
void gtk_icon_set_add_source(GtkIconSet *icon_set , GtkIconSource *source ) ;
#line 142
void gtk_icon_set_get_sizes(GtkIconSet *icon_set , GtkIconSize **sizes , gint *n_sizes ) ;
#line 146
GType gtk_icon_source_get_type(void) ;
#line 147
GtkIconSource *gtk_icon_source_new(void) ;
#line 148
GtkIconSource *gtk_icon_source_copy(GtkIconSource *source ) ;
#line 149
void gtk_icon_source_free(GtkIconSource *source ) ;
#line 151
void gtk_icon_source_set_filename(GtkIconSource *source , gchar *filename ) ;
#line 153
void gtk_icon_source_set_icon_name(GtkIconSource *source , gchar *icon_name ) ;
#line 155
void gtk_icon_source_set_pixbuf(GtkIconSource *source , GdkPixbuf *pixbuf ) ;
#line 158
gchar *gtk_icon_source_get_filename(GtkIconSource *source ) ;
#line 159
gchar *gtk_icon_source_get_icon_name(GtkIconSource *source ) ;
#line 160
GdkPixbuf *gtk_icon_source_get_pixbuf(GtkIconSource *source ) ;
#line 162
void gtk_icon_source_set_direction_wildcarded(GtkIconSource *source , gboolean setting ) ;
#line 164
void gtk_icon_source_set_state_wildcarded(GtkIconSource *source , gboolean setting ) ;
#line 166
void gtk_icon_source_set_size_wildcarded(GtkIconSource *source , gboolean setting ) ;
#line 168
gboolean gtk_icon_source_get_size_wildcarded(GtkIconSource *source ) ;
#line 169
gboolean gtk_icon_source_get_state_wildcarded(GtkIconSource *source ) ;
#line 170
gboolean gtk_icon_source_get_direction_wildcarded(GtkIconSource *source ) ;
#line 171
void gtk_icon_source_set_direction(GtkIconSource *source , GtkTextDirection direction ) ;
#line 173
void gtk_icon_source_set_state(GtkIconSource *source , GtkStateType state ) ;
#line 175
void gtk_icon_source_set_size(GtkIconSource *source , GtkIconSize size ) ;
#line 177
GtkTextDirection gtk_icon_source_get_direction(GtkIconSource *source ) ;
#line 178
GtkStateType gtk_icon_source_get_state(GtkIconSource *source ) ;
#line 179
GtkIconSize gtk_icon_source_get_size(GtkIconSource *source ) ;
#line 183
void _gtk_icon_set_invalidate_caches(void) ;
#line 184
GList *_gtk_icon_factory_list_ids(void) ;
#line 185
void _gtk_icon_factory_ensure_default_icons(void) ;
#line 103 "/usr/include/gtk-2.0/gtk/gtkicontheme.h"
GQuark gtk_icon_theme_error_quark(void) ;
#line 114
GType gtk_icon_theme_get_type(void) ;
#line 116
GtkIconTheme *gtk_icon_theme_new(void) ;
#line 117
GtkIconTheme *gtk_icon_theme_get_default(void) ;
#line 118
GtkIconTheme *gtk_icon_theme_get_for_screen(GdkScreen *screen ) ;
#line 119
void gtk_icon_theme_set_screen(GtkIconTheme *icon_theme , GdkScreen *screen ) ;
#line 122
void gtk_icon_theme_set_search_path(GtkIconTheme *icon_theme , gchar *path[] , gint n_elements ) ;
#line 125
void gtk_icon_theme_get_search_path(GtkIconTheme *icon_theme , gchar **path[] , gint *n_elements ) ;
#line 128
void gtk_icon_theme_append_search_path(GtkIconTheme *icon_theme , gchar *path ) ;
#line 130
void gtk_icon_theme_prepend_search_path(GtkIconTheme *icon_theme , gchar *path ) ;
#line 133
void gtk_icon_theme_set_custom_theme(GtkIconTheme *icon_theme , gchar *theme_name ) ;
#line 136
gboolean gtk_icon_theme_has_icon(GtkIconTheme *icon_theme , gchar *icon_name ) ;
#line 138
gint *gtk_icon_theme_get_icon_sizes(GtkIconTheme *icon_theme , gchar *icon_name ) ;
#line 140
GtkIconInfo *gtk_icon_theme_lookup_icon(GtkIconTheme *icon_theme , gchar *icon_name ,
                                        gint size , GtkIconLookupFlags flags ) ;
#line 144
GtkIconInfo *gtk_icon_theme_choose_icon(GtkIconTheme *icon_theme , gchar *icon_names[] ,
                                        gint size , GtkIconLookupFlags flags ) ;
#line 148
GdkPixbuf *gtk_icon_theme_load_icon(GtkIconTheme *icon_theme , gchar *icon_name ,
                                    gint size , GtkIconLookupFlags flags , GError **error ) ;
#line 154
GtkIconInfo *gtk_icon_theme_lookup_by_gicon(GtkIconTheme *icon_theme , GIcon *icon ,
                                            gint size , GtkIconLookupFlags flags ) ;
#line 159
GList *gtk_icon_theme_list_icons(GtkIconTheme *icon_theme , gchar *context ) ;
#line 161
GList *gtk_icon_theme_list_contexts(GtkIconTheme *icon_theme ) ;
#line 162
char *gtk_icon_theme_get_example_icon_name(GtkIconTheme *icon_theme ) ;
#line 164
gboolean gtk_icon_theme_rescan_if_needed(GtkIconTheme *icon_theme ) ;
#line 166
void gtk_icon_theme_add_builtin_icon(gchar *icon_name , gint size , GdkPixbuf *pixbuf ) ;
#line 170
GType gtk_icon_info_get_type(void) ;
#line 171
GtkIconInfo *gtk_icon_info_copy(GtkIconInfo *icon_info ) ;
#line 172
void gtk_icon_info_free(GtkIconInfo *icon_info ) ;
#line 174
GtkIconInfo *gtk_icon_info_new_for_pixbuf(GtkIconTheme *icon_theme , GdkPixbuf *pixbuf ) ;
#line 177
gint gtk_icon_info_get_base_size(GtkIconInfo *icon_info ) ;
#line 178
gchar *gtk_icon_info_get_filename(GtkIconInfo *icon_info ) ;
#line 179
GdkPixbuf *gtk_icon_info_get_builtin_pixbuf(GtkIconInfo *icon_info ) ;
#line 180
GdkPixbuf *gtk_icon_info_load_icon(GtkIconInfo *icon_info , GError **error ) ;
#line 182
void gtk_icon_info_set_raw_coordinates(GtkIconInfo *icon_info , gboolean raw_coordinates ) ;
#line 185
gboolean gtk_icon_info_get_embedded_rect(GtkIconInfo *icon_info , GdkRectangle *rectangle ) ;
#line 187
gboolean gtk_icon_info_get_attach_points(GtkIconInfo *icon_info , GdkPoint **points ,
                                         gint *n_points ) ;
#line 190
gchar *gtk_icon_info_get_display_name(GtkIconInfo *icon_info ) ;
#line 193
void _gtk_icon_theme_check_reload(GdkDisplay *display ) ;
#line 194
void _gtk_icon_theme_ensure_builtin_cache(void) ;
#line 37 "/usr/include/gtk-2.0/gtk/gtktooltip.h"
GType gtk_tooltip_get_type(void) ;
#line 39
void gtk_tooltip_set_markup(GtkTooltip *tooltip , gchar *markup ) ;
#line 41
void gtk_tooltip_set_text(GtkTooltip *tooltip , gchar *text ) ;
#line 43
void gtk_tooltip_set_icon(GtkTooltip *tooltip , GdkPixbuf *pixbuf ) ;
#line 45
void gtk_tooltip_set_icon_from_stock(GtkTooltip *tooltip , gchar *stock_id , GtkIconSize size ) ;
#line 48
void gtk_tooltip_set_icon_from_icon_name(GtkTooltip *tooltip , gchar *icon_name ,
                                         GtkIconSize size ) ;
#line 51
void gtk_tooltip_set_icon_from_gicon(GtkTooltip *tooltip , GIcon *gicon , GtkIconSize size ) ;
#line 54
void gtk_tooltip_set_custom(GtkTooltip *tooltip , GtkWidget *custom_widget ) ;
#line 57
void gtk_tooltip_set_tip_area(GtkTooltip *tooltip , GdkRectangle *rect ) ;
#line 60
void gtk_tooltip_trigger_tooltip_query(GdkDisplay *display ) ;
#line 63
void _gtk_tooltip_focus_in(GtkWidget *widget ) ;
#line 64
void _gtk_tooltip_focus_out(GtkWidget *widget ) ;
#line 65
void _gtk_tooltip_toggle_keyboard_mode(GtkWidget *widget ) ;
#line 66
void _gtk_tooltip_handle_event(GdkEvent *event ) ;
#line 67
void _gtk_tooltip_hide(GtkWidget *widget ) ;
#line 69
GtkWidget *_gtk_widget_find_at_coords(GdkWindow *window , gint window_x , gint window_y ,
                                      gint *widget_x , gint *widget_y ) ;
#line 90 "/usr/include/gtk-2.0/gtk/gtkiconview.h"
GType gtk_icon_view_get_type(void) ;
#line 91
GtkWidget *gtk_icon_view_new(void) ;
#line 92
GtkWidget *gtk_icon_view_new_with_model(GtkTreeModel *model ) ;
#line 94
void gtk_icon_view_set_model(GtkIconView *icon_view , GtkTreeModel *model ) ;
#line 96
GtkTreeModel *gtk_icon_view_get_model(GtkIconView *icon_view ) ;
#line 97
void gtk_icon_view_set_text_column(GtkIconView *icon_view , gint column ) ;
#line 99
gint gtk_icon_view_get_text_column(GtkIconView *icon_view ) ;
#line 100
void gtk_icon_view_set_markup_column(GtkIconView *icon_view , gint column ) ;
#line 102
gint gtk_icon_view_get_markup_column(GtkIconView *icon_view ) ;
#line 103
void gtk_icon_view_set_pixbuf_column(GtkIconView *icon_view , gint column ) ;
#line 105
gint gtk_icon_view_get_pixbuf_column(GtkIconView *icon_view ) ;
#line 107
void gtk_icon_view_set_orientation(GtkIconView *icon_view , GtkOrientation orientation ) ;
#line 109
GtkOrientation gtk_icon_view_get_orientation(GtkIconView *icon_view ) ;
#line 110
void gtk_icon_view_set_item_orientation(GtkIconView *icon_view , GtkOrientation orientation ) ;
#line 112
GtkOrientation gtk_icon_view_get_item_orientation(GtkIconView *icon_view ) ;
#line 113
void gtk_icon_view_set_columns(GtkIconView *icon_view , gint columns ) ;
#line 115
gint gtk_icon_view_get_columns(GtkIconView *icon_view ) ;
#line 116
void gtk_icon_view_set_item_width(GtkIconView *icon_view , gint item_width ) ;
#line 118
gint gtk_icon_view_get_item_width(GtkIconView *icon_view ) ;
#line 119
void gtk_icon_view_set_spacing(GtkIconView *icon_view , gint spacing ) ;
#line 121
gint gtk_icon_view_get_spacing(GtkIconView *icon_view ) ;
#line 122
void gtk_icon_view_set_row_spacing(GtkIconView *icon_view , gint row_spacing ) ;
#line 124
gint gtk_icon_view_get_row_spacing(GtkIconView *icon_view ) ;
#line 125
void gtk_icon_view_set_column_spacing(GtkIconView *icon_view , gint column_spacing ) ;
#line 127
gint gtk_icon_view_get_column_spacing(GtkIconView *icon_view ) ;
#line 128
void gtk_icon_view_set_margin(GtkIconView *icon_view , gint margin ) ;
#line 130
gint gtk_icon_view_get_margin(GtkIconView *icon_view ) ;
#line 131
void gtk_icon_view_set_item_padding(GtkIconView *icon_view , gint item_padding ) ;
#line 133
gint gtk_icon_view_get_item_padding(GtkIconView *icon_view ) ;
#line 136
GtkTreePath *gtk_icon_view_get_path_at_pos(GtkIconView *icon_view , gint x , gint y ) ;
#line 139
gboolean gtk_icon_view_get_item_at_pos(GtkIconView *icon_view , gint x , gint y ,
                                       GtkTreePath **path , GtkCellRenderer **cell ) ;
#line 144
gboolean gtk_icon_view_get_visible_range(GtkIconView *icon_view , GtkTreePath **start_path ,
                                         GtkTreePath **end_path ) ;
#line 148
void gtk_icon_view_selected_foreach(GtkIconView *icon_view , GtkIconViewForeachFunc func ,
                                    gpointer data ) ;
#line 151
void gtk_icon_view_set_selection_mode(GtkIconView *icon_view , GtkSelectionMode mode ) ;
#line 153
GtkSelectionMode gtk_icon_view_get_selection_mode(GtkIconView *icon_view ) ;
#line 154
void gtk_icon_view_select_path(GtkIconView *icon_view , GtkTreePath *path ) ;
#line 156
void gtk_icon_view_unselect_path(GtkIconView *icon_view , GtkTreePath *path ) ;
#line 158
gboolean gtk_icon_view_path_is_selected(GtkIconView *icon_view , GtkTreePath *path ) ;
#line 160
gint gtk_icon_view_get_item_row(GtkIconView *icon_view , GtkTreePath *path ) ;
#line 162
gint gtk_icon_view_get_item_column(GtkIconView *icon_view , GtkTreePath *path ) ;
#line 164
GList *gtk_icon_view_get_selected_items(GtkIconView *icon_view ) ;
#line 165
void gtk_icon_view_select_all(GtkIconView *icon_view ) ;
#line 166
void gtk_icon_view_unselect_all(GtkIconView *icon_view ) ;
#line 167
void gtk_icon_view_item_activated(GtkIconView *icon_view , GtkTreePath *path ) ;
#line 169
void gtk_icon_view_set_cursor(GtkIconView *icon_view , GtkTreePath *path , GtkCellRenderer *cell ,
                              gboolean start_editing ) ;
#line 173
gboolean gtk_icon_view_get_cursor(GtkIconView *icon_view , GtkTreePath **path , GtkCellRenderer **cell ) ;
#line 176
void gtk_icon_view_scroll_to_path(GtkIconView *icon_view , GtkTreePath *path , gboolean use_align ,
                                  gfloat row_align , gfloat col_align ) ;
#line 183
void gtk_icon_view_enable_model_drag_source(GtkIconView *icon_view , GdkModifierType start_button_mask ,
                                            GtkTargetEntry *targets , gint n_targets ,
                                            GdkDragAction actions ) ;
#line 188
void gtk_icon_view_enable_model_drag_dest(GtkIconView *icon_view , GtkTargetEntry *targets ,
                                          gint n_targets , GdkDragAction actions ) ;
#line 192
void gtk_icon_view_unset_model_drag_source(GtkIconView *icon_view ) ;
#line 193
void gtk_icon_view_unset_model_drag_dest(GtkIconView *icon_view ) ;
#line 194
void gtk_icon_view_set_reorderable(GtkIconView *icon_view , gboolean reorderable ) ;
#line 196
gboolean gtk_icon_view_get_reorderable(GtkIconView *icon_view ) ;
#line 200
void gtk_icon_view_set_drag_dest_item(GtkIconView *icon_view , GtkTreePath *path ,
                                      GtkIconViewDropPosition pos ) ;
#line 203
void gtk_icon_view_get_drag_dest_item(GtkIconView *icon_view , GtkTreePath **path ,
                                      GtkIconViewDropPosition *pos ) ;
#line 206
gboolean gtk_icon_view_get_dest_item_at_pos(GtkIconView *icon_view , gint drag_x ,
                                            gint drag_y , GtkTreePath **path , GtkIconViewDropPosition *pos ) ;
#line 211
GdkPixmap *gtk_icon_view_create_drag_icon(GtkIconView *icon_view , GtkTreePath *path ) ;
#line 214
void gtk_icon_view_convert_widget_to_bin_window_coords(GtkIconView *icon_view , gint wx ,
                                                       gint wy , gint *bx , gint *by ) ;
#line 221
void gtk_icon_view_set_tooltip_item(GtkIconView *icon_view , GtkTooltip *tooltip ,
                                    GtkTreePath *path ) ;
#line 224
void gtk_icon_view_set_tooltip_cell(GtkIconView *icon_view , GtkTooltip *tooltip ,
                                    GtkTreePath *path , GtkCellRenderer *cell ) ;
#line 228
gboolean gtk_icon_view_get_tooltip_context(GtkIconView *icon_view , gint *x , gint *y ,
                                           gboolean keyboard_tip , GtkTreeModel **model ,
                                           GtkTreePath **path , GtkTreeIter *iter ) ;
#line 235
void gtk_icon_view_set_tooltip_column(GtkIconView *icon_view , gint column ) ;
#line 237
gint gtk_icon_view_get_tooltip_column(GtkIconView *icon_view ) ;
#line 66 "/usr/include/gtk-2.0/gtk/gtkimagemenuitem.h"
GType gtk_image_menu_item_get_type(void) ;
#line 67
GtkWidget *gtk_image_menu_item_new(void) ;
#line 68
GtkWidget *gtk_image_menu_item_new_with_label(gchar *label ) ;
#line 69
GtkWidget *gtk_image_menu_item_new_with_mnemonic(gchar *label ) ;
#line 70
GtkWidget *gtk_image_menu_item_new_from_stock(gchar *stock_id , GtkAccelGroup *accel_group ) ;
#line 72
void gtk_image_menu_item_set_always_show_image(GtkImageMenuItem *image_menu_item ,
                                               gboolean always_show ) ;
#line 74
gboolean gtk_image_menu_item_get_always_show_image(GtkImageMenuItem *image_menu_item ) ;
#line 75
void gtk_image_menu_item_set_image(GtkImageMenuItem *image_menu_item , GtkWidget *image ) ;
#line 77
GtkWidget *gtk_image_menu_item_get_image(GtkImageMenuItem *image_menu_item ) ;
#line 78
void gtk_image_menu_item_set_use_stock(GtkImageMenuItem *image_menu_item , gboolean use_stock ) ;
#line 80
gboolean gtk_image_menu_item_get_use_stock(GtkImageMenuItem *image_menu_item ) ;
#line 81
void gtk_image_menu_item_set_accel_group(GtkImageMenuItem *image_menu_item , GtkAccelGroup *accel_group ) ;
#line 65 "/usr/include/gtk-2.0/gtk/gtkimcontextsimple.h"
GType gtk_im_context_simple_get_type(void) ;
#line 66
GtkIMContext *gtk_im_context_simple_new(void) ;
#line 68
void gtk_im_context_simple_add_table(GtkIMContextSimple *context_simple , guint16 *data ,
                                     gint max_seq_len , gint n_seqs ) ;
#line 66 "/usr/include/gtk-2.0/gtk/gtkimmulticontext.h"
GType gtk_im_multicontext_get_type(void) ;
#line 67
GtkIMContext *gtk_im_multicontext_new(void) ;
#line 69
void gtk_im_multicontext_append_menuitems(GtkIMMulticontext *context , GtkMenuShell *menushell ) ;
#line 71
char const   *gtk_im_multicontext_get_context_id(GtkIMMulticontext *context ) ;
#line 73
void gtk_im_multicontext_set_context_id(GtkIMMulticontext *context , char const   *context_id ) ;
#line 87 "/usr/include/gtk-2.0/gtk/gtkinfobar.h"
GType gtk_info_bar_get_type(void) ;
#line 88
GtkWidget *gtk_info_bar_new(void) ;
#line 90
GtkWidget *gtk_info_bar_new_with_buttons(gchar *first_button_text  , ...) ;
#line 93
GtkWidget *gtk_info_bar_get_action_area(GtkInfoBar *info_bar ) ;
#line 94
GtkWidget *gtk_info_bar_get_content_area(GtkInfoBar *info_bar ) ;
#line 95
void gtk_info_bar_add_action_widget(GtkInfoBar *info_bar , GtkWidget *child , gint response_id ) ;
#line 98
GtkWidget *gtk_info_bar_add_button(GtkInfoBar *info_bar , gchar *button_text , gint response_id ) ;
#line 101
void gtk_info_bar_add_buttons(GtkInfoBar *info_bar , gchar *first_button_text  , ...) ;
#line 104
void gtk_info_bar_set_response_sensitive(GtkInfoBar *info_bar , gint response_id ,
                                         gboolean setting ) ;
#line 107
void gtk_info_bar_set_default_response(GtkInfoBar *info_bar , gint response_id ) ;
#line 111
void gtk_info_bar_response(GtkInfoBar *info_bar , gint response_id ) ;
#line 114
void gtk_info_bar_set_message_type(GtkInfoBar *info_bar , GtkMessageType message_type ) ;
#line 116
GtkMessageType gtk_info_bar_get_message_type(GtkInfoBar *info_bar ) ;
#line 68 "/usr/include/gtk-2.0/gtk/gtkinvisible.h"
GType gtk_invisible_get_type(void) ;
#line 70
GtkWidget *gtk_invisible_new(void) ;
#line 71
GtkWidget *gtk_invisible_new_for_screen(GdkScreen *screen ) ;
#line 72
void gtk_invisible_set_screen(GtkInvisible *invisible , GdkScreen *screen ) ;
#line 74
GdkScreen *gtk_invisible_get_screen(GtkInvisible *invisible ) ;
#line 94 "/usr/include/gtk-2.0/gtk/gtklayout.h"
GType gtk_layout_get_type(void) ;
#line 95
GtkWidget *gtk_layout_new(GtkAdjustment *hadjustment , GtkAdjustment *vadjustment ) ;
#line 97
GdkWindow *gtk_layout_get_bin_window(GtkLayout *layout ) ;
#line 98
void gtk_layout_put(GtkLayout *layout , GtkWidget *child_widget , gint x , gint y ) ;
#line 103
void gtk_layout_move(GtkLayout *layout , GtkWidget *child_widget , gint x , gint y ) ;
#line 108
void gtk_layout_set_size(GtkLayout *layout , guint width , guint height ) ;
#line 111
void gtk_layout_get_size(GtkLayout *layout , guint *width , guint *height ) ;
#line 115
GtkAdjustment *gtk_layout_get_hadjustment(GtkLayout *layout ) ;
#line 116
GtkAdjustment *gtk_layout_get_vadjustment(GtkLayout *layout ) ;
#line 117
void gtk_layout_set_hadjustment(GtkLayout *layout , GtkAdjustment *adjustment ) ;
#line 119
void gtk_layout_set_vadjustment(GtkLayout *layout , GtkAdjustment *adjustment ) ;
#line 132
void gtk_layout_freeze(GtkLayout *layout ) ;
#line 133
void gtk_layout_thaw(GtkLayout *layout ) ;
#line 68 "/usr/include/gtk-2.0/gtk/gtklinkbutton.h"
GType gtk_link_button_get_type(void) ;
#line 70
GtkWidget *gtk_link_button_new(gchar *uri ) ;
#line 71
GtkWidget *gtk_link_button_new_with_label(gchar *uri , gchar *label ) ;
#line 74
gchar *gtk_link_button_get_uri(GtkLinkButton *link_button ) ;
#line 75
void gtk_link_button_set_uri(GtkLinkButton *link_button , gchar *uri ) ;
#line 79
GtkLinkButtonUriFunc gtk_link_button_set_uri_hook(GtkLinkButtonUriFunc func , gpointer data ,
                                                  GDestroyNotify destroy ) ;
#line 84
gboolean gtk_link_button_get_visited(GtkLinkButton *link_button ) ;
#line 85
void gtk_link_button_set_visited(GtkLinkButton *link_button , gboolean visited ) ;
#line 78 "/usr/include/gtk-2.0/gtk/gtkmain.h"
extern guint gtk_major_version ;
#line 79
extern guint gtk_minor_version ;
#line 80
extern guint gtk_micro_version ;
#line 81
extern guint gtk_binary_age ;
#line 82
extern guint gtk_interface_age ;
#line 83
gchar *gtk_check_version(guint required_major , guint required_minor , guint required_micro ) ;
#line 91
gboolean gtk_parse_args(int *argc , char ***argv ) ;
#line 94
void gtk_init(int *argc , char ***argv ) ;
#line 97
gboolean gtk_init_check(int *argc , char ***argv ) ;
#line 100
gboolean gtk_init_with_args(int *argc , char ***argv , char const   *parameter_string ,
                            GOptionEntry *entries , char const   *translation_domain ,
                            GError **error ) ;
#line 107
GOptionGroup *gtk_get_option_group(gboolean open_default_display ) ;
#line 131
void gtk_exit(gint error_code ) ;
#line 132
gchar *gtk_set_locale(void) ;
#line 135
void gtk_disable_setlocale(void) ;
#line 136
PangoLanguage *gtk_get_default_language(void) ;
#line 137
gboolean gtk_events_pending(void) ;
#line 143
void gtk_main_do_event(GdkEvent *event ) ;
#line 145
void gtk_main(void) ;
#line 146
guint gtk_main_level(void) ;
#line 147
void gtk_main_quit(void) ;
#line 148
gboolean gtk_main_iteration(void) ;
#line 150
gboolean gtk_main_iteration_do(gboolean blocking ) ;
#line 152
gboolean gtk_true(void) ;
#line 153
gboolean gtk_false(void) ;
#line 155
void gtk_grab_add(GtkWidget *widget ) ;
#line 156
GtkWidget *gtk_grab_get_current(void) ;
#line 157
void gtk_grab_remove(GtkWidget *widget ) ;
#line 160
void gtk_init_add(GtkFunction function , gpointer data ) ;
#line 162
void gtk_quit_add_destroy(guint main_level , GtkObject *object ) ;
#line 164
guint gtk_quit_add(guint main_level , GtkFunction function , gpointer data ) ;
#line 167
guint gtk_quit_add_full(guint main_level , GtkFunction function , GtkCallbackMarshal marshal ,
                        gpointer data , GDestroyNotify destroy ) ;
#line 172
void gtk_quit_remove(guint quit_handler_id ) ;
#line 173
void gtk_quit_remove_by_data(gpointer data ) ;
#line 174
guint gtk_timeout_add(guint32 interval , GtkFunction function , gpointer data ) ;
#line 177
guint gtk_timeout_add_full(guint32 interval , GtkFunction function , GtkCallbackMarshal marshal ,
                           gpointer data , GDestroyNotify destroy ) ;
#line 182
void gtk_timeout_remove(guint timeout_handler_id ) ;
#line 184
guint gtk_idle_add(GtkFunction function , gpointer data ) ;
#line 186
guint gtk_idle_add_priority(gint priority , GtkFunction function , gpointer data ) ;
#line 189
guint gtk_idle_add_full(gint priority , GtkFunction function , GtkCallbackMarshal marshal ,
                        gpointer data , GDestroyNotify destroy ) ;
#line 194
void gtk_idle_remove(guint idle_handler_id ) ;
#line 195
void gtk_idle_remove_by_data(gpointer data ) ;
#line 196
guint gtk_input_add_full(gint source , GdkInputCondition condition , GdkInputFunction function ,
                         GtkCallbackMarshal marshal , gpointer data , GDestroyNotify destroy ) ;
#line 202
void gtk_input_remove(guint input_handler_id ) ;
#line 205
guint gtk_key_snooper_install(GtkKeySnoopFunc snooper , gpointer func_data ) ;
#line 207
void gtk_key_snooper_remove(guint snooper_handler_id ) ;
#line 209
GdkEvent *gtk_get_current_event(void) ;
#line 210
guint32 gtk_get_current_event_time(void) ;
#line 211
gboolean gtk_get_current_event_state(GdkModifierType *state ) ;
#line 213
GtkWidget *gtk_get_event_widget(GdkEvent *event ) ;
#line 218
void gtk_propagate_event(GtkWidget *widget , GdkEvent *event ) ;
#line 221
gboolean _gtk_boolean_handled_accumulator(GSignalInvocationHint *ihint , GValue *return_accu ,
                                          GValue *handler_return , gpointer dummy ) ;
#line 226
gchar *_gtk_get_lc_ctype(void) ;
#line 228
gboolean _gtk_module_has_mixed_deps(GModule *module ) ;
#line 68 "/usr/include/gtk-2.0/gtk/gtkmenubar.h"
GType gtk_menu_bar_get_type(void) ;
#line 69
GtkWidget *gtk_menu_bar_new(void) ;
#line 71
GtkPackDirection gtk_menu_bar_get_pack_direction(GtkMenuBar *menubar ) ;
#line 72
void gtk_menu_bar_set_pack_direction(GtkMenuBar *menubar , GtkPackDirection pack_dir ) ;
#line 74
GtkPackDirection gtk_menu_bar_get_child_pack_direction(GtkMenuBar *menubar ) ;
#line 75
void gtk_menu_bar_set_child_pack_direction(GtkMenuBar *menubar , GtkPackDirection child_pack_dir ) ;
#line 85
void _gtk_menu_bar_cycle_focus(GtkMenuBar *menubar , GtkDirectionType dir ) ;
#line 87 "/usr/include/gtk-2.0/gtk/gtktooltips.h"
GType gtk_tooltips_get_type(void) ;
#line 88
GtkTooltips *gtk_tooltips_new(void) ;
#line 90
void gtk_tooltips_enable(GtkTooltips *tooltips ) ;
#line 91
void gtk_tooltips_disable(GtkTooltips *tooltips ) ;
#line 92
void gtk_tooltips_set_delay(GtkTooltips *tooltips , guint delay ) ;
#line 94
void gtk_tooltips_set_tip(GtkTooltips *tooltips , GtkWidget *widget , gchar *tip_text ,
                          gchar *tip_private ) ;
#line 98
GtkTooltipsData *gtk_tooltips_data_get(GtkWidget *widget ) ;
#line 99
void gtk_tooltips_force_window(GtkTooltips *tooltips ) ;
#line 101
gboolean gtk_tooltips_get_info_from_tip_window(GtkWindow *tip_window , GtkTooltips **tooltips ,
                                               GtkWidget **current_widget ) ;
#line 87 "/usr/include/gtk-2.0/gtk/gtksizegroup.h"
GType gtk_size_group_get_type(void) ;
#line 89
GtkSizeGroup *gtk_size_group_new(GtkSizeGroupMode mode ) ;
#line 90
void gtk_size_group_set_mode(GtkSizeGroup *size_group , GtkSizeGroupMode mode ) ;
#line 92
GtkSizeGroupMode gtk_size_group_get_mode(GtkSizeGroup *size_group ) ;
#line 93
void gtk_size_group_set_ignore_hidden(GtkSizeGroup *size_group , gboolean ignore_hidden ) ;
#line 95
gboolean gtk_size_group_get_ignore_hidden(GtkSizeGroup *size_group ) ;
#line 96
void gtk_size_group_add_widget(GtkSizeGroup *size_group , GtkWidget *widget ) ;
#line 98
void gtk_size_group_remove_widget(GtkSizeGroup *size_group , GtkWidget *widget ) ;
#line 100
GSList *gtk_size_group_get_widgets(GtkSizeGroup *size_group ) ;
#line 103
void _gtk_size_group_get_child_requisition(GtkWidget *widget , GtkRequisition *requisition ) ;
#line 105
void _gtk_size_group_compute_requisition(GtkWidget *widget , GtkRequisition *requisition ) ;
#line 107
void _gtk_size_group_queue_resize(GtkWidget *widget ) ;
#line 79 "/usr/include/gtk-2.0/gtk/gtktoolitem.h"
GType gtk_tool_item_get_type(void) ;
#line 80
GtkToolItem *gtk_tool_item_new(void) ;
#line 82
void gtk_tool_item_set_homogeneous(GtkToolItem *tool_item , gboolean homogeneous ) ;
#line 84
gboolean gtk_tool_item_get_homogeneous(GtkToolItem *tool_item ) ;
#line 86
void gtk_tool_item_set_expand(GtkToolItem *tool_item , gboolean expand ) ;
#line 88
gboolean gtk_tool_item_get_expand(GtkToolItem *tool_item ) ;
#line 91
void gtk_tool_item_set_tooltip(GtkToolItem *tool_item , GtkTooltips *tooltips , gchar *tip_text ,
                               gchar *tip_private ) ;
#line 96
void gtk_tool_item_set_tooltip_text(GtkToolItem *tool_item , gchar *text ) ;
#line 98
void gtk_tool_item_set_tooltip_markup(GtkToolItem *tool_item , gchar *markup ) ;
#line 101
void gtk_tool_item_set_use_drag_window(GtkToolItem *tool_item , gboolean use_drag_window ) ;
#line 103
gboolean gtk_tool_item_get_use_drag_window(GtkToolItem *tool_item ) ;
#line 105
void gtk_tool_item_set_visible_horizontal(GtkToolItem *tool_item , gboolean visible_horizontal ) ;
#line 107
gboolean gtk_tool_item_get_visible_horizontal(GtkToolItem *tool_item ) ;
#line 109
void gtk_tool_item_set_visible_vertical(GtkToolItem *tool_item , gboolean visible_vertical ) ;
#line 111
gboolean gtk_tool_item_get_visible_vertical(GtkToolItem *tool_item ) ;
#line 113
gboolean gtk_tool_item_get_is_important(GtkToolItem *tool_item ) ;
#line 114
void gtk_tool_item_set_is_important(GtkToolItem *tool_item , gboolean is_important ) ;
#line 117
PangoEllipsizeMode gtk_tool_item_get_ellipsize_mode(GtkToolItem *tool_item ) ;
#line 118
GtkIconSize gtk_tool_item_get_icon_size(GtkToolItem *tool_item ) ;
#line 119
GtkOrientation gtk_tool_item_get_orientation(GtkToolItem *tool_item ) ;
#line 120
GtkToolbarStyle gtk_tool_item_get_toolbar_style(GtkToolItem *tool_item ) ;
#line 121
GtkReliefStyle gtk_tool_item_get_relief_style(GtkToolItem *tool_item ) ;
#line 122
gfloat gtk_tool_item_get_text_alignment(GtkToolItem *tool_item ) ;
#line 123
GtkOrientation gtk_tool_item_get_text_orientation(GtkToolItem *tool_item ) ;
#line 124
GtkSizeGroup *gtk_tool_item_get_text_size_group(GtkToolItem *tool_item ) ;
#line 126
GtkWidget *gtk_tool_item_retrieve_proxy_menu_item(GtkToolItem *tool_item ) ;
#line 127
GtkWidget *gtk_tool_item_get_proxy_menu_item(GtkToolItem *tool_item , gchar *menu_item_id ) ;
#line 129
void gtk_tool_item_set_proxy_menu_item(GtkToolItem *tool_item , gchar *menu_item_id ,
                                       GtkWidget *menu_item ) ;
#line 132
void gtk_tool_item_rebuild_menu(GtkToolItem *tool_item ) ;
#line 134
void gtk_tool_item_toolbar_reconfigured(GtkToolItem *tool_item ) ;
#line 138
gboolean _gtk_tool_item_create_menu_proxy(GtkToolItem *tool_item ) ;
#line 69 "/usr/include/gtk-2.0/gtk/gtktoolbutton.h"
GType gtk_tool_button_get_type(void) ;
#line 70
GtkToolItem *gtk_tool_button_new(GtkWidget *icon_widget , gchar *label ) ;
#line 72
GtkToolItem *gtk_tool_button_new_from_stock(gchar *stock_id ) ;
#line 74
void gtk_tool_button_set_label(GtkToolButton *button , gchar *label ) ;
#line 76
gchar *gtk_tool_button_get_label(GtkToolButton *button ) ;
#line 77
void gtk_tool_button_set_use_underline(GtkToolButton *button , gboolean use_underline ) ;
#line 79
gboolean gtk_tool_button_get_use_underline(GtkToolButton *button ) ;
#line 80
void gtk_tool_button_set_stock_id(GtkToolButton *button , gchar *stock_id ) ;
#line 82
gchar *gtk_tool_button_get_stock_id(GtkToolButton *button ) ;
#line 83
void gtk_tool_button_set_icon_name(GtkToolButton *button , gchar *icon_name ) ;
#line 85
gchar *gtk_tool_button_get_icon_name(GtkToolButton *button ) ;
#line 86
void gtk_tool_button_set_icon_widget(GtkToolButton *button , GtkWidget *icon_widget ) ;
#line 88
GtkWidget *gtk_tool_button_get_icon_widget(GtkToolButton *button ) ;
#line 89
void gtk_tool_button_set_label_widget(GtkToolButton *button , GtkWidget *label_widget ) ;
#line 91
GtkWidget *gtk_tool_button_get_label_widget(GtkToolButton *button ) ;
#line 95
GtkWidget *_gtk_tool_button_get_button(GtkToolButton *button ) ;
#line 66 "/usr/include/gtk-2.0/gtk/gtkmenutoolbutton.h"
GType gtk_menu_tool_button_get_type(void) ;
#line 67
GtkToolItem *gtk_menu_tool_button_new(GtkWidget *icon_widget , gchar *label ) ;
#line 69
GtkToolItem *gtk_menu_tool_button_new_from_stock(gchar *stock_id ) ;
#line 71
void gtk_menu_tool_button_set_menu(GtkMenuToolButton *button , GtkWidget *menu ) ;
#line 73
GtkWidget *gtk_menu_tool_button_get_menu(GtkMenuToolButton *button ) ;
#line 76
void gtk_menu_tool_button_set_arrow_tooltip(GtkMenuToolButton *button , GtkTooltips *tooltips ,
                                            gchar *tip_text , gchar *tip_private ) ;
#line 82
void gtk_menu_tool_button_set_arrow_tooltip_text(GtkMenuToolButton *button , gchar *text ) ;
#line 84
void gtk_menu_tool_button_set_arrow_tooltip_markup(GtkMenuToolButton *button , gchar *markup ) ;
#line 99 "/usr/include/gtk-2.0/gtk/gtkmessagedialog.h"
GType gtk_message_dialog_get_type(void) ;
#line 101
GtkWidget *gtk_message_dialog_new(GtkWindow *parent , GtkDialogFlags flags , GtkMessageType type ,
                                  GtkButtonsType buttons , gchar *message_format 
                                  , ...) ;
#line 108
GtkWidget *gtk_message_dialog_new_with_markup(GtkWindow *parent , GtkDialogFlags flags ,
                                              GtkMessageType type , GtkButtonsType buttons ,
                                              gchar *message_format  , ...) ;
#line 115
void gtk_message_dialog_set_image(GtkMessageDialog *dialog , GtkWidget *image ) ;
#line 118
GtkWidget *gtk_message_dialog_get_image(GtkMessageDialog *dialog ) ;
#line 120
void gtk_message_dialog_set_markup(GtkMessageDialog *message_dialog , gchar *str ) ;
#line 123
void gtk_message_dialog_format_secondary_text(GtkMessageDialog *message_dialog , gchar *message_format 
                                              , ...) ;
#line 127
void gtk_message_dialog_format_secondary_markup(GtkMessageDialog *message_dialog ,
                                                gchar *message_format  , ...) ;
#line 131
GtkWidget *gtk_message_dialog_get_message_area(GtkMessageDialog *message_dialog ) ;
#line 36 "/usr/include/gtk-2.0/gtk/gtkmodules.h"
gchar *_gtk_find_module(gchar *name , gchar *type ) ;
#line 38
gchar **_gtk_get_module_path(gchar *type ) ;
#line 40
void _gtk_modules_init(gint *argc , gchar ***argv , gchar *gtk_modules_args ) ;
#line 43
void _gtk_modules_settings_changed(GtkSettings *settings , gchar *modules ) ;
#line 71 "/usr/include/gtk-2.0/gtk/gtkmountoperation.h"
GType gtk_mount_operation_get_type(void) ;
#line 72
GMountOperation *gtk_mount_operation_new(GtkWindow *parent ) ;
#line 73
gboolean gtk_mount_operation_is_showing(GtkMountOperation *op ) ;
#line 74
void gtk_mount_operation_set_parent(GtkMountOperation *op , GtkWindow *parent ) ;
#line 76
GtkWindow *gtk_mount_operation_get_parent(GtkMountOperation *op ) ;
#line 77
void gtk_mount_operation_set_screen(GtkMountOperation *op , GdkScreen *screen ) ;
#line 79
GdkScreen *gtk_mount_operation_get_screen(GtkMountOperation *op ) ;
#line 151 "/usr/include/gtk-2.0/gtk/gtknotebook.h"
GType gtk_notebook_get_type(void) ;
#line 152
GtkWidget *gtk_notebook_new(void) ;
#line 153
gint gtk_notebook_append_page(GtkNotebook *notebook , GtkWidget *child , GtkWidget *tab_label ) ;
#line 156
gint gtk_notebook_append_page_menu(GtkNotebook *notebook , GtkWidget *child , GtkWidget *tab_label ,
                                   GtkWidget *menu_label ) ;
#line 160
gint gtk_notebook_prepend_page(GtkNotebook *notebook , GtkWidget *child , GtkWidget *tab_label ) ;
#line 163
gint gtk_notebook_prepend_page_menu(GtkNotebook *notebook , GtkWidget *child , GtkWidget *tab_label ,
                                    GtkWidget *menu_label ) ;
#line 167
gint gtk_notebook_insert_page(GtkNotebook *notebook , GtkWidget *child , GtkWidget *tab_label ,
                              gint position ) ;
#line 171
gint gtk_notebook_insert_page_menu(GtkNotebook *notebook , GtkWidget *child , GtkWidget *tab_label ,
                                   GtkWidget *menu_label , gint position ) ;
#line 176
void gtk_notebook_remove_page(GtkNotebook *notebook , gint page_num ) ;
#line 184
void gtk_notebook_set_window_creation_hook(GtkNotebookWindowCreationFunc func , gpointer data ,
                                           GDestroyNotify destroy ) ;
#line 187
void gtk_notebook_set_group_id(GtkNotebook *notebook , gint group_id ) ;
#line 189
gint gtk_notebook_get_group_id(GtkNotebook *notebook ) ;
#line 191
void gtk_notebook_set_group(GtkNotebook *notebook , gpointer group ) ;
#line 193
gpointer gtk_notebook_get_group(GtkNotebook *notebook ) ;
#line 196
void gtk_notebook_set_group_name(GtkNotebook *notebook , gchar *group_name ) ;
#line 198
gchar *gtk_notebook_get_group_name(GtkNotebook *notebook ) ;
#line 205
gint gtk_notebook_get_current_page(GtkNotebook *notebook ) ;
#line 206
GtkWidget *gtk_notebook_get_nth_page(GtkNotebook *notebook , gint page_num ) ;
#line 208
gint gtk_notebook_get_n_pages(GtkNotebook *notebook ) ;
#line 209
gint gtk_notebook_page_num(GtkNotebook *notebook , GtkWidget *child ) ;
#line 211
void gtk_notebook_set_current_page(GtkNotebook *notebook , gint page_num ) ;
#line 213
void gtk_notebook_next_page(GtkNotebook *notebook ) ;
#line 214
void gtk_notebook_prev_page(GtkNotebook *notebook ) ;
#line 220
void gtk_notebook_set_show_border(GtkNotebook *notebook , gboolean show_border ) ;
#line 222
gboolean gtk_notebook_get_show_border(GtkNotebook *notebook ) ;
#line 223
void gtk_notebook_set_show_tabs(GtkNotebook *notebook , gboolean show_tabs ) ;
#line 225
gboolean gtk_notebook_get_show_tabs(GtkNotebook *notebook ) ;
#line 226
void gtk_notebook_set_tab_pos(GtkNotebook *notebook , GtkPositionType pos ) ;
#line 228
GtkPositionType gtk_notebook_get_tab_pos(GtkNotebook *notebook ) ;
#line 231
void gtk_notebook_set_homogeneous_tabs(GtkNotebook *notebook , gboolean homogeneous ) ;
#line 233
void gtk_notebook_set_tab_border(GtkNotebook *notebook , guint border_width ) ;
#line 235
void gtk_notebook_set_tab_hborder(GtkNotebook *notebook , guint tab_hborder ) ;
#line 237
void gtk_notebook_set_tab_vborder(GtkNotebook *notebook , guint tab_vborder ) ;
#line 241
void gtk_notebook_set_scrollable(GtkNotebook *notebook , gboolean scrollable ) ;
#line 243
gboolean gtk_notebook_get_scrollable(GtkNotebook *notebook ) ;
#line 244
guint16 gtk_notebook_get_tab_hborder(GtkNotebook *notebook ) ;
#line 245
guint16 gtk_notebook_get_tab_vborder(GtkNotebook *notebook ) ;
#line 251
void gtk_notebook_popup_enable(GtkNotebook *notebook ) ;
#line 252
void gtk_notebook_popup_disable(GtkNotebook *notebook ) ;
#line 258
GtkWidget *gtk_notebook_get_tab_label(GtkNotebook *notebook , GtkWidget *child ) ;
#line 260
void gtk_notebook_set_tab_label(GtkNotebook *notebook , GtkWidget *child , GtkWidget *tab_label ) ;
#line 263
void gtk_notebook_set_tab_label_text(GtkNotebook *notebook , GtkWidget *child , gchar *tab_text ) ;
#line 266
gchar *gtk_notebook_get_tab_label_text(GtkNotebook *notebook , GtkWidget *child ) ;
#line 268
GtkWidget *gtk_notebook_get_menu_label(GtkNotebook *notebook , GtkWidget *child ) ;
#line 270
void gtk_notebook_set_menu_label(GtkNotebook *notebook , GtkWidget *child , GtkWidget *menu_label ) ;
#line 273
void gtk_notebook_set_menu_label_text(GtkNotebook *notebook , GtkWidget *child , gchar *menu_text ) ;
#line 276
gchar *gtk_notebook_get_menu_label_text(GtkNotebook *notebook , GtkWidget *child ) ;
#line 279
void gtk_notebook_query_tab_label_packing(GtkNotebook *notebook , GtkWidget *child ,
                                          gboolean *expand , gboolean *fill , GtkPackType *pack_type ) ;
#line 284
void gtk_notebook_set_tab_label_packing(GtkNotebook *notebook , GtkWidget *child ,
                                        gboolean expand , gboolean fill , GtkPackType pack_type ) ;
#line 290
void gtk_notebook_reorder_child(GtkNotebook *notebook , GtkWidget *child , gint position ) ;
#line 293
gboolean gtk_notebook_get_tab_reorderable(GtkNotebook *notebook , GtkWidget *child ) ;
#line 295
void gtk_notebook_set_tab_reorderable(GtkNotebook *notebook , GtkWidget *child , gboolean reorderable ) ;
#line 298
gboolean gtk_notebook_get_tab_detachable(GtkNotebook *notebook , GtkWidget *child ) ;
#line 300
void gtk_notebook_set_tab_detachable(GtkNotebook *notebook , GtkWidget *child , gboolean detachable ) ;
#line 304
GtkWidget *gtk_notebook_get_action_widget(GtkNotebook *notebook , GtkPackType pack_type ) ;
#line 306
void gtk_notebook_set_action_widget(GtkNotebook *notebook , GtkWidget *widget , GtkPackType pack_type ) ;
#line 52 "/usr/include/gtk-2.0/gtk/gtkoffscreenwindow.h"
GType gtk_offscreen_window_get_type(void) ;
#line 54
GtkWidget *gtk_offscreen_window_new(void) ;
#line 55
GdkPixmap *gtk_offscreen_window_get_pixmap(GtkOffscreenWindow *offscreen ) ;
#line 56
GdkPixbuf *gtk_offscreen_window_get_pixbuf(GtkOffscreenWindow *offscreen ) ;
#line 52 "/usr/include/gtk-2.0/gtk/gtkorientable.h"
GType gtk_orientable_get_type(void) ;
#line 54
void gtk_orientable_set_orientation(GtkOrientable *orientable , GtkOrientation orientation ) ;
#line 56
GtkOrientation gtk_orientable_get_orientation(GtkOrientable *orientable ) ;
#line 47 "/usr/include/gtk-2.0/gtk/gtkpapersize.h"
GType gtk_paper_size_get_type(void) ;
#line 49
GtkPaperSize *gtk_paper_size_new(gchar *name ) ;
#line 50
GtkPaperSize *gtk_paper_size_new_from_ppd(gchar *ppd_name , gchar *ppd_display_name ,
                                          gdouble width , gdouble height ) ;
#line 54
GtkPaperSize *gtk_paper_size_new_custom(gchar *name , gchar *display_name , gdouble width ,
                                        gdouble height , GtkUnit unit ) ;
#line 59
GtkPaperSize *gtk_paper_size_copy(GtkPaperSize *other ) ;
#line 60
void gtk_paper_size_free(GtkPaperSize *size ) ;
#line 61
gboolean gtk_paper_size_is_equal(GtkPaperSize *size1 , GtkPaperSize *size2 ) ;
#line 64
GList *gtk_paper_size_get_paper_sizes(gboolean include_custom ) ;
#line 67
gchar *gtk_paper_size_get_name(GtkPaperSize *size ) ;
#line 68
gchar *gtk_paper_size_get_display_name(GtkPaperSize *size ) ;
#line 69
gchar *gtk_paper_size_get_ppd_name(GtkPaperSize *size ) ;
#line 71
gdouble gtk_paper_size_get_width(GtkPaperSize *size , GtkUnit unit ) ;
#line 72
gdouble gtk_paper_size_get_height(GtkPaperSize *size , GtkUnit unit ) ;
#line 73
gboolean gtk_paper_size_is_custom(GtkPaperSize *size ) ;
#line 76
void gtk_paper_size_set_size(GtkPaperSize *size , gdouble width , gdouble height ,
                             GtkUnit unit ) ;
#line 81
gdouble gtk_paper_size_get_default_top_margin(GtkPaperSize *size , GtkUnit unit ) ;
#line 83
gdouble gtk_paper_size_get_default_bottom_margin(GtkPaperSize *size , GtkUnit unit ) ;
#line 85
gdouble gtk_paper_size_get_default_left_margin(GtkPaperSize *size , GtkUnit unit ) ;
#line 87
gdouble gtk_paper_size_get_default_right_margin(GtkPaperSize *size , GtkUnit unit ) ;
#line 90
gchar *gtk_paper_size_get_default(void) ;
#line 92
GtkPaperSize *gtk_paper_size_new_from_key_file(GKeyFile *key_file , gchar *group_name ,
                                               GError **error ) ;
#line 95
void gtk_paper_size_to_key_file(GtkPaperSize *size , GKeyFile *key_file , gchar *group_name ) ;
#line 40 "/usr/include/gtk-2.0/gtk/gtkpagesetup.h"
GType gtk_page_setup_get_type(void) ;
#line 41
GtkPageSetup *gtk_page_setup_new(void) ;
#line 42
GtkPageSetup *gtk_page_setup_copy(GtkPageSetup *other ) ;
#line 43
GtkPageOrientation gtk_page_setup_get_orientation(GtkPageSetup *setup ) ;
#line 44
void gtk_page_setup_set_orientation(GtkPageSetup *setup , GtkPageOrientation orientation ) ;
#line 46
GtkPaperSize *gtk_page_setup_get_paper_size(GtkPageSetup *setup ) ;
#line 47
void gtk_page_setup_set_paper_size(GtkPageSetup *setup , GtkPaperSize *size ) ;
#line 49
gdouble gtk_page_setup_get_top_margin(GtkPageSetup *setup , GtkUnit unit ) ;
#line 51
void gtk_page_setup_set_top_margin(GtkPageSetup *setup , gdouble margin , GtkUnit unit ) ;
#line 54
gdouble gtk_page_setup_get_bottom_margin(GtkPageSetup *setup , GtkUnit unit ) ;
#line 56
void gtk_page_setup_set_bottom_margin(GtkPageSetup *setup , gdouble margin , GtkUnit unit ) ;
#line 59
gdouble gtk_page_setup_get_left_margin(GtkPageSetup *setup , GtkUnit unit ) ;
#line 61
void gtk_page_setup_set_left_margin(GtkPageSetup *setup , gdouble margin , GtkUnit unit ) ;
#line 64
gdouble gtk_page_setup_get_right_margin(GtkPageSetup *setup , GtkUnit unit ) ;
#line 66
void gtk_page_setup_set_right_margin(GtkPageSetup *setup , gdouble margin , GtkUnit unit ) ;
#line 70
void gtk_page_setup_set_paper_size_and_default_margins(GtkPageSetup *setup , GtkPaperSize *size ) ;
#line 74
gdouble gtk_page_setup_get_paper_width(GtkPageSetup *setup , GtkUnit unit ) ;
#line 76
gdouble gtk_page_setup_get_paper_height(GtkPageSetup *setup , GtkUnit unit ) ;
#line 81
gdouble gtk_page_setup_get_page_width(GtkPageSetup *setup , GtkUnit unit ) ;
#line 83
gdouble gtk_page_setup_get_page_height(GtkPageSetup *setup , GtkUnit unit ) ;
#line 87
GtkPageSetup *gtk_page_setup_new_from_file(gchar *file_name , GError **error ) ;
#line 89
gboolean gtk_page_setup_load_file(GtkPageSetup *setup , char const   *file_name ,
                                  GError **error ) ;
#line 92
gboolean gtk_page_setup_to_file(GtkPageSetup *setup , char const   *file_name , GError **error ) ;
#line 95
GtkPageSetup *gtk_page_setup_new_from_key_file(GKeyFile *key_file , gchar *group_name ,
                                               GError **error ) ;
#line 98
gboolean gtk_page_setup_load_key_file(GtkPageSetup *setup , GKeyFile *key_file , gchar *group_name ,
                                      GError **error ) ;
#line 102
void gtk_page_setup_to_key_file(GtkPageSetup *setup , GKeyFile *key_file , gchar *group_name ) ;
#line 87 "/usr/include/gtk-2.0/gtk/gtksocket.h"
GType gtk_socket_get_type(void) ;
#line 88
GtkWidget *gtk_socket_new(void) ;
#line 90
void gtk_socket_add_id(GtkSocket *socket_ , GdkNativeWindow window_id ) ;
#line 92
GdkNativeWindow gtk_socket_get_id(GtkSocket *socket_ ) ;
#line 93
GdkWindow *gtk_socket_get_plug_window(GtkSocket *socket_ ) ;
#line 96
void gtk_socket_steal(GtkSocket *socket_ , GdkNativeWindow wid ) ;
#line 78 "/usr/include/gtk-2.0/gtk/gtkplug.h"
GType gtk_plug_get_type(void) ;
#line 81
void gtk_plug_construct(GtkPlug *plug , GdkNativeWindow socket_id ) ;
#line 83
GtkWidget *gtk_plug_new(GdkNativeWindow socket_id ) ;
#line 86
void gtk_plug_construct_for_display(GtkPlug *plug , GdkDisplay *display , GdkNativeWindow socket_id ) ;
#line 89
GtkWidget *gtk_plug_new_for_display(GdkDisplay *display , GdkNativeWindow socket_id ) ;
#line 92
GdkNativeWindow gtk_plug_get_id(GtkPlug *plug ) ;
#line 94
gboolean gtk_plug_get_embedded(GtkPlug *plug ) ;
#line 96
GdkWindow *gtk_plug_get_socket_window(GtkPlug *plug ) ;
#line 98
void _gtk_plug_add_to_socket(GtkPlug *plug , GtkSocket *socket_ ) ;
#line 100
void _gtk_plug_remove_from_socket(GtkPlug *plug , GtkSocket *socket_ ) ;
#line 41 "/usr/include/gtk-2.0/gtk/gtkprintcontext.h"
GType gtk_print_context_get_type(void) ;
#line 45
cairo_t *gtk_print_context_get_cairo_context(GtkPrintContext *context ) ;
#line 47
GtkPageSetup *gtk_print_context_get_page_setup(GtkPrintContext *context ) ;
#line 48
gdouble gtk_print_context_get_width(GtkPrintContext *context ) ;
#line 49
gdouble gtk_print_context_get_height(GtkPrintContext *context ) ;
#line 50
gdouble gtk_print_context_get_dpi_x(GtkPrintContext *context ) ;
#line 51
gdouble gtk_print_context_get_dpi_y(GtkPrintContext *context ) ;
#line 52
gboolean gtk_print_context_get_hard_margins(GtkPrintContext *context , gdouble *top ,
                                            gdouble *bottom , gdouble *left , gdouble *right ) ;
#line 59
PangoFontMap *gtk_print_context_get_pango_fontmap(GtkPrintContext *context ) ;
#line 60
PangoContext *gtk_print_context_create_pango_context(GtkPrintContext *context ) ;
#line 61
PangoLayout *gtk_print_context_create_pango_layout(GtkPrintContext *context ) ;
#line 64
void gtk_print_context_set_cairo_context(GtkPrintContext *context , cairo_t *cr ,
                                         double dpi_x , double dpi_y ) ;
#line 49 "/usr/include/gtk-2.0/gtk/gtkprintsettings.h"
GType gtk_print_settings_get_type(void) ;
#line 50
GtkPrintSettings *gtk_print_settings_new(void) ;
#line 52
GtkPrintSettings *gtk_print_settings_copy(GtkPrintSettings *other ) ;
#line 54
GtkPrintSettings *gtk_print_settings_new_from_file(gchar *file_name , GError **error ) ;
#line 56
gboolean gtk_print_settings_load_file(GtkPrintSettings *settings , gchar *file_name ,
                                      GError **error ) ;
#line 59
gboolean gtk_print_settings_to_file(GtkPrintSettings *settings , gchar *file_name ,
                                    GError **error ) ;
#line 62
GtkPrintSettings *gtk_print_settings_new_from_key_file(GKeyFile *key_file , gchar *group_name ,
                                                       GError **error ) ;
#line 65
gboolean gtk_print_settings_load_key_file(GtkPrintSettings *settings , GKeyFile *key_file ,
                                          gchar *group_name , GError **error ) ;
#line 69
void gtk_print_settings_to_key_file(GtkPrintSettings *settings , GKeyFile *key_file ,
                                    gchar *group_name ) ;
#line 72
gboolean gtk_print_settings_has_key(GtkPrintSettings *settings , gchar *key ) ;
#line 74
gchar *gtk_print_settings_get(GtkPrintSettings *settings , gchar *key ) ;
#line 76
void gtk_print_settings_set(GtkPrintSettings *settings , gchar *key , gchar *value ) ;
#line 79
void gtk_print_settings_unset(GtkPrintSettings *settings , gchar *key ) ;
#line 81
void gtk_print_settings_foreach(GtkPrintSettings *settings , GtkPrintSettingsFunc func ,
                                gpointer user_data ) ;
#line 84
gboolean gtk_print_settings_get_bool(GtkPrintSettings *settings , gchar *key ) ;
#line 86
void gtk_print_settings_set_bool(GtkPrintSettings *settings , gchar *key , gboolean value ) ;
#line 89
gdouble gtk_print_settings_get_double(GtkPrintSettings *settings , gchar *key ) ;
#line 91
gdouble gtk_print_settings_get_double_with_default(GtkPrintSettings *settings , gchar *key ,
                                                   gdouble def ) ;
#line 94
void gtk_print_settings_set_double(GtkPrintSettings *settings , gchar *key , gdouble value ) ;
#line 97
gdouble gtk_print_settings_get_length(GtkPrintSettings *settings , gchar *key , GtkUnit unit ) ;
#line 100
void gtk_print_settings_set_length(GtkPrintSettings *settings , gchar *key , gdouble value ,
                                   GtkUnit unit ) ;
#line 104
gint gtk_print_settings_get_int(GtkPrintSettings *settings , gchar *key ) ;
#line 106
gint gtk_print_settings_get_int_with_default(GtkPrintSettings *settings , gchar *key ,
                                             gint def ) ;
#line 109
void gtk_print_settings_set_int(GtkPrintSettings *settings , gchar *key , gint value ) ;
#line 148
gchar *gtk_print_settings_get_printer(GtkPrintSettings *settings ) ;
#line 149
void gtk_print_settings_set_printer(GtkPrintSettings *settings , gchar *printer ) ;
#line 151
GtkPageOrientation gtk_print_settings_get_orientation(GtkPrintSettings *settings ) ;
#line 152
void gtk_print_settings_set_orientation(GtkPrintSettings *settings , GtkPageOrientation orientation ) ;
#line 154
GtkPaperSize *gtk_print_settings_get_paper_size(GtkPrintSettings *settings ) ;
#line 155
void gtk_print_settings_set_paper_size(GtkPrintSettings *settings , GtkPaperSize *paper_size ) ;
#line 157
gdouble gtk_print_settings_get_paper_width(GtkPrintSettings *settings , GtkUnit unit ) ;
#line 159
void gtk_print_settings_set_paper_width(GtkPrintSettings *settings , gdouble width ,
                                        GtkUnit unit ) ;
#line 162
gdouble gtk_print_settings_get_paper_height(GtkPrintSettings *settings , GtkUnit unit ) ;
#line 164
void gtk_print_settings_set_paper_height(GtkPrintSettings *settings , gdouble height ,
                                         GtkUnit unit ) ;
#line 167
gboolean gtk_print_settings_get_use_color(GtkPrintSettings *settings ) ;
#line 168
void gtk_print_settings_set_use_color(GtkPrintSettings *settings , gboolean use_color ) ;
#line 170
gboolean gtk_print_settings_get_collate(GtkPrintSettings *settings ) ;
#line 171
void gtk_print_settings_set_collate(GtkPrintSettings *settings , gboolean collate ) ;
#line 173
gboolean gtk_print_settings_get_reverse(GtkPrintSettings *settings ) ;
#line 174
void gtk_print_settings_set_reverse(GtkPrintSettings *settings , gboolean reverse ) ;
#line 176
GtkPrintDuplex gtk_print_settings_get_duplex(GtkPrintSettings *settings ) ;
#line 177
void gtk_print_settings_set_duplex(GtkPrintSettings *settings , GtkPrintDuplex duplex ) ;
#line 179
GtkPrintQuality gtk_print_settings_get_quality(GtkPrintSettings *settings ) ;
#line 180
void gtk_print_settings_set_quality(GtkPrintSettings *settings , GtkPrintQuality quality ) ;
#line 182
gint gtk_print_settings_get_n_copies(GtkPrintSettings *settings ) ;
#line 183
void gtk_print_settings_set_n_copies(GtkPrintSettings *settings , gint num_copies ) ;
#line 185
gint gtk_print_settings_get_number_up(GtkPrintSettings *settings ) ;
#line 186
void gtk_print_settings_set_number_up(GtkPrintSettings *settings , gint number_up ) ;
#line 188
GtkNumberUpLayout gtk_print_settings_get_number_up_layout(GtkPrintSettings *settings ) ;
#line 189
void gtk_print_settings_set_number_up_layout(GtkPrintSettings *settings , GtkNumberUpLayout number_up_layout ) ;
#line 191
gint gtk_print_settings_get_resolution(GtkPrintSettings *settings ) ;
#line 192
void gtk_print_settings_set_resolution(GtkPrintSettings *settings , gint resolution ) ;
#line 194
gint gtk_print_settings_get_resolution_x(GtkPrintSettings *settings ) ;
#line 195
gint gtk_print_settings_get_resolution_y(GtkPrintSettings *settings ) ;
#line 196
void gtk_print_settings_set_resolution_xy(GtkPrintSettings *settings , gint resolution_x ,
                                          gint resolution_y ) ;
#line 199
gdouble gtk_print_settings_get_printer_lpi(GtkPrintSettings *settings ) ;
#line 200
void gtk_print_settings_set_printer_lpi(GtkPrintSettings *settings , gdouble lpi ) ;
#line 202
gdouble gtk_print_settings_get_scale(GtkPrintSettings *settings ) ;
#line 203
void gtk_print_settings_set_scale(GtkPrintSettings *settings , gdouble scale ) ;
#line 205
GtkPrintPages gtk_print_settings_get_print_pages(GtkPrintSettings *settings ) ;
#line 206
void gtk_print_settings_set_print_pages(GtkPrintSettings *settings , GtkPrintPages pages ) ;
#line 208
GtkPageRange *gtk_print_settings_get_page_ranges(GtkPrintSettings *settings , gint *num_ranges ) ;
#line 210
void gtk_print_settings_set_page_ranges(GtkPrintSettings *settings , GtkPageRange *page_ranges ,
                                        gint num_ranges ) ;
#line 213
GtkPageSet gtk_print_settings_get_page_set(GtkPrintSettings *settings ) ;
#line 214
void gtk_print_settings_set_page_set(GtkPrintSettings *settings , GtkPageSet page_set ) ;
#line 216
gchar *gtk_print_settings_get_default_source(GtkPrintSettings *settings ) ;
#line 217
void gtk_print_settings_set_default_source(GtkPrintSettings *settings , gchar *default_source ) ;
#line 219
gchar *gtk_print_settings_get_media_type(GtkPrintSettings *settings ) ;
#line 220
void gtk_print_settings_set_media_type(GtkPrintSettings *settings , gchar *media_type ) ;
#line 222
gchar *gtk_print_settings_get_dither(GtkPrintSettings *settings ) ;
#line 223
void gtk_print_settings_set_dither(GtkPrintSettings *settings , gchar *dither ) ;
#line 225
gchar *gtk_print_settings_get_finishings(GtkPrintSettings *settings ) ;
#line 226
void gtk_print_settings_set_finishings(GtkPrintSettings *settings , gchar *finishings ) ;
#line 228
gchar *gtk_print_settings_get_output_bin(GtkPrintSettings *settings ) ;
#line 229
void gtk_print_settings_set_output_bin(GtkPrintSettings *settings , gchar *output_bin ) ;
#line 70 "/usr/include/gtk-2.0/gtk/gtkprintoperationpreview.h"
GType gtk_print_operation_preview_get_type(void) ;
#line 72
void gtk_print_operation_preview_render_page(GtkPrintOperationPreview *preview , gint page_nr ) ;
#line 74
void gtk_print_operation_preview_end_preview(GtkPrintOperationPreview *preview ) ;
#line 75
gboolean gtk_print_operation_preview_is_selected(GtkPrintOperationPreview *preview ,
                                                 gint page_nr ) ;
#line 139 "/usr/include/gtk-2.0/gtk/gtkprintoperation.h"
GQuark gtk_print_error_quark(void) ;
#line 141
GType gtk_print_operation_get_type(void) ;
#line 142
GtkPrintOperation *gtk_print_operation_new(void) ;
#line 143
void gtk_print_operation_set_default_page_setup(GtkPrintOperation *op , GtkPageSetup *default_page_setup ) ;
#line 145
GtkPageSetup *gtk_print_operation_get_default_page_setup(GtkPrintOperation *op ) ;
#line 146
void gtk_print_operation_set_print_settings(GtkPrintOperation *op , GtkPrintSettings *print_settings ) ;
#line 148
GtkPrintSettings *gtk_print_operation_get_print_settings(GtkPrintOperation *op ) ;
#line 149
void gtk_print_operation_set_job_name(GtkPrintOperation *op , gchar *job_name ) ;
#line 151
void gtk_print_operation_set_n_pages(GtkPrintOperation *op , gint n_pages ) ;
#line 153
void gtk_print_operation_set_current_page(GtkPrintOperation *op , gint current_page ) ;
#line 155
void gtk_print_operation_set_use_full_page(GtkPrintOperation *op , gboolean full_page ) ;
#line 157
void gtk_print_operation_set_unit(GtkPrintOperation *op , GtkUnit unit ) ;
#line 159
void gtk_print_operation_set_export_filename(GtkPrintOperation *op , gchar *filename ) ;
#line 161
void gtk_print_operation_set_track_print_status(GtkPrintOperation *op , gboolean track_status ) ;
#line 163
void gtk_print_operation_set_show_progress(GtkPrintOperation *op , gboolean show_progress ) ;
#line 165
void gtk_print_operation_set_allow_async(GtkPrintOperation *op , gboolean allow_async ) ;
#line 167
void gtk_print_operation_set_custom_tab_label(GtkPrintOperation *op , gchar *label ) ;
#line 169
GtkPrintOperationResult gtk_print_operation_run(GtkPrintOperation *op , GtkPrintOperationAction action ,
                                                GtkWindow *parent , GError **error ) ;
#line 173
void gtk_print_operation_get_error(GtkPrintOperation *op , GError **error ) ;
#line 175
GtkPrintStatus gtk_print_operation_get_status(GtkPrintOperation *op ) ;
#line 176
gchar *gtk_print_operation_get_status_string(GtkPrintOperation *op ) ;
#line 177
gboolean gtk_print_operation_is_finished(GtkPrintOperation *op ) ;
#line 178
void gtk_print_operation_cancel(GtkPrintOperation *op ) ;
#line 179
void gtk_print_operation_draw_page_finish(GtkPrintOperation *op ) ;
#line 180
void gtk_print_operation_set_defer_drawing(GtkPrintOperation *op ) ;
#line 181
void gtk_print_operation_set_support_selection(GtkPrintOperation *op , gboolean support_selection ) ;
#line 183
gboolean gtk_print_operation_get_support_selection(GtkPrintOperation *op ) ;
#line 184
void gtk_print_operation_set_has_selection(GtkPrintOperation *op , gboolean has_selection ) ;
#line 186
gboolean gtk_print_operation_get_has_selection(GtkPrintOperation *op ) ;
#line 187
void gtk_print_operation_set_embed_page_setup(GtkPrintOperation *op , gboolean embed ) ;
#line 189
gboolean gtk_print_operation_get_embed_page_setup(GtkPrintOperation *op ) ;
#line 190
gint gtk_print_operation_get_n_pages_to_print(GtkPrintOperation *op ) ;
#line 192
GtkPageSetup *gtk_print_run_page_setup_dialog(GtkWindow *parent , GtkPageSetup *page_setup ,
                                              GtkPrintSettings *settings ) ;
#line 199
void gtk_print_run_page_setup_dialog_async(GtkWindow *parent , GtkPageSetup *page_setup ,
                                           GtkPrintSettings *settings , GtkPageSetupDoneFunc done_cb ,
                                           gpointer data ) ;
#line 88 "/usr/include/gtk-2.0/gtk/gtkprogress.h"
GType gtk_progress_get_type(void) ;
#line 89
void gtk_progress_set_show_text(GtkProgress *progress , gboolean show_text ) ;
#line 91
void gtk_progress_set_text_alignment(GtkProgress *progress , gfloat x_align , gfloat y_align ) ;
#line 94
void gtk_progress_set_format_string(GtkProgress *progress , gchar *format ) ;
#line 96
void gtk_progress_set_adjustment(GtkProgress *progress , GtkAdjustment *adjustment ) ;
#line 98
void gtk_progress_configure(GtkProgress *progress , gdouble value , gdouble min ,
                            gdouble max ) ;
#line 102
void gtk_progress_set_percentage(GtkProgress *progress , gdouble percentage ) ;
#line 104
void gtk_progress_set_value(GtkProgress *progress , gdouble value ) ;
#line 106
gdouble gtk_progress_get_value(GtkProgress *progress ) ;
#line 107
void gtk_progress_set_activity_mode(GtkProgress *progress , gboolean activity_mode ) ;
#line 109
gchar *gtk_progress_get_current_text(GtkProgress *progress ) ;
#line 110
gchar *gtk_progress_get_text_from_value(GtkProgress *progress , gdouble value ) ;
#line 112
gdouble gtk_progress_get_current_percentage(GtkProgress *progress ) ;
#line 113
gdouble gtk_progress_get_percentage_from_value(GtkProgress *progress , gdouble value ) ;
#line 98 "/usr/include/gtk-2.0/gtk/gtkprogressbar.h"
GType gtk_progress_bar_get_type(void) ;
#line 99
GtkWidget *gtk_progress_bar_new(void) ;
#line 128
void gtk_progress_bar_pulse(GtkProgressBar *pbar ) ;
#line 129
void gtk_progress_bar_set_text(GtkProgressBar *pbar , gchar *text ) ;
#line 131
void gtk_progress_bar_set_fraction(GtkProgressBar *pbar , gdouble fraction ) ;
#line 134
void gtk_progress_bar_set_pulse_step(GtkProgressBar *pbar , gdouble fraction ) ;
#line 136
void gtk_progress_bar_set_orientation(GtkProgressBar *pbar , GtkProgressBarOrientation orientation ) ;
#line 139
gchar *gtk_progress_bar_get_text(GtkProgressBar *pbar ) ;
#line 140
gdouble gtk_progress_bar_get_fraction(GtkProgressBar *pbar ) ;
#line 141
gdouble gtk_progress_bar_get_pulse_step(GtkProgressBar *pbar ) ;
#line 143
GtkProgressBarOrientation gtk_progress_bar_get_orientation(GtkProgressBar *pbar ) ;
#line 144
void gtk_progress_bar_set_ellipsize(GtkProgressBar *pbar , PangoEllipsizeMode mode ) ;
#line 146
PangoEllipsizeMode gtk_progress_bar_get_ellipsize(GtkProgressBar *pbar ) ;
#line 152
GtkWidget *gtk_progress_bar_new_with_adjustment(GtkAdjustment *adjustment ) ;
#line 153
void gtk_progress_bar_set_bar_style(GtkProgressBar *pbar , GtkProgressBarStyle style ) ;
#line 155
void gtk_progress_bar_set_discrete_blocks(GtkProgressBar *pbar , guint blocks ) ;
#line 161
void gtk_progress_bar_set_activity_step(GtkProgressBar *pbar , guint step ) ;
#line 163
void gtk_progress_bar_set_activity_blocks(GtkProgressBar *pbar , guint blocks ) ;
#line 165
void gtk_progress_bar_update(GtkProgressBar *pbar , gdouble percentage ) ;
#line 75 "/usr/include/gtk-2.0/gtk/gtktoggleaction.h"
GType gtk_toggle_action_get_type(void) ;
#line 76
GtkToggleAction *gtk_toggle_action_new(gchar *name , gchar *label , gchar *tooltip ,
                                       gchar *stock_id ) ;
#line 80
void gtk_toggle_action_toggled(GtkToggleAction *action ) ;
#line 81
void gtk_toggle_action_set_active(GtkToggleAction *action , gboolean is_active ) ;
#line 83
gboolean gtk_toggle_action_get_active(GtkToggleAction *action ) ;
#line 84
void gtk_toggle_action_set_draw_as_radio(GtkToggleAction *action , gboolean draw_as_radio ) ;
#line 86
gboolean gtk_toggle_action_get_draw_as_radio(GtkToggleAction *action ) ;
#line 75 "/usr/include/gtk-2.0/gtk/gtkradioaction.h"
GType gtk_radio_action_get_type(void) ;
#line 76
GtkRadioAction *gtk_radio_action_new(gchar *name , gchar *label , gchar *tooltip ,
                                     gchar *stock_id , gint value ) ;
#line 81
GSList *gtk_radio_action_get_group(GtkRadioAction *action ) ;
#line 82
void gtk_radio_action_set_group(GtkRadioAction *action , GSList *group ) ;
#line 84
gint gtk_radio_action_get_current_value(GtkRadioAction *action ) ;
#line 85
void gtk_radio_action_set_current_value(GtkRadioAction *action , gint current_value ) ;
#line 72 "/usr/include/gtk-2.0/gtk/gtkradiobutton.h"
GType gtk_radio_button_get_type(void) ;
#line 74
GtkWidget *gtk_radio_button_new(GSList *group ) ;
#line 75
GtkWidget *gtk_radio_button_new_from_widget(GtkRadioButton *radio_group_member ) ;
#line 76
GtkWidget *gtk_radio_button_new_with_label(GSList *group , gchar *label ) ;
#line 78
GtkWidget *gtk_radio_button_new_with_label_from_widget(GtkRadioButton *radio_group_member ,
                                                       gchar *label ) ;
#line 80
GtkWidget *gtk_radio_button_new_with_mnemonic(GSList *group , gchar *label ) ;
#line 82
GtkWidget *gtk_radio_button_new_with_mnemonic_from_widget(GtkRadioButton *radio_group_member ,
                                                          gchar *label ) ;
#line 84
GSList *gtk_radio_button_get_group(GtkRadioButton *radio_button ) ;
#line 85
void gtk_radio_button_set_group(GtkRadioButton *radio_button , GSList *group ) ;
#line 72 "/usr/include/gtk-2.0/gtk/gtkradiomenuitem.h"
GType gtk_radio_menu_item_get_type(void) ;
#line 74
GtkWidget *gtk_radio_menu_item_new(GSList *group ) ;
#line 75
GtkWidget *gtk_radio_menu_item_new_with_label(GSList *group , gchar *label ) ;
#line 77
GtkWidget *gtk_radio_menu_item_new_with_mnemonic(GSList *group , gchar *label ) ;
#line 79
GtkWidget *gtk_radio_menu_item_new_from_widget(GtkRadioMenuItem *group ) ;
#line 80
GtkWidget *gtk_radio_menu_item_new_with_mnemonic_from_widget(GtkRadioMenuItem *group ,
                                                             gchar *label ) ;
#line 82
GtkWidget *gtk_radio_menu_item_new_with_label_from_widget(GtkRadioMenuItem *group ,
                                                          gchar *label ) ;
#line 84
GSList *gtk_radio_menu_item_get_group(GtkRadioMenuItem *radio_menu_item ) ;
#line 85
void gtk_radio_menu_item_set_group(GtkRadioMenuItem *radio_menu_item , GSList *group ) ;
#line 67 "/usr/include/gtk-2.0/gtk/gtktoggletoolbutton.h"
GType gtk_toggle_tool_button_get_type(void) ;
#line 68
GtkToolItem *gtk_toggle_tool_button_new(void) ;
#line 69
GtkToolItem *gtk_toggle_tool_button_new_from_stock(gchar *stock_id ) ;
#line 71
void gtk_toggle_tool_button_set_active(GtkToggleToolButton *button , gboolean is_active ) ;
#line 73
gboolean gtk_toggle_tool_button_get_active(GtkToggleToolButton *button ) ;
#line 60 "/usr/include/gtk-2.0/gtk/gtkradiotoolbutton.h"
GType gtk_radio_tool_button_get_type(void) ;
#line 62
GtkToolItem *gtk_radio_tool_button_new(GSList *group ) ;
#line 63
GtkToolItem *gtk_radio_tool_button_new_from_stock(GSList *group , gchar *stock_id ) ;
#line 65
GtkToolItem *gtk_radio_tool_button_new_from_widget(GtkRadioToolButton *group ) ;
#line 66
GtkToolItem *gtk_radio_tool_button_new_with_stock_from_widget(GtkRadioToolButton *group ,
                                                              gchar *stock_id ) ;
#line 68
GSList *gtk_radio_tool_button_get_group(GtkRadioToolButton *button ) ;
#line 69
void gtk_radio_tool_button_set_group(GtkRadioToolButton *button , GSList *group ) ;
#line 135 "/usr/include/gtk-2.0/gtk/gtkrecentmanager.h"
GQuark gtk_recent_manager_error_quark(void) ;
#line 138
GType gtk_recent_manager_get_type(void) ;
#line 140
GtkRecentManager *gtk_recent_manager_new(void) ;
#line 141
GtkRecentManager *gtk_recent_manager_get_default(void) ;
#line 144
GtkRecentManager *gtk_recent_manager_get_for_screen(GdkScreen *screen ) ;
#line 145
void gtk_recent_manager_set_screen(GtkRecentManager *manager , GdkScreen *screen ) ;
#line 149
gboolean gtk_recent_manager_add_item(GtkRecentManager *manager , gchar *uri ) ;
#line 151
gboolean gtk_recent_manager_add_full(GtkRecentManager *manager , gchar *uri , GtkRecentData *recent_data ) ;
#line 154
gboolean gtk_recent_manager_remove_item(GtkRecentManager *manager , gchar *uri , GError **error ) ;
#line 157
GtkRecentInfo *gtk_recent_manager_lookup_item(GtkRecentManager *manager , gchar *uri ,
                                              GError **error ) ;
#line 160
gboolean gtk_recent_manager_has_item(GtkRecentManager *manager , gchar *uri ) ;
#line 162
gboolean gtk_recent_manager_move_item(GtkRecentManager *manager , gchar *uri , gchar *new_uri ,
                                      GError **error ) ;
#line 166
void gtk_recent_manager_set_limit(GtkRecentManager *manager , gint limit ) ;
#line 168
gint gtk_recent_manager_get_limit(GtkRecentManager *manager ) ;
#line 169
GList *gtk_recent_manager_get_items(GtkRecentManager *manager ) ;
#line 170
gint gtk_recent_manager_purge_items(GtkRecentManager *manager , GError **error ) ;
#line 174
GType gtk_recent_info_get_type(void) ;
#line 176
GtkRecentInfo *gtk_recent_info_ref(GtkRecentInfo *info ) ;
#line 177
void gtk_recent_info_unref(GtkRecentInfo *info ) ;
#line 179
gchar *gtk_recent_info_get_uri(GtkRecentInfo *info ) ;
#line 180
gchar *gtk_recent_info_get_display_name(GtkRecentInfo *info ) ;
#line 181
gchar *gtk_recent_info_get_description(GtkRecentInfo *info ) ;
#line 182
gchar *gtk_recent_info_get_mime_type(GtkRecentInfo *info ) ;
#line 183
time_t gtk_recent_info_get_added(GtkRecentInfo *info ) ;
#line 184
time_t gtk_recent_info_get_modified(GtkRecentInfo *info ) ;
#line 185
time_t gtk_recent_info_get_visited(GtkRecentInfo *info ) ;
#line 186
gboolean gtk_recent_info_get_private_hint(GtkRecentInfo *info ) ;
#line 187
gboolean gtk_recent_info_get_application_info(GtkRecentInfo *info , gchar *app_name ,
                                              gchar **app_exec , guint *count , time_t *time_ ) ;
#line 192
gchar **gtk_recent_info_get_applications(GtkRecentInfo *info , gsize *length ) ;
#line 194
gchar *gtk_recent_info_last_application(GtkRecentInfo *info ) ;
#line 195
gboolean gtk_recent_info_has_application(GtkRecentInfo *info , gchar *app_name ) ;
#line 197
gchar **gtk_recent_info_get_groups(GtkRecentInfo *info , gsize *length ) ;
#line 199
gboolean gtk_recent_info_has_group(GtkRecentInfo *info , gchar *group_name ) ;
#line 201
GdkPixbuf *gtk_recent_info_get_icon(GtkRecentInfo *info , gint size ) ;
#line 203
gchar *gtk_recent_info_get_short_name(GtkRecentInfo *info ) ;
#line 204
gchar *gtk_recent_info_get_uri_display(GtkRecentInfo *info ) ;
#line 205
gint gtk_recent_info_get_age(GtkRecentInfo *info ) ;
#line 206
gboolean gtk_recent_info_is_local(GtkRecentInfo *info ) ;
#line 207
gboolean gtk_recent_info_exists(GtkRecentInfo *info ) ;
#line 208
gboolean gtk_recent_info_match(GtkRecentInfo *info_a , GtkRecentInfo *info_b ) ;
#line 212
void _gtk_recent_manager_sync(void) ;
#line 58 "/usr/include/gtk-2.0/gtk/gtkrecentaction.h"
GType gtk_recent_action_get_type(void) ;
#line 59
GtkAction *gtk_recent_action_new(gchar *name , gchar *label , gchar *tooltip , gchar *stock_id ) ;
#line 63
GtkAction *gtk_recent_action_new_for_manager(gchar *name , gchar *label , gchar *tooltip ,
                                             gchar *stock_id , GtkRecentManager *manager ) ;
#line 68
gboolean gtk_recent_action_get_show_numbers(GtkRecentAction *action ) ;
#line 69
void gtk_recent_action_set_show_numbers(GtkRecentAction *action , gboolean show_numbers ) ;
#line 64 "/usr/include/gtk-2.0/gtk/gtkrecentfilter.h"
GType gtk_recent_filter_get_type(void) ;
#line 66
GtkRecentFilter *gtk_recent_filter_new(void) ;
#line 67
void gtk_recent_filter_set_name(GtkRecentFilter *filter , gchar *name ) ;
#line 69
gchar *gtk_recent_filter_get_name(GtkRecentFilter *filter ) ;
#line 71
void gtk_recent_filter_add_mime_type(GtkRecentFilter *filter , gchar *mime_type ) ;
#line 73
void gtk_recent_filter_add_pattern(GtkRecentFilter *filter , gchar *pattern ) ;
#line 75
void gtk_recent_filter_add_pixbuf_formats(GtkRecentFilter *filter ) ;
#line 76
void gtk_recent_filter_add_application(GtkRecentFilter *filter , gchar *application ) ;
#line 78
void gtk_recent_filter_add_group(GtkRecentFilter *filter , gchar *group ) ;
#line 80
void gtk_recent_filter_add_age(GtkRecentFilter *filter , gint days ) ;
#line 82
void gtk_recent_filter_add_custom(GtkRecentFilter *filter , GtkRecentFilterFlags needed ,
                                  GtkRecentFilterFunc func , gpointer data , GDestroyNotify data_destroy ) ;
#line 88
GtkRecentFilterFlags gtk_recent_filter_get_needed(GtkRecentFilter *filter ) ;
#line 89
gboolean gtk_recent_filter_filter(GtkRecentFilter *filter , GtkRecentFilterInfo *filter_info ) ;
#line 78 "/usr/include/gtk-2.0/gtk/gtkrecentchooser.h"
GQuark gtk_recent_chooser_error_quark(void) ;
#line 118
GType gtk_recent_chooser_get_type(void) ;
#line 123
void gtk_recent_chooser_set_show_private(GtkRecentChooser *chooser , gboolean show_private ) ;
#line 125
gboolean gtk_recent_chooser_get_show_private(GtkRecentChooser *chooser ) ;
#line 126
void gtk_recent_chooser_set_show_not_found(GtkRecentChooser *chooser , gboolean show_not_found ) ;
#line 128
gboolean gtk_recent_chooser_get_show_not_found(GtkRecentChooser *chooser ) ;
#line 129
void gtk_recent_chooser_set_select_multiple(GtkRecentChooser *chooser , gboolean select_multiple ) ;
#line 131
gboolean gtk_recent_chooser_get_select_multiple(GtkRecentChooser *chooser ) ;
#line 132
void gtk_recent_chooser_set_limit(GtkRecentChooser *chooser , gint limit ) ;
#line 134
gint gtk_recent_chooser_get_limit(GtkRecentChooser *chooser ) ;
#line 135
void gtk_recent_chooser_set_local_only(GtkRecentChooser *chooser , gboolean local_only ) ;
#line 137
gboolean gtk_recent_chooser_get_local_only(GtkRecentChooser *chooser ) ;
#line 138
void gtk_recent_chooser_set_show_tips(GtkRecentChooser *chooser , gboolean show_tips ) ;
#line 140
gboolean gtk_recent_chooser_get_show_tips(GtkRecentChooser *chooser ) ;
#line 142
void gtk_recent_chooser_set_show_numbers(GtkRecentChooser *chooser , gboolean show_numbers ) ;
#line 144
gboolean gtk_recent_chooser_get_show_numbers(GtkRecentChooser *chooser ) ;
#line 146
void gtk_recent_chooser_set_show_icons(GtkRecentChooser *chooser , gboolean show_icons ) ;
#line 148
gboolean gtk_recent_chooser_get_show_icons(GtkRecentChooser *chooser ) ;
#line 149
void gtk_recent_chooser_set_sort_type(GtkRecentChooser *chooser , GtkRecentSortType sort_type ) ;
#line 151
GtkRecentSortType gtk_recent_chooser_get_sort_type(GtkRecentChooser *chooser ) ;
#line 152
void gtk_recent_chooser_set_sort_func(GtkRecentChooser *chooser , GtkRecentSortFunc sort_func ,
                                      gpointer sort_data , GDestroyNotify data_destroy ) ;
#line 160
gboolean gtk_recent_chooser_set_current_uri(GtkRecentChooser *chooser , gchar *uri ,
                                            GError **error ) ;
#line 163
gchar *gtk_recent_chooser_get_current_uri(GtkRecentChooser *chooser ) ;
#line 164
GtkRecentInfo *gtk_recent_chooser_get_current_item(GtkRecentChooser *chooser ) ;
#line 165
gboolean gtk_recent_chooser_select_uri(GtkRecentChooser *chooser , gchar *uri , GError **error ) ;
#line 168
void gtk_recent_chooser_unselect_uri(GtkRecentChooser *chooser , gchar *uri ) ;
#line 170
void gtk_recent_chooser_select_all(GtkRecentChooser *chooser ) ;
#line 171
void gtk_recent_chooser_unselect_all(GtkRecentChooser *chooser ) ;
#line 172
GList *gtk_recent_chooser_get_items(GtkRecentChooser *chooser ) ;
#line 173
gchar **gtk_recent_chooser_get_uris(GtkRecentChooser *chooser , gsize *length ) ;
#line 179
void gtk_recent_chooser_add_filter(GtkRecentChooser *chooser , GtkRecentFilter *filter ) ;
#line 181
void gtk_recent_chooser_remove_filter(GtkRecentChooser *chooser , GtkRecentFilter *filter ) ;
#line 183
GSList *gtk_recent_chooser_list_filters(GtkRecentChooser *chooser ) ;
#line 184
void gtk_recent_chooser_set_filter(GtkRecentChooser *chooser , GtkRecentFilter *filter ) ;
#line 186
GtkRecentFilter *gtk_recent_chooser_get_filter(GtkRecentChooser *chooser ) ;
#line 60 "/usr/include/gtk-2.0/gtk/gtkrecentchooserdialog.h"
GType gtk_recent_chooser_dialog_get_type(void) ;
#line 62
GtkWidget *gtk_recent_chooser_dialog_new(gchar *title , GtkWindow *parent , gchar *first_button_text 
                                         , ...) ;
#line 66
GtkWidget *gtk_recent_chooser_dialog_new_for_manager(gchar *title , GtkWindow *parent ,
                                                     GtkRecentManager *manager , gchar *first_button_text 
                                                     , ...) ;
#line 63 "/usr/include/gtk-2.0/gtk/gtkrecentchoosermenu.h"
GType gtk_recent_chooser_menu_get_type(void) ;
#line 65
GtkWidget *gtk_recent_chooser_menu_new(void) ;
#line 66
GtkWidget *gtk_recent_chooser_menu_new_for_manager(GtkRecentManager *manager ) ;
#line 68
gboolean gtk_recent_chooser_menu_get_show_numbers(GtkRecentChooserMenu *menu ) ;
#line 69
void gtk_recent_chooser_menu_set_show_numbers(GtkRecentChooserMenu *menu , gboolean show_numbers ) ;
#line 58 "/usr/include/gtk-2.0/gtk/gtkrecentchooserwidget.h"
GType gtk_recent_chooser_widget_get_type(void) ;
#line 59
GtkWidget *gtk_recent_chooser_widget_new(void) ;
#line 60
GtkWidget *gtk_recent_chooser_widget_new_for_manager(GtkRecentManager *manager ) ;
#line 84 "/usr/include/gtk-2.0/gtk/gtkscalebutton.h"
GType gtk_scale_button_get_type(void) ;
#line 85
GtkWidget *gtk_scale_button_new(GtkIconSize size , gdouble min , gdouble max , gdouble step ,
                                gchar **icons ) ;
#line 90
void gtk_scale_button_set_icons(GtkScaleButton *button , gchar **icons ) ;
#line 92
gdouble gtk_scale_button_get_value(GtkScaleButton *button ) ;
#line 93
void gtk_scale_button_set_value(GtkScaleButton *button , gdouble value ) ;
#line 95
GtkAdjustment *gtk_scale_button_get_adjustment(GtkScaleButton *button ) ;
#line 96
void gtk_scale_button_set_adjustment(GtkScaleButton *button , GtkAdjustment *adjustment ) ;
#line 98
GtkWidget *gtk_scale_button_get_plus_button(GtkScaleButton *button ) ;
#line 99
GtkWidget *gtk_scale_button_get_minus_button(GtkScaleButton *button ) ;
#line 100
GtkWidget *gtk_scale_button_get_popup(GtkScaleButton *button ) ;
#line 104
GtkOrientation gtk_scale_button_get_orientation(GtkScaleButton *button ) ;
#line 105
void gtk_scale_button_set_orientation(GtkScaleButton *button , GtkOrientation orientation ) ;
#line 69 "/usr/include/gtk-2.0/gtk/gtkvscrollbar.h"
GType gtk_vscrollbar_get_type(void) ;
#line 70
GtkWidget *gtk_vscrollbar_new(GtkAdjustment *adjustment ) ;
#line 74 "/usr/include/gtk-2.0/gtk/gtkviewport.h"
GType gtk_viewport_get_type(void) ;
#line 75
GtkWidget *gtk_viewport_new(GtkAdjustment *hadjustment , GtkAdjustment *vadjustment ) ;
#line 77
GtkAdjustment *gtk_viewport_get_hadjustment(GtkViewport *viewport ) ;
#line 78
GtkAdjustment *gtk_viewport_get_vadjustment(GtkViewport *viewport ) ;
#line 79
void gtk_viewport_set_hadjustment(GtkViewport *viewport , GtkAdjustment *adjustment ) ;
#line 81
void gtk_viewport_set_vadjustment(GtkViewport *viewport , GtkAdjustment *adjustment ) ;
#line 83
void gtk_viewport_set_shadow_type(GtkViewport *viewport , GtkShadowType type ) ;
#line 85
GtkShadowType gtk_viewport_get_shadow_type(GtkViewport *viewport ) ;
#line 86
GdkWindow *gtk_viewport_get_bin_window(GtkViewport *viewport ) ;
#line 87
GdkWindow *gtk_viewport_get_view_window(GtkViewport *viewport ) ;
#line 102 "/usr/include/gtk-2.0/gtk/gtkscrolledwindow.h"
GType gtk_scrolled_window_get_type(void) ;
#line 103
GtkWidget *gtk_scrolled_window_new(GtkAdjustment *hadjustment , GtkAdjustment *vadjustment ) ;
#line 105
void gtk_scrolled_window_set_hadjustment(GtkScrolledWindow *scrolled_window , GtkAdjustment *hadjustment ) ;
#line 107
void gtk_scrolled_window_set_vadjustment(GtkScrolledWindow *scrolled_window , GtkAdjustment *vadjustment ) ;
#line 109
GtkAdjustment *gtk_scrolled_window_get_hadjustment(GtkScrolledWindow *scrolled_window ) ;
#line 110
GtkAdjustment *gtk_scrolled_window_get_vadjustment(GtkScrolledWindow *scrolled_window ) ;
#line 111
GtkWidget *gtk_scrolled_window_get_hscrollbar(GtkScrolledWindow *scrolled_window ) ;
#line 112
GtkWidget *gtk_scrolled_window_get_vscrollbar(GtkScrolledWindow *scrolled_window ) ;
#line 113
void gtk_scrolled_window_set_policy(GtkScrolledWindow *scrolled_window , GtkPolicyType hscrollbar_policy ,
                                    GtkPolicyType vscrollbar_policy ) ;
#line 116
void gtk_scrolled_window_get_policy(GtkScrolledWindow *scrolled_window , GtkPolicyType *hscrollbar_policy ,
                                    GtkPolicyType *vscrollbar_policy ) ;
#line 119
void gtk_scrolled_window_set_placement(GtkScrolledWindow *scrolled_window , GtkCornerType window_placement ) ;
#line 121
void gtk_scrolled_window_unset_placement(GtkScrolledWindow *scrolled_window ) ;
#line 123
GtkCornerType gtk_scrolled_window_get_placement(GtkScrolledWindow *scrolled_window ) ;
#line 124
void gtk_scrolled_window_set_shadow_type(GtkScrolledWindow *scrolled_window , GtkShadowType type ) ;
#line 126
GtkShadowType gtk_scrolled_window_get_shadow_type(GtkScrolledWindow *scrolled_window ) ;
#line 127
void gtk_scrolled_window_add_with_viewport(GtkScrolledWindow *scrolled_window , GtkWidget *child ) ;
#line 130
gint _gtk_scrolled_window_get_scrollbar_spacing(GtkScrolledWindow *scrolled_window ) ;
#line 62 "/usr/include/gtk-2.0/gtk/gtkseparatormenuitem.h"
GType gtk_separator_menu_item_get_type(void) ;
#line 63
GtkWidget *gtk_separator_menu_item_new(void) ;
#line 63 "/usr/include/gtk-2.0/gtk/gtkseparatortoolitem.h"
GType gtk_separator_tool_item_get_type(void) ;
#line 64
GtkToolItem *gtk_separator_tool_item_new(void) ;
#line 66
gboolean gtk_separator_tool_item_get_draw(GtkSeparatorToolItem *item ) ;
#line 67
void gtk_separator_tool_item_set_draw(GtkSeparatorToolItem *item , gboolean draw ) ;
#line 32 "/usr/include/gtk-2.0/gtk/gtkshow.h"
gboolean gtk_show_uri(GdkScreen *screen , gchar *uri , guint32 timestamp , GError **error ) ;
#line 123 "/usr/include/gtk-2.0/gtk/gtkspinbutton.h"
GType gtk_spin_button_get_type(void) ;
#line 125
void gtk_spin_button_configure(GtkSpinButton *spin_button , GtkAdjustment *adjustment ,
                               gdouble climb_rate , guint digits ) ;
#line 130
GtkWidget *gtk_spin_button_new(GtkAdjustment *adjustment , gdouble climb_rate , guint digits ) ;
#line 134
GtkWidget *gtk_spin_button_new_with_range(gdouble min , gdouble max , gdouble step ) ;
#line 138
void gtk_spin_button_set_adjustment(GtkSpinButton *spin_button , GtkAdjustment *adjustment ) ;
#line 141
GtkAdjustment *gtk_spin_button_get_adjustment(GtkSpinButton *spin_button ) ;
#line 143
void gtk_spin_button_set_digits(GtkSpinButton *spin_button , guint digits ) ;
#line 145
guint gtk_spin_button_get_digits(GtkSpinButton *spin_button ) ;
#line 147
void gtk_spin_button_set_increments(GtkSpinButton *spin_button , gdouble step , gdouble page ) ;
#line 150
void gtk_spin_button_get_increments(GtkSpinButton *spin_button , gdouble *step , gdouble *page ) ;
#line 154
void gtk_spin_button_set_range(GtkSpinButton *spin_button , gdouble min , gdouble max ) ;
#line 157
void gtk_spin_button_get_range(GtkSpinButton *spin_button , gdouble *min , gdouble *max ) ;
#line 161
gdouble gtk_spin_button_get_value(GtkSpinButton *spin_button ) ;
#line 163
gint gtk_spin_button_get_value_as_int(GtkSpinButton *spin_button ) ;
#line 165
void gtk_spin_button_set_value(GtkSpinButton *spin_button , gdouble value ) ;
#line 168
void gtk_spin_button_set_update_policy(GtkSpinButton *spin_button , GtkSpinButtonUpdatePolicy policy ) ;
#line 170
GtkSpinButtonUpdatePolicy gtk_spin_button_get_update_policy(GtkSpinButton *spin_button ) ;
#line 172
void gtk_spin_button_set_numeric(GtkSpinButton *spin_button , gboolean numeric ) ;
#line 174
gboolean gtk_spin_button_get_numeric(GtkSpinButton *spin_button ) ;
#line 176
void gtk_spin_button_spin(GtkSpinButton *spin_button , GtkSpinType direction , gdouble increment ) ;
#line 180
void gtk_spin_button_set_wrap(GtkSpinButton *spin_button , gboolean wrap ) ;
#line 182
gboolean gtk_spin_button_get_wrap(GtkSpinButton *spin_button ) ;
#line 184
void gtk_spin_button_set_snap_to_ticks(GtkSpinButton *spin_button , gboolean snap_to_ticks ) ;
#line 186
gboolean gtk_spin_button_get_snap_to_ticks(GtkSpinButton *spin_button ) ;
#line 187
void gtk_spin_button_update(GtkSpinButton *spin_button ) ;
#line 58 "/usr/include/gtk-2.0/gtk/gtkspinner.h"
GType gtk_spinner_get_type(void) ;
#line 59
GtkWidget *gtk_spinner_new(void) ;
#line 60
void gtk_spinner_start(GtkSpinner *spinner ) ;
#line 61
void gtk_spinner_stop(GtkSpinner *spinner ) ;
#line 89 "/usr/include/gtk-2.0/gtk/gtkstatusbar.h"
GType gtk_statusbar_get_type(void) ;
#line 90
GtkWidget *gtk_statusbar_new(void) ;
#line 94
guint gtk_statusbar_get_context_id(GtkStatusbar *statusbar , gchar *context_description ) ;
#line 97
guint gtk_statusbar_push(GtkStatusbar *statusbar , guint context_id , gchar *text ) ;
#line 100
void gtk_statusbar_pop(GtkStatusbar *statusbar , guint context_id ) ;
#line 102
void gtk_statusbar_remove(GtkStatusbar *statusbar , guint context_id , guint message_id ) ;
#line 105
void gtk_statusbar_remove_all(GtkStatusbar *statusbar , guint context_id ) ;
#line 109
void gtk_statusbar_set_has_resize_grip(GtkStatusbar *statusbar , gboolean setting ) ;
#line 111
gboolean gtk_statusbar_get_has_resize_grip(GtkStatusbar *statusbar ) ;
#line 113
GtkWidget *gtk_statusbar_get_message_area(GtkStatusbar *statusbar ) ;
#line 80 "/usr/include/gtk-2.0/gtk/gtkstatusicon.h"
GType gtk_status_icon_get_type(void) ;
#line 82
GtkStatusIcon *gtk_status_icon_new(void) ;
#line 83
GtkStatusIcon *gtk_status_icon_new_from_pixbuf(GdkPixbuf *pixbuf ) ;
#line 84
GtkStatusIcon *gtk_status_icon_new_from_file(gchar *filename ) ;
#line 85
GtkStatusIcon *gtk_status_icon_new_from_stock(gchar *stock_id ) ;
#line 86
GtkStatusIcon *gtk_status_icon_new_from_icon_name(gchar *icon_name ) ;
#line 87
GtkStatusIcon *gtk_status_icon_new_from_gicon(GIcon *icon ) ;
#line 89
void gtk_status_icon_set_from_pixbuf(GtkStatusIcon *status_icon , GdkPixbuf *pixbuf ) ;
#line 91
void gtk_status_icon_set_from_file(GtkStatusIcon *status_icon , gchar *filename ) ;
#line 93
void gtk_status_icon_set_from_stock(GtkStatusIcon *status_icon , gchar *stock_id ) ;
#line 95
void gtk_status_icon_set_from_icon_name(GtkStatusIcon *status_icon , gchar *icon_name ) ;
#line 97
void gtk_status_icon_set_from_gicon(GtkStatusIcon *status_icon , GIcon *icon ) ;
#line 100
GtkImageType gtk_status_icon_get_storage_type(GtkStatusIcon *status_icon ) ;
#line 102
GdkPixbuf *gtk_status_icon_get_pixbuf(GtkStatusIcon *status_icon ) ;
#line 103
gchar *gtk_status_icon_get_stock(GtkStatusIcon *status_icon ) ;
#line 104
gchar *gtk_status_icon_get_icon_name(GtkStatusIcon *status_icon ) ;
#line 105
GIcon *gtk_status_icon_get_gicon(GtkStatusIcon *status_icon ) ;
#line 107
gint gtk_status_icon_get_size(GtkStatusIcon *status_icon ) ;
#line 109
void gtk_status_icon_set_screen(GtkStatusIcon *status_icon , GdkScreen *screen ) ;
#line 111
GdkScreen *gtk_status_icon_get_screen(GtkStatusIcon *status_icon ) ;
#line 114
void gtk_status_icon_set_tooltip(GtkStatusIcon *status_icon , gchar *tooltip_text ) ;
#line 117
void gtk_status_icon_set_has_tooltip(GtkStatusIcon *status_icon , gboolean has_tooltip ) ;
#line 119
void gtk_status_icon_set_tooltip_text(GtkStatusIcon *status_icon , gchar *text ) ;
#line 121
void gtk_status_icon_set_tooltip_markup(GtkStatusIcon *status_icon , gchar *markup ) ;
#line 123
void gtk_status_icon_set_title(GtkStatusIcon *status_icon , gchar *title ) ;
#line 125
gchar *gtk_status_icon_get_title(GtkStatusIcon *status_icon ) ;
#line 126
void gtk_status_icon_set_name(GtkStatusIcon *status_icon , gchar *name ) ;
#line 128
void gtk_status_icon_set_visible(GtkStatusIcon *status_icon , gboolean visible ) ;
#line 130
gboolean gtk_status_icon_get_visible(GtkStatusIcon *status_icon ) ;
#line 133
void gtk_status_icon_set_blinking(GtkStatusIcon *status_icon , gboolean blinking ) ;
#line 135
gboolean gtk_status_icon_get_blinking(GtkStatusIcon *status_icon ) ;
#line 138
gboolean gtk_status_icon_is_embedded(GtkStatusIcon *status_icon ) ;
#line 140
void gtk_status_icon_position_menu(GtkMenu *menu , gint *x , gint *y , gboolean *push_in ,
                                   gpointer user_data ) ;
#line 145
gboolean gtk_status_icon_get_geometry(GtkStatusIcon *status_icon , GdkScreen **screen ,
                                      GdkRectangle *area , GtkOrientation *orientation ) ;
#line 149
gboolean gtk_status_icon_get_has_tooltip(GtkStatusIcon *status_icon ) ;
#line 150
gchar *gtk_status_icon_get_tooltip_text(GtkStatusIcon *status_icon ) ;
#line 151
gchar *gtk_status_icon_get_tooltip_markup(GtkStatusIcon *status_icon ) ;
#line 153
guint32 gtk_status_icon_get_x11_window_id(GtkStatusIcon *status_icon ) ;
#line 51 "/usr/include/gtk-2.0/gtk/gtkstock.h"
void gtk_stock_add(GtkStockItem *items , guint n_items ) ;
#line 53
void gtk_stock_add_static(GtkStockItem *items , guint n_items ) ;
#line 55
gboolean gtk_stock_lookup(gchar *stock_id , GtkStockItem *item ) ;
#line 61
GSList *gtk_stock_list_ids(void) ;
#line 63
GtkStockItem *gtk_stock_item_copy(GtkStockItem *item ) ;
#line 64
void gtk_stock_item_free(GtkStockItem *item ) ;
#line 66
void gtk_stock_set_translate_func(gchar *domain , GtkTranslateFunc func , gpointer data ,
                                  GDestroyNotify notify ) ;
#line 102 "/usr/include/gtk-2.0/gtk/gtktable.h"
GType gtk_table_get_type(void) ;
#line 103
GtkWidget *gtk_table_new(guint rows , guint columns , gboolean homogeneous ) ;
#line 106
void gtk_table_resize(GtkTable *table , guint rows , guint columns ) ;
#line 109
void gtk_table_attach(GtkTable *table , GtkWidget *child , guint left_attach , guint right_attach ,
                      guint top_attach , guint bottom_attach , GtkAttachOptions xoptions ,
                      GtkAttachOptions yoptions , guint xpadding , guint ypadding ) ;
#line 119
void gtk_table_attach_defaults(GtkTable *table , GtkWidget *widget , guint left_attach ,
                               guint right_attach , guint top_attach , guint bottom_attach ) ;
#line 125
void gtk_table_set_row_spacing(GtkTable *table , guint row , guint spacing ) ;
#line 128
guint gtk_table_get_row_spacing(GtkTable *table , guint row ) ;
#line 130
void gtk_table_set_col_spacing(GtkTable *table , guint column , guint spacing ) ;
#line 133
guint gtk_table_get_col_spacing(GtkTable *table , guint column ) ;
#line 135
void gtk_table_set_row_spacings(GtkTable *table , guint spacing ) ;
#line 137
guint gtk_table_get_default_row_spacing(GtkTable *table ) ;
#line 138
void gtk_table_set_col_spacings(GtkTable *table , guint spacing ) ;
#line 140
guint gtk_table_get_default_col_spacing(GtkTable *table ) ;
#line 141
void gtk_table_set_homogeneous(GtkTable *table , gboolean homogeneous ) ;
#line 143
gboolean gtk_table_get_homogeneous(GtkTable *table ) ;
#line 144
void gtk_table_get_size(GtkTable *table , guint *rows , guint *columns ) ;
#line 70 "/usr/include/gtk-2.0/gtk/gtktearoffmenuitem.h"
GType gtk_tearoff_menu_item_get_type(void) ;
#line 71
GtkWidget *gtk_tearoff_menu_item_new(void) ;
#line 75 "/usr/include/gtk-2.0/gtk/gtktexttagtable.h"
GType gtk_text_tag_table_get_type(void) ;
#line 77
GtkTextTagTable *gtk_text_tag_table_new(void) ;
#line 78
void gtk_text_tag_table_add(GtkTextTagTable *table , GtkTextTag *tag ) ;
#line 80
void gtk_text_tag_table_remove(GtkTextTagTable *table , GtkTextTag *tag ) ;
#line 82
GtkTextTag *gtk_text_tag_table_lookup(GtkTextTagTable *table , gchar *name ) ;
#line 84
void gtk_text_tag_table_foreach(GtkTextTagTable *table , GtkTextTagTableForeach func ,
                                gpointer data ) ;
#line 87
gint gtk_text_tag_table_get_size(GtkTextTagTable *table ) ;
#line 93
void _gtk_text_tag_table_add_buffer(GtkTextTagTable *table , gpointer buffer ) ;
#line 95
void _gtk_text_tag_table_remove_buffer(GtkTextTagTable *table , gpointer buffer ) ;
#line 89 "/usr/include/gtk-2.0/gtk/gtktextmark.h"
GType gtk_text_mark_get_type(void) ;
#line 91
void gtk_text_mark_set_visible(GtkTextMark *mark , gboolean setting ) ;
#line 93
gboolean gtk_text_mark_get_visible(GtkTextMark *mark ) ;
#line 95
GtkTextMark *gtk_text_mark_new(gchar *name , gboolean left_gravity ) ;
#line 97
gchar *gtk_text_mark_get_name(GtkTextMark *mark ) ;
#line 98
gboolean gtk_text_mark_get_deleted(GtkTextMark *mark ) ;
#line 99
GtkTextBuffer *gtk_text_mark_get_buffer(GtkTextMark *mark ) ;
#line 100
gboolean gtk_text_mark_get_left_gravity(GtkTextMark *mark ) ;
#line 157 "/usr/include/gtk-2.0/gtk/gtktextbuffer.h"
GType gtk_text_buffer_get_type(void) ;
#line 162
GtkTextBuffer *gtk_text_buffer_new(GtkTextTagTable *table ) ;
#line 163
gint gtk_text_buffer_get_line_count(GtkTextBuffer *buffer ) ;
#line 164
gint gtk_text_buffer_get_char_count(GtkTextBuffer *buffer ) ;
#line 167
GtkTextTagTable *gtk_text_buffer_get_tag_table(GtkTextBuffer *buffer ) ;
#line 170
void gtk_text_buffer_set_text(GtkTextBuffer *buffer , gchar *text , gint len ) ;
#line 175
void gtk_text_buffer_insert(GtkTextBuffer *buffer , GtkTextIter *iter , gchar *text ,
                            gint len ) ;
#line 179
void gtk_text_buffer_insert_at_cursor(GtkTextBuffer *buffer , gchar *text , gint len ) ;
#line 183
gboolean gtk_text_buffer_insert_interactive(GtkTextBuffer *buffer , GtkTextIter *iter ,
                                            gchar *text , gint len , gboolean default_editable ) ;
#line 188
gboolean gtk_text_buffer_insert_interactive_at_cursor(GtkTextBuffer *buffer , gchar *text ,
                                                      gint len , gboolean default_editable ) ;
#line 193
void gtk_text_buffer_insert_range(GtkTextBuffer *buffer , GtkTextIter *iter , GtkTextIter *start ,
                                  GtkTextIter *end ) ;
#line 197
gboolean gtk_text_buffer_insert_range_interactive(GtkTextBuffer *buffer , GtkTextIter *iter ,
                                                  GtkTextIter *start , GtkTextIter *end ,
                                                  gboolean default_editable ) ;
#line 203
void gtk_text_buffer_insert_with_tags(GtkTextBuffer *buffer , GtkTextIter *iter ,
                                      gchar *text , gint len , GtkTextTag *first_tag 
                                      , ...) ;
#line 210
void gtk_text_buffer_insert_with_tags_by_name(GtkTextBuffer *buffer , GtkTextIter *iter ,
                                              gchar *text , gint len , gchar *first_tag_name 
                                              , ...) ;
#line 218
void gtk_text_buffer_delete(GtkTextBuffer *buffer , GtkTextIter *start , GtkTextIter *end ) ;
#line 221
gboolean gtk_text_buffer_delete_interactive(GtkTextBuffer *buffer , GtkTextIter *start_iter ,
                                            GtkTextIter *end_iter , gboolean default_editable ) ;
#line 225
gboolean gtk_text_buffer_backspace(GtkTextBuffer *buffer , GtkTextIter *iter , gboolean interactive ,
                                   gboolean default_editable ) ;
#line 231
gchar *gtk_text_buffer_get_text(GtkTextBuffer *buffer , GtkTextIter *start , GtkTextIter *end ,
                                gboolean include_hidden_chars ) ;
#line 236
gchar *gtk_text_buffer_get_slice(GtkTextBuffer *buffer , GtkTextIter *start , GtkTextIter *end ,
                                 gboolean include_hidden_chars ) ;
#line 242
void gtk_text_buffer_insert_pixbuf(GtkTextBuffer *buffer , GtkTextIter *iter , GdkPixbuf *pixbuf ) ;
#line 247
void gtk_text_buffer_insert_child_anchor(GtkTextBuffer *buffer , GtkTextIter *iter ,
                                         GtkTextChildAnchor *anchor ) ;
#line 252
GtkTextChildAnchor *gtk_text_buffer_create_child_anchor(GtkTextBuffer *buffer , GtkTextIter *iter ) ;
#line 256
void gtk_text_buffer_add_mark(GtkTextBuffer *buffer , GtkTextMark *mark , GtkTextIter *where ) ;
#line 259
GtkTextMark *gtk_text_buffer_create_mark(GtkTextBuffer *buffer , gchar *mark_name ,
                                         GtkTextIter *where , gboolean left_gravity ) ;
#line 263
void gtk_text_buffer_move_mark(GtkTextBuffer *buffer , GtkTextMark *mark , GtkTextIter *where ) ;
#line 266
void gtk_text_buffer_delete_mark(GtkTextBuffer *buffer , GtkTextMark *mark ) ;
#line 268
GtkTextMark *gtk_text_buffer_get_mark(GtkTextBuffer *buffer , gchar *name ) ;
#line 271
void gtk_text_buffer_move_mark_by_name(GtkTextBuffer *buffer , gchar *name , GtkTextIter *where ) ;
#line 274
void gtk_text_buffer_delete_mark_by_name(GtkTextBuffer *buffer , gchar *name ) ;
#line 277
GtkTextMark *gtk_text_buffer_get_insert(GtkTextBuffer *buffer ) ;
#line 278
GtkTextMark *gtk_text_buffer_get_selection_bound(GtkTextBuffer *buffer ) ;
#line 281
void gtk_text_buffer_place_cursor(GtkTextBuffer *buffer , GtkTextIter *where ) ;
#line 283
void gtk_text_buffer_select_range(GtkTextBuffer *buffer , GtkTextIter *ins , GtkTextIter *bound ) ;
#line 290
void gtk_text_buffer_apply_tag(GtkTextBuffer *buffer , GtkTextTag *tag , GtkTextIter *start ,
                               GtkTextIter *end ) ;
#line 294
void gtk_text_buffer_remove_tag(GtkTextBuffer *buffer , GtkTextTag *tag , GtkTextIter *start ,
                                GtkTextIter *end ) ;
#line 298
void gtk_text_buffer_apply_tag_by_name(GtkTextBuffer *buffer , gchar *name , GtkTextIter *start ,
                                       GtkTextIter *end ) ;
#line 302
void gtk_text_buffer_remove_tag_by_name(GtkTextBuffer *buffer , gchar *name , GtkTextIter *start ,
                                        GtkTextIter *end ) ;
#line 306
void gtk_text_buffer_remove_all_tags(GtkTextBuffer *buffer , GtkTextIter *start ,
                                     GtkTextIter *end ) ;
#line 314
GtkTextTag *gtk_text_buffer_create_tag(GtkTextBuffer *buffer , gchar *tag_name , gchar *first_property_name 
                                       , ...) ;
#line 322
void gtk_text_buffer_get_iter_at_line_offset(GtkTextBuffer *buffer , GtkTextIter *iter ,
                                             gint line_number , gint char_offset ) ;
#line 326
void gtk_text_buffer_get_iter_at_line_index(GtkTextBuffer *buffer , GtkTextIter *iter ,
                                            gint line_number , gint byte_index ) ;
#line 330
void gtk_text_buffer_get_iter_at_offset(GtkTextBuffer *buffer , GtkTextIter *iter ,
                                        gint char_offset ) ;
#line 333
void gtk_text_buffer_get_iter_at_line(GtkTextBuffer *buffer , GtkTextIter *iter ,
                                      gint line_number ) ;
#line 336
void gtk_text_buffer_get_start_iter(GtkTextBuffer *buffer , GtkTextIter *iter ) ;
#line 338
void gtk_text_buffer_get_end_iter(GtkTextBuffer *buffer , GtkTextIter *iter ) ;
#line 340
void gtk_text_buffer_get_bounds(GtkTextBuffer *buffer , GtkTextIter *start , GtkTextIter *end ) ;
#line 343
void gtk_text_buffer_get_iter_at_mark(GtkTextBuffer *buffer , GtkTextIter *iter ,
                                      GtkTextMark *mark ) ;
#line 347
void gtk_text_buffer_get_iter_at_child_anchor(GtkTextBuffer *buffer , GtkTextIter *iter ,
                                              GtkTextChildAnchor *anchor ) ;
#line 360
gboolean gtk_text_buffer_get_modified(GtkTextBuffer *buffer ) ;
#line 361
void gtk_text_buffer_set_modified(GtkTextBuffer *buffer , gboolean setting ) ;
#line 364
gboolean gtk_text_buffer_get_has_selection(GtkTextBuffer *buffer ) ;
#line 366
void gtk_text_buffer_add_selection_clipboard(GtkTextBuffer *buffer , GtkClipboard *clipboard ) ;
#line 368
void gtk_text_buffer_remove_selection_clipboard(GtkTextBuffer *buffer , GtkClipboard *clipboard ) ;
#line 371
void gtk_text_buffer_cut_clipboard(GtkTextBuffer *buffer , GtkClipboard *clipboard ,
                                   gboolean default_editable ) ;
#line 374
void gtk_text_buffer_copy_clipboard(GtkTextBuffer *buffer , GtkClipboard *clipboard ) ;
#line 376
void gtk_text_buffer_paste_clipboard(GtkTextBuffer *buffer , GtkClipboard *clipboard ,
                                     GtkTextIter *override_location , gboolean default_editable ) ;
#line 381
gboolean gtk_text_buffer_get_selection_bounds(GtkTextBuffer *buffer , GtkTextIter *start ,
                                              GtkTextIter *end ) ;
#line 384
gboolean gtk_text_buffer_delete_selection(GtkTextBuffer *buffer , gboolean interactive ,
                                          gboolean default_editable ) ;
#line 389
void gtk_text_buffer_begin_user_action(GtkTextBuffer *buffer ) ;
#line 390
void gtk_text_buffer_end_user_action(GtkTextBuffer *buffer ) ;
#line 392
GtkTargetList *gtk_text_buffer_get_copy_target_list(GtkTextBuffer *buffer ) ;
#line 393
GtkTargetList *gtk_text_buffer_get_paste_target_list(GtkTextBuffer *buffer ) ;
#line 396
void _gtk_text_buffer_spew(GtkTextBuffer *buffer ) ;
#line 398
GtkTextBTree *_gtk_text_buffer_get_btree(GtkTextBuffer *buffer ) ;
#line 400
PangoLogAttr *_gtk_text_buffer_get_line_log_attrs(GtkTextBuffer *buffer , GtkTextIter *anywhere_in_line ,
                                                  gint *char_len ) ;
#line 404
void _gtk_text_buffer_notify_will_remove_tag(GtkTextBuffer *buffer , GtkTextTag *tag ) ;
#line 48 "/usr/include/gtk-2.0/gtk/gtktextbufferrichtext.h"
GdkAtom gtk_text_buffer_register_serialize_format(GtkTextBuffer *buffer , gchar *mime_type ,
                                                  GtkTextBufferSerializeFunc function ,
                                                  gpointer user_data , GDestroyNotify user_data_destroy ) ;
#line 53
GdkAtom gtk_text_buffer_register_serialize_tagset(GtkTextBuffer *buffer , gchar *tagset_name ) ;
#line 56
GdkAtom gtk_text_buffer_register_deserialize_format(GtkTextBuffer *buffer , gchar *mime_type ,
                                                    GtkTextBufferDeserializeFunc function ,
                                                    gpointer user_data , GDestroyNotify user_data_destroy ) ;
#line 61
GdkAtom gtk_text_buffer_register_deserialize_tagset(GtkTextBuffer *buffer , gchar *tagset_name ) ;
#line 64
void gtk_text_buffer_unregister_serialize_format(GtkTextBuffer *buffer , GdkAtom format ) ;
#line 66
void gtk_text_buffer_unregister_deserialize_format(GtkTextBuffer *buffer , GdkAtom format ) ;
#line 69
void gtk_text_buffer_deserialize_set_can_create_tags(GtkTextBuffer *buffer , GdkAtom format ,
                                                     gboolean can_create_tags ) ;
#line 72
gboolean gtk_text_buffer_deserialize_get_can_create_tags(GtkTextBuffer *buffer , GdkAtom format ) ;
#line 75
GdkAtom *gtk_text_buffer_get_serialize_formats(GtkTextBuffer *buffer , gint *n_formats ) ;
#line 77
GdkAtom *gtk_text_buffer_get_deserialize_formats(GtkTextBuffer *buffer , gint *n_formats ) ;
#line 80
guint8 *gtk_text_buffer_serialize(GtkTextBuffer *register_buffer , GtkTextBuffer *content_buffer ,
                                  GdkAtom format , GtkTextIter *start , GtkTextIter *end ,
                                  gsize *length ) ;
#line 86
gboolean gtk_text_buffer_deserialize(GtkTextBuffer *register_buffer , GtkTextBuffer *content_buffer ,
                                     GdkAtom format , GtkTextIter *iter , guint8 *data ,
                                     gsize length , GError **error ) ;
#line 217 "/usr/include/gtk-2.0/gtk/gtktextview.h"
GType gtk_text_view_get_type(void) ;
#line 218
GtkWidget *gtk_text_view_new(void) ;
#line 219
GtkWidget *gtk_text_view_new_with_buffer(GtkTextBuffer *buffer ) ;
#line 220
void gtk_text_view_set_buffer(GtkTextView *text_view , GtkTextBuffer *buffer ) ;
#line 222
GtkTextBuffer *gtk_text_view_get_buffer(GtkTextView *text_view ) ;
#line 223
gboolean gtk_text_view_scroll_to_iter(GtkTextView *text_view , GtkTextIter *iter ,
                                      gdouble within_margin , gboolean use_align ,
                                      gdouble xalign , gdouble yalign ) ;
#line 229
void gtk_text_view_scroll_to_mark(GtkTextView *text_view , GtkTextMark *mark , gdouble within_margin ,
                                  gboolean use_align , gdouble xalign , gdouble yalign ) ;
#line 235
void gtk_text_view_scroll_mark_onscreen(GtkTextView *text_view , GtkTextMark *mark ) ;
#line 237
gboolean gtk_text_view_move_mark_onscreen(GtkTextView *text_view , GtkTextMark *mark ) ;
#line 239
gboolean gtk_text_view_place_cursor_onscreen(GtkTextView *text_view ) ;
#line 241
void gtk_text_view_get_visible_rect(GtkTextView *text_view , GdkRectangle *visible_rect ) ;
#line 243
void gtk_text_view_set_cursor_visible(GtkTextView *text_view , gboolean setting ) ;
#line 245
gboolean gtk_text_view_get_cursor_visible(GtkTextView *text_view ) ;
#line 247
void gtk_text_view_get_iter_location(GtkTextView *text_view , GtkTextIter *iter ,
                                     GdkRectangle *location ) ;
#line 250
void gtk_text_view_get_iter_at_location(GtkTextView *text_view , GtkTextIter *iter ,
                                        gint x , gint y ) ;
#line 254
void gtk_text_view_get_iter_at_position(GtkTextView *text_view , GtkTextIter *iter ,
                                        gint *trailing , gint x , gint y ) ;
#line 259
void gtk_text_view_get_line_yrange(GtkTextView *text_view , GtkTextIter *iter , gint *y ,
                                   gint *height ) ;
#line 264
void gtk_text_view_get_line_at_y(GtkTextView *text_view , GtkTextIter *target_iter ,
                                 gint y , gint *line_top ) ;
#line 269
void gtk_text_view_buffer_to_window_coords(GtkTextView *text_view , GtkTextWindowType win ,
                                           gint buffer_x , gint buffer_y , gint *window_x ,
                                           gint *window_y ) ;
#line 275
void gtk_text_view_window_to_buffer_coords(GtkTextView *text_view , GtkTextWindowType win ,
                                           gint window_x , gint window_y , gint *buffer_x ,
                                           gint *buffer_y ) ;
#line 282
GtkAdjustment *gtk_text_view_get_hadjustment(GtkTextView *text_view ) ;
#line 283
GtkAdjustment *gtk_text_view_get_vadjustment(GtkTextView *text_view ) ;
#line 285
GdkWindow *gtk_text_view_get_window(GtkTextView *text_view , GtkTextWindowType win ) ;
#line 287
GtkTextWindowType gtk_text_view_get_window_type(GtkTextView *text_view , GdkWindow *window ) ;
#line 290
void gtk_text_view_set_border_window_size(GtkTextView *text_view , GtkTextWindowType type ,
                                          gint size ) ;
#line 293
gint gtk_text_view_get_border_window_size(GtkTextView *text_view , GtkTextWindowType type ) ;
#line 296
gboolean gtk_text_view_forward_display_line(GtkTextView *text_view , GtkTextIter *iter ) ;
#line 298
gboolean gtk_text_view_backward_display_line(GtkTextView *text_view , GtkTextIter *iter ) ;
#line 300
gboolean gtk_text_view_forward_display_line_end(GtkTextView *text_view , GtkTextIter *iter ) ;
#line 302
gboolean gtk_text_view_backward_display_line_start(GtkTextView *text_view , GtkTextIter *iter ) ;
#line 304
gboolean gtk_text_view_starts_display_line(GtkTextView *text_view , GtkTextIter *iter ) ;
#line 306
gboolean gtk_text_view_move_visually(GtkTextView *text_view , GtkTextIter *iter ,
                                     gint count ) ;
#line 310
gboolean gtk_text_view_im_context_filter_keypress(GtkTextView *text_view , GdkEventKey *event ) ;
#line 312
void gtk_text_view_reset_im_context(GtkTextView *text_view ) ;
#line 315
void gtk_text_view_add_child_at_anchor(GtkTextView *text_view , GtkWidget *child ,
                                       GtkTextChildAnchor *anchor ) ;
#line 319
void gtk_text_view_add_child_in_window(GtkTextView *text_view , GtkWidget *child ,
                                       GtkTextWindowType which_window , gint xpos ,
                                       gint ypos ) ;
#line 326
void gtk_text_view_move_child(GtkTextView *text_view , GtkWidget *child , gint xpos ,
                              gint ypos ) ;
#line 334
void gtk_text_view_set_wrap_mode(GtkTextView *text_view , GtkWrapMode wrap_mode ) ;
#line 336
GtkWrapMode gtk_text_view_get_wrap_mode(GtkTextView *text_view ) ;
#line 337
void gtk_text_view_set_editable(GtkTextView *text_view , gboolean setting ) ;
#line 339
gboolean gtk_text_view_get_editable(GtkTextView *text_view ) ;
#line 340
void gtk_text_view_set_overwrite(GtkTextView *text_view , gboolean overwrite ) ;
#line 342
gboolean gtk_text_view_get_overwrite(GtkTextView *text_view ) ;
#line 343
void gtk_text_view_set_accepts_tab(GtkTextView *text_view , gboolean accepts_tab ) ;
#line 345
gboolean gtk_text_view_get_accepts_tab(GtkTextView *text_view ) ;
#line 346
void gtk_text_view_set_pixels_above_lines(GtkTextView *text_view , gint pixels_above_lines ) ;
#line 348
gint gtk_text_view_get_pixels_above_lines(GtkTextView *text_view ) ;
#line 349
void gtk_text_view_set_pixels_below_lines(GtkTextView *text_view , gint pixels_below_lines ) ;
#line 351
gint gtk_text_view_get_pixels_below_lines(GtkTextView *text_view ) ;
#line 352
void gtk_text_view_set_pixels_inside_wrap(GtkTextView *text_view , gint pixels_inside_wrap ) ;
#line 354
gint gtk_text_view_get_pixels_inside_wrap(GtkTextView *text_view ) ;
#line 355
void gtk_text_view_set_justification(GtkTextView *text_view , GtkJustification justification ) ;
#line 357
GtkJustification gtk_text_view_get_justification(GtkTextView *text_view ) ;
#line 358
void gtk_text_view_set_left_margin(GtkTextView *text_view , gint left_margin ) ;
#line 360
gint gtk_text_view_get_left_margin(GtkTextView *text_view ) ;
#line 361
void gtk_text_view_set_right_margin(GtkTextView *text_view , gint right_margin ) ;
#line 363
gint gtk_text_view_get_right_margin(GtkTextView *text_view ) ;
#line 364
void gtk_text_view_set_indent(GtkTextView *text_view , gint indent ) ;
#line 366
gint gtk_text_view_get_indent(GtkTextView *text_view ) ;
#line 367
void gtk_text_view_set_tabs(GtkTextView *text_view , PangoTabArray *tabs ) ;
#line 369
PangoTabArray *gtk_text_view_get_tabs(GtkTextView *text_view ) ;
#line 372
GtkTextAttributes *gtk_text_view_get_default_attributes(GtkTextView *text_view ) ;
#line 65 "/usr/include/gtk-2.0/gtk/gtkpixmap.h"
GType gtk_pixmap_get_type(void) ;
#line 66
GtkWidget *gtk_pixmap_new(GdkPixmap *pixmap , GdkBitmap *mask ) ;
#line 68
void gtk_pixmap_set(GtkPixmap *pixmap , GdkPixmap *val , GdkBitmap *mask ) ;
#line 71
void gtk_pixmap_get(GtkPixmap *pixmap , GdkPixmap **val , GdkBitmap **mask ) ;
#line 75
void gtk_pixmap_set_build_insensitive(GtkPixmap *pixmap , gboolean build ) ;
#line 141 "/usr/include/gtk-2.0/gtk/gtktoolbar.h"
GType gtk_toolbar_get_type(void) ;
#line 142
GtkWidget *gtk_toolbar_new(void) ;
#line 144
void gtk_toolbar_insert(GtkToolbar *toolbar , GtkToolItem *item , gint pos ) ;
#line 148
gint gtk_toolbar_get_item_index(GtkToolbar *toolbar , GtkToolItem *item ) ;
#line 150
gint gtk_toolbar_get_n_items(GtkToolbar *toolbar ) ;
#line 151
GtkToolItem *gtk_toolbar_get_nth_item(GtkToolbar *toolbar , gint n ) ;
#line 154
gboolean gtk_toolbar_get_show_arrow(GtkToolbar *toolbar ) ;
#line 155
void gtk_toolbar_set_show_arrow(GtkToolbar *toolbar , gboolean show_arrow ) ;
#line 158
GtkToolbarStyle gtk_toolbar_get_style(GtkToolbar *toolbar ) ;
#line 159
void gtk_toolbar_set_style(GtkToolbar *toolbar , GtkToolbarStyle style ) ;
#line 161
void gtk_toolbar_unset_style(GtkToolbar *toolbar ) ;
#line 163
GtkIconSize gtk_toolbar_get_icon_size(GtkToolbar *toolbar ) ;
#line 164
void gtk_toolbar_set_icon_size(GtkToolbar *toolbar , GtkIconSize icon_size ) ;
#line 166
void gtk_toolbar_unset_icon_size(GtkToolbar *toolbar ) ;
#line 168
GtkReliefStyle gtk_toolbar_get_relief_style(GtkToolbar *toolbar ) ;
#line 169
gint gtk_toolbar_get_drop_index(GtkToolbar *toolbar , gint x , gint y ) ;
#line 172
void gtk_toolbar_set_drop_highlight_item(GtkToolbar *toolbar , GtkToolItem *tool_item ,
                                         gint index_ ) ;
#line 178
gchar *_gtk_toolbar_elide_underscores(gchar *original ) ;
#line 179
void _gtk_toolbar_paint_space_line(GtkWidget *widget , GtkToolbar *toolbar , GdkRectangle *area ,
                                   GtkAllocation *allocation ) ;
#line 183
gint _gtk_toolbar_get_default_space_size(void) ;
#line 189
GtkOrientation gtk_toolbar_get_orientation(GtkToolbar *toolbar ) ;
#line 190
void gtk_toolbar_set_orientation(GtkToolbar *toolbar , GtkOrientation orientation ) ;
#line 192
gboolean gtk_toolbar_get_tooltips(GtkToolbar *toolbar ) ;
#line 193
void gtk_toolbar_set_tooltips(GtkToolbar *toolbar , gboolean enable ) ;
#line 197
GtkWidget *gtk_toolbar_append_item(GtkToolbar *toolbar , char const   *text , char const   *tooltip_text ,
                                   char const   *tooltip_private_text , GtkWidget *icon ,
                                   GCallback callback , gpointer user_data ) ;
#line 204
GtkWidget *gtk_toolbar_prepend_item(GtkToolbar *toolbar , char const   *text , char const   *tooltip_text ,
                                    char const   *tooltip_private_text , GtkWidget *icon ,
                                    GCallback callback , gpointer user_data ) ;
#line 211
GtkWidget *gtk_toolbar_insert_item(GtkToolbar *toolbar , char const   *text , char const   *tooltip_text ,
                                   char const   *tooltip_private_text , GtkWidget *icon ,
                                   GCallback callback , gpointer user_data , gint position ) ;
#line 221
GtkWidget *gtk_toolbar_insert_stock(GtkToolbar *toolbar , gchar *stock_id , char const   *tooltip_text ,
                                    char const   *tooltip_private_text , GCallback callback ,
                                    gpointer user_data , gint position ) ;
#line 230
void gtk_toolbar_append_space(GtkToolbar *toolbar ) ;
#line 231
void gtk_toolbar_prepend_space(GtkToolbar *toolbar ) ;
#line 232
void gtk_toolbar_insert_space(GtkToolbar *toolbar , gint position ) ;
#line 234
void gtk_toolbar_remove_space(GtkToolbar *toolbar , gint position ) ;
#line 237
GtkWidget *gtk_toolbar_append_element(GtkToolbar *toolbar , GtkToolbarChildType type ,
                                      GtkWidget *widget , char const   *text , char const   *tooltip_text ,
                                      char const   *tooltip_private_text , GtkWidget *icon ,
                                      GCallback callback , gpointer user_data ) ;
#line 247
GtkWidget *gtk_toolbar_prepend_element(GtkToolbar *toolbar , GtkToolbarChildType type ,
                                       GtkWidget *widget , char const   *text , char const   *tooltip_text ,
                                       char const   *tooltip_private_text , GtkWidget *icon ,
                                       GCallback callback , gpointer user_data ) ;
#line 257
GtkWidget *gtk_toolbar_insert_element(GtkToolbar *toolbar , GtkToolbarChildType type ,
                                      GtkWidget *widget , char const   *text , char const   *tooltip_text ,
                                      char const   *tooltip_private_text , GtkWidget *icon ,
                                      GCallback callback , gpointer user_data , gint position ) ;
#line 269
void gtk_toolbar_append_widget(GtkToolbar *toolbar , GtkWidget *widget , char const   *tooltip_text ,
                               char const   *tooltip_private_text ) ;
#line 273
void gtk_toolbar_prepend_widget(GtkToolbar *toolbar , GtkWidget *widget , char const   *tooltip_text ,
                                char const   *tooltip_private_text ) ;
#line 277
void gtk_toolbar_insert_widget(GtkToolbar *toolbar , GtkWidget *widget , char const   *tooltip_text ,
                               char const   *tooltip_private_text , gint position ) ;
#line 61 "/usr/include/gtk-2.0/gtk/gtktoolitemgroup.h"
GType gtk_tool_item_group_get_type(void) ;
#line 62
GtkWidget *gtk_tool_item_group_new(gchar *label ) ;
#line 64
void gtk_tool_item_group_set_label(GtkToolItemGroup *group , gchar *label ) ;
#line 66
void gtk_tool_item_group_set_label_widget(GtkToolItemGroup *group , GtkWidget *label_widget ) ;
#line 68
void gtk_tool_item_group_set_collapsed(GtkToolItemGroup *group , gboolean collapsed ) ;
#line 70
void gtk_tool_item_group_set_ellipsize(GtkToolItemGroup *group , PangoEllipsizeMode ellipsize ) ;
#line 72
void gtk_tool_item_group_set_header_relief(GtkToolItemGroup *group , GtkReliefStyle style ) ;
#line 75
gchar *gtk_tool_item_group_get_label(GtkToolItemGroup *group ) ;
#line 76
GtkWidget *gtk_tool_item_group_get_label_widget(GtkToolItemGroup *group ) ;
#line 77
gboolean gtk_tool_item_group_get_collapsed(GtkToolItemGroup *group ) ;
#line 78
PangoEllipsizeMode gtk_tool_item_group_get_ellipsize(GtkToolItemGroup *group ) ;
#line 79
GtkReliefStyle gtk_tool_item_group_get_header_relief(GtkToolItemGroup *group ) ;
#line 81
void gtk_tool_item_group_insert(GtkToolItemGroup *group , GtkToolItem *item , gint position ) ;
#line 84
void gtk_tool_item_group_set_item_position(GtkToolItemGroup *group , GtkToolItem *item ,
                                           gint position ) ;
#line 87
gint gtk_tool_item_group_get_item_position(GtkToolItemGroup *group , GtkToolItem *item ) ;
#line 90
guint gtk_tool_item_group_get_n_items(GtkToolItemGroup *group ) ;
#line 91
GtkToolItem *gtk_tool_item_group_get_nth_item(GtkToolItemGroup *group , guint index ) ;
#line 93
GtkToolItem *gtk_tool_item_group_get_drop_item(GtkToolItemGroup *group , gint x ,
                                               gint y ) ;
#line 88 "/usr/include/gtk-2.0/gtk/gtktoolpalette.h"
GType gtk_tool_palette_get_type(void) ;
#line 89
GtkWidget *gtk_tool_palette_new(void) ;
#line 91
void gtk_tool_palette_set_group_position(GtkToolPalette *palette , GtkToolItemGroup *group ,
                                         gint position ) ;
#line 94
void gtk_tool_palette_set_exclusive(GtkToolPalette *palette , GtkToolItemGroup *group ,
                                    gboolean exclusive ) ;
#line 97
void gtk_tool_palette_set_expand(GtkToolPalette *palette , GtkToolItemGroup *group ,
                                 gboolean expand ) ;
#line 101
gint gtk_tool_palette_get_group_position(GtkToolPalette *palette , GtkToolItemGroup *group ) ;
#line 103
gboolean gtk_tool_palette_get_exclusive(GtkToolPalette *palette , GtkToolItemGroup *group ) ;
#line 105
gboolean gtk_tool_palette_get_expand(GtkToolPalette *palette , GtkToolItemGroup *group ) ;
#line 108
void gtk_tool_palette_set_icon_size(GtkToolPalette *palette , GtkIconSize icon_size ) ;
#line 110
void gtk_tool_palette_unset_icon_size(GtkToolPalette *palette ) ;
#line 111
void gtk_tool_palette_set_style(GtkToolPalette *palette , GtkToolbarStyle style ) ;
#line 113
void gtk_tool_palette_unset_style(GtkToolPalette *palette ) ;
#line 115
GtkIconSize gtk_tool_palette_get_icon_size(GtkToolPalette *palette ) ;
#line 116
GtkToolbarStyle gtk_tool_palette_get_style(GtkToolPalette *palette ) ;
#line 118
GtkToolItem *gtk_tool_palette_get_drop_item(GtkToolPalette *palette , gint x , gint y ) ;
#line 121
GtkToolItemGroup *gtk_tool_palette_get_drop_group(GtkToolPalette *palette , gint x ,
                                                  gint y ) ;
#line 124
GtkWidget *gtk_tool_palette_get_drag_item(GtkToolPalette *palette , GtkSelectionData *selection ) ;
#line 127
void gtk_tool_palette_set_drag_source(GtkToolPalette *palette , GtkToolPaletteDragTargets targets ) ;
#line 129
void gtk_tool_palette_add_drag_dest(GtkToolPalette *palette , GtkWidget *widget ,
                                    GtkDestDefaults flags , GtkToolPaletteDragTargets targets ,
                                    GdkDragAction actions ) ;
#line 135
GtkAdjustment *gtk_tool_palette_get_hadjustment(GtkToolPalette *palette ) ;
#line 136
GtkAdjustment *gtk_tool_palette_get_vadjustment(GtkToolPalette *palette ) ;
#line 138
GtkTargetEntry *gtk_tool_palette_get_drag_target_item(void) ;
#line 139
GtkTargetEntry *gtk_tool_palette_get_drag_target_group(void) ;
#line 77 "/usr/include/gtk-2.0/gtk/gtktoolshell.h"
GType gtk_tool_shell_get_type(void) ;
#line 79
GtkIconSize gtk_tool_shell_get_icon_size(GtkToolShell *shell ) ;
#line 80
GtkOrientation gtk_tool_shell_get_orientation(GtkToolShell *shell ) ;
#line 81
GtkToolbarStyle gtk_tool_shell_get_style(GtkToolShell *shell ) ;
#line 82
GtkReliefStyle gtk_tool_shell_get_relief_style(GtkToolShell *shell ) ;
#line 83
void gtk_tool_shell_rebuild_menu(GtkToolShell *shell ) ;
#line 84
GtkOrientation gtk_tool_shell_get_text_orientation(GtkToolShell *shell ) ;
#line 85
gfloat gtk_tool_shell_get_text_alignment(GtkToolShell *shell ) ;
#line 86
PangoEllipsizeMode gtk_tool_shell_get_ellipsize_mode(GtkToolShell *shell ) ;
#line 87
GtkSizeGroup *gtk_tool_shell_get_text_size_group(GtkToolShell *shell ) ;
#line 31 "/usr/include/gtk-2.0/gtk/gtktestutils.h"
void gtk_test_init(int *argcp , char ***argvp  , ...) ;
#line 34
void gtk_test_register_all_types(void) ;
#line 35
GType *gtk_test_list_all_types(guint *n_types ) ;
#line 36
GtkWidget *gtk_test_find_widget(GtkWidget *widget , gchar *label_pattern , GType widget_type ) ;
#line 39
GtkWidget *gtk_test_create_widget(GType widget_type , gchar *first_property_name 
                                  , ...) ;
#line 42
GtkWidget *gtk_test_create_simple_window(gchar *window_title , gchar *dialog_text ) ;
#line 44
GtkWidget *gtk_test_display_button_window(gchar *window_title , gchar *dialog_text 
                                          , ...) ;
#line 47
void gtk_test_slider_set_perc(GtkWidget *widget , double percentage ) ;
#line 49
double gtk_test_slider_get_value(GtkWidget *widget ) ;
#line 50
gboolean gtk_test_spin_button_click(GtkSpinButton *spinner , guint button , gboolean upwards ) ;
#line 53
gboolean gtk_test_widget_click(GtkWidget *widget , guint button , GdkModifierType modifiers ) ;
#line 56
gboolean gtk_test_widget_send_key(GtkWidget *widget , guint keyval , GdkModifierType modifiers ) ;
#line 60
void gtk_test_text_set(GtkWidget *widget , gchar *string ) ;
#line 62
gchar *gtk_test_text_get(GtkWidget *widget ) ;
#line 65
GtkWidget *gtk_test_find_sibling(GtkWidget *base_widget , GType widget_type ) ;
#line 67
GtkWidget *gtk_test_find_label(GtkWidget *widget , gchar *label_pattern ) ;
#line 57 "/usr/include/gtk-2.0/gtk/gtktreednd.h"
GType gtk_tree_drag_source_get_type(void) ;
#line 60
gboolean gtk_tree_drag_source_row_draggable(GtkTreeDragSource *drag_source , GtkTreePath *path ) ;
#line 64
gboolean gtk_tree_drag_source_drag_data_delete(GtkTreeDragSource *drag_source , GtkTreePath *path ) ;
#line 70
gboolean gtk_tree_drag_source_drag_data_get(GtkTreeDragSource *drag_source , GtkTreePath *path ,
                                            GtkSelectionData *selection_data ) ;
#line 97
GType gtk_tree_drag_dest_get_type(void) ;
#line 102
gboolean gtk_tree_drag_dest_drag_data_received(GtkTreeDragDest *drag_dest , GtkTreePath *dest ,
                                               GtkSelectionData *selection_data ) ;
#line 108
gboolean gtk_tree_drag_dest_row_drop_possible(GtkTreeDragDest *drag_dest , GtkTreePath *dest_path ,
                                              GtkSelectionData *selection_data ) ;
#line 116
gboolean gtk_tree_set_row_drag_data(GtkSelectionData *selection_data , GtkTreeModel *tree_model ,
                                    GtkTreePath *path ) ;
#line 119
gboolean gtk_tree_get_row_drag_data(GtkSelectionData *selection_data , GtkTreeModel **tree_model ,
                                    GtkTreePath **path ) ;
#line 84 "/usr/include/gtk-2.0/gtk/gtktreemodelsort.h"
GType gtk_tree_model_sort_get_type(void) ;
#line 85
GtkTreeModel *gtk_tree_model_sort_new_with_model(GtkTreeModel *child_model ) ;
#line 87
GtkTreeModel *gtk_tree_model_sort_get_model(GtkTreeModelSort *tree_model ) ;
#line 88
GtkTreePath *gtk_tree_model_sort_convert_child_path_to_path(GtkTreeModelSort *tree_model_sort ,
                                                            GtkTreePath *child_path ) ;
#line 90
gboolean gtk_tree_model_sort_convert_child_iter_to_iter(GtkTreeModelSort *tree_model_sort ,
                                                        GtkTreeIter *sort_iter , GtkTreeIter *child_iter ) ;
#line 93
GtkTreePath *gtk_tree_model_sort_convert_path_to_child_path(GtkTreeModelSort *tree_model_sort ,
                                                            GtkTreePath *sorted_path ) ;
#line 95
void gtk_tree_model_sort_convert_iter_to_child_iter(GtkTreeModelSort *tree_model_sort ,
                                                    GtkTreeIter *child_iter , GtkTreeIter *sorted_iter ) ;
#line 98
void gtk_tree_model_sort_reset_default_sort_func(GtkTreeModelSort *tree_model_sort ) ;
#line 99
void gtk_tree_model_sort_clear_cache(GtkTreeModelSort *tree_model_sort ) ;
#line 100
gboolean gtk_tree_model_sort_iter_is_valid(GtkTreeModelSort *tree_model_sort , GtkTreeIter *iter ) ;
#line 76 "/usr/include/gtk-2.0/gtk/gtktreeselection.h"
GType gtk_tree_selection_get_type(void) ;
#line 78
void gtk_tree_selection_set_mode(GtkTreeSelection *selection , GtkSelectionMode type ) ;
#line 80
GtkSelectionMode gtk_tree_selection_get_mode(GtkTreeSelection *selection ) ;
#line 81
void gtk_tree_selection_set_select_function(GtkTreeSelection *selection , GtkTreeSelectionFunc func ,
                                            gpointer data , GDestroyNotify destroy ) ;
#line 85
gpointer gtk_tree_selection_get_user_data(GtkTreeSelection *selection ) ;
#line 86
GtkTreeView *gtk_tree_selection_get_tree_view(GtkTreeSelection *selection ) ;
#line 88
GtkTreeSelectionFunc gtk_tree_selection_get_select_function(GtkTreeSelection *selection ) ;
#line 92
gboolean gtk_tree_selection_get_selected(GtkTreeSelection *selection , GtkTreeModel **model ,
                                         GtkTreeIter *iter ) ;
#line 95
GList *gtk_tree_selection_get_selected_rows(GtkTreeSelection *selection , GtkTreeModel **model ) ;
#line 97
gint gtk_tree_selection_count_selected_rows(GtkTreeSelection *selection ) ;
#line 98
void gtk_tree_selection_selected_foreach(GtkTreeSelection *selection , GtkTreeSelectionForeachFunc func ,
                                         gpointer data ) ;
#line 101
void gtk_tree_selection_select_path(GtkTreeSelection *selection , GtkTreePath *path ) ;
#line 103
void gtk_tree_selection_unselect_path(GtkTreeSelection *selection , GtkTreePath *path ) ;
#line 105
void gtk_tree_selection_select_iter(GtkTreeSelection *selection , GtkTreeIter *iter ) ;
#line 107
void gtk_tree_selection_unselect_iter(GtkTreeSelection *selection , GtkTreeIter *iter ) ;
#line 109
gboolean gtk_tree_selection_path_is_selected(GtkTreeSelection *selection , GtkTreePath *path ) ;
#line 111
gboolean gtk_tree_selection_iter_is_selected(GtkTreeSelection *selection , GtkTreeIter *iter ) ;
#line 113
void gtk_tree_selection_select_all(GtkTreeSelection *selection ) ;
#line 114
void gtk_tree_selection_unselect_all(GtkTreeSelection *selection ) ;
#line 115
void gtk_tree_selection_select_range(GtkTreeSelection *selection , GtkTreePath *start_path ,
                                     GtkTreePath *end_path ) ;
#line 118
void gtk_tree_selection_unselect_range(GtkTreeSelection *selection , GtkTreePath *start_path ,
                                       GtkTreePath *end_path ) ;
#line 76 "/usr/include/gtk-2.0/gtk/gtktreestore.h"
GType gtk_tree_store_get_type(void) ;
#line 77
GtkTreeStore *gtk_tree_store_new(gint n_columns  , ...) ;
#line 79
GtkTreeStore *gtk_tree_store_newv(gint n_columns , GType *types ) ;
#line 81
void gtk_tree_store_set_column_types(GtkTreeStore *tree_store , gint n_columns , GType *types ) ;
#line 87
void gtk_tree_store_set_value(GtkTreeStore *tree_store , GtkTreeIter *iter , gint column ,
                              GValue *value ) ;
#line 91
void gtk_tree_store_set(GtkTreeStore *tree_store , GtkTreeIter *iter  , ...) ;
#line 94
void gtk_tree_store_set_valuesv(GtkTreeStore *tree_store , GtkTreeIter *iter , gint *columns ,
                                GValue *values , gint n_values ) ;
#line 99
void gtk_tree_store_set_valist(GtkTreeStore *tree_store , GtkTreeIter *iter , va_list var_args ) ;
#line 102
gboolean gtk_tree_store_remove(GtkTreeStore *tree_store , GtkTreeIter *iter ) ;
#line 104
void gtk_tree_store_insert(GtkTreeStore *tree_store , GtkTreeIter *iter , GtkTreeIter *parent ,
                           gint position ) ;
#line 108
void gtk_tree_store_insert_before(GtkTreeStore *tree_store , GtkTreeIter *iter , GtkTreeIter *parent ,
                                  GtkTreeIter *sibling ) ;
#line 112
void gtk_tree_store_insert_after(GtkTreeStore *tree_store , GtkTreeIter *iter , GtkTreeIter *parent ,
                                 GtkTreeIter *sibling ) ;
#line 116
void gtk_tree_store_insert_with_values(GtkTreeStore *tree_store , GtkTreeIter *iter ,
                                       GtkTreeIter *parent , gint position  , ...) ;
#line 121
void gtk_tree_store_insert_with_valuesv(GtkTreeStore *tree_store , GtkTreeIter *iter ,
                                        GtkTreeIter *parent , gint position , gint *columns ,
                                        GValue *values , gint n_values ) ;
#line 128
void gtk_tree_store_prepend(GtkTreeStore *tree_store , GtkTreeIter *iter , GtkTreeIter *parent ) ;
#line 131
void gtk_tree_store_append(GtkTreeStore *tree_store , GtkTreeIter *iter , GtkTreeIter *parent ) ;
#line 134
gboolean gtk_tree_store_is_ancestor(GtkTreeStore *tree_store , GtkTreeIter *iter ,
                                    GtkTreeIter *descendant ) ;
#line 137
gint gtk_tree_store_iter_depth(GtkTreeStore *tree_store , GtkTreeIter *iter ) ;
#line 139
void gtk_tree_store_clear(GtkTreeStore *tree_store ) ;
#line 140
gboolean gtk_tree_store_iter_is_valid(GtkTreeStore *tree_store , GtkTreeIter *iter ) ;
#line 142
void gtk_tree_store_reorder(GtkTreeStore *tree_store , GtkTreeIter *parent , gint *new_order ) ;
#line 145
void gtk_tree_store_swap(GtkTreeStore *tree_store , GtkTreeIter *a , GtkTreeIter *b ) ;
#line 148
void gtk_tree_store_move_before(GtkTreeStore *tree_store , GtkTreeIter *iter , GtkTreeIter *position ) ;
#line 151
void gtk_tree_store_move_after(GtkTreeStore *tree_store , GtkTreeIter *iter , GtkTreeIter *position ) ;
#line 113 "/usr/include/gtk-2.0/gtk/gtkuimanager.h"
GType gtk_ui_manager_get_type(void) ;
#line 114
GtkUIManager *gtk_ui_manager_new(void) ;
#line 115
void gtk_ui_manager_set_add_tearoffs(GtkUIManager *self , gboolean add_tearoffs ) ;
#line 117
gboolean gtk_ui_manager_get_add_tearoffs(GtkUIManager *self ) ;
#line 118
void gtk_ui_manager_insert_action_group(GtkUIManager *self , GtkActionGroup *action_group ,
                                        gint pos ) ;
#line 121
void gtk_ui_manager_remove_action_group(GtkUIManager *self , GtkActionGroup *action_group ) ;
#line 123
GList *gtk_ui_manager_get_action_groups(GtkUIManager *self ) ;
#line 124
GtkAccelGroup *gtk_ui_manager_get_accel_group(GtkUIManager *self ) ;
#line 125
GtkWidget *gtk_ui_manager_get_widget(GtkUIManager *self , gchar *path ) ;
#line 127
GSList *gtk_ui_manager_get_toplevels(GtkUIManager *self , GtkUIManagerItemType types ) ;
#line 129
GtkAction *gtk_ui_manager_get_action(GtkUIManager *self , gchar *path ) ;
#line 131
guint gtk_ui_manager_add_ui_from_string(GtkUIManager *self , gchar *buffer , gssize length ,
                                        GError **error ) ;
#line 135
guint gtk_ui_manager_add_ui_from_file(GtkUIManager *self , gchar *filename , GError **error ) ;
#line 138
void gtk_ui_manager_add_ui(GtkUIManager *self , guint merge_id , gchar *path , gchar *name ,
                           gchar *action , GtkUIManagerItemType type , gboolean top ) ;
#line 145
void gtk_ui_manager_remove_ui(GtkUIManager *self , guint merge_id ) ;
#line 147
gchar *gtk_ui_manager_get_ui(GtkUIManager *self ) ;
#line 148
void gtk_ui_manager_ensure_update(GtkUIManager *self ) ;
#line 149
guint gtk_ui_manager_new_merge_id(GtkUIManager *self ) ;
#line 63 "/usr/include/gtk-2.0/gtk/gtkvbbox.h"
GType gtk_vbutton_box_get_type(void) ;
#line 64
GtkWidget *gtk_vbutton_box_new(void) ;
#line 69
gint gtk_vbutton_box_get_spacing_default(void) ;
#line 70
void gtk_vbutton_box_set_spacing_default(gint spacing ) ;
#line 72
GtkButtonBoxStyle gtk_vbutton_box_get_layout_default(void) ;
#line 73
void gtk_vbutton_box_set_layout_default(GtkButtonBoxStyle layout ) ;
#line 77
GtkButtonBoxStyle _gtk_vbutton_box_get_layout_default(void) ;
#line 67 "/usr/include/gtk-2.0/gtk/gtkvolumebutton.h"
GType gtk_volume_button_get_type(void) ;
#line 68
GtkWidget *gtk_volume_button_new(void) ;
#line 60 "/usr/include/gtk-2.0/gtk/gtkvpaned.h"
GType gtk_vpaned_get_type(void) ;
#line 61
GtkWidget *gtk_vpaned_new(void) ;
#line 75 "/usr/include/gtk-2.0/gtk/gtkvruler.h"
GType gtk_vruler_get_type(void) ;
#line 76
GtkWidget *gtk_vruler_new(void) ;
#line 69 "/usr/include/gtk-2.0/gtk/gtkvscale.h"
GType gtk_vscale_get_type(void) ;
#line 70
GtkWidget *gtk_vscale_new(GtkAdjustment *adjustment ) ;
#line 71
GtkWidget *gtk_vscale_new_with_range(gdouble min , gdouble max , gdouble step ) ;
#line 69 "/usr/include/gtk-2.0/gtk/gtkvseparator.h"
GType gtk_vseparator_get_type(void) ;
#line 70
GtkWidget *gtk_vseparator_new(void) ;
#line 443 "/usr/include/gtk-2.0/gtk/gtkclist.h"
GType gtk_clist_get_type(void) ;
#line 446
GtkWidget *gtk_clist_new(gint columns ) ;
#line 447
GtkWidget *gtk_clist_new_with_titles(gint columns , gchar *titles[] ) ;
#line 451
void gtk_clist_set_hadjustment(GtkCList *clist , GtkAdjustment *adjustment ) ;
#line 453
void gtk_clist_set_vadjustment(GtkCList *clist , GtkAdjustment *adjustment ) ;
#line 457
GtkAdjustment *gtk_clist_get_hadjustment(GtkCList *clist ) ;
#line 458
GtkAdjustment *gtk_clist_get_vadjustment(GtkCList *clist ) ;
#line 461
void gtk_clist_set_shadow_type(GtkCList *clist , GtkShadowType type ) ;
#line 465
void gtk_clist_set_selection_mode(GtkCList *clist , GtkSelectionMode mode ) ;
#line 469
void gtk_clist_set_reorderable(GtkCList *clist , gboolean reorderable ) ;
#line 471
void gtk_clist_set_use_drag_icons(GtkCList *clist , gboolean use_icons ) ;
#line 473
void gtk_clist_set_button_actions(GtkCList *clist , guint button , guint8 button_actions ) ;
#line 481
void gtk_clist_freeze(GtkCList *clist ) ;
#line 482
void gtk_clist_thaw(GtkCList *clist ) ;
#line 485
void gtk_clist_column_titles_show(GtkCList *clist ) ;
#line 486
void gtk_clist_column_titles_hide(GtkCList *clist ) ;
#line 492
void gtk_clist_column_title_active(GtkCList *clist , gint column ) ;
#line 494
void gtk_clist_column_title_passive(GtkCList *clist , gint column ) ;
#line 496
void gtk_clist_column_titles_active(GtkCList *clist ) ;
#line 497
void gtk_clist_column_titles_passive(GtkCList *clist ) ;
#line 500
void gtk_clist_set_column_title(GtkCList *clist , gint column , gchar *title ) ;
#line 505
gchar *gtk_clist_get_column_title(GtkCList *clist , gint column ) ;
#line 509
void gtk_clist_set_column_widget(GtkCList *clist , gint column , GtkWidget *widget ) ;
#line 514
GtkWidget *gtk_clist_get_column_widget(GtkCList *clist , gint column ) ;
#line 518
void gtk_clist_set_column_justification(GtkCList *clist , gint column , GtkJustification justification ) ;
#line 523
void gtk_clist_set_column_visibility(GtkCList *clist , gint column , gboolean visible ) ;
#line 528
void gtk_clist_set_column_resizeable(GtkCList *clist , gint column , gboolean resizeable ) ;
#line 533
void gtk_clist_set_column_auto_resize(GtkCList *clist , gint column , gboolean auto_resize ) ;
#line 537
gint gtk_clist_columns_autosize(GtkCList *clist ) ;
#line 540
gint gtk_clist_optimal_column_width(GtkCList *clist , gint column ) ;
#line 547
void gtk_clist_set_column_width(GtkCList *clist , gint column , gint width ) ;
#line 552
void gtk_clist_set_column_min_width(GtkCList *clist , gint column , gint min_width ) ;
#line 555
void gtk_clist_set_column_max_width(GtkCList *clist , gint column , gint max_width ) ;
#line 562
void gtk_clist_set_row_height(GtkCList *clist , guint height ) ;
#line 570
void gtk_clist_moveto(GtkCList *clist , gint row , gint column , gfloat row_align ,
                      gfloat col_align ) ;
#line 577
GtkVisibility gtk_clist_row_is_visible(GtkCList *clist , gint row ) ;
#line 581
GtkCellType gtk_clist_get_cell_type(GtkCList *clist , gint row , gint column ) ;
#line 586
void gtk_clist_set_text(GtkCList *clist , gint row , gint column , gchar *text ) ;
#line 594
gint gtk_clist_get_text(GtkCList *clist , gint row , gint column , gchar **text ) ;
#line 600
void gtk_clist_set_pixmap(GtkCList *clist , gint row , gint column , GdkPixmap *pixmap ,
                          GdkBitmap *mask ) ;
#line 606
gint gtk_clist_get_pixmap(GtkCList *clist , gint row , gint column , GdkPixmap **pixmap ,
                          GdkBitmap **mask ) ;
#line 613
void gtk_clist_set_pixtext(GtkCList *clist , gint row , gint column , gchar *text ,
                           guint8 spacing , GdkPixmap *pixmap , GdkBitmap *mask ) ;
#line 621
gint gtk_clist_get_pixtext(GtkCList *clist , gint row , gint column , gchar **text ,
                           guint8 *spacing , GdkPixmap **pixmap , GdkBitmap **mask ) ;
#line 632
void gtk_clist_set_foreground(GtkCList *clist , gint row , GdkColor *color ) ;
#line 639
void gtk_clist_set_background(GtkCList *clist , gint row , GdkColor *color ) ;
#line 644
void gtk_clist_set_cell_style(GtkCList *clist , gint row , gint column , GtkStyle *style ) ;
#line 649
GtkStyle *gtk_clist_get_cell_style(GtkCList *clist , gint row , gint column ) ;
#line 653
void gtk_clist_set_row_style(GtkCList *clist , gint row , GtkStyle *style ) ;
#line 657
GtkStyle *gtk_clist_get_row_style(GtkCList *clist , gint row ) ;
#line 664
void gtk_clist_set_shift(GtkCList *clist , gint row , gint column , gint vertical ,
                         gint horizontal ) ;
#line 671
void gtk_clist_set_selectable(GtkCList *clist , gint row , gboolean selectable ) ;
#line 674
gboolean gtk_clist_get_selectable(GtkCList *clist , gint row ) ;
#line 680
gint gtk_clist_prepend(GtkCList *clist , gchar *text[] ) ;
#line 682
gint gtk_clist_append(GtkCList *clist , gchar *text[] ) ;
#line 688
gint gtk_clist_insert(GtkCList *clist , gint row , gchar *text[] ) ;
#line 693
void gtk_clist_remove(GtkCList *clist , gint row ) ;
#line 697
void gtk_clist_set_row_data(GtkCList *clist , gint row , gpointer data ) ;
#line 702
void gtk_clist_set_row_data_full(GtkCList *clist , gint row , gpointer data , GDestroyNotify destroy ) ;
#line 708
gpointer gtk_clist_get_row_data(GtkCList *clist , gint row ) ;
#line 714
gint gtk_clist_find_row_from_data(GtkCList *clist , gpointer data ) ;
#line 718
void gtk_clist_select_row(GtkCList *clist , gint row , gint column ) ;
#line 723
void gtk_clist_unselect_row(GtkCList *clist , gint row , gint column ) ;
#line 728
void gtk_clist_undo_selection(GtkCList *clist ) ;
#line 733
void gtk_clist_clear(GtkCList *clist ) ;
#line 739
gint gtk_clist_get_selection_info(GtkCList *clist , gint x , gint y , gint *row ,
                                  gint *column ) ;
#line 746
void gtk_clist_select_all(GtkCList *clist ) ;
#line 749
void gtk_clist_unselect_all(GtkCList *clist ) ;
#line 752
void gtk_clist_swap_rows(GtkCList *clist , gint row1 , gint row2 ) ;
#line 757
void gtk_clist_row_move(GtkCList *clist , gint source_row , gint dest_row ) ;
#line 762
void gtk_clist_set_compare_func(GtkCList *clist , GtkCListCompareFunc cmp_func ) ;
#line 766
void gtk_clist_set_sort_column(GtkCList *clist , gint column ) ;
#line 770
void gtk_clist_set_sort_type(GtkCList *clist , GtkSortType sort_type ) ;
#line 774
void gtk_clist_sort(GtkCList *clist ) ;
#line 777
void gtk_clist_set_auto_sort(GtkCList *clist , gboolean auto_sort ) ;
#line 782
PangoLayout *_gtk_clist_create_cell_layout(GtkCList *clist , GtkCListRow *clist_row ,
                                           gint column ) ;
#line 87 "/usr/include/gtk-2.0/gtk/gtkcombo.h"
GType gtk_combo_get_type(void) ;
#line 89
GtkWidget *gtk_combo_new(void) ;
#line 91
void gtk_combo_set_value_in_list(GtkCombo *combo , gboolean val , gboolean ok_if_empty ) ;
#line 95
void gtk_combo_set_use_arrows(GtkCombo *combo , gboolean val ) ;
#line 98
void gtk_combo_set_use_arrows_always(GtkCombo *combo , gboolean val ) ;
#line 101
void gtk_combo_set_case_sensitive(GtkCombo *combo , gboolean val ) ;
#line 105
void gtk_combo_set_item_string(GtkCombo *combo , GtkItem *item , gchar *item_value ) ;
#line 109
void gtk_combo_set_popdown_strings(GtkCombo *combo , GList *strings ) ;
#line 112
void gtk_combo_disable_activate(GtkCombo *combo ) ;
#line 175 "/usr/include/gtk-2.0/gtk/gtkctree.h"
GType gtk_ctree_get_type(void) ;
#line 176
GtkWidget *gtk_ctree_new_with_titles(gint columns , gint tree_column , gchar *titles[] ) ;
#line 179
GtkWidget *gtk_ctree_new(gint columns , gint tree_column ) ;
#line 181
GtkCTreeNode *gtk_ctree_insert_node(GtkCTree *ctree , GtkCTreeNode *parent , GtkCTreeNode *sibling ,
                                    gchar *text[] , guint8 spacing , GdkPixmap *pixmap_closed ,
                                    GdkBitmap *mask_closed , GdkPixmap *pixmap_opened ,
                                    GdkBitmap *mask_opened , gboolean is_leaf , gboolean expanded ) ;
#line 192
void gtk_ctree_remove_node(GtkCTree *ctree , GtkCTreeNode *node ) ;
#line 194
GtkCTreeNode *gtk_ctree_insert_gnode(GtkCTree *ctree , GtkCTreeNode *parent , GtkCTreeNode *sibling ,
                                     GNode *gnode , GtkCTreeGNodeFunc func , gpointer data ) ;
#line 200
GNode *gtk_ctree_export_to_gnode(GtkCTree *ctree , GNode *parent , GNode *sibling ,
                                 GtkCTreeNode *node , GtkCTreeGNodeFunc func , gpointer data ) ;
#line 212
void gtk_ctree_post_recursive(GtkCTree *ctree , GtkCTreeNode *node , GtkCTreeFunc func ,
                              gpointer data ) ;
#line 216
void gtk_ctree_post_recursive_to_depth(GtkCTree *ctree , GtkCTreeNode *node , gint depth ,
                                       GtkCTreeFunc func , gpointer data ) ;
#line 221
void gtk_ctree_pre_recursive(GtkCTree *ctree , GtkCTreeNode *node , GtkCTreeFunc func ,
                             gpointer data ) ;
#line 225
void gtk_ctree_pre_recursive_to_depth(GtkCTree *ctree , GtkCTreeNode *node , gint depth ,
                                      GtkCTreeFunc func , gpointer data ) ;
#line 230
gboolean gtk_ctree_is_viewable(GtkCTree *ctree , GtkCTreeNode *node ) ;
#line 232
GtkCTreeNode *gtk_ctree_last(GtkCTree *ctree , GtkCTreeNode *node ) ;
#line 234
GtkCTreeNode *gtk_ctree_find_node_ptr(GtkCTree *ctree , GtkCTreeRow *ctree_row ) ;
#line 236
GtkCTreeNode *gtk_ctree_node_nth(GtkCTree *ctree , guint row ) ;
#line 238
gboolean gtk_ctree_find(GtkCTree *ctree , GtkCTreeNode *node , GtkCTreeNode *child ) ;
#line 241
gboolean gtk_ctree_is_ancestor(GtkCTree *ctree , GtkCTreeNode *node , GtkCTreeNode *child ) ;
#line 244
GtkCTreeNode *gtk_ctree_find_by_row_data(GtkCTree *ctree , GtkCTreeNode *node , gpointer data ) ;
#line 248
GList *gtk_ctree_find_all_by_row_data(GtkCTree *ctree , GtkCTreeNode *node , gpointer data ) ;
#line 251
GtkCTreeNode *gtk_ctree_find_by_row_data_custom(GtkCTree *ctree , GtkCTreeNode *node ,
                                                gpointer data , GCompareFunc func ) ;
#line 256
GList *gtk_ctree_find_all_by_row_data_custom(GtkCTree *ctree , GtkCTreeNode *node ,
                                             gpointer data , GCompareFunc func ) ;
#line 260
gboolean gtk_ctree_is_hot_spot(GtkCTree *ctree , gint x , gint y ) ;
#line 268
void gtk_ctree_move(GtkCTree *ctree , GtkCTreeNode *node , GtkCTreeNode *new_parent ,
                    GtkCTreeNode *new_sibling ) ;
#line 272
void gtk_ctree_expand(GtkCTree *ctree , GtkCTreeNode *node ) ;
#line 274
void gtk_ctree_expand_recursive(GtkCTree *ctree , GtkCTreeNode *node ) ;
#line 276
void gtk_ctree_expand_to_depth(GtkCTree *ctree , GtkCTreeNode *node , gint depth ) ;
#line 279
void gtk_ctree_collapse(GtkCTree *ctree , GtkCTreeNode *node ) ;
#line 281
void gtk_ctree_collapse_recursive(GtkCTree *ctree , GtkCTreeNode *node ) ;
#line 283
void gtk_ctree_collapse_to_depth(GtkCTree *ctree , GtkCTreeNode *node , gint depth ) ;
#line 286
void gtk_ctree_toggle_expansion(GtkCTree *ctree , GtkCTreeNode *node ) ;
#line 288
void gtk_ctree_toggle_expansion_recursive(GtkCTree *ctree , GtkCTreeNode *node ) ;
#line 290
void gtk_ctree_select(GtkCTree *ctree , GtkCTreeNode *node ) ;
#line 292
void gtk_ctree_select_recursive(GtkCTree *ctree , GtkCTreeNode *node ) ;
#line 294
void gtk_ctree_unselect(GtkCTree *ctree , GtkCTreeNode *node ) ;
#line 296
void gtk_ctree_unselect_recursive(GtkCTree *ctree , GtkCTreeNode *node ) ;
#line 298
void gtk_ctree_real_select_recursive(GtkCTree *ctree , GtkCTreeNode *node , gint state ) ;
#line 306
void gtk_ctree_node_set_text(GtkCTree *ctree , GtkCTreeNode *node , gint column ,
                             gchar *text ) ;
#line 310
void gtk_ctree_node_set_pixmap(GtkCTree *ctree , GtkCTreeNode *node , gint column ,
                               GdkPixmap *pixmap , GdkBitmap *mask ) ;
#line 315
void gtk_ctree_node_set_pixtext(GtkCTree *ctree , GtkCTreeNode *node , gint column ,
                                gchar *text , guint8 spacing , GdkPixmap *pixmap ,
                                GdkBitmap *mask ) ;
#line 322
void gtk_ctree_set_node_info(GtkCTree *ctree , GtkCTreeNode *node , gchar *text ,
                             guint8 spacing , GdkPixmap *pixmap_closed , GdkBitmap *mask_closed ,
                             GdkPixmap *pixmap_opened , GdkBitmap *mask_opened , gboolean is_leaf ,
                             gboolean expanded ) ;
#line 332
void gtk_ctree_node_set_shift(GtkCTree *ctree , GtkCTreeNode *node , gint column ,
                              gint vertical , gint horizontal ) ;
#line 337
void gtk_ctree_node_set_selectable(GtkCTree *ctree , GtkCTreeNode *node , gboolean selectable ) ;
#line 340
gboolean gtk_ctree_node_get_selectable(GtkCTree *ctree , GtkCTreeNode *node ) ;
#line 342
GtkCellType gtk_ctree_node_get_cell_type(GtkCTree *ctree , GtkCTreeNode *node , gint column ) ;
#line 345
gboolean gtk_ctree_node_get_text(GtkCTree *ctree , GtkCTreeNode *node , gint column ,
                                 gchar **text ) ;
#line 349
gboolean gtk_ctree_node_get_pixmap(GtkCTree *ctree , GtkCTreeNode *node , gint column ,
                                   GdkPixmap **pixmap , GdkBitmap **mask ) ;
#line 354
gboolean gtk_ctree_node_get_pixtext(GtkCTree *ctree , GtkCTreeNode *node , gint column ,
                                    gchar **text , guint8 *spacing , GdkPixmap **pixmap ,
                                    GdkBitmap **mask ) ;
#line 361
gboolean gtk_ctree_get_node_info(GtkCTree *ctree , GtkCTreeNode *node , gchar **text ,
                                 guint8 *spacing , GdkPixmap **pixmap_closed , GdkBitmap **mask_closed ,
                                 GdkPixmap **pixmap_opened , GdkBitmap **mask_opened ,
                                 gboolean *is_leaf , gboolean *expanded ) ;
#line 371
void gtk_ctree_node_set_row_style(GtkCTree *ctree , GtkCTreeNode *node , GtkStyle *style ) ;
#line 374
GtkStyle *gtk_ctree_node_get_row_style(GtkCTree *ctree , GtkCTreeNode *node ) ;
#line 376
void gtk_ctree_node_set_cell_style(GtkCTree *ctree , GtkCTreeNode *node , gint column ,
                                   GtkStyle *style ) ;
#line 380
GtkStyle *gtk_ctree_node_get_cell_style(GtkCTree *ctree , GtkCTreeNode *node , gint column ) ;
#line 383
void gtk_ctree_node_set_foreground(GtkCTree *ctree , GtkCTreeNode *node , GdkColor *color ) ;
#line 386
void gtk_ctree_node_set_background(GtkCTree *ctree , GtkCTreeNode *node , GdkColor *color ) ;
#line 389
void gtk_ctree_node_set_row_data(GtkCTree *ctree , GtkCTreeNode *node , gpointer data ) ;
#line 392
void gtk_ctree_node_set_row_data_full(GtkCTree *ctree , GtkCTreeNode *node , gpointer data ,
                                      GDestroyNotify destroy ) ;
#line 396
gpointer gtk_ctree_node_get_row_data(GtkCTree *ctree , GtkCTreeNode *node ) ;
#line 398
void gtk_ctree_node_moveto(GtkCTree *ctree , GtkCTreeNode *node , gint column , gfloat row_align ,
                           gfloat col_align ) ;
#line 403
GtkVisibility gtk_ctree_node_is_visible(GtkCTree *ctree , GtkCTreeNode *node ) ;
#line 410
void gtk_ctree_set_indent(GtkCTree *ctree , gint indent ) ;
#line 412
void gtk_ctree_set_spacing(GtkCTree *ctree , gint spacing ) ;
#line 414
void gtk_ctree_set_show_stub(GtkCTree *ctree , gboolean show_stub ) ;
#line 416
void gtk_ctree_set_line_style(GtkCTree *ctree , GtkCTreeLineStyle line_style ) ;
#line 418
void gtk_ctree_set_expander_style(GtkCTree *ctree , GtkCTreeExpanderStyle expander_style ) ;
#line 420
void gtk_ctree_set_drag_compare_func(GtkCTree *ctree , GtkCTreeCompareDragFunc cmp_func ) ;
#line 427
void gtk_ctree_sort_node(GtkCTree *ctree , GtkCTreeNode *node ) ;
#line 429
void gtk_ctree_sort_recursive(GtkCTree *ctree , GtkCTreeNode *node ) ;
#line 439
GType gtk_ctree_node_get_type(void) ;
#line 88 "/usr/include/gtk-2.0/gtk/gtkcurve.h"
GType gtk_curve_get_type(void) ;
#line 89
GtkWidget *gtk_curve_new(void) ;
#line 90
void gtk_curve_reset(GtkCurve *curve ) ;
#line 91
void gtk_curve_set_gamma(GtkCurve *curve , gfloat gamma_ ) ;
#line 92
void gtk_curve_set_range(GtkCurve *curve , gfloat min_x , gfloat max_x , gfloat min_y ,
                         gfloat max_y ) ;
#line 95
void gtk_curve_get_vector(GtkCurve *curve , int veclen , gfloat vector[] ) ;
#line 97
void gtk_curve_set_vector(GtkCurve *curve , int veclen , gfloat vector[] ) ;
#line 99
void gtk_curve_set_curve_type(GtkCurve *curve , GtkCurveType type ) ;
#line 102 "/usr/include/gtk-2.0/gtk/gtkfilesel.h"
GType gtk_file_selection_get_type(void) ;
#line 103
GtkWidget *gtk_file_selection_new(gchar *title ) ;
#line 104
void gtk_file_selection_set_filename(GtkFileSelection *filesel , gchar *filename ) ;
#line 106
gchar *gtk_file_selection_get_filename(GtkFileSelection *filesel ) ;
#line 108
void gtk_file_selection_complete(GtkFileSelection *filesel , gchar *pattern ) ;
#line 110
void gtk_file_selection_show_fileop_buttons(GtkFileSelection *filesel ) ;
#line 111
void gtk_file_selection_hide_fileop_buttons(GtkFileSelection *filesel ) ;
#line 113
gchar **gtk_file_selection_get_selections(GtkFileSelection *filesel ) ;
#line 115
void gtk_file_selection_set_select_multiple(GtkFileSelection *filesel , gboolean select_multiple ) ;
#line 117
gboolean gtk_file_selection_get_select_multiple(GtkFileSelection *filesel ) ;
#line 74 "/usr/include/gtk-2.0/gtk/gtkgamma.h"
GType gtk_gamma_curve_get_type(void) ;
#line 75
GtkWidget *gtk_gamma_curve_new(void) ;
#line 93 "/usr/include/gtk-2.0/gtk/gtkinputdialog.h"
GType gtk_input_dialog_get_type(void) ;
#line 94
GtkWidget *gtk_input_dialog_new(void) ;
#line 132 "/usr/include/gtk-2.0/gtk/gtkitemfactory.h"
GType gtk_item_factory_get_type(void) ;
#line 137
GtkItemFactory *gtk_item_factory_new(GType container_type , gchar *path , GtkAccelGroup *accel_group ) ;
#line 140
void gtk_item_factory_construct(GtkItemFactory *ifactory , GType container_type ,
                                gchar *path , GtkAccelGroup *accel_group ) ;
#line 147
void gtk_item_factory_add_foreign(GtkWidget *accel_widget , gchar *full_path , GtkAccelGroup *accel_group ,
                                  guint keyval , GdkModifierType modifiers ) ;
#line 153
GtkItemFactory *gtk_item_factory_from_widget(GtkWidget *widget ) ;
#line 154
gchar *gtk_item_factory_path_from_widget(GtkWidget *widget ) ;
#line 156
GtkWidget *gtk_item_factory_get_item(GtkItemFactory *ifactory , gchar *path ) ;
#line 158
GtkWidget *gtk_item_factory_get_widget(GtkItemFactory *ifactory , gchar *path ) ;
#line 160
GtkWidget *gtk_item_factory_get_widget_by_action(GtkItemFactory *ifactory , guint action ) ;
#line 162
GtkWidget *gtk_item_factory_get_item_by_action(GtkItemFactory *ifactory , guint action ) ;
#line 165
void gtk_item_factory_create_item(GtkItemFactory *ifactory , GtkItemFactoryEntry *entry ,
                                  gpointer callback_data , guint callback_type ) ;
#line 169
void gtk_item_factory_create_items(GtkItemFactory *ifactory , guint n_entries , GtkItemFactoryEntry *entries ,
                                   gpointer callback_data ) ;
#line 173
void gtk_item_factory_delete_item(GtkItemFactory *ifactory , gchar *path ) ;
#line 175
void gtk_item_factory_delete_entry(GtkItemFactory *ifactory , GtkItemFactoryEntry *entry ) ;
#line 177
void gtk_item_factory_delete_entries(GtkItemFactory *ifactory , guint n_entries ,
                                     GtkItemFactoryEntry *entries ) ;
#line 180
void gtk_item_factory_popup(GtkItemFactory *ifactory , guint x , guint y , guint mouse_button ,
                            guint32 time_ ) ;
#line 185
void gtk_item_factory_popup_with_data(GtkItemFactory *ifactory , gpointer popup_data ,
                                      GDestroyNotify destroy , guint x , guint y ,
                                      guint mouse_button , guint32 time_ ) ;
#line 192
gpointer gtk_item_factory_popup_data(GtkItemFactory *ifactory ) ;
#line 193
gpointer gtk_item_factory_popup_data_from_widget(GtkWidget *widget ) ;
#line 194
void gtk_item_factory_set_translate_func(GtkItemFactory *ifactory , GtkTranslateFunc func ,
                                         gpointer data , GDestroyNotify notify ) ;
#line 219
void gtk_item_factory_create_items_ac(GtkItemFactory *ifactory , guint n_entries ,
                                      GtkItemFactoryEntry *entries , gpointer callback_data ,
                                      guint callback_type ) ;
#line 225
GtkItemFactory *gtk_item_factory_from_path(gchar *path ) ;
#line 226
void gtk_item_factory_create_menu_entries(guint n_entries , GtkMenuEntry *entries ) ;
#line 228
void gtk_item_factories_path_delete(gchar *ifactory_path , gchar *path ) ;
#line 84 "/usr/include/gtk-2.0/gtk/gtklist.h"
GType gtk_list_get_type(void) ;
#line 85
GtkWidget *gtk_list_new(void) ;
#line 86
void gtk_list_insert_items(GtkList *list , GList *items , gint position ) ;
#line 89
void gtk_list_append_items(GtkList *list , GList *items ) ;
#line 91
void gtk_list_prepend_items(GtkList *list , GList *items ) ;
#line 93
void gtk_list_remove_items(GtkList *list , GList *items ) ;
#line 95
void gtk_list_remove_items_no_unref(GtkList *list , GList *items ) ;
#line 97
void gtk_list_clear_items(GtkList *list , gint start , gint end ) ;
#line 100
void gtk_list_select_item(GtkList *list , gint item ) ;
#line 102
void gtk_list_unselect_item(GtkList *list , gint item ) ;
#line 104
void gtk_list_select_child(GtkList *list , GtkWidget *child ) ;
#line 106
void gtk_list_unselect_child(GtkList *list , GtkWidget *child ) ;
#line 108
gint gtk_list_child_position(GtkList *list , GtkWidget *child ) ;
#line 110
void gtk_list_set_selection_mode(GtkList *list , GtkSelectionMode mode ) ;
#line 113
void gtk_list_extend_selection(GtkList *list , GtkScrollType scroll_type , gfloat position ,
                               gboolean auto_start_selection ) ;
#line 117
void gtk_list_start_selection(GtkList *list ) ;
#line 118
void gtk_list_end_selection(GtkList *list ) ;
#line 119
void gtk_list_select_all(GtkList *list ) ;
#line 120
void gtk_list_unselect_all(GtkList *list ) ;
#line 121
void gtk_list_scroll_horizontal(GtkList *list , GtkScrollType scroll_type , gfloat position ) ;
#line 124
void gtk_list_scroll_vertical(GtkList *list , GtkScrollType scroll_type , gfloat position ) ;
#line 127
void gtk_list_toggle_add_mode(GtkList *list ) ;
#line 128
void gtk_list_toggle_focus_row(GtkList *list ) ;
#line 129
void gtk_list_toggle_row(GtkList *list , GtkWidget *item ) ;
#line 131
void gtk_list_undo_selection(GtkList *list ) ;
#line 132
void gtk_list_end_drag_selection(GtkList *list ) ;
#line 78 "/usr/include/gtk-2.0/gtk/gtklistitem.h"
GType gtk_list_item_get_type(void) ;
#line 79
GtkWidget *gtk_list_item_new(void) ;
#line 80
GtkWidget *gtk_list_item_new_with_label(gchar *label ) ;
#line 81
void gtk_list_item_select(GtkListItem *list_item ) ;
#line 82
void gtk_list_item_deselect(GtkListItem *list_item ) ;
#line 116 "/usr/include/gtk-2.0/gtk/gtkoldeditable.h"
GType gtk_old_editable_get_type(void) ;
#line 117
void gtk_old_editable_claim_selection(GtkOldEditable *old_editable , gboolean claim ,
                                      guint32 time_ ) ;
#line 120
void gtk_old_editable_changed(GtkOldEditable *old_editable ) ;
#line 73 "/usr/include/gtk-2.0/gtk/gtkoptionmenu.h"
GType gtk_option_menu_get_type(void) ;
#line 74
GtkWidget *gtk_option_menu_new(void) ;
#line 75
GtkWidget *gtk_option_menu_get_menu(GtkOptionMenu *option_menu ) ;
#line 76
void gtk_option_menu_set_menu(GtkOptionMenu *option_menu , GtkWidget *menu ) ;
#line 78
void gtk_option_menu_remove_menu(GtkOptionMenu *option_menu ) ;
#line 79
gint gtk_option_menu_get_history(GtkOptionMenu *option_menu ) ;
#line 80
void gtk_option_menu_set_history(GtkOptionMenu *option_menu , guint index_ ) ;
#line 89 "/usr/include/gtk-2.0/gtk/gtkpreview.h"
GType gtk_preview_get_type(void) ;
#line 90
void gtk_preview_uninit(void) ;
#line 91
GtkWidget *gtk_preview_new(GtkPreviewType type ) ;
#line 92
void gtk_preview_size(GtkPreview *preview , gint width , gint height ) ;
#line 95
void gtk_preview_put(GtkPreview *preview , GdkWindow *window , GdkGC *gc , gint srcx ,
                     gint srcy , gint destx , gint desty , gint width , gint height ) ;
#line 104
void gtk_preview_draw_row(GtkPreview *preview , guchar *data , gint x , gint y , gint w ) ;
#line 109
void gtk_preview_set_expand(GtkPreview *preview , gboolean expand ) ;
#line 112
void gtk_preview_set_gamma(double gamma_ ) ;
#line 113
void gtk_preview_set_color_cube(guint nred_shades , guint ngreen_shades , guint nblue_shades ,
                                guint ngray_shades ) ;
#line 117
void gtk_preview_set_install_cmap(gint install_cmap ) ;
#line 118
void gtk_preview_set_reserved(gint nreserved ) ;
#line 119
void gtk_preview_set_dither(GtkPreview *preview , GdkRgbDither dither ) ;
#line 121
GdkVisual *gtk_preview_get_visual(void) ;
#line 122
GdkColormap *gtk_preview_get_cmap(void) ;
#line 123
GtkPreviewInfo *gtk_preview_get_info(void) ;
#line 130
void gtk_preview_reset(void) ;
#line 96 "/usr/include/gtk-2.0/gtk/gtktipsquery.h"
GType gtk_tips_query_get_type(void) ;
#line 97
GtkWidget *gtk_tips_query_new(void) ;
#line 98
void gtk_tips_query_start_query(GtkTipsQuery *tips_query ) ;
#line 99
void gtk_tips_query_stop_query(GtkTipsQuery *tips_query ) ;
#line 100
void gtk_tips_query_set_caller(GtkTipsQuery *tips_query , GtkWidget *caller ) ;
#line 102
void gtk_tips_query_set_labels(GtkTipsQuery *tips_query , gchar *label_inactive ,
                               gchar *label_no_tip ) ;
#line 82 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.h"
int gsg_message_dialog_active ;
#line 93
int gsg_make_path(size_t buf_size , char *buf , char const   *prog_name___0 , char const   *prefix ,
                  char const   *dev_name , char const   *postfix ) ;
#line 98
void gsg_message(gchar *title , gchar *message ) ;
#line 99
void gsg_error(gchar *error ) ;
#line 100
void gsg_warning(gchar *warning ) ;
#line 101
int gsg_get_filename(char const   *label , char const   *default_name , size_t max_len ,
                     char *filename ) ;
#line 104
GSGDialog *gsg_create_dialog(GtkWidget *window , char const   *device_name , GSGCallback option_reload_callback ,
                             void *option_reload_arg , GSGCallback param_change_callback ,
                             void *param_change_arg ) ;
#line 110
void gsg_sync(GSGDialog *dialog___0 ) ;
#line 111
void gsg_refresh_dialog(GSGDialog *dialog___0 ) ;
#line 112
void gsg_update_scan_window(GSGDialog *dialog___0 ) ;
#line 113
void gsg_set_advanced(GSGDialog *dialog___0 , int advanced ) ;
#line 114
void gsg_set_tooltips(GSGDialog *dialog___0 , int enable ) ;
#line 115
void gsg_set_twocolumn(GSGDialog *dialog___0 , int twocolumn ) ;
#line 116
void gsg_set_sensitivity(GSGDialog *dialog___0 , int sensitive ) ;
#line 117
void gsg_destroy_dialog(GSGDialog *dialog___0 ) ;
#line 20 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preferences.h"
Preferences preferences ;
#line 22
void preferences_save(int fd ) ;
#line 23
void preferences_restore(int fd ) ;
#line 113 "/root/oss-experiment/data/sane-frontends-1.0.14/src/../include/sane/sanei_debug.h"
int sanei_debug_gtkglue  =    0;
#line 146
static void sanei_debug_gtkglue_call(int level , char const   *msg  , ...) ;
#line 153 "/root/oss-experiment/data/sane-frontends-1.0.14/src/../include/sane/sanei_debug.h"
static void sanei_debug_gtkglue_call(int level , char const   *msg  , ...) 
{ 
  va_list ap ;

  {
  {
#line 157
  __builtin_va_start((void *)ap, msg);
#line 158
  sanei_debug_msg(level, sanei_debug_gtkglue, "gtkglue", msg, (void *)ap);
#line 159
  __builtin_va_end((void *)ap);
  }
  return;
}
}
#line 53 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
int gsg_message_dialog_active  =    0;
#line 56
static void panel_rebuild(GSGDialog *dialog___0 ) ;
#line 59 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
static char const   *unit_string(SANE_Unit unit ) 
{ 
  double d ;

  {
  {
#line 65
  if ((unsigned int )unit == (unsigned int )0) {
#line 65
    goto case_0;
  }
#line 67
  if ((unsigned int )unit == (unsigned int )1) {
#line 67
    goto case_1;
  }
#line 69
  if ((unsigned int )unit == (unsigned int )2) {
#line 69
    goto case_2;
  }
#line 71
  if ((unsigned int )unit == (unsigned int )4) {
#line 71
    goto case_4;
  }
#line 73
  if ((unsigned int )unit == (unsigned int )5) {
#line 73
    goto case_5;
  }
#line 75
  if ((unsigned int )unit == (unsigned int )3) {
#line 75
    goto case_3;
  }
#line 82
  if ((unsigned int )unit == (unsigned int )6) {
#line 82
    goto case_6;
  }
#line 63
  goto switch_break;
  case_0: /* CIL Label */ 
#line 66
  return ("none");
  case_1: /* CIL Label */ 
#line 68
  return ("pixel");
  case_2: /* CIL Label */ 
#line 70
  return ("bit");
  case_4: /* CIL Label */ 
#line 72
  return ("dpi");
  case_5: /* CIL Label */ 
#line 74
  return ("%");
  case_3: /* CIL Label */ 
#line 76
  d = preferences.length_unit;
#line 77
  if (d > 9.90000000001) {
#line 77
    if (d < 10.1) {
#line 78
      return ("cm");
    } else {
#line 77
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 79
  if (d > 25.3000000001) {
#line 79
    if (d < 25.5) {
#line 80
      return ("in");
    }
  }
#line 81
  return ("mm");
  case_6: /* CIL Label */ 
#line 83
  return ("us");
  switch_break: /* CIL Label */ ;
  }
#line 85
  return ((char const   *)0);
}
}
#line 89 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
static void set_tooltip(GtkTooltips *tooltips , GtkWidget *widget , char const   *desc___0 ) 
{ 


  {
#line 91
  if (desc___0) {
#line 91
    if ((int )*(desc___0 + 0)) {
      {
#line 96
      gtk_tooltips_set_tip(tooltips, widget, desc___0, (gchar *)0);
      }
    }
  }
  return;
}
}
#line 101 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
int gsg_make_path(size_t buf_size , char *buf , char const   *prog_name___0 , char const   *prefix ,
                  char const   *dev_name , char const   *postfix ) 
{ 
  struct passwd *pw ;
  size_t len ;
  size_t extra ;
  int i ;
  __uid_t __cil_tmp11 ;
  struct passwd *__cil_tmp12 ;
  int *__cil_tmp13 ;
  char *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  size_t __cil_tmp17 ;
  size_t __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  size_t __cil_tmp20 ;
  size_t __cil_tmp21 ;
  size_t __cil_tmp22 ;
  size_t __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  size_t __cil_tmp25 ;
  int *__cil_tmp26 ;

  {
  {
#line 110
  __cil_tmp11 = getuid();
#line 110
  __cil_tmp12 = getpwuid(__cil_tmp11);
#line 110
  pw = __cil_tmp12;
  }
#line 111
  if (! pw) {
    {
#line 113
    __cil_tmp13 = __errno_location();
#line 113
    __cil_tmp14 = strerror(*__cil_tmp13);
#line 113
    snprintf(buf, buf_size, "Failed to determine home directory: %s.", __cil_tmp14);
#line 115
    gsg_error(buf);
    }
#line 116
    return (- 1);
  }
  {
#line 118
  snprintf(buf, buf_size, "%s/.sane\230\001", pw->pw_dir);
#line 119
  mkdir((char const   *)buf, (__mode_t )511);
#line 121
  len = strlen((char const   *)buf);
  }
#line 123
  if (prog_name___0) {
    {
#line 125
    extra = strlen(prog_name___0);
    }
#line 126
    if ((len + extra) + 1UL >= buf_size) {
#line 127
      goto filename_too_long;
    }
    {
#line 129
    __cil_tmp17 = len;
#line 129
    len ++;
#line 129
    *(buf + __cil_tmp17) = (char )'/';
#line 130
    memcpy(buf + len, prog_name___0, extra);
#line 131
    len += extra;
#line 132
    *(buf + len) = (char )'\000';
#line 133
    mkdir((char const   *)buf, (__mode_t )511);
    }
  }
#line 135
  if (len >= buf_size) {
#line 136
    goto filename_too_long;
  }
#line 138
  __cil_tmp18 = len;
#line 138
  len ++;
#line 138
  *(buf + __cil_tmp18) = (char )'/';
#line 140
  if (prefix) {
    {
#line 142
    extra = strlen(prefix);
    }
#line 143
    if (len + extra >= buf_size) {
#line 144
      goto filename_too_long;
    }
    {
#line 146
    memcpy(buf + len, prefix, extra);
#line 147
    len += extra;
    }
  }
#line 150
  if (dev_name) {
#line 156
    i = 0;
    {
#line 156
    while (1) {
      while_continue: /* CIL Label */ ;
#line 156
      if (! *(dev_name + i)) {
#line 156
        goto while_break;
      }
#line 158
      if (len + 2UL >= buf_size) {
#line 159
        goto filename_too_long;
      }
      {
#line 163
      if ((int )*(dev_name + i) == '/') {
#line 163
        goto case_47;
      }
#line 175
      if ((int )*(dev_name + i) == '+') {
#line 175
        goto case_43;
      }
#line 177
      goto switch_default;
      case_47: /* CIL Label */ 
#line 164
      __cil_tmp20 = len;
#line 164
      len ++;
#line 164
      *(buf + __cil_tmp20) = (char )'+';
#line 165
      __cil_tmp21 = len;
#line 165
      len ++;
#line 165
      *(buf + __cil_tmp21) = (char )'-';
#line 166
      goto switch_break;
      case_43: /* CIL Label */ 
#line 176
      __cil_tmp22 = len;
#line 176
      len ++;
#line 176
      *(buf + __cil_tmp22) = (char )'+';
      switch_default: /* CIL Label */ 
#line 178
      __cil_tmp23 = len;
#line 178
      len ++;
#line 178
      *(buf + __cil_tmp23) = *(dev_name + i);
#line 179
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 156
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 184
  if (postfix) {
    {
#line 186
    extra = strlen(postfix);
    }
#line 187
    if (len + extra >= buf_size) {
#line 188
      goto filename_too_long;
    }
    {
#line 189
    memcpy(buf + len, postfix, extra);
#line 190
    len += extra;
    }
  }
#line 192
  if (len >= buf_size) {
#line 193
    goto filename_too_long;
  }
#line 195
  __cil_tmp25 = len;
#line 195
  len ++;
#line 195
  *(buf + __cil_tmp25) = (char )'\000';
#line 196
  return (0);
  filename_too_long: 
  {
#line 199
  gsg_error("Filename too long.");
  }
  {
#line 200
  __cil_tmp26 = __errno_location();
#line 200
  *__cil_tmp26 = 7;
  }
#line 201
  return (- 1);
}
}
#line 205 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
static void set_option(GSGDialog *dialog___0 , int opt_num , void *val , SANE_Action action ) 
{ 
  SANE_Status status ;
  SANE_Int info ;
  char buf[256] ;
  SANE_Status __cil_tmp8 ;
  SANE_Option_Descriptor *__cil_tmp9 ;
  SANE_String_Const __cil_tmp10 ;

  {
  {
#line 211
  status = sane_control_option(dialog___0->dev, opt_num, action, val, & info);
  }
#line 212
  if ((unsigned int )status != 0U) {
    {
#line 214
    __cil_tmp10 = sane_strstatus(status);
#line 214
    snprintf((char *)buf, sizeof(buf), "Failed to set value of option %s: %s.", __cil_tmp9->name,
             __cil_tmp10);
#line 217
    gsg_error((char *)buf);
    }
#line 218
    return;
  }
#line 220
  if (info & (1 << 1)) {
    {
#line 222
    panel_rebuild(dialog___0);
    }
#line 223
    if (dialog___0->option_reload_callback) {
      {
#line 224
      (*(dialog___0->option_reload_callback))(dialog___0, dialog___0->option_reload_arg);
      }
    }
  }
#line 226
  if (dialog___0->param_change_callback) {
#line 226
    if (info & (1 << 2)) {
      {
#line 227
      (*(dialog___0->param_change_callback))(dialog___0, dialog___0->param_change_arg);
      }
    }
  }
  return;
}
}
#line 231 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
void gsg_close_dialog_callback(GtkWidget *widget , gpointer data ) 
{ 


  {
  {
#line 233
  gtk_widget_destroy(data);
#line 234
  gsg_message_dialog_active = 0;
  }
  return;
}
}
#line 238 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
void gsg_message(gchar *title , gchar *message ) 
{ 
  GtkWidget *main_vbox ;
  GtkWidget *label ;
  GtkWidget *button ;
  GtkWidget *message_dialog ;
  GtkWidget *__cil_tmp7 ;
  GType __cil_tmp8 ;
  GTypeInstance *__cil_tmp9 ;
  GType __cil_tmp10 ;
  GTypeInstance *__cil_tmp11 ;
  GtkWidget *__cil_tmp12 ;
  GType __cil_tmp13 ;
  GTypeInstance *__cil_tmp14 ;
  GType __cil_tmp15 ;
  GTypeInstance *__cil_tmp16 ;
  GtkWidget *__cil_tmp17 ;
  GType __cil_tmp18 ;
  GTypeInstance *__cil_tmp19 ;
  GtkWidget *__cil_tmp20 ;
  GType __cil_tmp21 ;
  GTypeInstance *__cil_tmp22 ;
  GType __cil_tmp23 ;
  GTypeInstance *__cil_tmp24 ;

  {
#line 243
  if (gsg_message_dialog_active) {
    {
#line 245
    fprintf(stderr, "%s: %s\n", title, message);
    }
#line 246
    return;
  }
  {
#line 248
  gsg_message_dialog_active = 1;
#line 249
  message_dialog = gtk_window_new((GtkWindowType )0);
#line 250
  __cil_tmp8 = gtk_window_get_type();
#line 250
  __cil_tmp9 = g_type_check_instance_cast((GTypeInstance *)message_dialog, __cil_tmp8);
#line 250
  gtk_window_set_position((GtkWindow *)((void *)__cil_tmp9), (GtkWindowPosition )2);
#line 251
  __cil_tmp10 = gtk_window_get_type();
#line 251
  __cil_tmp11 = g_type_check_instance_cast((GTypeInstance *)message_dialog, __cil_tmp10);
#line 251
  gtk_window_set_title((GtkWindow *)((void *)__cil_tmp11), title);
#line 254
  main_vbox = gtk_vbox_new(! 0, 5);
#line 255
  __cil_tmp13 = gtk_container_get_type();
#line 255
  __cil_tmp14 = g_type_check_instance_cast((GTypeInstance *)main_vbox, __cil_tmp13);
#line 255
  gtk_container_set_border_width((GtkContainer *)((void *)__cil_tmp14), (guint )5);
#line 256
  gtk_widget_show(main_vbox);
#line 258
  __cil_tmp15 = gtk_container_get_type();
#line 258
  __cil_tmp16 = g_type_check_instance_cast((GTypeInstance *)message_dialog, __cil_tmp15);
#line 258
  gtk_container_add((GtkContainer *)((void *)__cil_tmp16), main_vbox);
#line 261
  label = gtk_label_new(message);
#line 262
  __cil_tmp18 = gtk_container_get_type();
#line 262
  __cil_tmp19 = g_type_check_instance_cast((GTypeInstance *)main_vbox, __cil_tmp18);
#line 262
  gtk_container_add((GtkContainer *)((void *)__cil_tmp19), label);
#line 263
  gtk_widget_show(label);
#line 266
  button = gtk_button_new_with_label((gchar *)"OK");
#line 267
  __cil_tmp21 = gtk_object_get_type();
#line 267
  __cil_tmp22 = g_type_check_instance_cast((GTypeInstance *)button, __cil_tmp21);
#line 267
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp22), (gchar *)"clicked",
                          (GtkSignalFunc )(& gsg_close_dialog_callback), (GtkCallbackMarshal )((void *)0),
                          message_dialog, (GDestroyNotify )((void *)0), 0, 0);
#line 270
  __cil_tmp23 = gtk_container_get_type();
#line 270
  __cil_tmp24 = g_type_check_instance_cast((GTypeInstance *)main_vbox, __cil_tmp23);
#line 270
  gtk_container_add((GtkContainer *)((void *)__cil_tmp24), button);
#line 272
  gtk_widget_show(button);
#line 273
  gtk_widget_show(message_dialog);
  }
  return;
}
}
#line 277 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
void gsg_error(gchar *error ) 
{ 


  {
  {
#line 279
  gsg_message("Error", error);
  }
  return;
}
}
#line 283 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
void gsg_warning(gchar *warning ) 
{ 


  {
  {
#line 285
  gsg_message("Warning", warning);
  }
  return;
}
}
#line 289 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
static void get_filename_button_clicked(GtkWidget *w , gpointer data ) 
{ 
  int *clicked ;

  {
#line 291
  clicked = data;
#line 292
  *clicked = 1;
  return;
}
}
#line 296 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
int gsg_get_filename(char const   *label , char const   *default_name , size_t max_len ,
                     char *filename ) 
{ 
  int cancel ;
  int ok ;
  GtkWidget *filesel ;
  GtkWidget *__cil_tmp8 ;
  GType __cil_tmp9 ;
  GTypeInstance *__cil_tmp10 ;
  GType __cil_tmp11 ;
  GTypeInstance *__cil_tmp12 ;
  GType __cil_tmp13 ;
  GTypeInstance *__cil_tmp14 ;
  GType __cil_tmp15 ;
  GTypeInstance *__cil_tmp16 ;
  GType __cil_tmp17 ;
  GTypeInstance *__cil_tmp18 ;
  GType __cil_tmp19 ;
  GTypeInstance *__cil_tmp20 ;
  gboolean __cil_tmp21 ;
  size_t len ;
  size_t cwd_len ;
  char *cwd ;
  GType __cil_tmp25 ;
  GTypeInstance *__cil_tmp26 ;
  gchar *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  void *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  size_t __cil_tmp31 ;
  int __cil_tmp32 ;
  int tmp ;

  {
#line 299
  cancel = 0;
  {
#line 299
  ok = 0;
#line 302
  filesel = gtk_file_selection_new((char *)label);
#line 304
  __cil_tmp9 = gtk_window_get_type();
#line 304
  __cil_tmp10 = g_type_check_instance_cast((GTypeInstance *)filesel, __cil_tmp9);
#line 304
  gtk_window_set_modal((GtkWindow *)((void *)__cil_tmp10), ! 0);
#line 306
  __cil_tmp13 = gtk_object_get_type();
#line 306
  __cil_tmp14 = g_type_check_instance_cast((GTypeInstance *)((GtkFileSelection *)((void *)__cil_tmp12))->cancel_button,
                                           __cil_tmp13);
#line 306
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp14), (gchar *)"clicked",
                          (GtkSignalFunc )(& get_filename_button_clicked), (GtkCallbackMarshal )((void *)0),
                          & cancel, (GDestroyNotify )((void *)0), 0, 0);
#line 310
  __cil_tmp17 = gtk_object_get_type();
#line 310
  __cil_tmp18 = g_type_check_instance_cast((GTypeInstance *)((GtkFileSelection *)((void *)__cil_tmp16))->ok_button,
                                           __cil_tmp17);
#line 310
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp18), (gchar *)"clicked",
                          (GtkSignalFunc )(& get_filename_button_clicked), (GtkCallbackMarshal )((void *)0),
                          & ok, (GDestroyNotify )((void *)0), 0, 0);
  }
#line 313
  if (default_name) {
    {
#line 314
    __cil_tmp19 = gtk_file_selection_get_type();
#line 314
    __cil_tmp20 = g_type_check_instance_cast((GTypeInstance *)filesel, __cil_tmp19);
#line 314
    gtk_file_selection_set_filename((GtkFileSelection *)((void *)__cil_tmp20), (char *)default_name);
    }
  }
  {
#line 317
  gtk_widget_show(filesel);
  }
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (! (! cancel && ! ok)) {
#line 319
      goto while_break;
    }
    {
#line 321
    __cil_tmp21 = gtk_events_pending();
    }
#line 321
    if (! __cil_tmp21) {
      {
#line 322
      usleep((__useconds_t )100000);
      }
    }
    {
#line 323
    gtk_main_iteration();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  if (ok) {
    {
#line 331
    __cil_tmp25 = gtk_file_selection_get_type();
#line 331
    __cil_tmp26 = g_type_check_instance_cast((GTypeInstance *)filesel, __cil_tmp25);
#line 331
    __cil_tmp27 = gtk_file_selection_get_filename((GtkFileSelection *)((void *)__cil_tmp26));
#line 331
    strncpy(filename, __cil_tmp27, max_len - 1UL);
#line 334
    *(filename + (max_len - 1UL)) = (char )'\000';
#line 336
    len = strlen((char const   *)filename);
#line 337
    cwd = (char *)__builtin_alloca(len + 2UL);
#line 338
    getcwd(cwd, len + 1UL);
#line 339
    cwd_len = strlen((char const   *)cwd);
#line 340
    __cil_tmp31 = cwd_len;
#line 340
    cwd_len ++;
#line 340
    *(cwd + __cil_tmp31) = (char )'/';
#line 341
    *(cwd + cwd_len) = (char )'\000';
#line 342
    __cil_tmp32 = strncmp((char const   *)filename, (char const   *)cwd, cwd_len);
    }
#line 342
    if (__cil_tmp32 == 0) {
      {
#line 343
      memcpy(filename, filename + cwd_len, (len - cwd_len) + 1UL);
      }
    }
  }
  {
#line 345
  gtk_widget_destroy(filesel);
  }
#line 346
  if (cancel) {
#line 346
    tmp = - 1;
  } else {
#line 346
    tmp = 0;
  }
#line 346
  return (tmp);
}
}
#line 350 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
static gint autobutton_update(GtkWidget *widget , GSGDialogElement *elem ) 
{ 
  GSGDialog *dialog___0 ;
  int opt_num ;
  SANE_Option_Descriptor *opt ;
  SANE_Status status ;
  SANE_Word val ;
  char buf[256] ;
  SANE_Option_Descriptor *__cil_tmp9 ;
  GType __cil_tmp10 ;
  GTypeInstance *__cil_tmp11 ;
  SANE_Status __cil_tmp12 ;
  SANE_String_Const __cil_tmp13 ;

  {
  {
#line 352
  dialog___0 = elem->dialog;
#line 353
  opt_num = (int )(elem - dialog___0->element);
#line 359
  opt = sane_get_option_descriptor(dialog___0->dev, opt_num);
  }
#line 360
  if (((GtkToggleButton *)((void *)__cil_tmp11))->active) {
    {
#line 361
    set_option(dialog___0, opt_num, (void *)0, (SANE_Action )2);
    }
  } else {
    {
#line 364
    status = sane_control_option(dialog___0->dev, opt_num, (SANE_Action )0, & val,
                                 (SANE_Int *)0);
    }
#line 366
    if ((unsigned int )status != 0U) {
      {
#line 368
      __cil_tmp13 = sane_strstatus(status);
#line 368
      snprintf((char *)buf, sizeof(buf), "Failed to obtain value of option %s: %s.\230\001",
               opt->name, __cil_tmp13);
#line 371
      gsg_error((char *)buf);
      }
    }
    {
#line 373
    set_option(dialog___0, opt_num, & val, (SANE_Action )1);
    }
  }
#line 375
  return (0);
}
}
#line 379 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
static void autobutton_new(GtkWidget *parent , GSGDialogElement *elem , GtkWidget *label ,
                           GtkTooltips *tooltips ) 
{ 
  GtkWidget *button ;
  GtkWidget *alignment ;
  GtkWidget *__cil_tmp7 ;
  GType __cil_tmp8 ;
  GTypeInstance *__cil_tmp9 ;
  GType __cil_tmp10 ;
  GTypeInstance *__cil_tmp11 ;
  GtkWidget *__cil_tmp12 ;
  GType __cil_tmp13 ;
  GTypeInstance *__cil_tmp14 ;
  GType __cil_tmp15 ;
  GTypeInstance *__cil_tmp16 ;
  GType __cil_tmp17 ;
  GTypeInstance *__cil_tmp18 ;

  {
  {
#line 384
  button = gtk_check_button_new();
#line 385
  __cil_tmp8 = gtk_container_get_type();
#line 385
  __cil_tmp9 = g_type_check_instance_cast((GTypeInstance *)button, __cil_tmp8);
#line 385
  gtk_container_set_border_width((GtkContainer *)((void *)__cil_tmp9), (guint )0);
#line 386
  gtk_widget_set_usize(button, 20, 20);
#line 387
  __cil_tmp10 = gtk_object_get_type();
#line 387
  __cil_tmp11 = g_type_check_instance_cast((GTypeInstance *)button, __cil_tmp10);
#line 387
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp11), (gchar *)"toggled",
                          (GtkSignalFunc )(& autobutton_update), (GtkCallbackMarshal )((void *)0),
                          elem, (GDestroyNotify )((void *)0), 0, 0);
#line 389
  set_tooltip(tooltips, button, "Turns on automatic mode.\340:\231\367:V");
#line 391
  alignment = gtk_alignment_new((gfloat )0., (gfloat )1., (gfloat )0.5, (gfloat )0.5);
#line 392
  __cil_tmp13 = gtk_container_get_type();
#line 392
  __cil_tmp14 = g_type_check_instance_cast((GTypeInstance *)alignment, __cil_tmp13);
#line 392
  gtk_container_add((GtkContainer *)((void *)__cil_tmp14), button);
#line 394
  __cil_tmp15 = gtk_box_get_type();
#line 394
  __cil_tmp16 = g_type_check_instance_cast((GTypeInstance *)parent, __cil_tmp15);
#line 394
  gtk_box_pack_end((GtkBox *)((void *)__cil_tmp16), label, 0, 0, (guint )0);
#line 395
  __cil_tmp17 = gtk_box_get_type();
#line 395
  __cil_tmp18 = g_type_check_instance_cast((GTypeInstance *)parent, __cil_tmp17);
#line 395
  gtk_box_pack_end((GtkBox *)((void *)__cil_tmp18), alignment, 0, 0, (guint )2);
#line 397
  gtk_widget_show(alignment);
#line 398
  gtk_widget_show(button);
  }
  return;
}
}
#line 402 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
static gint button_update(GtkWidget *widget , GSGDialogElement *elem ) 
{ 
  GSGDialog *dialog___0 ;
  int opt_num ;
  SANE_Option_Descriptor *opt ;
  SANE_Word val ;
  SANE_Option_Descriptor *__cil_tmp7 ;
  GType __cil_tmp8 ;
  GTypeInstance *__cil_tmp9 ;

  {
  {
#line 404
  dialog___0 = elem->dialog;
#line 405
  opt_num = (int )(elem - dialog___0->element);
#line 407
  val = 0;
#line 409
  opt = sane_get_option_descriptor(dialog___0->dev, opt_num);
  }
#line 410
  if (((GtkToggleButton *)((void *)__cil_tmp9))->active) {
#line 411
    val = 1;
  }
  {
#line 412
  set_option(dialog___0, opt_num, & val, (SANE_Action )1);
  }
#line 413
  return (0);
}
}
#line 417 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
static void button_new(GtkWidget *parent , char const   *name , SANE_Word val , GSGDialogElement *elem ,
                       GtkTooltips *tooltips , char const   *desc___0 , gint is_settable ) 
{ 
  GtkWidget *button ;
  GtkWidget *__cil_tmp9 ;
  GType __cil_tmp10 ;
  GTypeInstance *__cil_tmp11 ;
  GType __cil_tmp12 ;
  GTypeInstance *__cil_tmp13 ;
  GType __cil_tmp14 ;
  GTypeInstance *__cil_tmp15 ;
  GType __cil_tmp16 ;
  GTypeInstance *__cil_tmp17 ;

  {
  {
#line 423
  button = gtk_check_button_new_with_label((char *)name);
#line 424
  __cil_tmp10 = gtk_toggle_button_get_type();
#line 424
  __cil_tmp11 = g_type_check_instance_cast((GTypeInstance *)button, __cil_tmp10);
#line 424
  gtk_toggle_button_set_active((GtkToggleButton *)((void *)__cil_tmp11), val);
#line 425
  __cil_tmp12 = gtk_object_get_type();
#line 425
  __cil_tmp13 = g_type_check_instance_cast((GTypeInstance *)button, __cil_tmp12);
#line 425
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp13), (gchar *)"toggled",
                          (GtkSignalFunc )(& button_update), (GtkCallbackMarshal )((void *)0),
                          elem, (GDestroyNotify )((void *)0), 0, 0);
#line 427
  __cil_tmp14 = gtk_box_get_type();
#line 427
  __cil_tmp15 = g_type_check_instance_cast((GTypeInstance *)parent, __cil_tmp14);
#line 427
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp15), button, 0, ! 0, (guint )0);
  }
#line 428
  if (! is_settable) {
    {
#line 429
    __cil_tmp16 = gtk_widget_get_type();
#line 429
    __cil_tmp17 = g_type_check_instance_cast((GTypeInstance *)button, __cil_tmp16);
#line 429
    gtk_widget_set_sensitive((GtkWidget *)((void *)__cil_tmp17), 0);
    }
  }
  {
#line 430
  gtk_widget_show(button);
#line 431
  set_tooltip(tooltips, button, desc___0);
#line 433
  elem->widget = button;
  }
  return;
}
}
#line 437 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
static void scale_update(GtkAdjustment *adj_data , GSGDialogElement *elem ) 
{ 
  SANE_Option_Descriptor *opt ;
  GSGDialog *dialog___0 ;
  SANE_Word val ;
  SANE_Word new_val ;
  int opt_num ;
  double d ;
  SANE_Status status ;
  SANE_Option_Descriptor *__cil_tmp10 ;
  SANE_Status __cil_tmp11 ;
  SANE_String_Const __cil_tmp12 ;
  GType __cil_tmp13 ;
  GTypeInstance *__cil_tmp14 ;

  {
  {
#line 440
  dialog___0 = elem->dialog;
#line 446
  sanei_init_debug("gtkglue", & sanei_debug_gtkglue);
#line 448
  sanei_debug_gtkglue_call(4, "scale_update\n");
#line 451
  opt_num = (int )(elem - dialog___0->element);
#line 452
  opt = sane_get_option_descriptor(dialog___0->dev, opt_num);
  }
  {
#line 455
  if ((unsigned int )opt->type == (unsigned int )1) {
#line 455
    goto case_1;
  }
#line 459
  if ((unsigned int )opt->type == (unsigned int )2) {
#line 459
    goto case_2;
  }
#line 466
  goto switch_default;
  case_1: /* CIL Label */ 
#line 456
  val = (SANE_Word )(adj_data->value + 0.5);
#line 457
  goto switch_break;
  case_2: /* CIL Label */ 
#line 460
  d = adj_data->value;
#line 461
  if ((unsigned int )opt->unit == 3U) {
#line 462
    d *= preferences.length_unit;
  }
#line 463
  val = (SANE_Word )(d * (double )(1 << 16));
#line 464
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 467
  fprintf(stderr, "scale_update: unknown type %d\n", (unsigned int )opt->type);
  }
#line 468
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 470
  set_option(dialog___0, opt_num, & val, (SANE_Action )1);
#line 471
  status = sane_control_option(dialog___0->dev, opt_num, (SANE_Action )0, & new_val,
                               (SANE_Int *)0);
  }
#line 474
  if ((unsigned int )status != 0U) {
    {
#line 476
    __cil_tmp12 = sane_strstatus(status);
#line 476
    sanei_debug_gtkglue_call(0, "scale_update: sane_control_option failed: %s\n",
                             __cil_tmp12);
    }
#line 478
    return;
  }
#line 481
  if (new_val != val) {
#line 483
    val = new_val;
#line 484
    goto value_changed;
  }
#line 486
  return;
  value_changed: 
  {
#line 491
  if ((unsigned int )opt->type == (unsigned int )1) {
#line 491
    goto case_1___0;
  }
#line 495
  if ((unsigned int )opt->type == (unsigned int )2) {
#line 495
    goto case_2___0;
  }
#line 502
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
#line 492
  adj_data->value = (gdouble )val;
#line 493
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 496
  d = (double )val / (double )(1 << 16);
#line 497
  if ((unsigned int )opt->unit == 3U) {
#line 498
    d /= preferences.length_unit;
  }
#line 499
  adj_data->value = d;
#line 500
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 503
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 508
  __cil_tmp13 = gtk_object_get_type();
#line 508
  __cil_tmp14 = g_type_check_instance_cast((GTypeInstance *)adj_data, __cil_tmp13);
#line 508
  gtk_signal_emit_by_name((GtkObject *)((void *)__cil_tmp14), (gchar *)"value_changed");
  }
#line 509
  return;
}
}
#line 513 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
static void scale_new(GtkWidget *parent , char const   *name , gfloat val , gfloat min ,
                      gfloat max , gfloat quant , int automatic , GSGDialogElement *elem ,
                      GtkTooltips *tooltips , char const   *desc___0 , gint is_settable ) 
{ 
  GtkWidget *hbox ;
  GtkWidget *label ;
  GtkWidget *scale ;
  GtkWidget *__cil_tmp15 ;
  GType __cil_tmp16 ;
  GTypeInstance *__cil_tmp17 ;
  GType __cil_tmp18 ;
  GTypeInstance *__cil_tmp19 ;
  GtkWidget *__cil_tmp20 ;
  GType __cil_tmp21 ;
  GTypeInstance *__cil_tmp22 ;
  GtkObject *__cil_tmp23 ;
  GType __cil_tmp24 ;
  GTypeInstance *__cil_tmp25 ;
  GtkWidget *__cil_tmp26 ;
  GType __cil_tmp27 ;
  GTypeInstance *__cil_tmp28 ;
  GType __cil_tmp29 ;
  GTypeInstance *__cil_tmp30 ;
  GType __cil_tmp31 ;
  GTypeInstance *__cil_tmp32 ;
  GType __cil_tmp33 ;
  GTypeInstance *__cil_tmp34 ;
  GType __cil_tmp35 ;
  GTypeInstance *__cil_tmp36 ;
  GType __cil_tmp37 ;
  GTypeInstance *__cil_tmp38 ;

  {
  {
#line 520
  hbox = gtk_hbox_new(0, 2);
#line 521
  __cil_tmp16 = gtk_container_get_type();
#line 521
  __cil_tmp17 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp16);
#line 521
  gtk_container_set_border_width((GtkContainer *)((void *)__cil_tmp17), (guint )0);
#line 522
  __cil_tmp18 = gtk_box_get_type();
#line 522
  __cil_tmp19 = g_type_check_instance_cast((GTypeInstance *)parent, __cil_tmp18);
#line 522
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp19), hbox, 0, 0, (guint )0);
#line 524
  label = gtk_label_new((char *)name);
#line 525
  __cil_tmp21 = gtk_box_get_type();
#line 525
  __cil_tmp22 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp21);
#line 525
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp22), label, 0, 0, (guint )2);
#line 527
  elem->data = gtk_adjustment_new((gdouble )val, (gdouble )min, (gdouble )max, (gdouble )quant,
                                  1., 0.);
#line 528
  __cil_tmp24 = gtk_adjustment_get_type();
#line 528
  __cil_tmp25 = g_type_check_instance_cast((GTypeInstance *)elem->data, __cil_tmp24);
#line 528
  __cil_tmp26 = gtk_hscale_new((GtkAdjustment *)((void *)__cil_tmp25));
#line 528
  scale = __cil_tmp26;
#line 529
  set_tooltip(tooltips, scale, desc___0);
#line 530
  gtk_widget_set_usize(scale, 200, 0);
  }
#line 532
  if (automatic) {
    {
#line 533
    autobutton_new(hbox, elem, scale, tooltips);
    }
  } else {
    {
#line 535
    __cil_tmp27 = gtk_box_get_type();
#line 535
    __cil_tmp28 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp27);
#line 535
    gtk_box_pack_end((GtkBox *)((void *)__cil_tmp28), scale, 0, 0, (guint )0);
    }
  }
  {
#line 537
  __cil_tmp29 = gtk_range_get_type();
#line 537
  __cil_tmp30 = g_type_check_instance_cast((GTypeInstance *)scale, __cil_tmp29);
#line 537
  gtk_range_set_update_policy((GtkRange *)((void *)__cil_tmp30), (GtkUpdateType )0);
#line 538
  __cil_tmp31 = gtk_scale_get_type();
#line 538
  __cil_tmp32 = g_type_check_instance_cast((GTypeInstance *)scale, __cil_tmp31);
#line 538
  gtk_scale_set_value_pos((GtkScale *)((void *)__cil_tmp32), (GtkPositionType )2);
  }
#line 539
  if ((double )(quant - (float )((int )quant)) == 0.) {
    {
#line 540
    __cil_tmp33 = gtk_scale_get_type();
#line 540
    __cil_tmp34 = g_type_check_instance_cast((GTypeInstance *)scale, __cil_tmp33);
#line 540
    gtk_scale_set_digits((GtkScale *)((void *)__cil_tmp34), 0);
    }
  } else {
    {
#line 543
    __cil_tmp35 = gtk_scale_get_type();
#line 543
    __cil_tmp36 = g_type_check_instance_cast((GTypeInstance *)scale, __cil_tmp35);
#line 543
    gtk_scale_set_digits((GtkScale *)((void *)__cil_tmp36), 1);
    }
  }
  {
#line 545
  gtk_signal_connect_full(elem->data, (gchar *)"value_changed", (GtkSignalFunc )(& scale_update),
                          (GtkCallbackMarshal )((void *)0), elem, (GDestroyNotify )((void *)0),
                          0, 0);
#line 548
  gtk_widget_show(label);
#line 549
  gtk_widget_show(scale);
  }
#line 550
  if (! is_settable) {
    {
#line 551
    __cil_tmp37 = gtk_widget_get_type();
#line 551
    __cil_tmp38 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp37);
#line 551
    gtk_widget_set_sensitive((GtkWidget *)((void *)__cil_tmp38), 0);
    }
  }
  {
#line 553
  gtk_widget_show(hbox);
#line 555
  elem->widget = scale;
  }
  return;
}
}
#line 559 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
static void push_button_callback(GtkWidget *widget , gpointer data ) 
{ 
  GSGDialogElement *elem ;
  GSGDialog *dialog___0 ;
  int opt_num ;

  {
  {
#line 561
  elem = data;
#line 562
  dialog___0 = elem->dialog;
#line 565
  opt_num = (int )(elem - dialog___0->element);
#line 566
  set_option(dialog___0, opt_num, (void *)0, (SANE_Action )1);
  }
  return;
}
}
#line 570 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
static int option_menu_lookup(GSGMenuItem menu_items[] , char const   *string ) 
{ 
  int i ;
  int __cil_tmp4 ;

  {
#line 574
  i = 0;
  {
#line 574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 574
    if (! (__cil_tmp4 != 0)) {
#line 574
      goto while_break;
    }

#line 574
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 575
  return (i);
}
}
#line 579 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
static void option_menu_callback(GtkWidget *widget , gpointer data ) 
{ 
  GSGMenuItem *menu_item ;
  GSGDialogElement *elem ;
  SANE_Option_Descriptor *opt ;
  GSGDialog *dialog___0 ;
  int opt_num ;
  double dval ;
  SANE_Word val ;
  void *valp ;
  SANE_Option_Descriptor *__cil_tmp11 ;

  {
  {
#line 581
  menu_item = data;
#line 582
  elem = menu_item->elem;
#line 584
  dialog___0 = elem->dialog;
#line 588
  valp = & val;
#line 590
  opt_num = (int )(elem - dialog___0->element);
#line 591
  opt = sane_get_option_descriptor(dialog___0->dev, opt_num);
  }
  {
#line 594
  if ((unsigned int )opt->type == (unsigned int )1) {
#line 594
    goto case_1;
  }
#line 598
  if ((unsigned int )opt->type == (unsigned int )2) {
#line 598
    goto case_2;
  }
#line 603
  if ((unsigned int )opt->type == (unsigned int )3) {
#line 603
    goto case_3;
  }
#line 607
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 595
  sscanf((char const   *)menu_item->label, "%d", & val);
  }
#line 596
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 599
  sscanf((char const   *)menu_item->label, "%lg", & dval);
  }
#line 600
  val = (SANE_Word )(dval * (double )(1 << 16));
#line 601
  goto switch_break;
  case_3: /* CIL Label */ 
#line 604
  valp = menu_item->label;
#line 605
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 608
  fprintf(stderr, "option_menu_callback: unexpected type %d\n", (unsigned int )opt->type);
  }
#line 610
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 612
  set_option(dialog___0, opt_num, valp, (SANE_Action )1);
  }
  return;
}
}
#line 616 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
static void option_menu_new(GtkWidget *parent , char const   *name , char *str_list[] ,
                            char const   *val , GSGDialogElement *elem , GtkTooltips *tooltips ,
                            char const   *desc___0 , gint is_settable ) 
{ 
  GtkWidget *hbox ;
  GtkWidget *label ;
  GtkWidget *option_menu ;
  GtkWidget *menu ;
  GtkWidget *item ;
  GSGMenuItem *menu_items ;
  int i ;
  int num_items ;
  GtkWidget *__cil_tmp17 ;
  GType __cil_tmp18 ;
  GTypeInstance *__cil_tmp19 ;
  GType __cil_tmp20 ;
  GTypeInstance *__cil_tmp21 ;
  GtkWidget *__cil_tmp22 ;
  GType __cil_tmp23 ;
  GTypeInstance *__cil_tmp24 ;
  void *__cil_tmp25 ;
  GtkWidget *__cil_tmp26 ;
  GtkWidget *__cil_tmp27 ;
  GType __cil_tmp28 ;
  GTypeInstance *__cil_tmp29 ;
  GType __cil_tmp30 ;
  GTypeInstance *__cil_tmp31 ;
  GtkWidget *__cil_tmp32 ;
  GType __cil_tmp33 ;
  GTypeInstance *__cil_tmp34 ;
  GType __cil_tmp35 ;
  GTypeInstance *__cil_tmp36 ;
  GType __cil_tmp37 ;
  GTypeInstance *__cil_tmp38 ;
  int __cil_tmp39 ;
  GType __cil_tmp40 ;
  GTypeInstance *__cil_tmp41 ;

  {
  {
#line 624
  hbox = gtk_hbox_new(0, 2);
#line 625
  __cil_tmp18 = gtk_container_get_type();
#line 625
  __cil_tmp19 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp18);
#line 625
  gtk_container_set_border_width((GtkContainer *)((void *)__cil_tmp19), (guint )0);
#line 626
  __cil_tmp20 = gtk_box_get_type();
#line 626
  __cil_tmp21 = g_type_check_instance_cast((GTypeInstance *)parent, __cil_tmp20);
#line 626
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp21), hbox, 0, 0, (guint )0);
#line 628
  label = gtk_label_new((char *)name);
#line 629
  __cil_tmp23 = gtk_box_get_type();
#line 629
  __cil_tmp24 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp23);
#line 629
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp24), label, 0, 0, (guint )2);
#line 631
  num_items = 0;
  }
  {
#line 631
  while (1) {
    while_continue: /* CIL Label */ ;
#line 631
    if (! str_list[num_items]) {
#line 631
      goto while_break;
    }

#line 631
    num_items ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 632
  menu_items = (GSGMenuItem *)malloc((unsigned long )num_items * sizeof(*(menu_items + 0)));
#line 634
  menu = gtk_menu_new();
#line 635
  i = 0;
  }
  {
#line 635
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 635
    if (! (i < num_items)) {
#line 635
      goto while_break___0;
    }
    {
#line 637
    item = gtk_menu_item_new_with_label(str_list[i]);
#line 638
    __cil_tmp28 = gtk_container_get_type();
#line 638
    __cil_tmp29 = g_type_check_instance_cast((GTypeInstance *)menu, __cil_tmp28);
#line 638
    gtk_container_add((GtkContainer *)((void *)__cil_tmp29), item);
#line 639
    __cil_tmp30 = gtk_object_get_type();
#line 639
    __cil_tmp31 = g_type_check_instance_cast((GTypeInstance *)item, __cil_tmp30);
#line 639
    gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp31), (gchar *)"activate\310\001",
                            (GtkSignalFunc )(& option_menu_callback), (GtkCallbackMarshal )((void *)0),
                            menu_items + i, (GDestroyNotify )((void *)0), 0, 0);
#line 643
    gtk_widget_show(item);
#line 645
    (menu_items + i)->label = str_list[i];
#line 646
    (menu_items + i)->elem = elem;
#line 647
    (menu_items + i)->index = i;
    }
#line 635
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 650
  option_menu = gtk_option_menu_new();
#line 651
  __cil_tmp33 = gtk_box_get_type();
#line 651
  __cil_tmp34 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp33);
#line 651
  gtk_box_pack_end((GtkBox *)((void *)__cil_tmp34), option_menu, 0, 0, (guint )2);
#line 652
  __cil_tmp35 = gtk_option_menu_get_type();
#line 652
  __cil_tmp36 = g_type_check_instance_cast((GTypeInstance *)option_menu, __cil_tmp35);
#line 652
  gtk_option_menu_set_menu((GtkOptionMenu *)((void *)__cil_tmp36), menu);
#line 653
  __cil_tmp37 = gtk_option_menu_get_type();
#line 653
  __cil_tmp38 = g_type_check_instance_cast((GTypeInstance *)option_menu, __cil_tmp37);
  }
  {
#line 653
  __cil_tmp39 = option_menu_lookup(menu_items, val);
#line 653
  gtk_option_menu_set_history((GtkOptionMenu *)((void *)__cil_tmp38), (guint )__cil_tmp39);
#line 655
  set_tooltip(tooltips, option_menu, desc___0);
#line 657
  gtk_widget_show(label);
#line 658
  gtk_widget_show(option_menu);
  }
#line 659
  if (! is_settable) {
    {
#line 660
    __cil_tmp40 = gtk_widget_get_type();
#line 660
    __cil_tmp41 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp40);
#line 660
    gtk_widget_set_sensitive((GtkWidget *)((void *)__cil_tmp41), 0);
    }
  }
  {
#line 661
  gtk_widget_show(hbox);
#line 663
  elem->widget = option_menu;
#line 664
  elem->menu_size = num_items;
#line 665
  elem->menu = menu_items;
  }
  return;
}
}
#line 669 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
static void text_entry_callback(GtkWidget *w , gpointer data ) 
{ 
  GSGDialogElement *elem ;
  SANE_Option_Descriptor *opt ;
  GSGDialog *dialog___0 ;
  gchar *text ;
  int opt_num ;
  char *buf ;
  SANE_Option_Descriptor *__cil_tmp9 ;
  void *__cil_tmp10 ;
  GType __cil_tmp11 ;
  GTypeInstance *__cil_tmp12 ;
  gchar *__cil_tmp13 ;
  int __cil_tmp14 ;
  GType __cil_tmp15 ;
  GTypeInstance *__cil_tmp16 ;

  {
  {
#line 671
  elem = data;
#line 673
  dialog___0 = elem->dialog;
#line 678
  opt_num = (int )(elem - dialog___0->element);
#line 679
  opt = sane_get_option_descriptor(dialog___0->dev, opt_num);
#line 681
  buf = (char *)__builtin_alloca((unsigned long )opt->size);
#line 682
  *(buf + 0) = (char )'\000';
#line 684
  __cil_tmp11 = gtk_entry_get_type();
#line 684
  __cil_tmp12 = g_type_check_instance_cast((GTypeInstance *)elem->widget, __cil_tmp11);
#line 684
  __cil_tmp13 = gtk_entry_get_text((GtkEntry *)((void *)__cil_tmp12));
#line 684
  text = __cil_tmp13;
  }
#line 685
  if (text) {
    {
#line 686
    strncpy(buf, text, (unsigned long )opt->size);
    }
  }
  {
#line 687
  *(buf + (opt->size - 1)) = (char )'\000';
#line 689
  set_option(dialog___0, opt_num, buf, (SANE_Action )1);
#line 691
  __cil_tmp14 = strcmp((char const   *)buf, text);
  }
#line 691
  if (__cil_tmp14 != 0) {
    {
#line 693
    __cil_tmp15 = gtk_entry_get_type();
#line 693
    __cil_tmp16 = g_type_check_instance_cast((GTypeInstance *)elem->widget, __cil_tmp15);
#line 693
    gtk_entry_set_text((GtkEntry *)((void *)__cil_tmp16), buf);
    }
  }
  return;
}
}
#line 697 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
static void text_entry_new(GtkWidget *parent , char const   *name , char const   *val ,
                           GSGDialogElement *elem , GtkTooltips *tooltips , char const   *desc___0 ,
                           gint is_settable ) 
{ 
  GtkWidget *hbox ;
  GtkWidget *text ;
  GtkWidget *label ;
  GtkWidget *__cil_tmp11 ;
  GType __cil_tmp12 ;
  GTypeInstance *__cil_tmp13 ;
  GType __cil_tmp14 ;
  GTypeInstance *__cil_tmp15 ;
  GtkWidget *__cil_tmp16 ;
  GType __cil_tmp17 ;
  GTypeInstance *__cil_tmp18 ;
  GtkWidget *__cil_tmp19 ;
  GType __cil_tmp20 ;
  GTypeInstance *__cil_tmp21 ;
  GType __cil_tmp22 ;
  GTypeInstance *__cil_tmp23 ;
  GType __cil_tmp24 ;
  GTypeInstance *__cil_tmp25 ;
  GType __cil_tmp26 ;
  GTypeInstance *__cil_tmp27 ;

  {
  {
#line 703
  hbox = gtk_hbox_new(0, 2);
#line 704
  __cil_tmp12 = gtk_container_get_type();
#line 704
  __cil_tmp13 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp12);
#line 704
  gtk_container_set_border_width((GtkContainer *)((void *)__cil_tmp13), (guint )0);
#line 705
  __cil_tmp14 = gtk_box_get_type();
#line 705
  __cil_tmp15 = g_type_check_instance_cast((GTypeInstance *)parent, __cil_tmp14);
#line 705
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp15), hbox, 0, 0, (guint )0);
#line 707
  label = gtk_label_new((char *)name);
#line 708
  __cil_tmp17 = gtk_box_get_type();
#line 708
  __cil_tmp18 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp17);
#line 708
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp18), label, 0, 0, (guint )2);
#line 710
  text = gtk_entry_new();
#line 711
  __cil_tmp20 = gtk_entry_get_type();
#line 711
  __cil_tmp21 = g_type_check_instance_cast((GTypeInstance *)text, __cil_tmp20);
#line 711
  gtk_entry_set_text((GtkEntry *)((void *)__cil_tmp21), (char *)val);
#line 712
  __cil_tmp22 = gtk_box_get_type();
#line 712
  __cil_tmp23 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp22);
#line 712
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp23), text, 0, ! 0, (guint )0);
#line 713
  __cil_tmp24 = gtk_object_get_type();
#line 713
  __cil_tmp25 = g_type_check_instance_cast((GTypeInstance *)text, __cil_tmp24);
#line 713
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp25), (gchar *)"changed",
                          (GtkSignalFunc )(& text_entry_callback), (GtkCallbackMarshal )((void *)0),
                          elem, (GDestroyNotify )((void *)0), 0, 0);
#line 715
  set_tooltip(tooltips, text, desc___0);
#line 717
  gtk_widget_show(hbox);
  }
#line 718
  if (! is_settable) {
    {
#line 719
    __cil_tmp26 = gtk_widget_get_type();
#line 719
    __cil_tmp27 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp26);
#line 719
    gtk_widget_set_sensitive((GtkWidget *)((void *)__cil_tmp27), 0);
    }
  }
  {
#line 720
  gtk_widget_show(label);
#line 721
  gtk_widget_show(text);
#line 723
  elem->widget = text;
  }
  return;
}
}
#line 727 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
static GtkWidget *group_new(GtkWidget *parent , char const   *title ) 
{ 
  GtkWidget *frame ;
  GtkWidget *vbox ;
  GtkWidget *__cil_tmp5 ;
  GType __cil_tmp6 ;
  GTypeInstance *__cil_tmp7 ;
  GType __cil_tmp8 ;
  GTypeInstance *__cil_tmp9 ;
  GType __cil_tmp10 ;
  GTypeInstance *__cil_tmp11 ;
  GtkWidget *__cil_tmp12 ;
  GType __cil_tmp13 ;
  GTypeInstance *__cil_tmp14 ;
  GType __cil_tmp15 ;
  GTypeInstance *__cil_tmp16 ;

  {
  {
#line 731
  frame = gtk_frame_new((char *)title);
#line 732
  __cil_tmp6 = gtk_container_get_type();
#line 732
  __cil_tmp7 = g_type_check_instance_cast((GTypeInstance *)frame, __cil_tmp6);
#line 732
  gtk_container_set_border_width((GtkContainer *)((void *)__cil_tmp7), (guint )4);
#line 733
  __cil_tmp8 = gtk_frame_get_type();
#line 733
  __cil_tmp9 = g_type_check_instance_cast((GTypeInstance *)frame, __cil_tmp8);
#line 733
  gtk_frame_set_shadow_type((GtkFrame *)((void *)__cil_tmp9), (GtkShadowType )3);
#line 734
  __cil_tmp10 = gtk_box_get_type();
#line 734
  __cil_tmp11 = g_type_check_instance_cast((GTypeInstance *)parent, __cil_tmp10);
#line 734
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp11), frame, 0, 0, (guint )0);
#line 736
  vbox = gtk_vbox_new(0, 4);
#line 737
  __cil_tmp13 = gtk_container_get_type();
#line 737
  __cil_tmp14 = g_type_check_instance_cast((GTypeInstance *)vbox, __cil_tmp13);
#line 737
  gtk_container_set_border_width((GtkContainer *)((void *)__cil_tmp14), (guint )2);
#line 738
  __cil_tmp15 = gtk_container_get_type();
#line 738
  __cil_tmp16 = g_type_check_instance_cast((GTypeInstance *)frame, __cil_tmp15);
#line 738
  gtk_container_add((GtkContainer *)((void *)__cil_tmp16), vbox);
#line 739
  gtk_widget_show(vbox);
  }
#line 740
  return (vbox);
}
}
#line 744 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
static GtkWidget *curve_new(GSGDialog *dialog___0 , int optnum ) 
{ 
  SANE_Option_Descriptor *opt ;
  gfloat fmin___0 ;
  gfloat fmax___0 ;
  gfloat val ;
  gfloat *vector ;
  SANE_Word *optval ;
  SANE_Word min ;
  SANE_Word max ;
  GtkWidget *curve ;
  GtkWidget *gamma___0 ;
  SANE_Status status ;
  SANE_Handle dev ;
  int i ;
  int optlen ;
  GtkWidget *__cil_tmp17 ;
  GType __cil_tmp18 ;
  GTypeInstance *__cil_tmp19 ;
  SANE_Option_Descriptor *__cil_tmp20 ;
  void *__cil_tmp21 ;
  GType __cil_tmp22 ;
  GTypeInstance *__cil_tmp23 ;
  SANE_Status __cil_tmp24 ;
  GType __cil_tmp25 ;
  GTypeInstance *__cil_tmp26 ;

  {
  {
#line 754
  gamma___0 = gtk_gamma_curve_new();
#line 755
  curve = ((GtkGammaCurve *)((void *)__cil_tmp19))->curve;
#line 756
  dev = dialog___0->dev;
#line 758
  opt = sane_get_option_descriptor(dev, optnum);
#line 759
  optlen = (int )((unsigned long )opt->size / sizeof(SANE_Word ));
#line 760
  vector = (gfloat *)__builtin_alloca((unsigned long )optlen * (sizeof(*(vector + 0)) + sizeof(*(optval + 0))));
#line 761
  optval = (SANE_Word *)(vector + optlen);
#line 763
  max = 0;
#line 763
  min = max;
  }
  {
#line 766
  if ((unsigned int )opt->constraint_type == (unsigned int )1) {
#line 766
    goto case_1;
  }
#line 771
  if ((unsigned int )opt->constraint_type == (unsigned int )2) {
#line 771
    goto case_2;
  }
#line 785
  goto switch_default;
  case_1: /* CIL Label */ 
#line 767
  min = (opt->constraint.range)->min;
#line 768
  max = (opt->constraint.range)->max;
#line 769
  goto switch_break;
  case_2: /* CIL Label */ 
#line 772
  if (*(opt->constraint.word_list + 0) > 1) {
#line 774
    max = *(opt->constraint.word_list + 1);
#line 774
    min = max;
#line 775
    i = 2;
    {
#line 775
    while (1) {
      while_continue: /* CIL Label */ ;
#line 775
      if (! (i < *(opt->constraint.word_list + 0))) {
#line 775
        goto while_break;
      }
#line 777
      if (*(opt->constraint.word_list + i) < min) {
#line 778
        min = *(opt->constraint.word_list + i);
      }
#line 779
      if (*(opt->constraint.word_list + i) > max) {
#line 780
        max = *(opt->constraint.word_list + i);
      }
#line 775
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 783
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 786
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 788
  if (min == max) {
    {
#line 790
    fprintf(stderr, "curve_new: warning: option `%s\' has no value constraint\n\230\001",
            opt->name);
#line 793
    fmin___0 = (gfloat )0;
#line 794
    fmax___0 = (gfloat )255;
    }
  } else
#line 796
  if ((unsigned int )opt->type == 2U) {
#line 798
    fmin___0 = (gfloat )((double )min / (double )(1 << 16));
#line 799
    fmax___0 = (gfloat )((double )max / (double )(1 << 16));
  } else {
#line 803
    fmin___0 = (gfloat )min;
#line 804
    fmax___0 = (gfloat )max;
  }
  {
#line 806
  __cil_tmp22 = gtk_curve_get_type();
#line 806
  __cil_tmp23 = g_type_check_instance_cast((GTypeInstance *)curve, __cil_tmp22);
#line 806
  gtk_curve_set_range((GtkCurve *)((void *)__cil_tmp23), (gfloat )0, (gfloat )(optlen - 1),
                      fmin___0, fmax___0);
#line 808
  status = sane_control_option(dev, optnum, (SANE_Action )0, optval, (SANE_Int *)0);
  }
#line 810
  if ((unsigned int )status == 0U) {
#line 812
    i = 0;
    {
#line 812
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 812
      if (! (i < optlen)) {
#line 812
        goto while_break___0;
      }
#line 814
      if ((unsigned int )opt->type == 2U) {
#line 815
        val = (gfloat )((double )*(optval + i) / (double )(1 << 16));
      } else {
#line 817
        val = (gfloat )*(optval + i);
      }
#line 818
      *(vector + i) = val;
#line 812
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 820
    __cil_tmp25 = gtk_curve_get_type();
#line 820
    __cil_tmp26 = g_type_check_instance_cast((GTypeInstance *)curve, __cil_tmp25);
#line 820
    gtk_curve_set_vector((GtkCurve *)((void *)__cil_tmp26), optlen, vector);
    }
  } else {
    {
#line 823
    gtk_widget_set_sensitive(gamma___0, 0);
    }
  }
#line 825
  return (gamma___0);
}
}
#line 829 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
static void vector_new(GSGDialog *dialog___0 , GtkWidget *vbox , int num_vopts , int *vopts ) 
{ 
  GtkWidget *notebook ;
  GtkWidget *label ;
  GtkWidget *curve ;
  SANE_Option_Descriptor *opt ;
  int i ;
  GtkWidget *__cil_tmp10 ;
  GType __cil_tmp11 ;
  GTypeInstance *__cil_tmp12 ;
  GType __cil_tmp13 ;
  GTypeInstance *__cil_tmp14 ;
  SANE_Option_Descriptor *__cil_tmp15 ;
  GtkWidget *__cil_tmp16 ;
  GtkWidget *__cil_tmp17 ;
  GType __cil_tmp18 ;
  GTypeInstance *__cil_tmp19 ;
  GtkWidget *__cil_tmp20 ;
  GType __cil_tmp21 ;
  GTypeInstance *__cil_tmp22 ;
  GType __cil_tmp23 ;
  GTypeInstance *__cil_tmp24 ;

  {
  {
#line 835
  notebook = gtk_notebook_new();
#line 836
  __cil_tmp11 = gtk_container_get_type();
#line 836
  __cil_tmp12 = g_type_check_instance_cast((GTypeInstance *)notebook, __cil_tmp11);
#line 836
  gtk_container_set_border_width((GtkContainer *)((void *)__cil_tmp12), (guint )4);
#line 837
  __cil_tmp13 = gtk_box_get_type();
#line 837
  __cil_tmp14 = g_type_check_instance_cast((GTypeInstance *)vbox, __cil_tmp13);
#line 837
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp14), notebook, ! 0, ! 0, (guint )0);
#line 839
  i = 0;
  }
  {
#line 839
  while (1) {
    while_continue: /* CIL Label */ ;
#line 839
    if (! (i < num_vopts)) {
#line 839
      goto while_break;
    }
    {
#line 841
    opt = sane_get_option_descriptor(dialog___0->dev, *(vopts + i));
#line 843
    label = gtk_label_new((char *)opt->title);
#line 844
    vbox = gtk_vbox_new(0, 0);
#line 845
    __cil_tmp18 = gtk_notebook_get_type();
#line 845
    __cil_tmp19 = g_type_check_instance_cast((GTypeInstance *)notebook, __cil_tmp18);
#line 845
    gtk_notebook_append_page((GtkNotebook *)((void *)__cil_tmp19), vbox, label);
#line 846
    gtk_widget_show(vbox);
#line 847
    gtk_widget_show(label);
#line 849
    curve = curve_new(dialog___0, *(vopts + i));
#line 850
    __cil_tmp21 = gtk_container_get_type();
#line 850
    __cil_tmp22 = g_type_check_instance_cast((GTypeInstance *)curve, __cil_tmp21);
#line 850
    gtk_container_set_border_width((GtkContainer *)((void *)__cil_tmp22), (guint )4);
#line 851
    __cil_tmp23 = gtk_box_get_type();
#line 851
    __cil_tmp24 = g_type_check_instance_cast((GTypeInstance *)vbox, __cil_tmp23);
#line 851
    gtk_box_pack_start((GtkBox *)((void *)__cil_tmp24), curve, ! 0, ! 0, (guint )0);
#line 852
    gtk_widget_show(curve);
#line 854
    (dialog___0->element + *(vopts + i))->widget = curve;
    }
#line 839
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 856
  gtk_widget_show(notebook);
  }
  return;
}
}
#line 860 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
static void panel_destroy(GSGDialog *dialog___0 ) 
{ 
  SANE_Option_Descriptor *opt ;
  GSGDialogElement *elem ;
  int i ;
  int j ;
  GType __cil_tmp6 ;
  GTypeInstance *__cil_tmp7 ;
  SANE_Option_Descriptor *__cil_tmp8 ;

  {
  {
#line 871
  __cil_tmp6 = gtk_object_get_type();
#line 871
  __cil_tmp7 = g_type_check_instance_cast((GTypeInstance *)dialog___0->tooltips, __cil_tmp6);
#line 871
  gtk_object_sink((GtkObject *)((void *)__cil_tmp7));
#line 876
  gtk_widget_destroy(dialog___0->main_hbox);
#line 879
  i = 0;
  }
  {
#line 879
  while (1) {
    while_continue: /* CIL Label */ ;
#line 879
    if (! (i < dialog___0->num_elements)) {
#line 879
      goto while_break;
    }
#line 881
    if ((dialog___0->element + i)->menu) {
      {
#line 883
      opt = sane_get_option_descriptor(dialog___0->dev, i);
#line 884
      elem = dialog___0->element + i;
      }
#line 885
      if ((unsigned int )opt->type != 3U) {
#line 886
        j = 0;
        {
#line 886
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 886
          if (! (j < elem->menu_size)) {
#line 886
            goto while_break___0;
          }
#line 887
          if ((elem->menu + j)->label) {
            {
#line 889
            free((elem->menu + j)->label);
#line 890
            (elem->menu + j)->label = (gchar *)0;
            }
          }
#line 886
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 892
      free(elem->menu);
#line 893
      elem->menu = (GSGMenuItem *)0;
      }
    }
#line 879
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 896
  memset(dialog___0->element, 0, (unsigned long )dialog___0->num_elements * sizeof(*(dialog___0->element + 0)));
  }
  return;
}
}
#line 901 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
static void panel_build(GSGDialog *dialog___0 ) 
{ 
  GtkWidget *main_hbox ;
  GtkWidget *standard_vbox ;
  GtkWidget *advanced_vbox ;
  GtkWidget *option_vbox ;
  GtkWidget *parent ;
  GtkWidget *vbox ;
  GtkWidget *button ;
  GtkWidget *label ;
  SANE_Option_Descriptor *opt ;
  SANE_Handle dev ;
  double dval ;
  double dmin ;
  double dmax ;
  double dquant ;
  char *buf ;
  char str[16] ;
  char title[256] ;
  GSGDialogElement *elem ;
  SANE_Word quant ;
  SANE_Word val ;
  SANE_Status status ;
  SANE_Int num_words ;
  char **str_list ;
  int i ;
  int j ;
  int num_vector_opts ;
  int *vector_opts ;
  SANE_Bool val_in_list ;
  GtkWidget *__cil_tmp30 ;
  GtkWidget *__cil_tmp31 ;
  GtkWidget *__cil_tmp32 ;
  GType __cil_tmp33 ;
  GTypeInstance *__cil_tmp34 ;
  GtkWidget *__cil_tmp35 ;
  GType __cil_tmp36 ;
  GTypeInstance *__cil_tmp37 ;
  GtkWidget *__cil_tmp38 ;
  GType __cil_tmp39 ;
  GTypeInstance *__cil_tmp40 ;
  GtkTooltips *__cil_tmp41 ;
  GdkColormap *__cil_tmp42 ;
  GdkColormap *__cil_tmp43 ;
  GType __cil_tmp44 ;
  GTypeInstance *__cil_tmp45 ;
  void *__cil_tmp46 ;
  SANE_Option_Descriptor *__cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  char const   *__cil_tmp54 ;
  GtkWidget *__cil_tmp55 ;
  int tmp ;
  SANE_Status __cil_tmp57 ;
  int __cil_tmp58 ;
  SANE_Status __cil_tmp59 ;
  void *__cil_tmp60 ;
  char *__cil_tmp61 ;
  int __cil_tmp62 ;
  SANE_Status __cil_tmp63 ;
  void *__cil_tmp64 ;
  char *__cil_tmp65 ;
  void *__cil_tmp66 ;
  SANE_Status __cil_tmp67 ;
  GtkWidget *__cil_tmp68 ;
  GType __cil_tmp69 ;
  GTypeInstance *__cil_tmp70 ;
  GtkWidget *__cil_tmp71 ;
  GType __cil_tmp72 ;
  GTypeInstance *__cil_tmp73 ;
  GType __cil_tmp74 ;
  GTypeInstance *__cil_tmp75 ;
  char msg[256] ;
  SANE_String_Const __cil_tmp77 ;

  {
  {
#line 906
  dev = dialog___0->dev;
#line 915
  num_vector_opts = 0;
#line 918
  main_hbox = gtk_hbox_new(0, 2);
  }
#line 920
  if (dialog___0->twocolumn) {
    {
#line 922
    option_vbox = gtk_hbox_new(0, 2);
    }
  } else {
    {
#line 926
    option_vbox = gtk_vbox_new(0, 2);
    }
  }
  {
#line 929
  __cil_tmp33 = gtk_box_get_type();
#line 929
  __cil_tmp34 = g_type_check_instance_cast((GTypeInstance *)main_hbox, __cil_tmp33);
#line 929
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp34), option_vbox, 0, 0, (guint )0);
#line 930
  gtk_widget_show(option_vbox);
#line 934
  standard_vbox = gtk_vbox_new(0, 0);
#line 935
  gtk_widget_show(standard_vbox);
#line 936
  __cil_tmp36 = gtk_box_get_type();
#line 936
  __cil_tmp37 = g_type_check_instance_cast((GTypeInstance *)option_vbox, __cil_tmp36);
#line 936
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp37), standard_vbox, 0, 0, (guint )0);
#line 940
  advanced_vbox = gtk_vbox_new(0, 0);
#line 941
  __cil_tmp39 = gtk_box_get_type();
#line 941
  __cil_tmp40 = g_type_check_instance_cast((GTypeInstance *)option_vbox, __cil_tmp39);
#line 941
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp40), advanced_vbox, ! 0, ! 0, (guint )0);
#line 944
  dialog___0->tooltips = gtk_tooltips_new();
#line 945
  dialog___0->tooltips_fg.red = (guint16 )0;
#line 946
  dialog___0->tooltips_fg.green = (guint16 )0;
#line 947
  dialog___0->tooltips_fg.blue = (guint16 )0;
#line 949
  __cil_tmp42 = gtk_widget_get_colormap(main_hbox);
#line 949
  gdk_color_alloc(__cil_tmp42, & dialog___0->tooltips_fg);
#line 950
  dialog___0->tooltips_bg.red = (guint16 )61669;
#line 951
  dialog___0->tooltips_bg.green = (guint16 )59113;
#line 952
  dialog___0->tooltips_bg.blue = (guint16 )35979;
#line 953
  __cil_tmp43 = gtk_widget_get_colormap(main_hbox);
#line 953
  gdk_color_alloc(__cil_tmp43, & dialog___0->tooltips_bg);
#line 961
  gsg_set_tooltips(dialog___0, preferences.tooltips_enabled);
#line 963
  __cil_tmp44 = gtk_container_get_type();
#line 963
  __cil_tmp45 = g_type_check_instance_cast((GTypeInstance *)dialog___0->window, __cil_tmp44);
#line 963
  gtk_container_add((GtkContainer *)((void *)__cil_tmp45), main_hbox);
#line 964
  dialog___0->main_hbox = main_hbox;
#line 965
  dialog___0->advanced_vbox = advanced_vbox;
#line 968
  dialog___0->well_known.preview = - 1;
#line 969
  dialog___0->well_known.dpi = - 1;
#line 970
  dialog___0->well_known.coord[0] = - 1;
#line 971
  dialog___0->well_known.coord[1] = - 1;
#line 972
  dialog___0->well_known.coord[2] = - 1;
#line 973
  dialog___0->well_known.coord[3] = - 1;
#line 975
  vector_opts = (int *)__builtin_alloca((unsigned long )dialog___0->num_elements * sizeof(int ));
#line 977
  parent = standard_vbox;
#line 978
  i = 1;
  }
  {
#line 978
  while (1) {
    while_continue: /* CIL Label */ ;
#line 978
    if (! (i < dialog___0->num_elements)) {
#line 978
      goto while_break;
    }
    {
#line 980
    opt = sane_get_option_descriptor(dev, i);
    }
#line 981
    if (! ((opt->cap & (1 << 5)) == 0)) {
#line 982
      goto while_continue;
    }
#line 984
    if (opt->name) {
      {
#line 986
      __cil_tmp48 = strcmp(opt->name, "preview");
      }
#line 986
      if (__cil_tmp48 == 0) {
#line 986
        if ((unsigned int )opt->type == 0U) {
#line 989
          dialog___0->well_known.preview = i;
#line 990
          goto while_continue;
        } else {
#line 986
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        {
#line 992
        __cil_tmp49 = strcmp(opt->name, "resolution");
        }
#line 992
        if (__cil_tmp49 == 0) {
#line 992
          if ((unsigned int )opt->unit == 4U) {
#line 992
            if ((unsigned int )opt->type == 1U) {
#line 996
              dialog___0->well_known.dpi = i;
            } else
#line 992
            if ((unsigned int )opt->type == 2U) {
#line 996
              dialog___0->well_known.dpi = i;
            } else {
#line 992
              goto _L;
            }
          } else {
#line 992
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          _L___0: /* CIL Label */ 
          {
#line 997
          __cil_tmp50 = strcmp(opt->name, "tl-x");
          }
#line 997
          if (__cil_tmp50 == 0) {
#line 998
            dialog___0->well_known.coord[0] = i;
          } else {
            {
#line 999
            __cil_tmp51 = strcmp(opt->name, "tl-y");
            }
#line 999
            if (__cil_tmp51 == 0) {
#line 1000
              dialog___0->well_known.coord[1] = i;
            } else {
              {
#line 1001
              __cil_tmp52 = strcmp(opt->name, "br-x");
              }
#line 1001
              if (__cil_tmp52 == 0) {
#line 1002
                dialog___0->well_known.coord[2] = i;
              } else {
                {
#line 1003
                __cil_tmp53 = strcmp(opt->name, "br-y");
                }
#line 1003
                if (__cil_tmp53 == 0) {
#line 1004
                  dialog___0->well_known.coord[3] = i;
                }
              }
            }
          }
        }
      }
    }
#line 1007
    elem = dialog___0->element + i;
#line 1008
    elem->dialog = dialog___0;
#line 1010
    if ((unsigned int )opt->unit == 0U) {
      {
#line 1011
      strncpy((char *)title, opt->title, sizeof(title));
      }
    } else {
      {
#line 1013
      __cil_tmp54 = unit_string(opt->unit);
#line 1013
      snprintf((char *)title, sizeof(title), "%s [%s]", opt->title, __cil_tmp54);
      }
    }
    {
#line 1018
    if ((unsigned int )opt->type == (unsigned int )5) {
#line 1018
      goto case_5;
    }
#line 1027
    if ((unsigned int )opt->type == (unsigned int )0) {
#line 1027
      goto case_0;
    }
#line 1043
    if ((unsigned int )opt->type == (unsigned int )1) {
#line 1043
      goto case_1;
    }
#line 1060
    if ((unsigned int )opt->type == (unsigned int )1) {
#line 1060
      goto case_1___0;
    }
#line 1074
    if ((unsigned int )opt->type == (unsigned int )2) {
#line 1074
      goto case_2;
    }
#line 1102
    if ((unsigned int )opt->type == (unsigned int )0) {
#line 1102
      goto case_0___0;
    }
#line 1114
    if ((unsigned int )opt->type == (unsigned int )2) {
#line 1114
      goto case_2___0;
    }
#line 1131
    if ((unsigned int )opt->type == (unsigned int )1) {
#line 1131
      goto case_1___1;
    }
#line 1154
    if ((unsigned int )opt->type == (unsigned int )2) {
#line 1154
      goto case_2___1;
    }
#line 1173
    if ((unsigned int )opt->type == (unsigned int )0) {
#line 1173
      goto case_0___1;
    }
#line 1185
    if ((unsigned int )opt->type == (unsigned int )3) {
#line 1185
      goto case_3;
    }
#line 1201
    if ((unsigned int )opt->type == (unsigned int )3) {
#line 1201
      goto case_3___0;
    }
#line 1210
    if ((unsigned int )opt->type == (unsigned int )0) {
#line 1210
      goto case_0___2;
    }
#line 1225
    if ((unsigned int )opt->type == (unsigned int )4) {
#line 1225
      goto case_4;
    }
#line 1245
    goto switch_default___2;
    case_5: /* CIL Label */ 
#line 1020
    vbox = standard_vbox;
#line 1021
    if (opt->cap & (1 << 6)) {
#line 1022
      vbox = advanced_vbox;
    }
    {
#line 1023
    parent = group_new(vbox, (char const   *)((char *)title));
#line 1024
    elem->widget = parent;
    }
#line 1025
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1028
    if (opt->cap & (1 << 6)) {
#line 1028
      if (! dialog___0->advanced) {
#line 1029
        goto switch_break;
      }
    }
#line 1030
    if (! (opt->cap & (1 << 2))) {
#line 1031
      goto switch_break;
    }
    {
#line 1033
    status = sane_control_option(dialog___0->dev, i, (SANE_Action )0, & val, (SANE_Int *)0);
    }
#line 1035
    if ((unsigned int )status != 0U) {
#line 1036
      goto get_value_failed;
    }
    {
#line 1038
    button_new(parent, (char const   *)((char *)title), val, elem, dialog___0->tooltips,
               opt->desc, (opt->cap & 1) != 0);
#line 1040
    gtk_widget_show(parent->parent);
    }
#line 1041
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1044
    if (opt->cap & (1 << 6)) {
#line 1044
      if (! dialog___0->advanced) {
#line 1045
        goto switch_break;
      }
    }
#line 1046
    if (! (opt->cap & (1 << 2))) {
#line 1047
      goto switch_break;
    }
#line 1048
    if ((unsigned long )opt->size != sizeof(SANE_Word )) {
#line 1050
      __cil_tmp58 = num_vector_opts;
#line 1050
      num_vector_opts ++;
#line 1050
      *(vector_opts + __cil_tmp58) = i;
#line 1051
      goto switch_break;
    }
    {
#line 1053
    status = sane_control_option(dialog___0->dev, i, (SANE_Action )0, & val, (SANE_Int *)0);
    }
#line 1055
    if ((unsigned int )status != 0U) {
#line 1056
      goto get_value_failed;
    }
    {
#line 1060
    if ((unsigned int )opt->constraint_type == (unsigned int )1) {
#line 1060
      goto case_1___0;
    }
#line 1074
    if ((unsigned int )opt->constraint_type == (unsigned int )2) {
#line 1074
      goto case_2;
    }
#line 1102
    if ((unsigned int )opt->constraint_type == (unsigned int )0) {
#line 1102
      goto case_0___0;
    }
#line 1107
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 1062
    quant = (opt->constraint.range)->quant;
#line 1063
    if (quant == 0) {
#line 1064
      quant = 1;
    }
    {
#line 1065
    scale_new(parent, (char const   *)((char *)title), (gfloat )val, (gfloat )(opt->constraint.range)->min,
              (gfloat )(opt->constraint.range)->max, (gfloat )quant, opt->cap & (1 << 4),
              elem, dialog___0->tooltips, opt->desc, (opt->cap & 1) != 0);
#line 1071
    gtk_widget_show(parent->parent);
    }
#line 1072
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 1076
    num_words = *(opt->constraint.word_list + 0);
#line 1077
    if (num_words == 0) {
      {
#line 1079
      fprintf(stderr, "panel_build: empty word list!\n");
      }
#line 1080
      goto switch_break___0;
    }
    {
#line 1082
    val_in_list = 0;
#line 1083
    str_list = (char **)malloc((unsigned long )(num_words + 1) * sizeof(*(str_list + 0)));
#line 1084
    j = 0;
    }
    {
#line 1084
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1084
      if (! (j < num_words)) {
#line 1084
        goto while_break___0;
      }
#line 1086
      if (*(opt->constraint.word_list + (j + 1)) == val) {
#line 1087
        val_in_list = 1;
      }
      {
#line 1088
      sprintf((char *)str, "%d", *(opt->constraint.word_list + (j + 1)));
#line 1089
      *(str_list + j) = strdup((char const   *)((char *)str));
      }
#line 1084
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1091
    *(str_list + j) = (char *)0;
#line 1092
    if (! val_in_list) {
#line 1093
      val = *(opt->constraint.word_list + 1);
    }
    {
#line 1094
    sprintf((char *)str, "%d", val);
#line 1095
    option_menu_new(parent, (char const   *)((char *)title), str_list, (char const   *)((char *)str),
                    elem, dialog___0->tooltips, opt->desc, (opt->cap & 1) != 0);
#line 1098
    free(str_list);
#line 1099
    gtk_widget_show(parent->parent);
    }
#line 1100
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 1105
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 1108
    fprintf(stderr, "panel_build: unknown constraint %d!\n", (unsigned int )opt->constraint_type);
    }
#line 1110
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1112
    goto switch_break;
    case_2___0: /* CIL Label */ 
#line 1115
    if (opt->cap & (1 << 6)) {
#line 1115
      if (! dialog___0->advanced) {
#line 1116
        goto switch_break;
      }
    }
#line 1117
    if (! (opt->cap & (1 << 2))) {
#line 1118
      goto switch_break;
    }
#line 1119
    if ((unsigned long )opt->size != sizeof(SANE_Word )) {
#line 1121
      __cil_tmp62 = num_vector_opts;
#line 1121
      num_vector_opts ++;
#line 1121
      *(vector_opts + __cil_tmp62) = i;
#line 1122
      goto switch_break;
    }
    {
#line 1124
    status = sane_control_option(dialog___0->dev, i, (SANE_Action )0, & val, (SANE_Int *)0);
    }
#line 1126
    if ((unsigned int )status != 0U) {
#line 1127
      goto get_value_failed;
    }
    {
#line 1131
    if ((unsigned int )opt->constraint_type == (unsigned int )1) {
#line 1131
      goto case_1___1;
    }
#line 1154
    if ((unsigned int )opt->constraint_type == (unsigned int )2) {
#line 1154
      goto case_2___1;
    }
#line 1173
    if ((unsigned int )opt->constraint_type == (unsigned int )0) {
#line 1173
      goto case_0___1;
    }
#line 1178
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 1133
    quant = (opt->constraint.range)->quant;
#line 1134
    if (quant == 0) {
#line 1135
      quant = 1;
    }
#line 1136
    dval = (double )val / (double )(1 << 16);
#line 1137
    dmin = (double )(opt->constraint.range)->min / (double )(1 << 16);
#line 1138
    dmax = (double )(opt->constraint.range)->max / (double )(1 << 16);
#line 1139
    dquant = (double )quant / (double )(1 << 16);
#line 1140
    if ((unsigned int )opt->unit == 3U) {
#line 1142
      dval /= preferences.length_unit;
#line 1143
      dmin /= preferences.length_unit;
#line 1144
      dmax /= preferences.length_unit;
#line 1145
      dquant /= preferences.length_unit;
    }
    {
#line 1147
    scale_new(parent, (char const   *)((char *)title), (gfloat )dval, (gfloat )dmin,
              (gfloat )dmax, (gfloat )dquant, opt->cap & (1 << 4), elem, dialog___0->tooltips,
              opt->desc, (opt->cap & 1) != 0);
#line 1151
    gtk_widget_show(parent->parent);
    }
#line 1152
    goto switch_break___1;
    case_2___1: /* CIL Label */ 
#line 1156
    num_words = *(opt->constraint.word_list + 0);
    {
#line 1157
    str_list = (char **)malloc((unsigned long )(num_words + 1) * sizeof(*(str_list + 0)));
#line 1158
    j = 0;
    }
    {
#line 1158
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1158
      if (! (j < num_words)) {
#line 1158
        goto while_break___1;
      }
      {
#line 1160
      sprintf((char *)str, "%g", (double )*(opt->constraint.word_list + (j + 1)) / (double )(1 << 16));
#line 1162
      *(str_list + j) = strdup((char const   *)((char *)str));
      }
#line 1158
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1164
    *(str_list + j) = (char *)0;
#line 1165
    sprintf((char *)str, "%g", (double )val / (double )(1 << 16));
#line 1166
    option_menu_new(parent, (char const   *)((char *)title), str_list, (char const   *)((char *)str),
                    elem, dialog___0->tooltips, opt->desc, (opt->cap & 1) != 0);
#line 1169
    free(str_list);
#line 1170
    gtk_widget_show(parent->parent);
    }
#line 1171
    goto switch_break___1;
    case_0___1: /* CIL Label */ 
#line 1176
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 1179
    fprintf(stderr, "panel_build: unknown constraint %d!\n", (unsigned int )opt->constraint_type);
    }
#line 1181
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 1183
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1186
    if (opt->cap & (1 << 6)) {
#line 1186
      if (! dialog___0->advanced) {
#line 1187
        goto switch_break;
      }
    }
#line 1188
    if (! (opt->cap & (1 << 2))) {
#line 1189
      goto switch_break;
    }
    {
#line 1190
    buf = (char *)malloc((unsigned long )opt->size);
#line 1191
    status = sane_control_option(dialog___0->dev, i, (SANE_Action )0, buf, (SANE_Int *)0);
    }
#line 1193
    if ((unsigned int )status != 0U) {
      {
#line 1195
      free(buf);
      }
#line 1196
      goto get_value_failed;
    }
    {
#line 1201
    if ((unsigned int )opt->constraint_type == (unsigned int )3) {
#line 1201
      goto case_3___0;
    }
#line 1210
    if ((unsigned int )opt->constraint_type == (unsigned int )0) {
#line 1210
      goto case_0___2;
    }
#line 1217
    goto switch_default___1;
    case_3___0: /* CIL Label */ 
    {
#line 1203
    option_menu_new(parent, (char const   *)((char *)title), (char **)opt->constraint.string_list,
                    (char const   *)buf, elem, dialog___0->tooltips, opt->desc, (opt->cap & 1) != 0);
    }
    {
#line 1207
    gtk_widget_show(parent->parent);
    }
#line 1208
    goto switch_break___2;
    case_0___2: /* CIL Label */ 
    {
#line 1211
    text_entry_new(parent, (char const   *)((char *)title), (char const   *)buf, elem,
                   dialog___0->tooltips, opt->desc, (opt->cap & 1) != 0);
    }
    {
#line 1214
    gtk_widget_show(parent->parent);
    }
#line 1215
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
    {
#line 1218
    fprintf(stderr, "panel_build: unknown constraint %d!\n", (unsigned int )opt->constraint_type);
    }
#line 1220
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
    {
#line 1222
    free(buf);
    }
#line 1223
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1226
    if (opt->cap & (1 << 6)) {
#line 1226
      if (! dialog___0->advanced) {
#line 1227
        goto switch_break;
      }
    }
    {
#line 1228
    button = gtk_button_new();
#line 1229
    __cil_tmp69 = gtk_object_get_type();
#line 1229
    __cil_tmp70 = g_type_check_instance_cast((GTypeInstance *)button, __cil_tmp69);
#line 1229
    gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp70), (gchar *)"clicked",
                            (GtkSignalFunc )(& push_button_callback), (GtkCallbackMarshal )((void *)0),
                            elem, (GDestroyNotify )((void *)0), 0, 0);
#line 1231
    set_tooltip(dialog___0->tooltips, button, opt->desc);
#line 1233
    label = gtk_label_new((char *)title);
#line 1234
    __cil_tmp72 = gtk_container_get_type();
#line 1234
    __cil_tmp73 = g_type_check_instance_cast((GTypeInstance *)button, __cil_tmp72);
#line 1234
    gtk_container_add((GtkContainer *)((void *)__cil_tmp73), label);
#line 1236
    __cil_tmp74 = gtk_box_get_type();
#line 1236
    __cil_tmp75 = g_type_check_instance_cast((GTypeInstance *)parent, __cil_tmp74);
#line 1236
    gtk_box_pack_start((GtkBox *)((void *)__cil_tmp75), button, 0, ! 0, (guint )0);
#line 1238
    gtk_widget_show(label);
#line 1239
    gtk_widget_show(button);
#line 1241
    elem->widget = button;
#line 1242
    gtk_widget_show(parent->parent);
    }
#line 1243
    goto switch_break;
    switch_default___2: /* CIL Label */ 
    {
#line 1246
    fprintf(stderr, "panel_build: Unknown type %d\n", (unsigned int )opt->type);
    }
#line 1247
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1249
    goto while_continue;
    get_value_failed: 
    {
#line 1255
    __cil_tmp77 = sane_strstatus(status);
#line 1255
    sprintf((char *)msg, "Failed to obtain value of option %s: %s.\230\001", opt->name,
            __cil_tmp77);
#line 1257
    gsg_error((char *)msg);
    }
#line 978
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1263
  if (num_vector_opts) {
    {
#line 1264
    vector_new(dialog___0, main_hbox, num_vector_opts, vector_opts);
    }
  }
#line 1266
  if (dialog___0->advanced) {
    {
#line 1267
    gtk_widget_show(dialog___0->advanced_vbox);
    }
  } else {
    {
#line 1269
    gtk_widget_hide(dialog___0->advanced_vbox);
    }
  }
  {
#line 1270
  gtk_widget_show(main_hbox);
  }
  return;
}
}
#line 1279 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
static void panel_rebuild(GSGDialog *dialog___0 ) 
{ 


  {
  {
#line 1281
  panel_destroy(dialog___0);
#line 1282
  panel_build(dialog___0);
  }
  return;
}
}
#line 1286 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
GSGDialog *gsg_create_dialog(GtkWidget *window , char const   *device_name , GSGCallback option_reload_callback ,
                             void *option_reload_arg , GSGCallback param_change_callback ,
                             void *param_change_arg ) 
{ 
  SANE_Int num_elements ;
  GSGDialog *dialog___0 ;
  SANE_Status status ;
  SANE_Handle dev ;
  char buf[256] ;
  SANE_Status __cil_tmp12 ;
  SANE_String_Const __cil_tmp13 ;
  SANE_Status __cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  void *__cil_tmp17 ;

  {
  {
#line 1297
  status = sane_open(device_name, & dev);
  }
#line 1298
  if ((unsigned int )status != 0U) {
    {
#line 1300
    __cil_tmp13 = sane_strstatus(status);
#line 1300
    sprintf((char *)buf, "Failed to open device `%s\': %s.", device_name, __cil_tmp13);
#line 1302
    gsg_error((char *)buf);
    }
#line 1303
    return ((GSGDialog *)0);
  }
  {
#line 1306
  __cil_tmp14 = sane_control_option(dev, 0, (SANE_Action )0, & num_elements, (SANE_Int *)0);
  }
#line 1306
  if ((unsigned int )__cil_tmp14 != 0U) {
    {
#line 1309
    gsg_error("Error obtaining option count.");
#line 1310
    sane_close(dev);
    }
#line 1311
    return ((GSGDialog *)0);
  }
  {
#line 1314
  dialog___0 = (GSGDialog *)malloc(sizeof(*dialog___0));
#line 1315
  memset(dialog___0, 0, sizeof(*dialog___0));
#line 1317
  dialog___0->window = window;
#line 1318
  dialog___0->dev = dev;
#line 1319
  __cil_tmp16 = strdup(device_name);
#line 1319
  dialog___0->dev_name = (char const   *)__cil_tmp16;
#line 1320
  dialog___0->num_elements = num_elements;
#line 1321
  dialog___0->option_reload_callback = option_reload_callback;
#line 1322
  dialog___0->option_reload_arg = option_reload_arg;
#line 1323
  dialog___0->param_change_callback = param_change_callback;
#line 1324
  dialog___0->param_change_arg = param_change_arg;
#line 1325
  dialog___0->advanced = (u_int )preferences.advanced;
#line 1326
  dialog___0->twocolumn = preferences.twocolumn_enabled;
#line 1328
  dialog___0->element = (GSGDialogElement *)malloc((unsigned long )num_elements * sizeof(*(dialog___0->element + 0)));
#line 1329
  memset(dialog___0->element, 0, (unsigned long )num_elements * sizeof(*(dialog___0->element + 0)));
#line 1331
  panel_build(dialog___0);
  }
#line 1332
  return (dialog___0);
}
}
#line 1336 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
void gsg_refresh_dialog(GSGDialog *dialog___0 ) 
{ 


  {
  {
#line 1338
  panel_rebuild(dialog___0);
  }
#line 1339
  if (dialog___0->param_change_callback) {
    {
#line 1340
    (*(dialog___0->param_change_callback))(dialog___0, dialog___0->param_change_arg);
    }
  }
  return;
}
}
#line 1344 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
void gsg_update_scan_window(GSGDialog *dialog___0 ) 
{ 
  SANE_Option_Descriptor *opt ;
  double old_val ;
  double new_val ;
  GSGDialogElement *elem ;
  SANE_Status status ;
  SANE_Word word ;
  int i ;
  int optnum ;
  char str[64] ;
  SANE_Option_Descriptor *__cil_tmp11 ;
  SANE_Status __cil_tmp12 ;
  GType __cil_tmp13 ;
  GTypeInstance *__cil_tmp14 ;
  GType __cil_tmp15 ;
  GTypeInstance *__cil_tmp16 ;
  GType __cil_tmp17 ;
  GTypeInstance *__cil_tmp18 ;
  GType __cil_tmp19 ;
  GTypeInstance *__cil_tmp20 ;
  GType __cil_tmp21 ;
  GTypeInstance *__cil_tmp22 ;
  GType __cil_tmp23 ;
  GTypeInstance *__cil_tmp24 ;
  int __cil_tmp25 ;

  {
#line 1354
  i = 0;
  {
#line 1354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1354
    if (! (i < 4)) {
#line 1354
      goto while_break;
    }
#line 1355
    if (dialog___0->well_known.coord[i] > 0) {
      {
#line 1357
      optnum = dialog___0->well_known.coord[i];
#line 1358
      elem = dialog___0->element + optnum;
#line 1359
      opt = sane_get_option_descriptor(dialog___0->dev, optnum);
#line 1361
      status = sane_control_option(dialog___0->dev, optnum, (SANE_Action )0, & word,
                                   (SANE_Int *)0);
      }
#line 1363
      if ((unsigned int )status != 0U) {
#line 1364
        goto while_continue;
      }
      {
#line 1368
      if ((unsigned int )opt->constraint_type == (unsigned int )1) {
#line 1368
        goto case_1;
      }
#line 1388
      if ((unsigned int )opt->constraint_type == (unsigned int )2) {
#line 1388
        goto case_2;
      }
#line 1399
      goto switch_default;
      case_1: /* CIL Label */ 
#line 1369
      if ((unsigned int )opt->type == 1U) {
#line 1371
        old_val = ((GtkAdjustment *)((void *)__cil_tmp14))->value;
#line 1372
        new_val = (double )word;
#line 1373
        ((GtkAdjustment *)((void *)__cil_tmp16))->value = new_val;
      } else {
#line 1377
        old_val = ((GtkAdjustment *)((void *)__cil_tmp18))->value;
#line 1378
        new_val = (double )word / (double )(1 << 16);
#line 1379
        if ((unsigned int )opt->unit == 3U) {
#line 1380
          new_val /= preferences.length_unit;
        }
#line 1381
        ((GtkAdjustment *)((void *)__cil_tmp20))->value = new_val;
      }
#line 1383
      if (old_val != new_val) {
        {
#line 1384
        __cil_tmp21 = gtk_object_get_type();
#line 1384
        __cil_tmp22 = g_type_check_instance_cast((GTypeInstance *)elem->data, __cil_tmp21);
#line 1384
        gtk_signal_emit_by_name((GtkObject *)((void *)__cil_tmp22), (gchar *)"value_changed");
        }
      }
#line 1386
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1389
      if ((unsigned int )opt->type == 1U) {
        {
#line 1390
        sprintf((char *)str, "%d", word);
        }
      } else {
        {
#line 1392
        sprintf((char *)str, "%g", (double )word / (double )(1 << 16));
        }
      }
      {
#line 1394
      __cil_tmp23 = gtk_option_menu_get_type();
#line 1394
      __cil_tmp24 = g_type_check_instance_cast((GTypeInstance *)elem->widget, __cil_tmp23);
      }
      {
#line 1394
      __cil_tmp25 = option_menu_lookup(elem->menu, (char const   *)((char *)str));
#line 1394
      gtk_option_menu_set_history((GtkOptionMenu *)((void *)__cil_tmp24), (guint )__cil_tmp25);
      }
#line 1397
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1400
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 1354
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1409 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
void gsg_sync(GSGDialog *dialog___0 ) 
{ 
  SANE_Option_Descriptor *opt ;
  gfloat val ;
  gfloat *vector ;
  SANE_Word *optval ;
  int i ;
  int j ;
  int optlen ;
  GtkWidget *curve ;
  SANE_Option_Descriptor *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  GType __cil_tmp13 ;
  GTypeInstance *__cil_tmp14 ;
  GType __cil_tmp15 ;
  GTypeInstance *__cil_tmp16 ;

  {
#line 1417
  i = 1;
  {
#line 1417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1417
    if (! (i < dialog___0->num_elements)) {
#line 1417
      goto while_break;
    }
    {
#line 1419
    opt = sane_get_option_descriptor(dialog___0->dev, i);
    }
#line 1420
    if (! ((opt->cap & (1 << 5)) == 0)) {
#line 1421
      goto while_continue;
    }
#line 1423
    if ((unsigned int )opt->type != 1U) {
#line 1423
      if ((unsigned int )opt->type != 2U) {
#line 1424
        goto while_continue;
      }
    }
#line 1426
    if ((unsigned long )opt->size == sizeof(SANE_Word )) {
#line 1427
      goto while_continue;
    }
    {
#line 1431
    optlen = (int )((unsigned long )opt->size / sizeof(SANE_Word ));
#line 1432
    optval = (SANE_Word *)__builtin_alloca((unsigned long )optlen * sizeof(*(optval + 0)));
#line 1433
    vector = (gfloat *)__builtin_alloca((unsigned long )optlen * sizeof(*(vector + 0)));
#line 1435
    curve = ((GtkGammaCurve *)((void *)__cil_tmp14))->curve;
#line 1436
    __cil_tmp15 = gtk_curve_get_type();
#line 1436
    __cil_tmp16 = g_type_check_instance_cast((GTypeInstance *)curve, __cil_tmp15);
#line 1436
    gtk_curve_get_vector((GtkCurve *)((void *)__cil_tmp16), optlen, vector);
#line 1437
    j = 0;
    }
    {
#line 1437
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1437
      if (! (j < optlen)) {
#line 1437
        goto while_break___0;
      }
#line 1439
      val = *(vector + j);
#line 1440
      if ((unsigned int )opt->type == 2U) {
#line 1441
        *(optval + j) = (SANE_Word )(val * (float )(1 << 16));
      } else {
#line 1443
        *(optval + j) = (SANE_Word )((double )val + 0.5);
      }
#line 1437
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1446
    set_option(dialog___0, i, optval, (SANE_Action )1);
    }
#line 1417
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1451 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
void gsg_set_advanced(GSGDialog *dialog___0 , int advanced ) 
{ 


  {
  {
#line 1453
  dialog___0->advanced = (u_int )advanced;
#line 1454
  panel_rebuild(dialog___0);
  }
  return;
}
}
#line 1458 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
void gsg_set_tooltips(GSGDialog *dialog___0 , int enable ) 
{ 


  {
#line 1460
  if (! dialog___0->tooltips) {
#line 1461
    return;
  }
#line 1463
  if (enable) {
    {
#line 1464
    gtk_tooltips_enable(dialog___0->tooltips);
    }
  } else {
    {
#line 1466
    gtk_tooltips_disable(dialog___0->tooltips);
    }
  }
  return;
}
}
#line 1470 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
void gsg_set_twocolumn(GSGDialog *dialog___0 , int twocolumn ) 
{ 


  {
  {
#line 1472
  dialog___0->twocolumn = twocolumn;
#line 1473
  panel_rebuild(dialog___0);
  }
  return;
}
}
#line 1477 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
void gsg_set_sensitivity(GSGDialog *dialog___0 , int sensitive ) 
{ 
  SANE_Option_Descriptor *opt ;
  int i ;
  SANE_Option_Descriptor *__cil_tmp5 ;

  {
#line 1482
  i = 0;
  {
#line 1482
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1482
    if (! (i < dialog___0->num_elements)) {
#line 1482
      goto while_break;
    }
    {
#line 1484
    opt = sane_get_option_descriptor(dialog___0->dev, i);
    }
#line 1486
    if (! (dialog___0->element + i)->widget) {
#line 1488
      goto while_continue;
    } else
#line 1486
    if (! ((opt->cap & (1 << 5)) == 0)) {
#line 1488
      goto while_continue;
    } else
#line 1486
    if ((unsigned int )opt->type == 5U) {
#line 1488
      goto while_continue;
    }
    {
#line 1490
    gtk_widget_set_sensitive((dialog___0->element + i)->widget, sensitive);
    }
#line 1482
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1495 "/root/oss-experiment/data/sane-frontends-1.0.14/src/gtkglue.c"
void gsg_destroy_dialog(GSGDialog *dialog___0 ) 
{ 
  SANE_Handle dev ;

  {
  {
#line 1497
  dev = dialog___0->dev;
#line 1499
  panel_destroy(dialog___0);
#line 1500
  free((void *)dialog___0->dev_name);
#line 1501
  free(dialog___0->element);
#line 1502
  free(dialog___0);
#line 1504
  sane_close(dev);
  }
  return;
}
}
#line 35 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preferences.c"
Preferences preferences  = 
#line 35 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preferences.c"
     {(char const   *)0, (char const   *)0, 0, 1, 1, 10., 1, 0, 1.};
#line 48
static void w_string(Wire *w , Preferences *p , long offset ) ;
#line 49
static void w_double(Wire *w , Preferences *p , long offset ) ;
#line 50
static void w_int(Wire *w , Preferences *p , long offset ) ;
#line 58 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preferences.c"
static struct __anonstruct_647 desc[9]  = 
#line 58
  {      {"device", & w_string, (char *)(& ((Preferences *)0)->device) - (char *)0}, 
        {"filename\230", & w_string, (char *)(& ((Preferences *)0)->filename) - (char *)0}, 
        {"advanced\230",
      & w_int, (char *)(& ((Preferences *)0)->advanced) - (char *)0}, 
        {"tool-tips", & w_int, (char *)(& ((Preferences *)0)->tooltips_enabled) - (char *)0}, 
        {"twocolumn",
      & w_int, (char *)(& ((Preferences *)0)->twocolumn_enabled) - (char *)0}, 
        {"length-unit", & w_double, (char *)(& ((Preferences *)0)->length_unit) - (char *)0}, 
        {"preserve-preview\230",
      & w_int, (char *)(& ((Preferences *)0)->preserve_preview) - (char *)0}, 
        {"preview-own-cmap\230", & w_int, (char *)(& ((Preferences *)0)->preview_own_cmap) - (char *)0}, 
        {"preview-gamma",
      & w_double, (char *)(& ((Preferences *)0)->preview_gamma) - (char *)0}};
#line 72 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preferences.c"
static void w_string(Wire *w , Preferences *p , long offset ) 
{ 
  SANE_String string ;
  char const   **field ;
  char *__cil_tmp6 ;
  char *tmp ;

  {
#line 76
  if ((unsigned int )w->direction == 0U) {
#line 77
    string = *((char **)((char *)p + offset));
  }
  {
#line 79
  sanei_w_string(w, & string);
  }
#line 81
  if ((unsigned int )w->direction == 1U) {
#line 83
    if (w->status == 0) {
#line 87
      field = (char const   **)((char *)p + offset);
#line 88
      if (*field) {
        {
#line 89
        free((char *)*field);
        }
      }
#line 90
      if (string) {
        {
#line 90
        __cil_tmp6 = strdup((char const   *)string);
#line 90
        tmp = __cil_tmp6;
        }
      } else {
#line 90
        tmp = (char *)0;
      }
#line 90
      *field = (char const   *)tmp;
    }
    {
#line 92
    sanei_w_free(w, (WireCodecFunc )(& sanei_w_string), & string);
    }
  }
  return;
}
}
#line 97 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preferences.c"
static void w_double(Wire *w , Preferences *p , long offset ) 
{ 
  SANE_Word word ;

  {
#line 101
  if ((unsigned int )w->direction == 0U) {
#line 102
    word = (SANE_Word )(*((double *)((char *)p + offset)) * (double )(1 << 16));
  }
  {
#line 104
  sanei_w_word(w, & word);
  }
#line 106
  if ((unsigned int )w->direction == 1U) {
#line 108
    if (w->status == 0) {
#line 109
      *((double *)((char *)p + offset)) = (double )word / (double )(1 << 16);
    }
    {
#line 110
    sanei_w_free(w, (WireCodecFunc )(& sanei_w_word), & word);
    }
  }
  return;
}
}
#line 115 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preferences.c"
static void w_int(Wire *w , Preferences *p , long offset ) 
{ 
  SANE_Word word ;

  {
#line 119
  if ((unsigned int )w->direction == 0U) {
#line 120
    word = *((int *)((char *)p + offset));
  }
  {
#line 122
  sanei_w_word(w, & word);
  }
#line 124
  if ((unsigned int )w->direction == 1U) {
#line 126
    if (w->status == 0) {
#line 127
      *((int *)((char *)p + offset)) = word;
    }
    {
#line 128
    sanei_w_free(w, (WireCodecFunc )(& sanei_w_word), & word);
    }
  }
  return;
}
}
#line 133 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preferences.c"
void preferences_save(int fd ) 
{ 
  Wire w ;
  int i ;

  {
  {
#line 138
  w.io.fd = fd;
#line 139
  w.io.read = & read;
#line 140
  w.io.write = & write;
#line 141
  sanei_w_init(& w, & sanei_codec_ascii_init);
#line 142
  sanei_w_set_dir(& w, (WireDirection )0);
#line 144
  i = 0;
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (i < (int )(sizeof(desc) / sizeof(desc[0])))) {
#line 144
      goto while_break;
    }
    {
#line 146
    sanei_w_string(& w, & desc[i].name);
#line 147
    (*(desc[i].codec))(& w, & preferences, desc[i].offset);
    }
#line 144
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 150
  sanei_w_set_dir(& w, (WireDirection )1);
  }
  return;
}
}
#line 154 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preferences.c"
void preferences_restore(int fd ) 
{ 
  SANE_String name ;
  Wire w ;
  int i ;
  int __cil_tmp5 ;

  {
  {
#line 160
  w.io.fd = fd;
#line 161
  w.io.read = & read;
#line 162
  w.io.write = & write;
#line 163
  sanei_w_init(& w, & sanei_codec_ascii_init);
#line 164
  sanei_w_set_dir(& w, (WireDirection )1);
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 168
    sanei_w_space(& w, (size_t )3);
    }
#line 169
    if (w.status) {
#line 170
      return;
    }
    {
#line 172
    sanei_w_string(& w, & name);
    }
#line 173
    if (! name) {
#line 174
      return;
    } else
#line 173
    if (w.status) {
#line 174
      return;
    }
#line 176
    i = 0;
    {
#line 176
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 176
      if (! (i < (int )(sizeof(desc) / sizeof(desc[0])))) {
#line 176
        goto while_break___0;
      }
      {
#line 178
      __cil_tmp5 = strcmp((char const   *)name, (char const   *)desc[i].name);
      }
#line 178
      if (__cil_tmp5 == 0) {
        {
#line 180
        (*(desc[i].codec))(& w, & preferences, desc[i].offset);
        }
#line 181
        goto while_break___0;
      }
#line 176
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassify(double __value ) ;
#line 24
extern  __attribute__((__nothrow__)) int __signbit(double __value ) ;
#line 29
extern  __attribute__((__nothrow__)) int __isinf(double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finite(double __value ) ;
#line 37
extern  __attribute__((__nothrow__)) int __isnan(double __value ) ;
#line 41
extern  __attribute__((__nothrow__)) int __iseqsig(double __x , double __y ) ;
#line 44
extern  __attribute__((__nothrow__)) int __issignaling(double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) double __acos(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double asin(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double __asin(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double __atan(double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double __atan2(double __y , double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double __cos(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double __sin(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double __tan(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double cosh(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double __cosh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double sinh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double __sinh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double __tanh(double __x ) ;
#line 79
extern  __attribute__((__nothrow__)) void sincos(double __x , double *__sinx , double *__cosx ) ;
#line 79
extern  __attribute__((__nothrow__)) void __sincos(double __x , double *__sinx , double *__cosx ) ;
#line 85
extern  __attribute__((__nothrow__)) double acosh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double __acosh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double asinh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double __asinh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double atanh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double __atanh(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double __exp(double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) double __frexp(double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double __ldexp(double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) double __log(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double __log10(double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) double modf(double __x , double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) double __modf(double __x , double *__iptr ) ;
#line 114
extern  __attribute__((__nothrow__)) double exp10(double __x ) ;
#line 114
extern  __attribute__((__nothrow__)) double __exp10(double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) double expm1(double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) double __expm1(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double log1p(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double __log1p(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double logb(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double __logb(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double exp2(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double __exp2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double log2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double __log2(double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) double __pow(double __x , double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) double __sqrt(double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) double hypot(double __x , double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) double __hypot(double __x , double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) double cbrt(double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) double __cbrt(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double ceil(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double __ceil(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double fabs(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double __fabs(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double __floor(double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) double __fmod(double __x , double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinf(double __value ) ;
#line 183
extern  __attribute__((__nothrow__)) int finite(double __value ) ;
#line 187
extern  __attribute__((__nothrow__)) double drem(double __x , double __y ) ;
#line 187
extern  __attribute__((__nothrow__)) double __drem(double __x , double __y ) ;
#line 191
extern  __attribute__((__nothrow__)) double significand(double __x ) ;
#line 191
extern  __attribute__((__nothrow__)) double __significand(double __x ) ;
#line 198
extern  __attribute__((__nothrow__)) double copysign(double __x , double __y ) ;
#line 198
extern  __attribute__((__nothrow__)) double __copysign(double __x , double __y ) ;
#line 203
extern  __attribute__((__nothrow__)) double nan(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) double __nan(char const   *__tagb ) ;
#line 213
extern  __attribute__((__nothrow__)) int isnan(double __value ) ;
#line 220
extern  __attribute__((__nothrow__)) double j0(double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double __j0(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double j1(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double __j1(double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double jn(int  , double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double __jn(int  , double  ) ;
#line 223
extern  __attribute__((__nothrow__)) double y0(double  ) ;
#line 223
extern  __attribute__((__nothrow__)) double __y0(double  ) ;
#line 224
extern  __attribute__((__nothrow__)) double y1(double  ) ;
#line 224
extern  __attribute__((__nothrow__)) double __y1(double  ) ;
#line 225
extern  __attribute__((__nothrow__)) double yn(int  , double  ) ;
#line 225
extern  __attribute__((__nothrow__)) double __yn(int  , double  ) ;
#line 231
extern  __attribute__((__nothrow__)) double erf(double  ) ;
#line 231
extern  __attribute__((__nothrow__)) double __erf(double  ) ;
#line 232
extern  __attribute__((__nothrow__)) double erfc(double  ) ;
#line 232
extern  __attribute__((__nothrow__)) double __erfc(double  ) ;
#line 233
extern  __attribute__((__nothrow__)) double lgamma(double  ) ;
#line 233
extern  __attribute__((__nothrow__)) double __lgamma(double  ) ;
#line 238
extern  __attribute__((__nothrow__)) double tgamma(double  ) ;
#line 238
extern  __attribute__((__nothrow__)) double __tgamma(double  ) ;
#line 244
extern  __attribute__((__nothrow__)) double gamma(double  ) ;
#line 244
extern  __attribute__((__nothrow__)) double __gamma(double  ) ;
#line 252
extern  __attribute__((__nothrow__)) double lgamma_r(double  , int *__signgamp ) ;
#line 252
extern  __attribute__((__nothrow__)) double __lgamma_r(double  , int *__signgamp ) ;
#line 259
extern  __attribute__((__nothrow__)) double rint(double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) double __rint(double __x ) ;
#line 262
extern  __attribute__((__nothrow__)) double nextafter(double __x , double __y ) ;
#line 262
extern  __attribute__((__nothrow__)) double __nextafter(double __x , double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) double nexttoward(double __x , long double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) double __nexttoward(double __x , long double __y ) ;
#line 269
extern  __attribute__((__nothrow__)) double nextdown(double __x ) ;
#line 269
extern  __attribute__((__nothrow__)) double __nextdown(double __x ) ;
#line 271
extern  __attribute__((__nothrow__)) double nextup(double __x ) ;
#line 271
extern  __attribute__((__nothrow__)) double __nextup(double __x ) ;
#line 275
extern  __attribute__((__nothrow__)) double remainder(double __x , double __y ) ;
#line 275
extern  __attribute__((__nothrow__)) double __remainder(double __x , double __y ) ;
#line 279
extern  __attribute__((__nothrow__)) double scalbn(double __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) double __scalbn(double __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogb(double __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogb(double __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long llogb(double __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long __llogb(double __x ) ;
#line 293
extern  __attribute__((__nothrow__)) double scalbln(double __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) double __scalbln(double __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) double nearbyint(double __x ) ;
#line 297
extern  __attribute__((__nothrow__)) double __nearbyint(double __x ) ;
#line 301
extern  __attribute__((__nothrow__)) double round(double __x ) ;
#line 301
extern  __attribute__((__nothrow__)) double __round(double __x ) ;
#line 305
extern  __attribute__((__nothrow__)) double trunc(double __x ) ;
#line 305
extern  __attribute__((__nothrow__)) double __trunc(double __x ) ;
#line 310
extern  __attribute__((__nothrow__)) double remquo(double __x , double __y , int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) double __remquo(double __x , double __y , int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrint(double __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrint(double __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrint(double __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrint(double __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lround(double __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lround(double __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llround(double __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llround(double __x ) ;
#line 329
extern  __attribute__((__nothrow__)) double fdim(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double __fdim(double __x , double __y ) ;
#line 333
extern  __attribute__((__nothrow__)) double fmax(double __x , double __y ) ;
#line 333
extern  __attribute__((__nothrow__)) double __fmax(double __x , double __y ) ;
#line 336
extern  __attribute__((__nothrow__)) double fmin(double __x , double __y ) ;
#line 336
extern  __attribute__((__nothrow__)) double __fmin(double __x , double __y ) ;
#line 340
extern  __attribute__((__nothrow__)) double fma(double __x , double __y , double __z ) ;
#line 340
extern  __attribute__((__nothrow__)) double __fma(double __x , double __y , double __z ) ;
#line 345
extern  __attribute__((__nothrow__)) double roundeven(double __x ) ;
#line 345
extern  __attribute__((__nothrow__)) double __roundeven(double __x ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t fromfp(double __x , int __round ,
                                                       unsigned int __width ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t __fromfp(double __x , int __round ,
                                                         unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t ufromfp(double __x , int __round ,
                                                         unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfp(double __x , int __round ,
                                                           unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t fromfpx(double __x , int __round ,
                                                        unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t __fromfpx(double __x , int __round ,
                                                          unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpx(double __x , int __round ,
                                                          unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpx(double __x , int __round ,
                                                            unsigned int __width ) ;
#line 370
extern  __attribute__((__nothrow__)) int canonicalize(double *__cx , double const   *__x ) ;
#line 377
extern  __attribute__((__nothrow__)) double fmaxmag(double __x , double __y ) ;
#line 377
extern  __attribute__((__nothrow__)) double __fmaxmag(double __x , double __y ) ;
#line 380
extern  __attribute__((__nothrow__)) double fminmag(double __x , double __y ) ;
#line 380
extern  __attribute__((__nothrow__)) double __fminmag(double __x , double __y ) ;
#line 385
extern  __attribute__((__nothrow__)) double fmaximum(double __x , double __y ) ;
#line 385
extern  __attribute__((__nothrow__)) double __fmaximum(double __x , double __y ) ;
#line 388
extern  __attribute__((__nothrow__)) double fminimum(double __x , double __y ) ;
#line 388
extern  __attribute__((__nothrow__)) double __fminimum(double __x , double __y ) ;
#line 391
extern  __attribute__((__nothrow__)) double fmaximum_num(double __x , double __y ) ;
#line 391
extern  __attribute__((__nothrow__)) double __fmaximum_num(double __x , double __y ) ;
#line 394
extern  __attribute__((__nothrow__)) double fminimum_num(double __x , double __y ) ;
#line 394
extern  __attribute__((__nothrow__)) double __fminimum_num(double __x , double __y ) ;
#line 397
extern  __attribute__((__nothrow__)) double fmaximum_mag(double __x , double __y ) ;
#line 397
extern  __attribute__((__nothrow__)) double __fmaximum_mag(double __x , double __y ) ;
#line 400
extern  __attribute__((__nothrow__)) double fminimum_mag(double __x , double __y ) ;
#line 400
extern  __attribute__((__nothrow__)) double __fminimum_mag(double __x , double __y ) ;
#line 403
extern  __attribute__((__nothrow__)) double fmaximum_mag_num(double __x , double __y ) ;
#line 403
extern  __attribute__((__nothrow__)) double __fmaximum_mag_num(double __x , double __y ) ;
#line 406
extern  __attribute__((__nothrow__)) double fminimum_mag_num(double __x , double __y ) ;
#line 406
extern  __attribute__((__nothrow__)) double __fminimum_mag_num(double __x , double __y ) ;
#line 411
extern  __attribute__((__nothrow__)) int totalorder(double const   *__x , double const   *__y ) ;
#line 416
extern  __attribute__((__nothrow__)) int totalordermag(double const   *__x , double const   *__y ) ;
#line 421
extern  __attribute__((__nothrow__)) double getpayload(double const   *__x ) ;
#line 421
extern  __attribute__((__nothrow__)) double __getpayload(double const   *__x ) ;
#line 424
extern  __attribute__((__nothrow__)) int setpayload(double *__x , double __payload ) ;
#line 427
extern  __attribute__((__nothrow__)) int setpayloadsig(double *__x , double __payload ) ;
#line 435
extern  __attribute__((__nothrow__)) double scalb(double __x , double __n ) ;
#line 435
extern  __attribute__((__nothrow__)) double __scalb(double __x , double __n ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf(float __value ) ;
#line 24
extern  __attribute__((__nothrow__)) int __signbitf(float __value ) ;
#line 29
extern  __attribute__((__nothrow__)) int __isinff(float __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef(float __value ) ;
#line 37
extern  __attribute__((__nothrow__)) int __isnanf(float __value ) ;
#line 41
extern  __attribute__((__nothrow__)) int __iseqsigf(float __x , float __y ) ;
#line 44
extern  __attribute__((__nothrow__)) int __issignalingf(float __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) float acosf(float __x ) ;
#line 53
extern  __attribute__((__nothrow__)) float __acosf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float asinf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float __asinf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float atanf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float __atanf(float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float atan2f(float __y , float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float __atan2f(float __y , float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float cosf(float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float __cosf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float sinf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float __sinf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float tanf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float __tanf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float coshf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float __coshf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float sinhf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float __sinhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float tanhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float __tanhf(float __x ) ;
#line 79
extern  __attribute__((__nothrow__)) void sincosf(float __x , float *__sinx , float *__cosx ) ;
#line 79
extern  __attribute__((__nothrow__)) void __sincosf(float __x , float *__sinx , float *__cosx ) ;
#line 85
extern  __attribute__((__nothrow__)) float acoshf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float __acoshf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float asinhf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float __asinhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float atanhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float __atanhf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float expf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float __expf(float __x ) ;
#line 98
extern  __attribute__((__nothrow__)) float frexpf(float __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) float __frexpf(float __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float ldexpf(float __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float __ldexpf(float __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) float logf(float __x ) ;
#line 104
extern  __attribute__((__nothrow__)) float __logf(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float log10f(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float __log10f(float __x ) ;
#line 110
extern  __attribute__((__nothrow__)) float modff(float __x , float *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) float __modff(float __x , float *__iptr ) ;
#line 114
extern  __attribute__((__nothrow__)) float exp10f(float __x ) ;
#line 114
extern  __attribute__((__nothrow__)) float __exp10f(float __x ) ;
#line 119
extern  __attribute__((__nothrow__)) float expm1f(float __x ) ;
#line 119
extern  __attribute__((__nothrow__)) float __expm1f(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float log1pf(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float __log1pf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float logbf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float __logbf(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float exp2f(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float __exp2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float log2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float __log2f(float __x ) ;
#line 140
extern  __attribute__((__nothrow__)) float powf(float __x , float __y ) ;
#line 140
extern  __attribute__((__nothrow__)) float __powf(float __x , float __y ) ;
#line 143
extern  __attribute__((__nothrow__)) float sqrtf(float __x ) ;
#line 143
extern  __attribute__((__nothrow__)) float __sqrtf(float __x ) ;
#line 147
extern  __attribute__((__nothrow__)) float hypotf(float __x , float __y ) ;
#line 147
extern  __attribute__((__nothrow__)) float __hypotf(float __x , float __y ) ;
#line 152
extern  __attribute__((__nothrow__)) float cbrtf(float __x ) ;
#line 152
extern  __attribute__((__nothrow__)) float __cbrtf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float ceilf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float __ceilf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float fabsf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float __fabsf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float floorf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float __floorf(float __x ) ;
#line 168
extern  __attribute__((__nothrow__)) float fmodf(float __x , float __y ) ;
#line 168
extern  __attribute__((__nothrow__)) float __fmodf(float __x , float __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinff(float __value ) ;
#line 183
extern  __attribute__((__nothrow__)) int finitef(float __value ) ;
#line 187
extern  __attribute__((__nothrow__)) float dremf(float __x , float __y ) ;
#line 187
extern  __attribute__((__nothrow__)) float __dremf(float __x , float __y ) ;
#line 191
extern  __attribute__((__nothrow__)) float significandf(float __x ) ;
#line 191
extern  __attribute__((__nothrow__)) float __significandf(float __x ) ;
#line 198
extern  __attribute__((__nothrow__)) float copysignf(float __x , float __y ) ;
#line 198
extern  __attribute__((__nothrow__)) float __copysignf(float __x , float __y ) ;
#line 203
extern  __attribute__((__nothrow__)) float nanf(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) float __nanf(char const   *__tagb ) ;
#line 213
extern  __attribute__((__nothrow__)) int isnanf(float __value ) ;
#line 220
extern  __attribute__((__nothrow__)) float j0f(float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float __j0f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float j1f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float __j1f(float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float jnf(int  , float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float __jnf(int  , float  ) ;
#line 223
extern  __attribute__((__nothrow__)) float y0f(float  ) ;
#line 223
extern  __attribute__((__nothrow__)) float __y0f(float  ) ;
#line 224
extern  __attribute__((__nothrow__)) float y1f(float  ) ;
#line 224
extern  __attribute__((__nothrow__)) float __y1f(float  ) ;
#line 225
extern  __attribute__((__nothrow__)) float ynf(int  , float  ) ;
#line 225
extern  __attribute__((__nothrow__)) float __ynf(int  , float  ) ;
#line 231
extern  __attribute__((__nothrow__)) float erff(float  ) ;
#line 231
extern  __attribute__((__nothrow__)) float __erff(float  ) ;
#line 232
extern  __attribute__((__nothrow__)) float erfcf(float  ) ;
#line 232
extern  __attribute__((__nothrow__)) float __erfcf(float  ) ;
#line 233
extern  __attribute__((__nothrow__)) float lgammaf(float  ) ;
#line 233
extern  __attribute__((__nothrow__)) float __lgammaf(float  ) ;
#line 238
extern  __attribute__((__nothrow__)) float tgammaf(float  ) ;
#line 238
extern  __attribute__((__nothrow__)) float __tgammaf(float  ) ;
#line 244
extern  __attribute__((__nothrow__)) float gammaf(float  ) ;
#line 244
extern  __attribute__((__nothrow__)) float __gammaf(float  ) ;
#line 252
extern  __attribute__((__nothrow__)) float lgammaf_r(float  , int *__signgamp ) ;
#line 252
extern  __attribute__((__nothrow__)) float __lgammaf_r(float  , int *__signgamp ) ;
#line 259
extern  __attribute__((__nothrow__)) float rintf(float __x ) ;
#line 259
extern  __attribute__((__nothrow__)) float __rintf(float __x ) ;
#line 262
extern  __attribute__((__nothrow__)) float nextafterf(float __x , float __y ) ;
#line 262
extern  __attribute__((__nothrow__)) float __nextafterf(float __x , float __y ) ;
#line 264
extern  __attribute__((__nothrow__)) float nexttowardf(float __x , long double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) float __nexttowardf(float __x , long double __y ) ;
#line 269
extern  __attribute__((__nothrow__)) float nextdownf(float __x ) ;
#line 269
extern  __attribute__((__nothrow__)) float __nextdownf(float __x ) ;
#line 271
extern  __attribute__((__nothrow__)) float nextupf(float __x ) ;
#line 271
extern  __attribute__((__nothrow__)) float __nextupf(float __x ) ;
#line 275
extern  __attribute__((__nothrow__)) float remainderf(float __x , float __y ) ;
#line 275
extern  __attribute__((__nothrow__)) float __remainderf(float __x , float __y ) ;
#line 279
extern  __attribute__((__nothrow__)) float scalbnf(float __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) float __scalbnf(float __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogbf(float __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogbf(float __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long llogbf(float __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long __llogbf(float __x ) ;
#line 293
extern  __attribute__((__nothrow__)) float scalblnf(float __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) float __scalblnf(float __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) float nearbyintf(float __x ) ;
#line 297
extern  __attribute__((__nothrow__)) float __nearbyintf(float __x ) ;
#line 301
extern  __attribute__((__nothrow__)) float roundf(float __x ) ;
#line 301
extern  __attribute__((__nothrow__)) float __roundf(float __x ) ;
#line 305
extern  __attribute__((__nothrow__)) float truncf(float __x ) ;
#line 305
extern  __attribute__((__nothrow__)) float __truncf(float __x ) ;
#line 310
extern  __attribute__((__nothrow__)) float remquof(float __x , float __y , int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) float __remquof(float __x , float __y , int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrintf(float __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrintf(float __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrintf(float __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lroundf(float __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lroundf(float __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llroundf(float __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llroundf(float __x ) ;
#line 329
extern  __attribute__((__nothrow__)) float fdimf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float __fdimf(float __x , float __y ) ;
#line 333
extern  __attribute__((__nothrow__)) float fmaxf(float __x , float __y ) ;
#line 333
extern  __attribute__((__nothrow__)) float __fmaxf(float __x , float __y ) ;
#line 336
extern  __attribute__((__nothrow__)) float fminf(float __x , float __y ) ;
#line 336
extern  __attribute__((__nothrow__)) float __fminf(float __x , float __y ) ;
#line 340
extern  __attribute__((__nothrow__)) float fmaf(float __x , float __y , float __z ) ;
#line 340
extern  __attribute__((__nothrow__)) float __fmaf(float __x , float __y , float __z ) ;
#line 345
extern  __attribute__((__nothrow__)) float roundevenf(float __x ) ;
#line 345
extern  __attribute__((__nothrow__)) float __roundevenf(float __x ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t fromfpf(float __x , int __round ,
                                                        unsigned int __width ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t __fromfpf(float __x , int __round ,
                                                          unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpf(float __x , int __round ,
                                                          unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpf(float __x , int __round ,
                                                            unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t fromfpxf(float __x , int __round ,
                                                         unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t __fromfpxf(float __x , int __round ,
                                                           unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpxf(float __x , int __round ,
                                                           unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpxf(float __x , int __round ,
                                                             unsigned int __width ) ;
#line 370
extern  __attribute__((__nothrow__)) int canonicalizef(float *__cx , float const   *__x ) ;
#line 377
extern  __attribute__((__nothrow__)) float fmaxmagf(float __x , float __y ) ;
#line 377
extern  __attribute__((__nothrow__)) float __fmaxmagf(float __x , float __y ) ;
#line 380
extern  __attribute__((__nothrow__)) float fminmagf(float __x , float __y ) ;
#line 380
extern  __attribute__((__nothrow__)) float __fminmagf(float __x , float __y ) ;
#line 385
extern  __attribute__((__nothrow__)) float fmaximumf(float __x , float __y ) ;
#line 385
extern  __attribute__((__nothrow__)) float __fmaximumf(float __x , float __y ) ;
#line 388
extern  __attribute__((__nothrow__)) float fminimumf(float __x , float __y ) ;
#line 388
extern  __attribute__((__nothrow__)) float __fminimumf(float __x , float __y ) ;
#line 391
extern  __attribute__((__nothrow__)) float fmaximum_numf(float __x , float __y ) ;
#line 391
extern  __attribute__((__nothrow__)) float __fmaximum_numf(float __x , float __y ) ;
#line 394
extern  __attribute__((__nothrow__)) float fminimum_numf(float __x , float __y ) ;
#line 394
extern  __attribute__((__nothrow__)) float __fminimum_numf(float __x , float __y ) ;
#line 397
extern  __attribute__((__nothrow__)) float fmaximum_magf(float __x , float __y ) ;
#line 397
extern  __attribute__((__nothrow__)) float __fmaximum_magf(float __x , float __y ) ;
#line 400
extern  __attribute__((__nothrow__)) float fminimum_magf(float __x , float __y ) ;
#line 400
extern  __attribute__((__nothrow__)) float __fminimum_magf(float __x , float __y ) ;
#line 403
extern  __attribute__((__nothrow__)) float fmaximum_mag_numf(float __x , float __y ) ;
#line 403
extern  __attribute__((__nothrow__)) float __fmaximum_mag_numf(float __x , float __y ) ;
#line 406
extern  __attribute__((__nothrow__)) float fminimum_mag_numf(float __x , float __y ) ;
#line 406
extern  __attribute__((__nothrow__)) float __fminimum_mag_numf(float __x , float __y ) ;
#line 411
extern  __attribute__((__nothrow__)) int totalorderf(float const   *__x , float const   *__y ) ;
#line 416
extern  __attribute__((__nothrow__)) int totalordermagf(float const   *__x , float const   *__y ) ;
#line 421
extern  __attribute__((__nothrow__)) float getpayloadf(float const   *__x ) ;
#line 421
extern  __attribute__((__nothrow__)) float __getpayloadf(float const   *__x ) ;
#line 424
extern  __attribute__((__nothrow__)) int setpayloadf(float *__x , float __payload ) ;
#line 427
extern  __attribute__((__nothrow__)) int setpayloadsigf(float *__x , float __payload ) ;
#line 435
extern  __attribute__((__nothrow__)) float scalbf(float __x , float __n ) ;
#line 435
extern  __attribute__((__nothrow__)) float __scalbf(float __x , float __n ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyl(long double __value ) ;
#line 24
extern  __attribute__((__nothrow__)) int __signbitl(long double __value ) ;
#line 29
extern  __attribute__((__nothrow__)) int __isinfl(long double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitel(long double __value ) ;
#line 37
extern  __attribute__((__nothrow__)) int __isnanl(long double __value ) ;
#line 41
extern  __attribute__((__nothrow__)) int __iseqsigl(long double __x , long double __y ) ;
#line 44
extern  __attribute__((__nothrow__)) int __issignalingl(long double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) long double acosl(long double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) long double __acosl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double asinl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double __asinl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double atanl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double __atanl(long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double atan2l(long double __y , long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double __atan2l(long double __y , long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double cosl(long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double __cosl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double sinl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double __sinl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double tanl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double __tanl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double coshl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double __coshl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double sinhl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double __sinhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double tanhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double __tanhl(long double __x ) ;
#line 79
extern  __attribute__((__nothrow__)) void sincosl(long double __x , long double *__sinx ,
                                                  long double *__cosx ) ;
#line 79
extern  __attribute__((__nothrow__)) void __sincosl(long double __x , long double *__sinx ,
                                                    long double *__cosx ) ;
#line 85
extern  __attribute__((__nothrow__)) long double acoshl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double __acoshl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double asinhl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double __asinhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double atanhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double __atanhl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double expl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double __expl(long double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) long double __frexpl(long double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double __ldexpl(long double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) long double logl(long double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) long double __logl(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double log10l(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double __log10l(long double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) long double modfl(long double __x , long double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) long double __modfl(long double __x , long double *__iptr ) ;
#line 114
extern  __attribute__((__nothrow__)) long double exp10l(long double __x ) ;
#line 114
extern  __attribute__((__nothrow__)) long double __exp10l(long double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) long double expm1l(long double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) long double __expm1l(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double log1pl(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double __log1pl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double logbl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double __logbl(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double exp2l(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double __exp2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double log2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double __log2l(long double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) long double powl(long double __x , long double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) long double __powl(long double __x , long double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) long double sqrtl(long double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) long double __sqrtl(long double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) long double hypotl(long double __x , long double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) long double __hypotl(long double __x , long double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) long double cbrtl(long double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) long double __cbrtl(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double ceill(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double __ceill(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double fabsl(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double __fabsl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double floorl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double __floorl(long double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) long double fmodl(long double __x , long double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) long double __fmodl(long double __x , long double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinfl(long double __value ) ;
#line 183
extern  __attribute__((__nothrow__)) int finitel(long double __value ) ;
#line 187
extern  __attribute__((__nothrow__)) long double dreml(long double __x , long double __y ) ;
#line 187
extern  __attribute__((__nothrow__)) long double __dreml(long double __x , long double __y ) ;
#line 191
extern  __attribute__((__nothrow__)) long double significandl(long double __x ) ;
#line 191
extern  __attribute__((__nothrow__)) long double __significandl(long double __x ) ;
#line 198
extern  __attribute__((__nothrow__)) long double copysignl(long double __x , long double __y ) ;
#line 198
extern  __attribute__((__nothrow__)) long double __copysignl(long double __x , long double __y ) ;
#line 203
extern  __attribute__((__nothrow__)) long double nanl(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) long double __nanl(char const   *__tagb ) ;
#line 213
extern  __attribute__((__nothrow__)) int isnanl(long double __value ) ;
#line 220
extern  __attribute__((__nothrow__)) long double j0l(long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double __j0l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double j1l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double __j1l(long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double jnl(int  , long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double __jnl(int  , long double  ) ;
#line 223
extern  __attribute__((__nothrow__)) long double y0l(long double  ) ;
#line 223
extern  __attribute__((__nothrow__)) long double __y0l(long double  ) ;
#line 224
extern  __attribute__((__nothrow__)) long double y1l(long double  ) ;
#line 224
extern  __attribute__((__nothrow__)) long double __y1l(long double  ) ;
#line 225
extern  __attribute__((__nothrow__)) long double ynl(int  , long double  ) ;
#line 225
extern  __attribute__((__nothrow__)) long double __ynl(int  , long double  ) ;
#line 231
extern  __attribute__((__nothrow__)) long double erfl(long double  ) ;
#line 231
extern  __attribute__((__nothrow__)) long double __erfl(long double  ) ;
#line 232
extern  __attribute__((__nothrow__)) long double erfcl(long double  ) ;
#line 232
extern  __attribute__((__nothrow__)) long double __erfcl(long double  ) ;
#line 233
extern  __attribute__((__nothrow__)) long double lgammal(long double  ) ;
#line 233
extern  __attribute__((__nothrow__)) long double __lgammal(long double  ) ;
#line 238
extern  __attribute__((__nothrow__)) long double tgammal(long double  ) ;
#line 238
extern  __attribute__((__nothrow__)) long double __tgammal(long double  ) ;
#line 244
extern  __attribute__((__nothrow__)) long double gammal(long double  ) ;
#line 244
extern  __attribute__((__nothrow__)) long double __gammal(long double  ) ;
#line 252
extern  __attribute__((__nothrow__)) long double lgammal_r(long double  , int *__signgamp ) ;
#line 252
extern  __attribute__((__nothrow__)) long double __lgammal_r(long double  , int *__signgamp ) ;
#line 259
extern  __attribute__((__nothrow__)) long double rintl(long double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) long double __rintl(long double __x ) ;
#line 262
extern  __attribute__((__nothrow__)) long double nextafterl(long double __x , long double __y ) ;
#line 262
extern  __attribute__((__nothrow__)) long double __nextafterl(long double __x , long double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) long double nexttowardl(long double __x , long double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) long double __nexttowardl(long double __x , long double __y ) ;
#line 269
extern  __attribute__((__nothrow__)) long double nextdownl(long double __x ) ;
#line 269
extern  __attribute__((__nothrow__)) long double __nextdownl(long double __x ) ;
#line 271
extern  __attribute__((__nothrow__)) long double nextupl(long double __x ) ;
#line 271
extern  __attribute__((__nothrow__)) long double __nextupl(long double __x ) ;
#line 275
extern  __attribute__((__nothrow__)) long double remainderl(long double __x , long double __y ) ;
#line 275
extern  __attribute__((__nothrow__)) long double __remainderl(long double __x , long double __y ) ;
#line 279
extern  __attribute__((__nothrow__)) long double scalbnl(long double __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) long double __scalbnl(long double __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogbl(long double __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogbl(long double __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long llogbl(long double __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long __llogbl(long double __x ) ;
#line 293
extern  __attribute__((__nothrow__)) long double scalblnl(long double __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) long double __scalblnl(long double __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) long double nearbyintl(long double __x ) ;
#line 297
extern  __attribute__((__nothrow__)) long double __nearbyintl(long double __x ) ;
#line 301
extern  __attribute__((__nothrow__)) long double roundl(long double __x ) ;
#line 301
extern  __attribute__((__nothrow__)) long double __roundl(long double __x ) ;
#line 305
extern  __attribute__((__nothrow__)) long double truncl(long double __x ) ;
#line 305
extern  __attribute__((__nothrow__)) long double __truncl(long double __x ) ;
#line 310
extern  __attribute__((__nothrow__)) long double remquol(long double __x , long double __y ,
                                                         int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) long double __remquol(long double __x , long double __y ,
                                                           int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrintl(long double __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrintl(long double __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrintl(long double __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrintl(long double __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lroundl(long double __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lroundl(long double __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llroundl(long double __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llroundl(long double __x ) ;
#line 329
extern  __attribute__((__nothrow__)) long double fdiml(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double __fdiml(long double __x , long double __y ) ;
#line 333
extern  __attribute__((__nothrow__)) long double fmaxl(long double __x , long double __y ) ;
#line 333
extern  __attribute__((__nothrow__)) long double __fmaxl(long double __x , long double __y ) ;
#line 336
extern  __attribute__((__nothrow__)) long double fminl(long double __x , long double __y ) ;
#line 336
extern  __attribute__((__nothrow__)) long double __fminl(long double __x , long double __y ) ;
#line 340
extern  __attribute__((__nothrow__)) long double fmal(long double __x , long double __y ,
                                                      long double __z ) ;
#line 340
extern  __attribute__((__nothrow__)) long double __fmal(long double __x , long double __y ,
                                                        long double __z ) ;
#line 345
extern  __attribute__((__nothrow__)) long double roundevenl(long double __x ) ;
#line 345
extern  __attribute__((__nothrow__)) long double __roundevenl(long double __x ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t fromfpl(long double __x , int __round ,
                                                        unsigned int __width ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t __fromfpl(long double __x , int __round ,
                                                          unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpl(long double __x , int __round ,
                                                          unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpl(long double __x , int __round ,
                                                            unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t fromfpxl(long double __x , int __round ,
                                                         unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t __fromfpxl(long double __x , int __round ,
                                                           unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpxl(long double __x , int __round ,
                                                           unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpxl(long double __x , int __round ,
                                                             unsigned int __width ) ;
#line 370
extern  __attribute__((__nothrow__)) int canonicalizel(long double *__cx , long double const   *__x ) ;
#line 377
extern  __attribute__((__nothrow__)) long double fmaxmagl(long double __x , long double __y ) ;
#line 377
extern  __attribute__((__nothrow__)) long double __fmaxmagl(long double __x , long double __y ) ;
#line 380
extern  __attribute__((__nothrow__)) long double fminmagl(long double __x , long double __y ) ;
#line 380
extern  __attribute__((__nothrow__)) long double __fminmagl(long double __x , long double __y ) ;
#line 385
extern  __attribute__((__nothrow__)) long double fmaximuml(long double __x , long double __y ) ;
#line 385
extern  __attribute__((__nothrow__)) long double __fmaximuml(long double __x , long double __y ) ;
#line 388
extern  __attribute__((__nothrow__)) long double fminimuml(long double __x , long double __y ) ;
#line 388
extern  __attribute__((__nothrow__)) long double __fminimuml(long double __x , long double __y ) ;
#line 391
extern  __attribute__((__nothrow__)) long double fmaximum_numl(long double __x , long double __y ) ;
#line 391
extern  __attribute__((__nothrow__)) long double __fmaximum_numl(long double __x ,
                                                                 long double __y ) ;
#line 394
extern  __attribute__((__nothrow__)) long double fminimum_numl(long double __x , long double __y ) ;
#line 394
extern  __attribute__((__nothrow__)) long double __fminimum_numl(long double __x ,
                                                                 long double __y ) ;
#line 397
extern  __attribute__((__nothrow__)) long double fmaximum_magl(long double __x , long double __y ) ;
#line 397
extern  __attribute__((__nothrow__)) long double __fmaximum_magl(long double __x ,
                                                                 long double __y ) ;
#line 400
extern  __attribute__((__nothrow__)) long double fminimum_magl(long double __x , long double __y ) ;
#line 400
extern  __attribute__((__nothrow__)) long double __fminimum_magl(long double __x ,
                                                                 long double __y ) ;
#line 403
extern  __attribute__((__nothrow__)) long double fmaximum_mag_numl(long double __x ,
                                                                   long double __y ) ;
#line 403
extern  __attribute__((__nothrow__)) long double __fmaximum_mag_numl(long double __x ,
                                                                     long double __y ) ;
#line 406
extern  __attribute__((__nothrow__)) long double fminimum_mag_numl(long double __x ,
                                                                   long double __y ) ;
#line 406
extern  __attribute__((__nothrow__)) long double __fminimum_mag_numl(long double __x ,
                                                                     long double __y ) ;
#line 411
extern  __attribute__((__nothrow__)) int totalorderl(long double const   *__x , long double const   *__y ) ;
#line 416
extern  __attribute__((__nothrow__)) int totalordermagl(long double const   *__x ,
                                                        long double const   *__y ) ;
#line 421
extern  __attribute__((__nothrow__)) long double getpayloadl(long double const   *__x ) ;
#line 421
extern  __attribute__((__nothrow__)) long double __getpayloadl(long double const   *__x ) ;
#line 424
extern  __attribute__((__nothrow__)) int setpayloadl(long double *__x , long double __payload ) ;
#line 427
extern  __attribute__((__nothrow__)) int setpayloadsigl(long double *__x , long double __payload ) ;
#line 435
extern  __attribute__((__nothrow__)) long double scalbl(long double __x , long double __n ) ;
#line 435
extern  __attribute__((__nothrow__)) long double __scalbl(long double __x , long double __n ) ;
#line 53
extern  __attribute__((__nothrow__)) int acosf32(int __x ) ;
#line 53
extern  __attribute__((__nothrow__)) int __acosf32(int __x ) ;
#line 55
extern  __attribute__((__nothrow__)) int asinf32(int __x ) ;
#line 55
extern  __attribute__((__nothrow__)) int __asinf32(int __x ) ;
#line 57
extern  __attribute__((__nothrow__)) int atanf32(int __x ) ;
#line 57
extern  __attribute__((__nothrow__)) int __atanf32(int __x ) ;
#line 59
extern  __attribute__((__nothrow__)) int atan2f32(int __y , int __x ) ;
#line 59
extern  __attribute__((__nothrow__)) int __atan2f32(int __y , int __x ) ;
#line 62
extern  __attribute__((__nothrow__)) int cosf32(int __x ) ;
#line 62
extern  __attribute__((__nothrow__)) int __cosf32(int __x ) ;
#line 64
extern  __attribute__((__nothrow__)) int sinf32(int __x ) ;
#line 64
extern  __attribute__((__nothrow__)) int __sinf32(int __x ) ;
#line 66
extern  __attribute__((__nothrow__)) int tanf32(int __x ) ;
#line 66
extern  __attribute__((__nothrow__)) int __tanf32(int __x ) ;
#line 71
extern  __attribute__((__nothrow__)) int coshf32(int __x ) ;
#line 71
extern  __attribute__((__nothrow__)) int __coshf32(int __x ) ;
#line 73
extern  __attribute__((__nothrow__)) int sinhf32(int __x ) ;
#line 73
extern  __attribute__((__nothrow__)) int __sinhf32(int __x ) ;
#line 75
extern  __attribute__((__nothrow__)) int tanhf32(int __x ) ;
#line 75
extern  __attribute__((__nothrow__)) int __tanhf32(int __x ) ;
#line 79
extern  __attribute__((__nothrow__)) void sincosf32(int __x , int *__sinx , int *__cosx ) ;
#line 79
extern  __attribute__((__nothrow__)) void __sincosf32(int __x , int *__sinx , int *__cosx ) ;
#line 85
extern  __attribute__((__nothrow__)) int acoshf32(int __x ) ;
#line 85
extern  __attribute__((__nothrow__)) int __acoshf32(int __x ) ;
#line 87
extern  __attribute__((__nothrow__)) int asinhf32(int __x ) ;
#line 87
extern  __attribute__((__nothrow__)) int __asinhf32(int __x ) ;
#line 89
extern  __attribute__((__nothrow__)) int atanhf32(int __x ) ;
#line 89
extern  __attribute__((__nothrow__)) int __atanhf32(int __x ) ;
#line 95
extern  __attribute__((__nothrow__)) int expf32(int __x ) ;
#line 95
extern  __attribute__((__nothrow__)) int __expf32(int __x ) ;
#line 98
extern  __attribute__((__nothrow__)) int frexpf32(int __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) int __frexpf32(int __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) int ldexpf32(int __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) int __ldexpf32(int __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) int logf32(int __x ) ;
#line 104
extern  __attribute__((__nothrow__)) int __logf32(int __x ) ;
#line 107
extern  __attribute__((__nothrow__)) int log10f32(int __x ) ;
#line 107
extern  __attribute__((__nothrow__)) int __log10f32(int __x ) ;
#line 110
extern  __attribute__((__nothrow__)) int modff32(int __x , int *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) int __modff32(int __x , int *__iptr ) ;
#line 114
extern  __attribute__((__nothrow__)) int exp10f32(int __x ) ;
#line 114
extern  __attribute__((__nothrow__)) int __exp10f32(int __x ) ;
#line 119
extern  __attribute__((__nothrow__)) int expm1f32(int __x ) ;
#line 119
extern  __attribute__((__nothrow__)) int __expm1f32(int __x ) ;
#line 122
extern  __attribute__((__nothrow__)) int log1pf32(int __x ) ;
#line 122
extern  __attribute__((__nothrow__)) int __log1pf32(int __x ) ;
#line 125
extern  __attribute__((__nothrow__)) int logbf32(int __x ) ;
#line 125
extern  __attribute__((__nothrow__)) int __logbf32(int __x ) ;
#line 130
extern  __attribute__((__nothrow__)) int exp2f32(int __x ) ;
#line 130
extern  __attribute__((__nothrow__)) int __exp2f32(int __x ) ;
#line 133
extern  __attribute__((__nothrow__)) int log2f32(int __x ) ;
#line 133
extern  __attribute__((__nothrow__)) int __log2f32(int __x ) ;
#line 140
extern  __attribute__((__nothrow__)) int powf32(int __x , int __y ) ;
#line 140
extern  __attribute__((__nothrow__)) int __powf32(int __x , int __y ) ;
#line 143
extern  __attribute__((__nothrow__)) int sqrtf32(int __x ) ;
#line 143
extern  __attribute__((__nothrow__)) int __sqrtf32(int __x ) ;
#line 147
extern  __attribute__((__nothrow__)) int hypotf32(int __x , int __y ) ;
#line 147
extern  __attribute__((__nothrow__)) int __hypotf32(int __x , int __y ) ;
#line 152
extern  __attribute__((__nothrow__)) int cbrtf32(int __x ) ;
#line 152
extern  __attribute__((__nothrow__)) int __cbrtf32(int __x ) ;
#line 159
extern  __attribute__((__nothrow__)) int ceilf32(int __x ) ;
#line 159
extern  __attribute__((__nothrow__)) int __ceilf32(int __x ) ;
#line 162
extern  __attribute__((__nothrow__)) int fabsf32(int __x ) ;
#line 162
extern  __attribute__((__nothrow__)) int __fabsf32(int __x ) ;
#line 165
extern  __attribute__((__nothrow__)) int floorf32(int __x ) ;
#line 165
extern  __attribute__((__nothrow__)) int __floorf32(int __x ) ;
#line 168
extern  __attribute__((__nothrow__)) int fmodf32(int __x , int __y ) ;
#line 168
extern  __attribute__((__nothrow__)) int __fmodf32(int __x , int __y ) ;
#line 198
extern  __attribute__((__nothrow__)) int copysignf32(int __x , int __y ) ;
#line 198
extern  __attribute__((__nothrow__)) int __copysignf32(int __x , int __y ) ;
#line 203
extern  __attribute__((__nothrow__)) int nanf32(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) int __nanf32(char const   *__tagb ) ;
#line 220
extern  __attribute__((__nothrow__)) int j0f32() ;
#line 220
extern  __attribute__((__nothrow__)) int __j0f32() ;
#line 221
extern  __attribute__((__nothrow__)) int j1f32() ;
#line 221
extern  __attribute__((__nothrow__)) int __j1f32() ;
#line 222
extern  __attribute__((__nothrow__)) int jnf32(int  , int _Float32 ) ;
#line 222
extern  __attribute__((__nothrow__)) int __jnf32(int  , int _Float32 ) ;
#line 223
extern  __attribute__((__nothrow__)) int y0f32() ;
#line 223
extern  __attribute__((__nothrow__)) int __y0f32() ;
#line 224
extern  __attribute__((__nothrow__)) int y1f32() ;
#line 224
extern  __attribute__((__nothrow__)) int __y1f32() ;
#line 225
extern  __attribute__((__nothrow__)) int ynf32(int  , int _Float32 ) ;
#line 225
extern  __attribute__((__nothrow__)) int __ynf32(int  , int _Float32 ) ;
#line 231
extern  __attribute__((__nothrow__)) int erff32() ;
#line 231
extern  __attribute__((__nothrow__)) int __erff32() ;
#line 232
extern  __attribute__((__nothrow__)) int erfcf32() ;
#line 232
extern  __attribute__((__nothrow__)) int __erfcf32() ;
#line 233
extern  __attribute__((__nothrow__)) int lgammaf32() ;
#line 233
extern  __attribute__((__nothrow__)) int __lgammaf32() ;
#line 238
extern  __attribute__((__nothrow__)) int tgammaf32() ;
#line 238
extern  __attribute__((__nothrow__)) int __tgammaf32() ;
#line 252
extern  __attribute__((__nothrow__)) int lgammaf32_r() ;
#line 252
extern  __attribute__((__nothrow__)) int __lgammaf32_r() ;
#line 259
extern  __attribute__((__nothrow__)) int rintf32(int __x ) ;
#line 259
extern  __attribute__((__nothrow__)) int __rintf32(int __x ) ;
#line 262
extern  __attribute__((__nothrow__)) int nextafterf32(int __x , int __y ) ;
#line 262
extern  __attribute__((__nothrow__)) int __nextafterf32(int __x , int __y ) ;
#line 269
extern  __attribute__((__nothrow__)) int nextdownf32(int __x ) ;
#line 269
extern  __attribute__((__nothrow__)) int __nextdownf32(int __x ) ;
#line 271
extern  __attribute__((__nothrow__)) int nextupf32(int __x ) ;
#line 271
extern  __attribute__((__nothrow__)) int __nextupf32(int __x ) ;
#line 275
extern  __attribute__((__nothrow__)) int remainderf32(int __x , int __y ) ;
#line 275
extern  __attribute__((__nothrow__)) int __remainderf32(int __x , int __y ) ;
#line 279
extern  __attribute__((__nothrow__)) int scalbnf32(int __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) int __scalbnf32(int __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogbf32(int __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogbf32(int __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long llogbf32(int __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long __llogbf32(int __x ) ;
#line 293
extern  __attribute__((__nothrow__)) int scalblnf32(int __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) int __scalblnf32(int __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) int nearbyintf32(int __x ) ;
#line 297
extern  __attribute__((__nothrow__)) int __nearbyintf32(int __x ) ;
#line 301
extern  __attribute__((__nothrow__)) int roundf32(int __x ) ;
#line 301
extern  __attribute__((__nothrow__)) int __roundf32(int __x ) ;
#line 305
extern  __attribute__((__nothrow__)) int truncf32(int __x ) ;
#line 305
extern  __attribute__((__nothrow__)) int __truncf32(int __x ) ;
#line 310
extern  __attribute__((__nothrow__)) int remquof32(int __x , int __y , int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) int __remquof32(int __x , int __y , int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrintf32(int __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrintf32(int __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrintf32(int __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrintf32(int __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lroundf32(int __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lroundf32(int __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llroundf32(int __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llroundf32(int __x ) ;
#line 329
extern  __attribute__((__nothrow__)) int fdimf32(int __x , int __y ) ;
#line 329
extern  __attribute__((__nothrow__)) int __fdimf32(int __x , int __y ) ;
#line 333
extern  __attribute__((__nothrow__)) int fmaxf32(int __x , int __y ) ;
#line 333
extern  __attribute__((__nothrow__)) int __fmaxf32(int __x , int __y ) ;
#line 336
extern  __attribute__((__nothrow__)) int fminf32(int __x , int __y ) ;
#line 336
extern  __attribute__((__nothrow__)) int __fminf32(int __x , int __y ) ;
#line 340
extern  __attribute__((__nothrow__)) int fmaf32(int __x , int __y , int __z ) ;
#line 340
extern  __attribute__((__nothrow__)) int __fmaf32(int __x , int __y , int __z ) ;
#line 345
extern  __attribute__((__nothrow__)) int roundevenf32(int __x ) ;
#line 345
extern  __attribute__((__nothrow__)) int __roundevenf32(int __x ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t fromfpf32(int __x , int __round ,
                                                          unsigned int __width ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t __fromfpf32(int __x , int __round ,
                                                            unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpf32(int __x , int __round ,
                                                            unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpf32(int __x , int __round ,
                                                              unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t fromfpxf32(int __x , int __round ,
                                                           unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t __fromfpxf32(int __x , int __round ,
                                                             unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpxf32(int __x , int __round ,
                                                             unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpxf32(int __x , int __round ,
                                                               unsigned int __width ) ;
#line 370
extern  __attribute__((__nothrow__)) int canonicalizef32(int *__cx , int const   *__x ) ;
#line 377
extern  __attribute__((__nothrow__)) int fmaxmagf32(int __x , int __y ) ;
#line 377
extern  __attribute__((__nothrow__)) int __fmaxmagf32(int __x , int __y ) ;
#line 380
extern  __attribute__((__nothrow__)) int fminmagf32(int __x , int __y ) ;
#line 380
extern  __attribute__((__nothrow__)) int __fminmagf32(int __x , int __y ) ;
#line 385
extern  __attribute__((__nothrow__)) int fmaximumf32(int __x , int __y ) ;
#line 385
extern  __attribute__((__nothrow__)) int __fmaximumf32(int __x , int __y ) ;
#line 388
extern  __attribute__((__nothrow__)) int fminimumf32(int __x , int __y ) ;
#line 388
extern  __attribute__((__nothrow__)) int __fminimumf32(int __x , int __y ) ;
#line 391
extern  __attribute__((__nothrow__)) int fmaximum_numf32(int __x , int __y ) ;
#line 391
extern  __attribute__((__nothrow__)) int __fmaximum_numf32(int __x , int __y ) ;
#line 394
extern  __attribute__((__nothrow__)) int fminimum_numf32(int __x , int __y ) ;
#line 394
extern  __attribute__((__nothrow__)) int __fminimum_numf32(int __x , int __y ) ;
#line 397
extern  __attribute__((__nothrow__)) int fmaximum_magf32(int __x , int __y ) ;
#line 397
extern  __attribute__((__nothrow__)) int __fmaximum_magf32(int __x , int __y ) ;
#line 400
extern  __attribute__((__nothrow__)) int fminimum_magf32(int __x , int __y ) ;
#line 400
extern  __attribute__((__nothrow__)) int __fminimum_magf32(int __x , int __y ) ;
#line 403
extern  __attribute__((__nothrow__)) int fmaximum_mag_numf32(int __x , int __y ) ;
#line 403
extern  __attribute__((__nothrow__)) int __fmaximum_mag_numf32(int __x , int __y ) ;
#line 406
extern  __attribute__((__nothrow__)) int fminimum_mag_numf32(int __x , int __y ) ;
#line 406
extern  __attribute__((__nothrow__)) int __fminimum_mag_numf32(int __x , int __y ) ;
#line 411
extern  __attribute__((__nothrow__)) int totalorderf32(int const   *__x , int const   *__y ) ;
#line 416
extern  __attribute__((__nothrow__)) int totalordermagf32(int const   *__x , int const   *__y ) ;
#line 421
extern  __attribute__((__nothrow__)) int getpayloadf32(int const   *__x ) ;
#line 421
extern  __attribute__((__nothrow__)) int __getpayloadf32(int const   *__x ) ;
#line 424
extern  __attribute__((__nothrow__)) int setpayloadf32(int *__x , int __payload ) ;
#line 427
extern  __attribute__((__nothrow__)) int setpayloadsigf32(int *__x , int __payload ) ;
#line 53
extern  __attribute__((__nothrow__)) int acosf64(int __x ) ;
#line 53
extern  __attribute__((__nothrow__)) int __acosf64(int __x ) ;
#line 55
extern  __attribute__((__nothrow__)) int asinf64(int __x ) ;
#line 55
extern  __attribute__((__nothrow__)) int __asinf64(int __x ) ;
#line 57
extern  __attribute__((__nothrow__)) int atanf64(int __x ) ;
#line 57
extern  __attribute__((__nothrow__)) int __atanf64(int __x ) ;
#line 59
extern  __attribute__((__nothrow__)) int atan2f64(int __y , int __x ) ;
#line 59
extern  __attribute__((__nothrow__)) int __atan2f64(int __y , int __x ) ;
#line 62
extern  __attribute__((__nothrow__)) int cosf64(int __x ) ;
#line 62
extern  __attribute__((__nothrow__)) int __cosf64(int __x ) ;
#line 64
extern  __attribute__((__nothrow__)) int sinf64(int __x ) ;
#line 64
extern  __attribute__((__nothrow__)) int __sinf64(int __x ) ;
#line 66
extern  __attribute__((__nothrow__)) int tanf64(int __x ) ;
#line 66
extern  __attribute__((__nothrow__)) int __tanf64(int __x ) ;
#line 71
extern  __attribute__((__nothrow__)) int coshf64(int __x ) ;
#line 71
extern  __attribute__((__nothrow__)) int __coshf64(int __x ) ;
#line 73
extern  __attribute__((__nothrow__)) int sinhf64(int __x ) ;
#line 73
extern  __attribute__((__nothrow__)) int __sinhf64(int __x ) ;
#line 75
extern  __attribute__((__nothrow__)) int tanhf64(int __x ) ;
#line 75
extern  __attribute__((__nothrow__)) int __tanhf64(int __x ) ;
#line 79
extern  __attribute__((__nothrow__)) void sincosf64(int __x , int *__sinx , int *__cosx ) ;
#line 79
extern  __attribute__((__nothrow__)) void __sincosf64(int __x , int *__sinx , int *__cosx ) ;
#line 85
extern  __attribute__((__nothrow__)) int acoshf64(int __x ) ;
#line 85
extern  __attribute__((__nothrow__)) int __acoshf64(int __x ) ;
#line 87
extern  __attribute__((__nothrow__)) int asinhf64(int __x ) ;
#line 87
extern  __attribute__((__nothrow__)) int __asinhf64(int __x ) ;
#line 89
extern  __attribute__((__nothrow__)) int atanhf64(int __x ) ;
#line 89
extern  __attribute__((__nothrow__)) int __atanhf64(int __x ) ;
#line 95
extern  __attribute__((__nothrow__)) int expf64(int __x ) ;
#line 95
extern  __attribute__((__nothrow__)) int __expf64(int __x ) ;
#line 98
extern  __attribute__((__nothrow__)) int frexpf64(int __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) int __frexpf64(int __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) int ldexpf64(int __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) int __ldexpf64(int __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) int logf64(int __x ) ;
#line 104
extern  __attribute__((__nothrow__)) int __logf64(int __x ) ;
#line 107
extern  __attribute__((__nothrow__)) int log10f64(int __x ) ;
#line 107
extern  __attribute__((__nothrow__)) int __log10f64(int __x ) ;
#line 110
extern  __attribute__((__nothrow__)) int modff64(int __x , int *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) int __modff64(int __x , int *__iptr ) ;
#line 114
extern  __attribute__((__nothrow__)) int exp10f64(int __x ) ;
#line 114
extern  __attribute__((__nothrow__)) int __exp10f64(int __x ) ;
#line 119
extern  __attribute__((__nothrow__)) int expm1f64(int __x ) ;
#line 119
extern  __attribute__((__nothrow__)) int __expm1f64(int __x ) ;
#line 122
extern  __attribute__((__nothrow__)) int log1pf64(int __x ) ;
#line 122
extern  __attribute__((__nothrow__)) int __log1pf64(int __x ) ;
#line 125
extern  __attribute__((__nothrow__)) int logbf64(int __x ) ;
#line 125
extern  __attribute__((__nothrow__)) int __logbf64(int __x ) ;
#line 130
extern  __attribute__((__nothrow__)) int exp2f64(int __x ) ;
#line 130
extern  __attribute__((__nothrow__)) int __exp2f64(int __x ) ;
#line 133
extern  __attribute__((__nothrow__)) int log2f64(int __x ) ;
#line 133
extern  __attribute__((__nothrow__)) int __log2f64(int __x ) ;
#line 140
extern  __attribute__((__nothrow__)) int powf64(int __x , int __y ) ;
#line 140
extern  __attribute__((__nothrow__)) int __powf64(int __x , int __y ) ;
#line 143
extern  __attribute__((__nothrow__)) int sqrtf64(int __x ) ;
#line 143
extern  __attribute__((__nothrow__)) int __sqrtf64(int __x ) ;
#line 147
extern  __attribute__((__nothrow__)) int hypotf64(int __x , int __y ) ;
#line 147
extern  __attribute__((__nothrow__)) int __hypotf64(int __x , int __y ) ;
#line 152
extern  __attribute__((__nothrow__)) int cbrtf64(int __x ) ;
#line 152
extern  __attribute__((__nothrow__)) int __cbrtf64(int __x ) ;
#line 159
extern  __attribute__((__nothrow__)) int ceilf64(int __x ) ;
#line 159
extern  __attribute__((__nothrow__)) int __ceilf64(int __x ) ;
#line 162
extern  __attribute__((__nothrow__)) int fabsf64(int __x ) ;
#line 162
extern  __attribute__((__nothrow__)) int __fabsf64(int __x ) ;
#line 165
extern  __attribute__((__nothrow__)) int floorf64(int __x ) ;
#line 165
extern  __attribute__((__nothrow__)) int __floorf64(int __x ) ;
#line 168
extern  __attribute__((__nothrow__)) int fmodf64(int __x , int __y ) ;
#line 168
extern  __attribute__((__nothrow__)) int __fmodf64(int __x , int __y ) ;
#line 198
extern  __attribute__((__nothrow__)) int copysignf64(int __x , int __y ) ;
#line 198
extern  __attribute__((__nothrow__)) int __copysignf64(int __x , int __y ) ;
#line 203
extern  __attribute__((__nothrow__)) int nanf64(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) int __nanf64(char const   *__tagb ) ;
#line 220
extern  __attribute__((__nothrow__)) int j0f64() ;
#line 220
extern  __attribute__((__nothrow__)) int __j0f64() ;
#line 221
extern  __attribute__((__nothrow__)) int j1f64() ;
#line 221
extern  __attribute__((__nothrow__)) int __j1f64() ;
#line 222
extern  __attribute__((__nothrow__)) int jnf64(int  , int _Float64 ) ;
#line 222
extern  __attribute__((__nothrow__)) int __jnf64(int  , int _Float64 ) ;
#line 223
extern  __attribute__((__nothrow__)) int y0f64() ;
#line 223
extern  __attribute__((__nothrow__)) int __y0f64() ;
#line 224
extern  __attribute__((__nothrow__)) int y1f64() ;
#line 224
extern  __attribute__((__nothrow__)) int __y1f64() ;
#line 225
extern  __attribute__((__nothrow__)) int ynf64(int  , int _Float64 ) ;
#line 225
extern  __attribute__((__nothrow__)) int __ynf64(int  , int _Float64 ) ;
#line 231
extern  __attribute__((__nothrow__)) int erff64() ;
#line 231
extern  __attribute__((__nothrow__)) int __erff64() ;
#line 232
extern  __attribute__((__nothrow__)) int erfcf64() ;
#line 232
extern  __attribute__((__nothrow__)) int __erfcf64() ;
#line 233
extern  __attribute__((__nothrow__)) int lgammaf64() ;
#line 233
extern  __attribute__((__nothrow__)) int __lgammaf64() ;
#line 238
extern  __attribute__((__nothrow__)) int tgammaf64() ;
#line 238
extern  __attribute__((__nothrow__)) int __tgammaf64() ;
#line 252
extern  __attribute__((__nothrow__)) int lgammaf64_r() ;
#line 252
extern  __attribute__((__nothrow__)) int __lgammaf64_r() ;
#line 259
extern  __attribute__((__nothrow__)) int rintf64(int __x ) ;
#line 259
extern  __attribute__((__nothrow__)) int __rintf64(int __x ) ;
#line 262
extern  __attribute__((__nothrow__)) int nextafterf64(int __x , int __y ) ;
#line 262
extern  __attribute__((__nothrow__)) int __nextafterf64(int __x , int __y ) ;
#line 269
extern  __attribute__((__nothrow__)) int nextdownf64(int __x ) ;
#line 269
extern  __attribute__((__nothrow__)) int __nextdownf64(int __x ) ;
#line 271
extern  __attribute__((__nothrow__)) int nextupf64(int __x ) ;
#line 271
extern  __attribute__((__nothrow__)) int __nextupf64(int __x ) ;
#line 275
extern  __attribute__((__nothrow__)) int remainderf64(int __x , int __y ) ;
#line 275
extern  __attribute__((__nothrow__)) int __remainderf64(int __x , int __y ) ;
#line 279
extern  __attribute__((__nothrow__)) int scalbnf64(int __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) int __scalbnf64(int __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogbf64(int __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogbf64(int __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long llogbf64(int __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long __llogbf64(int __x ) ;
#line 293
extern  __attribute__((__nothrow__)) int scalblnf64(int __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) int __scalblnf64(int __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) int nearbyintf64(int __x ) ;
#line 297
extern  __attribute__((__nothrow__)) int __nearbyintf64(int __x ) ;
#line 301
extern  __attribute__((__nothrow__)) int roundf64(int __x ) ;
#line 301
extern  __attribute__((__nothrow__)) int __roundf64(int __x ) ;
#line 305
extern  __attribute__((__nothrow__)) int truncf64(int __x ) ;
#line 305
extern  __attribute__((__nothrow__)) int __truncf64(int __x ) ;
#line 310
extern  __attribute__((__nothrow__)) int remquof64(int __x , int __y , int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) int __remquof64(int __x , int __y , int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrintf64(int __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrintf64(int __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrintf64(int __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrintf64(int __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lroundf64(int __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lroundf64(int __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llroundf64(int __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llroundf64(int __x ) ;
#line 329
extern  __attribute__((__nothrow__)) int fdimf64(int __x , int __y ) ;
#line 329
extern  __attribute__((__nothrow__)) int __fdimf64(int __x , int __y ) ;
#line 333
extern  __attribute__((__nothrow__)) int fmaxf64(int __x , int __y ) ;
#line 333
extern  __attribute__((__nothrow__)) int __fmaxf64(int __x , int __y ) ;
#line 336
extern  __attribute__((__nothrow__)) int fminf64(int __x , int __y ) ;
#line 336
extern  __attribute__((__nothrow__)) int __fminf64(int __x , int __y ) ;
#line 340
extern  __attribute__((__nothrow__)) int fmaf64(int __x , int __y , int __z ) ;
#line 340
extern  __attribute__((__nothrow__)) int __fmaf64(int __x , int __y , int __z ) ;
#line 345
extern  __attribute__((__nothrow__)) int roundevenf64(int __x ) ;
#line 345
extern  __attribute__((__nothrow__)) int __roundevenf64(int __x ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t fromfpf64(int __x , int __round ,
                                                          unsigned int __width ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t __fromfpf64(int __x , int __round ,
                                                            unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpf64(int __x , int __round ,
                                                            unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpf64(int __x , int __round ,
                                                              unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t fromfpxf64(int __x , int __round ,
                                                           unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t __fromfpxf64(int __x , int __round ,
                                                             unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpxf64(int __x , int __round ,
                                                             unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpxf64(int __x , int __round ,
                                                               unsigned int __width ) ;
#line 370
extern  __attribute__((__nothrow__)) int canonicalizef64(int *__cx , int const   *__x ) ;
#line 377
extern  __attribute__((__nothrow__)) int fmaxmagf64(int __x , int __y ) ;
#line 377
extern  __attribute__((__nothrow__)) int __fmaxmagf64(int __x , int __y ) ;
#line 380
extern  __attribute__((__nothrow__)) int fminmagf64(int __x , int __y ) ;
#line 380
extern  __attribute__((__nothrow__)) int __fminmagf64(int __x , int __y ) ;
#line 385
extern  __attribute__((__nothrow__)) int fmaximumf64(int __x , int __y ) ;
#line 385
extern  __attribute__((__nothrow__)) int __fmaximumf64(int __x , int __y ) ;
#line 388
extern  __attribute__((__nothrow__)) int fminimumf64(int __x , int __y ) ;
#line 388
extern  __attribute__((__nothrow__)) int __fminimumf64(int __x , int __y ) ;
#line 391
extern  __attribute__((__nothrow__)) int fmaximum_numf64(int __x , int __y ) ;
#line 391
extern  __attribute__((__nothrow__)) int __fmaximum_numf64(int __x , int __y ) ;
#line 394
extern  __attribute__((__nothrow__)) int fminimum_numf64(int __x , int __y ) ;
#line 394
extern  __attribute__((__nothrow__)) int __fminimum_numf64(int __x , int __y ) ;
#line 397
extern  __attribute__((__nothrow__)) int fmaximum_magf64(int __x , int __y ) ;
#line 397
extern  __attribute__((__nothrow__)) int __fmaximum_magf64(int __x , int __y ) ;
#line 400
extern  __attribute__((__nothrow__)) int fminimum_magf64(int __x , int __y ) ;
#line 400
extern  __attribute__((__nothrow__)) int __fminimum_magf64(int __x , int __y ) ;
#line 403
extern  __attribute__((__nothrow__)) int fmaximum_mag_numf64(int __x , int __y ) ;
#line 403
extern  __attribute__((__nothrow__)) int __fmaximum_mag_numf64(int __x , int __y ) ;
#line 406
extern  __attribute__((__nothrow__)) int fminimum_mag_numf64(int __x , int __y ) ;
#line 406
extern  __attribute__((__nothrow__)) int __fminimum_mag_numf64(int __x , int __y ) ;
#line 411
extern  __attribute__((__nothrow__)) int totalorderf64(int const   *__x , int const   *__y ) ;
#line 416
extern  __attribute__((__nothrow__)) int totalordermagf64(int const   *__x , int const   *__y ) ;
#line 421
extern  __attribute__((__nothrow__)) int getpayloadf64(int const   *__x ) ;
#line 421
extern  __attribute__((__nothrow__)) int __getpayloadf64(int const   *__x ) ;
#line 424
extern  __attribute__((__nothrow__)) int setpayloadf64(int *__x , int __payload ) ;
#line 427
extern  __attribute__((__nothrow__)) int setpayloadsigf64(int *__x , int __payload ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf128(int __value ) ;
#line 24
extern  __attribute__((__nothrow__)) int __signbitf128(int __value ) ;
#line 29
extern  __attribute__((__nothrow__)) int __isinff128(int __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef128(int __value ) ;
#line 37
extern  __attribute__((__nothrow__)) int __isnanf128(int __value ) ;
#line 41
extern  __attribute__((__nothrow__)) int __iseqsigf128(int __x , int __y ) ;
#line 44
extern  __attribute__((__nothrow__)) int __issignalingf128(int __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) int acosf128(int __x ) ;
#line 53
extern  __attribute__((__nothrow__)) int __acosf128(int __x ) ;
#line 55
extern  __attribute__((__nothrow__)) int asinf128(int __x ) ;
#line 55
extern  __attribute__((__nothrow__)) int __asinf128(int __x ) ;
#line 57
extern  __attribute__((__nothrow__)) int atanf128(int __x ) ;
#line 57
extern  __attribute__((__nothrow__)) int __atanf128(int __x ) ;
#line 59
extern  __attribute__((__nothrow__)) int atan2f128(int __y , int __x ) ;
#line 59
extern  __attribute__((__nothrow__)) int __atan2f128(int __y , int __x ) ;
#line 62
extern  __attribute__((__nothrow__)) int cosf128(int __x ) ;
#line 62
extern  __attribute__((__nothrow__)) int __cosf128(int __x ) ;
#line 64
extern  __attribute__((__nothrow__)) int sinf128(int __x ) ;
#line 64
extern  __attribute__((__nothrow__)) int __sinf128(int __x ) ;
#line 66
extern  __attribute__((__nothrow__)) int tanf128(int __x ) ;
#line 66
extern  __attribute__((__nothrow__)) int __tanf128(int __x ) ;
#line 71
extern  __attribute__((__nothrow__)) int coshf128(int __x ) ;
#line 71
extern  __attribute__((__nothrow__)) int __coshf128(int __x ) ;
#line 73
extern  __attribute__((__nothrow__)) int sinhf128(int __x ) ;
#line 73
extern  __attribute__((__nothrow__)) int __sinhf128(int __x ) ;
#line 75
extern  __attribute__((__nothrow__)) int tanhf128(int __x ) ;
#line 75
extern  __attribute__((__nothrow__)) int __tanhf128(int __x ) ;
#line 79
extern  __attribute__((__nothrow__)) void sincosf128(int __x , int *__sinx , int *__cosx ) ;
#line 79
extern  __attribute__((__nothrow__)) void __sincosf128(int __x , int *__sinx , int *__cosx ) ;
#line 85
extern  __attribute__((__nothrow__)) int acoshf128(int __x ) ;
#line 85
extern  __attribute__((__nothrow__)) int __acoshf128(int __x ) ;
#line 87
extern  __attribute__((__nothrow__)) int asinhf128(int __x ) ;
#line 87
extern  __attribute__((__nothrow__)) int __asinhf128(int __x ) ;
#line 89
extern  __attribute__((__nothrow__)) int atanhf128(int __x ) ;
#line 89
extern  __attribute__((__nothrow__)) int __atanhf128(int __x ) ;
#line 95
extern  __attribute__((__nothrow__)) int expf128(int __x ) ;
#line 95
extern  __attribute__((__nothrow__)) int __expf128(int __x ) ;
#line 98
extern  __attribute__((__nothrow__)) int frexpf128(int __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) int __frexpf128(int __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) int ldexpf128(int __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) int __ldexpf128(int __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) int logf128(int __x ) ;
#line 104
extern  __attribute__((__nothrow__)) int __logf128(int __x ) ;
#line 107
extern  __attribute__((__nothrow__)) int log10f128(int __x ) ;
#line 107
extern  __attribute__((__nothrow__)) int __log10f128(int __x ) ;
#line 110
extern  __attribute__((__nothrow__)) int modff128(int __x , int *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) int __modff128(int __x , int *__iptr ) ;
#line 114
extern  __attribute__((__nothrow__)) int exp10f128(int __x ) ;
#line 114
extern  __attribute__((__nothrow__)) int __exp10f128(int __x ) ;
#line 119
extern  __attribute__((__nothrow__)) int expm1f128(int __x ) ;
#line 119
extern  __attribute__((__nothrow__)) int __expm1f128(int __x ) ;
#line 122
extern  __attribute__((__nothrow__)) int log1pf128(int __x ) ;
#line 122
extern  __attribute__((__nothrow__)) int __log1pf128(int __x ) ;
#line 125
extern  __attribute__((__nothrow__)) int logbf128(int __x ) ;
#line 125
extern  __attribute__((__nothrow__)) int __logbf128(int __x ) ;
#line 130
extern  __attribute__((__nothrow__)) int exp2f128(int __x ) ;
#line 130
extern  __attribute__((__nothrow__)) int __exp2f128(int __x ) ;
#line 133
extern  __attribute__((__nothrow__)) int log2f128(int __x ) ;
#line 133
extern  __attribute__((__nothrow__)) int __log2f128(int __x ) ;
#line 140
extern  __attribute__((__nothrow__)) int powf128(int __x , int __y ) ;
#line 140
extern  __attribute__((__nothrow__)) int __powf128(int __x , int __y ) ;
#line 143
extern  __attribute__((__nothrow__)) int sqrtf128(int __x ) ;
#line 143
extern  __attribute__((__nothrow__)) int __sqrtf128(int __x ) ;
#line 147
extern  __attribute__((__nothrow__)) int hypotf128(int __x , int __y ) ;
#line 147
extern  __attribute__((__nothrow__)) int __hypotf128(int __x , int __y ) ;
#line 152
extern  __attribute__((__nothrow__)) int cbrtf128(int __x ) ;
#line 152
extern  __attribute__((__nothrow__)) int __cbrtf128(int __x ) ;
#line 159
extern  __attribute__((__nothrow__)) int ceilf128(int __x ) ;
#line 159
extern  __attribute__((__nothrow__)) int __ceilf128(int __x ) ;
#line 162
extern  __attribute__((__nothrow__)) int fabsf128(int __x ) ;
#line 162
extern  __attribute__((__nothrow__)) int __fabsf128(int __x ) ;
#line 165
extern  __attribute__((__nothrow__)) int floorf128(int __x ) ;
#line 165
extern  __attribute__((__nothrow__)) int __floorf128(int __x ) ;
#line 168
extern  __attribute__((__nothrow__)) int fmodf128(int __x , int __y ) ;
#line 168
extern  __attribute__((__nothrow__)) int __fmodf128(int __x , int __y ) ;
#line 198
extern  __attribute__((__nothrow__)) int copysignf128(int __x , int __y ) ;
#line 198
extern  __attribute__((__nothrow__)) int __copysignf128(int __x , int __y ) ;
#line 203
extern  __attribute__((__nothrow__)) int nanf128(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) int __nanf128(char const   *__tagb ) ;
#line 220
extern  __attribute__((__nothrow__)) int j0f128() ;
#line 220
extern  __attribute__((__nothrow__)) int __j0f128() ;
#line 221
extern  __attribute__((__nothrow__)) int j1f128() ;
#line 221
extern  __attribute__((__nothrow__)) int __j1f128() ;
#line 222
extern  __attribute__((__nothrow__)) int jnf128(int  , int _Float128 ) ;
#line 222
extern  __attribute__((__nothrow__)) int __jnf128(int  , int _Float128 ) ;
#line 223
extern  __attribute__((__nothrow__)) int y0f128() ;
#line 223
extern  __attribute__((__nothrow__)) int __y0f128() ;
#line 224
extern  __attribute__((__nothrow__)) int y1f128() ;
#line 224
extern  __attribute__((__nothrow__)) int __y1f128() ;
#line 225
extern  __attribute__((__nothrow__)) int ynf128(int  , int _Float128 ) ;
#line 225
extern  __attribute__((__nothrow__)) int __ynf128(int  , int _Float128 ) ;
#line 231
extern  __attribute__((__nothrow__)) int erff128() ;
#line 231
extern  __attribute__((__nothrow__)) int __erff128() ;
#line 232
extern  __attribute__((__nothrow__)) int erfcf128() ;
#line 232
extern  __attribute__((__nothrow__)) int __erfcf128() ;
#line 233
extern  __attribute__((__nothrow__)) int lgammaf128() ;
#line 233
extern  __attribute__((__nothrow__)) int __lgammaf128() ;
#line 238
extern  __attribute__((__nothrow__)) int tgammaf128() ;
#line 238
extern  __attribute__((__nothrow__)) int __tgammaf128() ;
#line 252
extern  __attribute__((__nothrow__)) int lgammaf128_r() ;
#line 252
extern  __attribute__((__nothrow__)) int __lgammaf128_r() ;
#line 259
extern  __attribute__((__nothrow__)) int rintf128(int __x ) ;
#line 259
extern  __attribute__((__nothrow__)) int __rintf128(int __x ) ;
#line 262
extern  __attribute__((__nothrow__)) int nextafterf128(int __x , int __y ) ;
#line 262
extern  __attribute__((__nothrow__)) int __nextafterf128(int __x , int __y ) ;
#line 269
extern  __attribute__((__nothrow__)) int nextdownf128(int __x ) ;
#line 269
extern  __attribute__((__nothrow__)) int __nextdownf128(int __x ) ;
#line 271
extern  __attribute__((__nothrow__)) int nextupf128(int __x ) ;
#line 271
extern  __attribute__((__nothrow__)) int __nextupf128(int __x ) ;
#line 275
extern  __attribute__((__nothrow__)) int remainderf128(int __x , int __y ) ;
#line 275
extern  __attribute__((__nothrow__)) int __remainderf128(int __x , int __y ) ;
#line 279
extern  __attribute__((__nothrow__)) int scalbnf128(int __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) int __scalbnf128(int __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogbf128(int __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogbf128(int __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long llogbf128(int __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long __llogbf128(int __x ) ;
#line 293
extern  __attribute__((__nothrow__)) int scalblnf128(int __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) int __scalblnf128(int __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) int nearbyintf128(int __x ) ;
#line 297
extern  __attribute__((__nothrow__)) int __nearbyintf128(int __x ) ;
#line 301
extern  __attribute__((__nothrow__)) int roundf128(int __x ) ;
#line 301
extern  __attribute__((__nothrow__)) int __roundf128(int __x ) ;
#line 305
extern  __attribute__((__nothrow__)) int truncf128(int __x ) ;
#line 305
extern  __attribute__((__nothrow__)) int __truncf128(int __x ) ;
#line 310
extern  __attribute__((__nothrow__)) int remquof128(int __x , int __y , int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) int __remquof128(int __x , int __y , int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrintf128(int __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrintf128(int __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrintf128(int __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrintf128(int __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lroundf128(int __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lroundf128(int __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llroundf128(int __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llroundf128(int __x ) ;
#line 329
extern  __attribute__((__nothrow__)) int fdimf128(int __x , int __y ) ;
#line 329
extern  __attribute__((__nothrow__)) int __fdimf128(int __x , int __y ) ;
#line 333
extern  __attribute__((__nothrow__)) int fmaxf128(int __x , int __y ) ;
#line 333
extern  __attribute__((__nothrow__)) int __fmaxf128(int __x , int __y ) ;
#line 336
extern  __attribute__((__nothrow__)) int fminf128(int __x , int __y ) ;
#line 336
extern  __attribute__((__nothrow__)) int __fminf128(int __x , int __y ) ;
#line 340
extern  __attribute__((__nothrow__)) int fmaf128(int __x , int __y , int __z ) ;
#line 340
extern  __attribute__((__nothrow__)) int __fmaf128(int __x , int __y , int __z ) ;
#line 345
extern  __attribute__((__nothrow__)) int roundevenf128(int __x ) ;
#line 345
extern  __attribute__((__nothrow__)) int __roundevenf128(int __x ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t fromfpf128(int __x , int __round ,
                                                           unsigned int __width ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t __fromfpf128(int __x , int __round ,
                                                             unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpf128(int __x , int __round ,
                                                             unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpf128(int __x , int __round ,
                                                               unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t fromfpxf128(int __x , int __round ,
                                                            unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t __fromfpxf128(int __x , int __round ,
                                                              unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpxf128(int __x , int __round ,
                                                              unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpxf128(int __x , int __round ,
                                                                unsigned int __width ) ;
#line 370
extern  __attribute__((__nothrow__)) int canonicalizef128(int *__cx , int const   *__x ) ;
#line 377
extern  __attribute__((__nothrow__)) int fmaxmagf128(int __x , int __y ) ;
#line 377
extern  __attribute__((__nothrow__)) int __fmaxmagf128(int __x , int __y ) ;
#line 380
extern  __attribute__((__nothrow__)) int fminmagf128(int __x , int __y ) ;
#line 380
extern  __attribute__((__nothrow__)) int __fminmagf128(int __x , int __y ) ;
#line 385
extern  __attribute__((__nothrow__)) int fmaximumf128(int __x , int __y ) ;
#line 385
extern  __attribute__((__nothrow__)) int __fmaximumf128(int __x , int __y ) ;
#line 388
extern  __attribute__((__nothrow__)) int fminimumf128(int __x , int __y ) ;
#line 388
extern  __attribute__((__nothrow__)) int __fminimumf128(int __x , int __y ) ;
#line 391
extern  __attribute__((__nothrow__)) int fmaximum_numf128(int __x , int __y ) ;
#line 391
extern  __attribute__((__nothrow__)) int __fmaximum_numf128(int __x , int __y ) ;
#line 394
extern  __attribute__((__nothrow__)) int fminimum_numf128(int __x , int __y ) ;
#line 394
extern  __attribute__((__nothrow__)) int __fminimum_numf128(int __x , int __y ) ;
#line 397
extern  __attribute__((__nothrow__)) int fmaximum_magf128(int __x , int __y ) ;
#line 397
extern  __attribute__((__nothrow__)) int __fmaximum_magf128(int __x , int __y ) ;
#line 400
extern  __attribute__((__nothrow__)) int fminimum_magf128(int __x , int __y ) ;
#line 400
extern  __attribute__((__nothrow__)) int __fminimum_magf128(int __x , int __y ) ;
#line 403
extern  __attribute__((__nothrow__)) int fmaximum_mag_numf128(int __x , int __y ) ;
#line 403
extern  __attribute__((__nothrow__)) int __fmaximum_mag_numf128(int __x , int __y ) ;
#line 406
extern  __attribute__((__nothrow__)) int fminimum_mag_numf128(int __x , int __y ) ;
#line 406
extern  __attribute__((__nothrow__)) int __fminimum_mag_numf128(int __x , int __y ) ;
#line 411
extern  __attribute__((__nothrow__)) int totalorderf128(int const   *__x , int const   *__y ) ;
#line 416
extern  __attribute__((__nothrow__)) int totalordermagf128(int const   *__x , int const   *__y ) ;
#line 421
extern  __attribute__((__nothrow__)) int getpayloadf128(int const   *__x ) ;
#line 421
extern  __attribute__((__nothrow__)) int __getpayloadf128(int const   *__x ) ;
#line 424
extern  __attribute__((__nothrow__)) int setpayloadf128(int *__x , int __payload ) ;
#line 427
extern  __attribute__((__nothrow__)) int setpayloadsigf128(int *__x , int __payload ) ;
#line 53
extern  __attribute__((__nothrow__)) int acosf32x(int __x ) ;
#line 53
extern  __attribute__((__nothrow__)) int __acosf32x(int __x ) ;
#line 55
extern  __attribute__((__nothrow__)) int asinf32x(int __x ) ;
#line 55
extern  __attribute__((__nothrow__)) int __asinf32x(int __x ) ;
#line 57
extern  __attribute__((__nothrow__)) int atanf32x(int __x ) ;
#line 57
extern  __attribute__((__nothrow__)) int __atanf32x(int __x ) ;
#line 59
extern  __attribute__((__nothrow__)) int atan2f32x(int __y , int __x ) ;
#line 59
extern  __attribute__((__nothrow__)) int __atan2f32x(int __y , int __x ) ;
#line 62
extern  __attribute__((__nothrow__)) int cosf32x(int __x ) ;
#line 62
extern  __attribute__((__nothrow__)) int __cosf32x(int __x ) ;
#line 64
extern  __attribute__((__nothrow__)) int sinf32x(int __x ) ;
#line 64
extern  __attribute__((__nothrow__)) int __sinf32x(int __x ) ;
#line 66
extern  __attribute__((__nothrow__)) int tanf32x(int __x ) ;
#line 66
extern  __attribute__((__nothrow__)) int __tanf32x(int __x ) ;
#line 71
extern  __attribute__((__nothrow__)) int coshf32x(int __x ) ;
#line 71
extern  __attribute__((__nothrow__)) int __coshf32x(int __x ) ;
#line 73
extern  __attribute__((__nothrow__)) int sinhf32x(int __x ) ;
#line 73
extern  __attribute__((__nothrow__)) int __sinhf32x(int __x ) ;
#line 75
extern  __attribute__((__nothrow__)) int tanhf32x(int __x ) ;
#line 75
extern  __attribute__((__nothrow__)) int __tanhf32x(int __x ) ;
#line 79
extern  __attribute__((__nothrow__)) void sincosf32x(int __x , int *__sinx , int *__cosx ) ;
#line 79
extern  __attribute__((__nothrow__)) void __sincosf32x(int __x , int *__sinx , int *__cosx ) ;
#line 85
extern  __attribute__((__nothrow__)) int acoshf32x(int __x ) ;
#line 85
extern  __attribute__((__nothrow__)) int __acoshf32x(int __x ) ;
#line 87
extern  __attribute__((__nothrow__)) int asinhf32x(int __x ) ;
#line 87
extern  __attribute__((__nothrow__)) int __asinhf32x(int __x ) ;
#line 89
extern  __attribute__((__nothrow__)) int atanhf32x(int __x ) ;
#line 89
extern  __attribute__((__nothrow__)) int __atanhf32x(int __x ) ;
#line 95
extern  __attribute__((__nothrow__)) int expf32x(int __x ) ;
#line 95
extern  __attribute__((__nothrow__)) int __expf32x(int __x ) ;
#line 98
extern  __attribute__((__nothrow__)) int frexpf32x(int __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) int __frexpf32x(int __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) int ldexpf32x(int __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) int __ldexpf32x(int __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) int logf32x(int __x ) ;
#line 104
extern  __attribute__((__nothrow__)) int __logf32x(int __x ) ;
#line 107
extern  __attribute__((__nothrow__)) int log10f32x(int __x ) ;
#line 107
extern  __attribute__((__nothrow__)) int __log10f32x(int __x ) ;
#line 110
extern  __attribute__((__nothrow__)) int modff32x(int __x , int *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) int __modff32x(int __x , int *__iptr ) ;
#line 114
extern  __attribute__((__nothrow__)) int exp10f32x(int __x ) ;
#line 114
extern  __attribute__((__nothrow__)) int __exp10f32x(int __x ) ;
#line 119
extern  __attribute__((__nothrow__)) int expm1f32x(int __x ) ;
#line 119
extern  __attribute__((__nothrow__)) int __expm1f32x(int __x ) ;
#line 122
extern  __attribute__((__nothrow__)) int log1pf32x(int __x ) ;
#line 122
extern  __attribute__((__nothrow__)) int __log1pf32x(int __x ) ;
#line 125
extern  __attribute__((__nothrow__)) int logbf32x(int __x ) ;
#line 125
extern  __attribute__((__nothrow__)) int __logbf32x(int __x ) ;
#line 130
extern  __attribute__((__nothrow__)) int exp2f32x(int __x ) ;
#line 130
extern  __attribute__((__nothrow__)) int __exp2f32x(int __x ) ;
#line 133
extern  __attribute__((__nothrow__)) int log2f32x(int __x ) ;
#line 133
extern  __attribute__((__nothrow__)) int __log2f32x(int __x ) ;
#line 140
extern  __attribute__((__nothrow__)) int powf32x(int __x , int __y ) ;
#line 140
extern  __attribute__((__nothrow__)) int __powf32x(int __x , int __y ) ;
#line 143
extern  __attribute__((__nothrow__)) int sqrtf32x(int __x ) ;
#line 143
extern  __attribute__((__nothrow__)) int __sqrtf32x(int __x ) ;
#line 147
extern  __attribute__((__nothrow__)) int hypotf32x(int __x , int __y ) ;
#line 147
extern  __attribute__((__nothrow__)) int __hypotf32x(int __x , int __y ) ;
#line 152
extern  __attribute__((__nothrow__)) int cbrtf32x(int __x ) ;
#line 152
extern  __attribute__((__nothrow__)) int __cbrtf32x(int __x ) ;
#line 159
extern  __attribute__((__nothrow__)) int ceilf32x(int __x ) ;
#line 159
extern  __attribute__((__nothrow__)) int __ceilf32x(int __x ) ;
#line 162
extern  __attribute__((__nothrow__)) int fabsf32x(int __x ) ;
#line 162
extern  __attribute__((__nothrow__)) int __fabsf32x(int __x ) ;
#line 165
extern  __attribute__((__nothrow__)) int floorf32x(int __x ) ;
#line 165
extern  __attribute__((__nothrow__)) int __floorf32x(int __x ) ;
#line 168
extern  __attribute__((__nothrow__)) int fmodf32x(int __x , int __y ) ;
#line 168
extern  __attribute__((__nothrow__)) int __fmodf32x(int __x , int __y ) ;
#line 198
extern  __attribute__((__nothrow__)) int copysignf32x(int __x , int __y ) ;
#line 198
extern  __attribute__((__nothrow__)) int __copysignf32x(int __x , int __y ) ;
#line 203
extern  __attribute__((__nothrow__)) int nanf32x(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) int __nanf32x(char const   *__tagb ) ;
#line 220
extern  __attribute__((__nothrow__)) int j0f32x() ;
#line 220
extern  __attribute__((__nothrow__)) int __j0f32x() ;
#line 221
extern  __attribute__((__nothrow__)) int j1f32x() ;
#line 221
extern  __attribute__((__nothrow__)) int __j1f32x() ;
#line 222
extern  __attribute__((__nothrow__)) int jnf32x(int  , int _Float32x ) ;
#line 222
extern  __attribute__((__nothrow__)) int __jnf32x(int  , int _Float32x ) ;
#line 223
extern  __attribute__((__nothrow__)) int y0f32x() ;
#line 223
extern  __attribute__((__nothrow__)) int __y0f32x() ;
#line 224
extern  __attribute__((__nothrow__)) int y1f32x() ;
#line 224
extern  __attribute__((__nothrow__)) int __y1f32x() ;
#line 225
extern  __attribute__((__nothrow__)) int ynf32x(int  , int _Float32x ) ;
#line 225
extern  __attribute__((__nothrow__)) int __ynf32x(int  , int _Float32x ) ;
#line 231
extern  __attribute__((__nothrow__)) int erff32x() ;
#line 231
extern  __attribute__((__nothrow__)) int __erff32x() ;
#line 232
extern  __attribute__((__nothrow__)) int erfcf32x() ;
#line 232
extern  __attribute__((__nothrow__)) int __erfcf32x() ;
#line 233
extern  __attribute__((__nothrow__)) int lgammaf32x() ;
#line 233
extern  __attribute__((__nothrow__)) int __lgammaf32x() ;
#line 238
extern  __attribute__((__nothrow__)) int tgammaf32x() ;
#line 238
extern  __attribute__((__nothrow__)) int __tgammaf32x() ;
#line 252
extern  __attribute__((__nothrow__)) int lgammaf32x_r() ;
#line 252
extern  __attribute__((__nothrow__)) int __lgammaf32x_r() ;
#line 259
extern  __attribute__((__nothrow__)) int rintf32x(int __x ) ;
#line 259
extern  __attribute__((__nothrow__)) int __rintf32x(int __x ) ;
#line 262
extern  __attribute__((__nothrow__)) int nextafterf32x(int __x , int __y ) ;
#line 262
extern  __attribute__((__nothrow__)) int __nextafterf32x(int __x , int __y ) ;
#line 269
extern  __attribute__((__nothrow__)) int nextdownf32x(int __x ) ;
#line 269
extern  __attribute__((__nothrow__)) int __nextdownf32x(int __x ) ;
#line 271
extern  __attribute__((__nothrow__)) int nextupf32x(int __x ) ;
#line 271
extern  __attribute__((__nothrow__)) int __nextupf32x(int __x ) ;
#line 275
extern  __attribute__((__nothrow__)) int remainderf32x(int __x , int __y ) ;
#line 275
extern  __attribute__((__nothrow__)) int __remainderf32x(int __x , int __y ) ;
#line 279
extern  __attribute__((__nothrow__)) int scalbnf32x(int __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) int __scalbnf32x(int __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogbf32x(int __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogbf32x(int __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long llogbf32x(int __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long __llogbf32x(int __x ) ;
#line 293
extern  __attribute__((__nothrow__)) int scalblnf32x(int __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) int __scalblnf32x(int __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) int nearbyintf32x(int __x ) ;
#line 297
extern  __attribute__((__nothrow__)) int __nearbyintf32x(int __x ) ;
#line 301
extern  __attribute__((__nothrow__)) int roundf32x(int __x ) ;
#line 301
extern  __attribute__((__nothrow__)) int __roundf32x(int __x ) ;
#line 305
extern  __attribute__((__nothrow__)) int truncf32x(int __x ) ;
#line 305
extern  __attribute__((__nothrow__)) int __truncf32x(int __x ) ;
#line 310
extern  __attribute__((__nothrow__)) int remquof32x(int __x , int __y , int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) int __remquof32x(int __x , int __y , int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrintf32x(int __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrintf32x(int __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrintf32x(int __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrintf32x(int __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lroundf32x(int __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lroundf32x(int __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llroundf32x(int __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llroundf32x(int __x ) ;
#line 329
extern  __attribute__((__nothrow__)) int fdimf32x(int __x , int __y ) ;
#line 329
extern  __attribute__((__nothrow__)) int __fdimf32x(int __x , int __y ) ;
#line 333
extern  __attribute__((__nothrow__)) int fmaxf32x(int __x , int __y ) ;
#line 333
extern  __attribute__((__nothrow__)) int __fmaxf32x(int __x , int __y ) ;
#line 336
extern  __attribute__((__nothrow__)) int fminf32x(int __x , int __y ) ;
#line 336
extern  __attribute__((__nothrow__)) int __fminf32x(int __x , int __y ) ;
#line 340
extern  __attribute__((__nothrow__)) int fmaf32x(int __x , int __y , int __z ) ;
#line 340
extern  __attribute__((__nothrow__)) int __fmaf32x(int __x , int __y , int __z ) ;
#line 345
extern  __attribute__((__nothrow__)) int roundevenf32x(int __x ) ;
#line 345
extern  __attribute__((__nothrow__)) int __roundevenf32x(int __x ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t fromfpf32x(int __x , int __round ,
                                                           unsigned int __width ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t __fromfpf32x(int __x , int __round ,
                                                             unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpf32x(int __x , int __round ,
                                                             unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpf32x(int __x , int __round ,
                                                               unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t fromfpxf32x(int __x , int __round ,
                                                            unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t __fromfpxf32x(int __x , int __round ,
                                                              unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpxf32x(int __x , int __round ,
                                                              unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpxf32x(int __x , int __round ,
                                                                unsigned int __width ) ;
#line 370
extern  __attribute__((__nothrow__)) int canonicalizef32x(int *__cx , int const   *__x ) ;
#line 377
extern  __attribute__((__nothrow__)) int fmaxmagf32x(int __x , int __y ) ;
#line 377
extern  __attribute__((__nothrow__)) int __fmaxmagf32x(int __x , int __y ) ;
#line 380
extern  __attribute__((__nothrow__)) int fminmagf32x(int __x , int __y ) ;
#line 380
extern  __attribute__((__nothrow__)) int __fminmagf32x(int __x , int __y ) ;
#line 385
extern  __attribute__((__nothrow__)) int fmaximumf32x(int __x , int __y ) ;
#line 385
extern  __attribute__((__nothrow__)) int __fmaximumf32x(int __x , int __y ) ;
#line 388
extern  __attribute__((__nothrow__)) int fminimumf32x(int __x , int __y ) ;
#line 388
extern  __attribute__((__nothrow__)) int __fminimumf32x(int __x , int __y ) ;
#line 391
extern  __attribute__((__nothrow__)) int fmaximum_numf32x(int __x , int __y ) ;
#line 391
extern  __attribute__((__nothrow__)) int __fmaximum_numf32x(int __x , int __y ) ;
#line 394
extern  __attribute__((__nothrow__)) int fminimum_numf32x(int __x , int __y ) ;
#line 394
extern  __attribute__((__nothrow__)) int __fminimum_numf32x(int __x , int __y ) ;
#line 397
extern  __attribute__((__nothrow__)) int fmaximum_magf32x(int __x , int __y ) ;
#line 397
extern  __attribute__((__nothrow__)) int __fmaximum_magf32x(int __x , int __y ) ;
#line 400
extern  __attribute__((__nothrow__)) int fminimum_magf32x(int __x , int __y ) ;
#line 400
extern  __attribute__((__nothrow__)) int __fminimum_magf32x(int __x , int __y ) ;
#line 403
extern  __attribute__((__nothrow__)) int fmaximum_mag_numf32x(int __x , int __y ) ;
#line 403
extern  __attribute__((__nothrow__)) int __fmaximum_mag_numf32x(int __x , int __y ) ;
#line 406
extern  __attribute__((__nothrow__)) int fminimum_mag_numf32x(int __x , int __y ) ;
#line 406
extern  __attribute__((__nothrow__)) int __fminimum_mag_numf32x(int __x , int __y ) ;
#line 411
extern  __attribute__((__nothrow__)) int totalorderf32x(int const   *__x , int const   *__y ) ;
#line 416
extern  __attribute__((__nothrow__)) int totalordermagf32x(int const   *__x , int const   *__y ) ;
#line 421
extern  __attribute__((__nothrow__)) int getpayloadf32x(int const   *__x ) ;
#line 421
extern  __attribute__((__nothrow__)) int __getpayloadf32x(int const   *__x ) ;
#line 424
extern  __attribute__((__nothrow__)) int setpayloadf32x(int *__x , int __payload ) ;
#line 427
extern  __attribute__((__nothrow__)) int setpayloadsigf32x(int *__x , int __payload ) ;
#line 53
extern  __attribute__((__nothrow__)) int acosf64x(int __x ) ;
#line 53
extern  __attribute__((__nothrow__)) int __acosf64x(int __x ) ;
#line 55
extern  __attribute__((__nothrow__)) int asinf64x(int __x ) ;
#line 55
extern  __attribute__((__nothrow__)) int __asinf64x(int __x ) ;
#line 57
extern  __attribute__((__nothrow__)) int atanf64x(int __x ) ;
#line 57
extern  __attribute__((__nothrow__)) int __atanf64x(int __x ) ;
#line 59
extern  __attribute__((__nothrow__)) int atan2f64x(int __y , int __x ) ;
#line 59
extern  __attribute__((__nothrow__)) int __atan2f64x(int __y , int __x ) ;
#line 62
extern  __attribute__((__nothrow__)) int cosf64x(int __x ) ;
#line 62
extern  __attribute__((__nothrow__)) int __cosf64x(int __x ) ;
#line 64
extern  __attribute__((__nothrow__)) int sinf64x(int __x ) ;
#line 64
extern  __attribute__((__nothrow__)) int __sinf64x(int __x ) ;
#line 66
extern  __attribute__((__nothrow__)) int tanf64x(int __x ) ;
#line 66
extern  __attribute__((__nothrow__)) int __tanf64x(int __x ) ;
#line 71
extern  __attribute__((__nothrow__)) int coshf64x(int __x ) ;
#line 71
extern  __attribute__((__nothrow__)) int __coshf64x(int __x ) ;
#line 73
extern  __attribute__((__nothrow__)) int sinhf64x(int __x ) ;
#line 73
extern  __attribute__((__nothrow__)) int __sinhf64x(int __x ) ;
#line 75
extern  __attribute__((__nothrow__)) int tanhf64x(int __x ) ;
#line 75
extern  __attribute__((__nothrow__)) int __tanhf64x(int __x ) ;
#line 79
extern  __attribute__((__nothrow__)) void sincosf64x(int __x , int *__sinx , int *__cosx ) ;
#line 79
extern  __attribute__((__nothrow__)) void __sincosf64x(int __x , int *__sinx , int *__cosx ) ;
#line 85
extern  __attribute__((__nothrow__)) int acoshf64x(int __x ) ;
#line 85
extern  __attribute__((__nothrow__)) int __acoshf64x(int __x ) ;
#line 87
extern  __attribute__((__nothrow__)) int asinhf64x(int __x ) ;
#line 87
extern  __attribute__((__nothrow__)) int __asinhf64x(int __x ) ;
#line 89
extern  __attribute__((__nothrow__)) int atanhf64x(int __x ) ;
#line 89
extern  __attribute__((__nothrow__)) int __atanhf64x(int __x ) ;
#line 95
extern  __attribute__((__nothrow__)) int expf64x(int __x ) ;
#line 95
extern  __attribute__((__nothrow__)) int __expf64x(int __x ) ;
#line 98
extern  __attribute__((__nothrow__)) int frexpf64x(int __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) int __frexpf64x(int __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) int ldexpf64x(int __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) int __ldexpf64x(int __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) int logf64x(int __x ) ;
#line 104
extern  __attribute__((__nothrow__)) int __logf64x(int __x ) ;
#line 107
extern  __attribute__((__nothrow__)) int log10f64x(int __x ) ;
#line 107
extern  __attribute__((__nothrow__)) int __log10f64x(int __x ) ;
#line 110
extern  __attribute__((__nothrow__)) int modff64x(int __x , int *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) int __modff64x(int __x , int *__iptr ) ;
#line 114
extern  __attribute__((__nothrow__)) int exp10f64x(int __x ) ;
#line 114
extern  __attribute__((__nothrow__)) int __exp10f64x(int __x ) ;
#line 119
extern  __attribute__((__nothrow__)) int expm1f64x(int __x ) ;
#line 119
extern  __attribute__((__nothrow__)) int __expm1f64x(int __x ) ;
#line 122
extern  __attribute__((__nothrow__)) int log1pf64x(int __x ) ;
#line 122
extern  __attribute__((__nothrow__)) int __log1pf64x(int __x ) ;
#line 125
extern  __attribute__((__nothrow__)) int logbf64x(int __x ) ;
#line 125
extern  __attribute__((__nothrow__)) int __logbf64x(int __x ) ;
#line 130
extern  __attribute__((__nothrow__)) int exp2f64x(int __x ) ;
#line 130
extern  __attribute__((__nothrow__)) int __exp2f64x(int __x ) ;
#line 133
extern  __attribute__((__nothrow__)) int log2f64x(int __x ) ;
#line 133
extern  __attribute__((__nothrow__)) int __log2f64x(int __x ) ;
#line 140
extern  __attribute__((__nothrow__)) int powf64x(int __x , int __y ) ;
#line 140
extern  __attribute__((__nothrow__)) int __powf64x(int __x , int __y ) ;
#line 143
extern  __attribute__((__nothrow__)) int sqrtf64x(int __x ) ;
#line 143
extern  __attribute__((__nothrow__)) int __sqrtf64x(int __x ) ;
#line 147
extern  __attribute__((__nothrow__)) int hypotf64x(int __x , int __y ) ;
#line 147
extern  __attribute__((__nothrow__)) int __hypotf64x(int __x , int __y ) ;
#line 152
extern  __attribute__((__nothrow__)) int cbrtf64x(int __x ) ;
#line 152
extern  __attribute__((__nothrow__)) int __cbrtf64x(int __x ) ;
#line 159
extern  __attribute__((__nothrow__)) int ceilf64x(int __x ) ;
#line 159
extern  __attribute__((__nothrow__)) int __ceilf64x(int __x ) ;
#line 162
extern  __attribute__((__nothrow__)) int fabsf64x(int __x ) ;
#line 162
extern  __attribute__((__nothrow__)) int __fabsf64x(int __x ) ;
#line 165
extern  __attribute__((__nothrow__)) int floorf64x(int __x ) ;
#line 165
extern  __attribute__((__nothrow__)) int __floorf64x(int __x ) ;
#line 168
extern  __attribute__((__nothrow__)) int fmodf64x(int __x , int __y ) ;
#line 168
extern  __attribute__((__nothrow__)) int __fmodf64x(int __x , int __y ) ;
#line 198
extern  __attribute__((__nothrow__)) int copysignf64x(int __x , int __y ) ;
#line 198
extern  __attribute__((__nothrow__)) int __copysignf64x(int __x , int __y ) ;
#line 203
extern  __attribute__((__nothrow__)) int nanf64x(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) int __nanf64x(char const   *__tagb ) ;
#line 220
extern  __attribute__((__nothrow__)) int j0f64x() ;
#line 220
extern  __attribute__((__nothrow__)) int __j0f64x() ;
#line 221
extern  __attribute__((__nothrow__)) int j1f64x() ;
#line 221
extern  __attribute__((__nothrow__)) int __j1f64x() ;
#line 222
extern  __attribute__((__nothrow__)) int jnf64x(int  , int _Float64x ) ;
#line 222
extern  __attribute__((__nothrow__)) int __jnf64x(int  , int _Float64x ) ;
#line 223
extern  __attribute__((__nothrow__)) int y0f64x() ;
#line 223
extern  __attribute__((__nothrow__)) int __y0f64x() ;
#line 224
extern  __attribute__((__nothrow__)) int y1f64x() ;
#line 224
extern  __attribute__((__nothrow__)) int __y1f64x() ;
#line 225
extern  __attribute__((__nothrow__)) int ynf64x(int  , int _Float64x ) ;
#line 225
extern  __attribute__((__nothrow__)) int __ynf64x(int  , int _Float64x ) ;
#line 231
extern  __attribute__((__nothrow__)) int erff64x() ;
#line 231
extern  __attribute__((__nothrow__)) int __erff64x() ;
#line 232
extern  __attribute__((__nothrow__)) int erfcf64x() ;
#line 232
extern  __attribute__((__nothrow__)) int __erfcf64x() ;
#line 233
extern  __attribute__((__nothrow__)) int lgammaf64x() ;
#line 233
extern  __attribute__((__nothrow__)) int __lgammaf64x() ;
#line 238
extern  __attribute__((__nothrow__)) int tgammaf64x() ;
#line 238
extern  __attribute__((__nothrow__)) int __tgammaf64x() ;
#line 252
extern  __attribute__((__nothrow__)) int lgammaf64x_r() ;
#line 252
extern  __attribute__((__nothrow__)) int __lgammaf64x_r() ;
#line 259
extern  __attribute__((__nothrow__)) int rintf64x(int __x ) ;
#line 259
extern  __attribute__((__nothrow__)) int __rintf64x(int __x ) ;
#line 262
extern  __attribute__((__nothrow__)) int nextafterf64x(int __x , int __y ) ;
#line 262
extern  __attribute__((__nothrow__)) int __nextafterf64x(int __x , int __y ) ;
#line 269
extern  __attribute__((__nothrow__)) int nextdownf64x(int __x ) ;
#line 269
extern  __attribute__((__nothrow__)) int __nextdownf64x(int __x ) ;
#line 271
extern  __attribute__((__nothrow__)) int nextupf64x(int __x ) ;
#line 271
extern  __attribute__((__nothrow__)) int __nextupf64x(int __x ) ;
#line 275
extern  __attribute__((__nothrow__)) int remainderf64x(int __x , int __y ) ;
#line 275
extern  __attribute__((__nothrow__)) int __remainderf64x(int __x , int __y ) ;
#line 279
extern  __attribute__((__nothrow__)) int scalbnf64x(int __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) int __scalbnf64x(int __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogbf64x(int __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogbf64x(int __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long llogbf64x(int __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long __llogbf64x(int __x ) ;
#line 293
extern  __attribute__((__nothrow__)) int scalblnf64x(int __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) int __scalblnf64x(int __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) int nearbyintf64x(int __x ) ;
#line 297
extern  __attribute__((__nothrow__)) int __nearbyintf64x(int __x ) ;
#line 301
extern  __attribute__((__nothrow__)) int roundf64x(int __x ) ;
#line 301
extern  __attribute__((__nothrow__)) int __roundf64x(int __x ) ;
#line 305
extern  __attribute__((__nothrow__)) int truncf64x(int __x ) ;
#line 305
extern  __attribute__((__nothrow__)) int __truncf64x(int __x ) ;
#line 310
extern  __attribute__((__nothrow__)) int remquof64x(int __x , int __y , int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) int __remquof64x(int __x , int __y , int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrintf64x(int __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrintf64x(int __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrintf64x(int __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrintf64x(int __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lroundf64x(int __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lroundf64x(int __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llroundf64x(int __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llroundf64x(int __x ) ;
#line 329
extern  __attribute__((__nothrow__)) int fdimf64x(int __x , int __y ) ;
#line 329
extern  __attribute__((__nothrow__)) int __fdimf64x(int __x , int __y ) ;
#line 333
extern  __attribute__((__nothrow__)) int fmaxf64x(int __x , int __y ) ;
#line 333
extern  __attribute__((__nothrow__)) int __fmaxf64x(int __x , int __y ) ;
#line 336
extern  __attribute__((__nothrow__)) int fminf64x(int __x , int __y ) ;
#line 336
extern  __attribute__((__nothrow__)) int __fminf64x(int __x , int __y ) ;
#line 340
extern  __attribute__((__nothrow__)) int fmaf64x(int __x , int __y , int __z ) ;
#line 340
extern  __attribute__((__nothrow__)) int __fmaf64x(int __x , int __y , int __z ) ;
#line 345
extern  __attribute__((__nothrow__)) int roundevenf64x(int __x ) ;
#line 345
extern  __attribute__((__nothrow__)) int __roundevenf64x(int __x ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t fromfpf64x(int __x , int __round ,
                                                           unsigned int __width ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t __fromfpf64x(int __x , int __round ,
                                                             unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpf64x(int __x , int __round ,
                                                             unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpf64x(int __x , int __round ,
                                                               unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t fromfpxf64x(int __x , int __round ,
                                                            unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t __fromfpxf64x(int __x , int __round ,
                                                              unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpxf64x(int __x , int __round ,
                                                              unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpxf64x(int __x , int __round ,
                                                                unsigned int __width ) ;
#line 370
extern  __attribute__((__nothrow__)) int canonicalizef64x(int *__cx , int const   *__x ) ;
#line 377
extern  __attribute__((__nothrow__)) int fmaxmagf64x(int __x , int __y ) ;
#line 377
extern  __attribute__((__nothrow__)) int __fmaxmagf64x(int __x , int __y ) ;
#line 380
extern  __attribute__((__nothrow__)) int fminmagf64x(int __x , int __y ) ;
#line 380
extern  __attribute__((__nothrow__)) int __fminmagf64x(int __x , int __y ) ;
#line 385
extern  __attribute__((__nothrow__)) int fmaximumf64x(int __x , int __y ) ;
#line 385
extern  __attribute__((__nothrow__)) int __fmaximumf64x(int __x , int __y ) ;
#line 388
extern  __attribute__((__nothrow__)) int fminimumf64x(int __x , int __y ) ;
#line 388
extern  __attribute__((__nothrow__)) int __fminimumf64x(int __x , int __y ) ;
#line 391
extern  __attribute__((__nothrow__)) int fmaximum_numf64x(int __x , int __y ) ;
#line 391
extern  __attribute__((__nothrow__)) int __fmaximum_numf64x(int __x , int __y ) ;
#line 394
extern  __attribute__((__nothrow__)) int fminimum_numf64x(int __x , int __y ) ;
#line 394
extern  __attribute__((__nothrow__)) int __fminimum_numf64x(int __x , int __y ) ;
#line 397
extern  __attribute__((__nothrow__)) int fmaximum_magf64x(int __x , int __y ) ;
#line 397
extern  __attribute__((__nothrow__)) int __fmaximum_magf64x(int __x , int __y ) ;
#line 400
extern  __attribute__((__nothrow__)) int fminimum_magf64x(int __x , int __y ) ;
#line 400
extern  __attribute__((__nothrow__)) int __fminimum_magf64x(int __x , int __y ) ;
#line 403
extern  __attribute__((__nothrow__)) int fmaximum_mag_numf64x(int __x , int __y ) ;
#line 403
extern  __attribute__((__nothrow__)) int __fmaximum_mag_numf64x(int __x , int __y ) ;
#line 406
extern  __attribute__((__nothrow__)) int fminimum_mag_numf64x(int __x , int __y ) ;
#line 406
extern  __attribute__((__nothrow__)) int __fminimum_mag_numf64x(int __x , int __y ) ;
#line 411
extern  __attribute__((__nothrow__)) int totalorderf64x(int const   *__x , int const   *__y ) ;
#line 416
extern  __attribute__((__nothrow__)) int totalordermagf64x(int const   *__x , int const   *__y ) ;
#line 421
extern  __attribute__((__nothrow__)) int getpayloadf64x(int const   *__x ) ;
#line 421
extern  __attribute__((__nothrow__)) int __getpayloadf64x(int const   *__x ) ;
#line 424
extern  __attribute__((__nothrow__)) int setpayloadf64x(int *__x , int __payload ) ;
#line 427
extern  __attribute__((__nothrow__)) int setpayloadsigf64x(int *__x , int __payload ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h"
extern  __attribute__((__nothrow__)) float fadd(double __x , double __y ) ;
#line 27
extern  __attribute__((__nothrow__)) float fdiv(double __x , double __y ) ;
#line 30
extern  __attribute__((__nothrow__)) float ffma(double __x , double __y , double __z ) ;
#line 33
extern  __attribute__((__nothrow__)) float fmul(double __x , double __y ) ;
#line 36
extern  __attribute__((__nothrow__)) float fsqrt(double __x ) ;
#line 39
extern  __attribute__((__nothrow__)) float fsub(double __x , double __y ) ;
#line 24
extern  __attribute__((__nothrow__)) float faddl(long double __x , long double __y ) ;
#line 27
extern  __attribute__((__nothrow__)) float fdivl(long double __x , long double __y ) ;
#line 30
extern  __attribute__((__nothrow__)) float ffmal(long double __x , long double __y ,
                                                 long double __z ) ;
#line 33
extern  __attribute__((__nothrow__)) float fmull(long double __x , long double __y ) ;
#line 36
extern  __attribute__((__nothrow__)) float fsqrtl(long double __x ) ;
#line 39
extern  __attribute__((__nothrow__)) float fsubl(long double __x , long double __y ) ;
#line 24
extern  __attribute__((__nothrow__)) double daddl(long double __x , long double __y ) ;
#line 27
extern  __attribute__((__nothrow__)) double ddivl(long double __x , long double __y ) ;
#line 30
extern  __attribute__((__nothrow__)) double dfmal(long double __x , long double __y ,
                                                  long double __z ) ;
#line 33
extern  __attribute__((__nothrow__)) double dmull(long double __x , long double __y ) ;
#line 36
extern  __attribute__((__nothrow__)) double dsqrtl(long double __x ) ;
#line 39
extern  __attribute__((__nothrow__)) double dsubl(long double __x , long double __y ) ;
#line 24
extern  __attribute__((__nothrow__)) int f32addf32x(int __x , int __y ) ;
#line 27
extern  __attribute__((__nothrow__)) int f32divf32x(int __x , int __y ) ;
#line 30
extern  __attribute__((__nothrow__)) int f32fmaf32x(int __x , int __y , int __z ) ;
#line 33
extern  __attribute__((__nothrow__)) int f32mulf32x(int __x , int __y ) ;
#line 36
extern  __attribute__((__nothrow__)) int f32sqrtf32x(int __x ) ;
#line 39
extern  __attribute__((__nothrow__)) int f32subf32x(int __x , int __y ) ;
#line 24
extern  __attribute__((__nothrow__)) int f32addf64(int __x , int __y ) ;
#line 27
extern  __attribute__((__nothrow__)) int f32divf64(int __x , int __y ) ;
#line 30
extern  __attribute__((__nothrow__)) int f32fmaf64(int __x , int __y , int __z ) ;
#line 33
extern  __attribute__((__nothrow__)) int f32mulf64(int __x , int __y ) ;
#line 36
extern  __attribute__((__nothrow__)) int f32sqrtf64(int __x ) ;
#line 39
extern  __attribute__((__nothrow__)) int f32subf64(int __x , int __y ) ;
#line 24
extern  __attribute__((__nothrow__)) int f32addf64x(int __x , int __y ) ;
#line 27
extern  __attribute__((__nothrow__)) int f32divf64x(int __x , int __y ) ;
#line 30
extern  __attribute__((__nothrow__)) int f32fmaf64x(int __x , int __y , int __z ) ;
#line 33
extern  __attribute__((__nothrow__)) int f32mulf64x(int __x , int __y ) ;
#line 36
extern  __attribute__((__nothrow__)) int f32sqrtf64x(int __x ) ;
#line 39
extern  __attribute__((__nothrow__)) int f32subf64x(int __x , int __y ) ;
#line 24
extern  __attribute__((__nothrow__)) int f32addf128(int __x , int __y ) ;
#line 27
extern  __attribute__((__nothrow__)) int f32divf128(int __x , int __y ) ;
#line 30
extern  __attribute__((__nothrow__)) int f32fmaf128(int __x , int __y , int __z ) ;
#line 33
extern  __attribute__((__nothrow__)) int f32mulf128(int __x , int __y ) ;
#line 36
extern  __attribute__((__nothrow__)) int f32sqrtf128(int __x ) ;
#line 39
extern  __attribute__((__nothrow__)) int f32subf128(int __x , int __y ) ;
#line 24
extern  __attribute__((__nothrow__)) int f32xaddf64(int __x , int __y ) ;
#line 27
extern  __attribute__((__nothrow__)) int f32xdivf64(int __x , int __y ) ;
#line 30
extern  __attribute__((__nothrow__)) int f32xfmaf64(int __x , int __y , int __z ) ;
#line 33
extern  __attribute__((__nothrow__)) int f32xmulf64(int __x , int __y ) ;
#line 36
extern  __attribute__((__nothrow__)) int f32xsqrtf64(int __x ) ;
#line 39
extern  __attribute__((__nothrow__)) int f32xsubf64(int __x , int __y ) ;
#line 24
extern  __attribute__((__nothrow__)) int f32xaddf64x(int __x , int __y ) ;
#line 27
extern  __attribute__((__nothrow__)) int f32xdivf64x(int __x , int __y ) ;
#line 30
extern  __attribute__((__nothrow__)) int f32xfmaf64x(int __x , int __y , int __z ) ;
#line 33
extern  __attribute__((__nothrow__)) int f32xmulf64x(int __x , int __y ) ;
#line 36
extern  __attribute__((__nothrow__)) int f32xsqrtf64x(int __x ) ;
#line 39
extern  __attribute__((__nothrow__)) int f32xsubf64x(int __x , int __y ) ;
#line 24
extern  __attribute__((__nothrow__)) int f32xaddf128(int __x , int __y ) ;
#line 27
extern  __attribute__((__nothrow__)) int f32xdivf128(int __x , int __y ) ;
#line 30
extern  __attribute__((__nothrow__)) int f32xfmaf128(int __x , int __y , int __z ) ;
#line 33
extern  __attribute__((__nothrow__)) int f32xmulf128(int __x , int __y ) ;
#line 36
extern  __attribute__((__nothrow__)) int f32xsqrtf128(int __x ) ;
#line 39
extern  __attribute__((__nothrow__)) int f32xsubf128(int __x , int __y ) ;
#line 24
extern  __attribute__((__nothrow__)) int f64addf64x(int __x , int __y ) ;
#line 27
extern  __attribute__((__nothrow__)) int f64divf64x(int __x , int __y ) ;
#line 30
extern  __attribute__((__nothrow__)) int f64fmaf64x(int __x , int __y , int __z ) ;
#line 33
extern  __attribute__((__nothrow__)) int f64mulf64x(int __x , int __y ) ;
#line 36
extern  __attribute__((__nothrow__)) int f64sqrtf64x(int __x ) ;
#line 39
extern  __attribute__((__nothrow__)) int f64subf64x(int __x , int __y ) ;
#line 24
extern  __attribute__((__nothrow__)) int f64addf128(int __x , int __y ) ;
#line 27
extern  __attribute__((__nothrow__)) int f64divf128(int __x , int __y ) ;
#line 30
extern  __attribute__((__nothrow__)) int f64fmaf128(int __x , int __y , int __z ) ;
#line 33
extern  __attribute__((__nothrow__)) int f64mulf128(int __x , int __y ) ;
#line 36
extern  __attribute__((__nothrow__)) int f64sqrtf128(int __x ) ;
#line 39
extern  __attribute__((__nothrow__)) int f64subf128(int __x , int __y ) ;
#line 24
extern  __attribute__((__nothrow__)) int f64xaddf128(int __x , int __y ) ;
#line 27
extern  __attribute__((__nothrow__)) int f64xdivf128(int __x , int __y ) ;
#line 30
extern  __attribute__((__nothrow__)) int f64xfmaf128(int __x , int __y , int __z ) ;
#line 33
extern  __attribute__((__nothrow__)) int f64xmulf128(int __x , int __y ) ;
#line 36
extern  __attribute__((__nothrow__)) int f64xsqrtf128(int __x ) ;
#line 39
extern  __attribute__((__nothrow__)) int f64xsubf128(int __x , int __y ) ;
#line 854 "/usr/include/math.h"
extern int signgam ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h"
extern  __attribute__((__nothrow__)) int __iscanonicall(long double __x ) ;
#line 76 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.h"
Preview *preview_new(GSGDialog *dialog___0 ) ;
#line 79
void preview_update(Preview *p ) ;
#line 82
void preview_scan(Preview *p ) ;
#line 85
void preview_destroy(Preview *p ) ;
#line 113 "/root/oss-experiment/data/sane-frontends-1.0.14/src/../include/sane/sanei_debug.h"
int sanei_debug_preview  =    0;
#line 146
static void sanei_debug_preview_call(int level , char const   *msg  , ...) ;
#line 153 "/root/oss-experiment/data/sane-frontends-1.0.14/src/../include/sane/sanei_debug.h"
static void sanei_debug_preview_call(int level , char const   *msg  , ...) 
{ 
  va_list ap ;

  {
  {
#line 157
  __builtin_va_start((void *)ap, msg);
#line 158
  sanei_debug_msg(level, sanei_debug_preview, "preview", msg, (void *)ap);
#line 159
  __builtin_va_end((void *)ap);
  }
  return;
}
}
#line 113 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static void scan_start(Preview *p ) ;
#line 114
static void scan_done(Preview *p ) ;
#line 117 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static void draw_rect(GdkWindow *win , GdkGC *gc , int coord[4] ) 
{ 
  gint x ;
  gint y ;
  gint w ;
  gint h ;

  {
#line 121
  x = coord[0];
#line 122
  y = coord[1];
#line 123
  w = coord[2] - x;
#line 124
  h = coord[3] - y;
#line 125
  if (w < 0) {
#line 127
    x = coord[2];
#line 128
    w = - w;
  }
#line 130
  if (h < 0) {
#line 132
    y = coord[3];
#line 133
    h = - h;
  }
  {
#line 135
  gdk_draw_rectangle(win, gc, 0, x, y, w + 1, h + 1);
  }
  return;
}
}
#line 139 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static void draw_selection(Preview *p ) 
{ 


  {
#line 141
  if (! p->gc) {
#line 143
    return;
  }
#line 145
  if (p->previous_selection.active) {
    {
#line 146
    draw_rect((p->window)->window, p->gc, (int *)p->previous_selection.coord);
    }
  }
#line 148
  if (p->selection.active) {
    {
#line 149
    draw_rect((p->window)->window, p->gc, (int *)p->selection.coord);
    }
  }
#line 151
  p->previous_selection = p->selection;
  return;
}
}
#line 155 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static void update_selection(Preview *p ) 
{ 
  float min ;
  float max ;
  float normal ;
  float dev_selection[4] ;
  SANE_Option_Descriptor *opt ;
  SANE_Status status ;
  SANE_Word val ;
  int i ;
  int optnum ;
  SANE_Option_Descriptor *__cil_tmp11 ;
  SANE_Status __cil_tmp12 ;
  int tmp ;

  {
  {
#line 163
  p->previous_selection = p->selection;
#line 165
  memcpy((float *)dev_selection, (float *)p->surface, sizeof(dev_selection));
#line 166
  i = 0;
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! (i < 4)) {
#line 166
      goto while_break;
    }
#line 168
    optnum = (p->dialog)->well_known.coord[i];
#line 169
    if (optnum > 0) {
      {
#line 171
      opt = sane_get_option_descriptor((p->dialog)->dev, optnum);
#line 172
      status = sane_control_option((p->dialog)->dev, optnum, (SANE_Action )0, & val,
                                   (SANE_Int *)0);
      }
#line 174
      if ((unsigned int )status != 0U) {
#line 175
        goto while_continue;
      }
#line 176
      if ((unsigned int )opt->type == 2U) {
#line 177
        dev_selection[i] = (float )((double )val / (double )(1 << 16));
      } else {
#line 179
        dev_selection[i] = (float )val;
      }
    }
#line 166
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  i = 0;
  {
#line 182
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 182
    if (! (i < 2)) {
#line 182
      goto while_break___0;
    }
#line 184
    min = p->surface[i];
#line 185
    if ((double )min <= - 5000000000.) {
#line 186
      min = (float )0.;
    }
#line 187
    max = p->surface[i + 2];
#line 188
    if ((double )max >= 5000000000.) {
#line 189
      max = (float )p->preview_width;
    }
#line 191
    if (i == 0) {
#line 191
      tmp = p->preview_width;
    } else {
#line 191
      tmp = p->preview_height;
    }
#line 191
    normal = (float )(tmp - 1);
#line 192
    normal /= max - min;
#line 193
    p->selection.active = ! 0;
#line 194
    p->selection.coord[i] = (int )((double )((dev_selection[i] - min) * normal) + 0.5);
#line 195
    p->selection.coord[i + 2] = (int )((double )((dev_selection[i + 2] - min) * normal) + 0.5);
#line 197
    if (p->selection.coord[i + 2] < p->selection.coord[i]) {
#line 198
      p->selection.coord[i + 2] = p->selection.coord[i];
    }
#line 182
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 200
  draw_selection(p);
  }
  return;
}
}
#line 204 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static void get_image_scale(Preview *p , float *xscalep , float *yscalep ) 
{ 
  float xscale ;
  float yscale ;
  float swidth ;
  float sheight ;
  int tmp ;

  {
#line 208
  if (p->image_width == 0) {
#line 209
    xscale = (float )1.;
  } else {
#line 212
    xscale = (float )p->image_width / (float )p->preview_width;
#line 213
    if (p->image_height > 0) {
#line 213
      if ((float )p->preview_height * xscale < (float )p->image_height) {
#line 214
        xscale = (float )p->image_height / (float )p->preview_height;
      }
    }
  }
#line 216
  yscale = xscale;
#line 218
  if ((unsigned int )p->surface_unit == 1U) {
#line 218
    if (p->image_width <= p->preview_width) {
#line 218
      if (p->image_height <= p->preview_height) {
#line 225
        swidth = (p->surface[2] - p->surface[0]) + (float )1;
#line 226
        sheight = (p->surface[3] - p->surface[1]) + (float )1;
#line 227
        xscale = (float )1.;
#line 228
        yscale = (float )1.;
#line 229
        if (p->image_width > 0) {
#line 229
          if ((double )swidth < 5000000000.) {
#line 230
            xscale = (float )p->image_width / swidth;
          }
        }
#line 231
        if (p->image_height > 0) {
#line 231
          if ((double )sheight < 5000000000.) {
#line 232
            yscale = (float )p->image_height / sheight;
          }
        }
      }
    }
  }
#line 234
  *xscalep = xscale;
#line 235
  *yscalep = yscale;
  return;
}
}
#line 239 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static void paint_image(Preview *p ) 
{ 
  float xscale ;
  float yscale ;
  float src_x ;
  float src_y ;
  int dst_x ;
  int dst_y ;
  int height ;
  int x ;
  int y ;
  int src_offset ;
  gint gwidth ;
  gint gheight ;
  GType __cil_tmp14 ;
  GTypeInstance *__cil_tmp15 ;

  {
  {
#line 245
  gwidth = p->preview_width;
#line 246
  gheight = p->preview_height;
#line 248
  get_image_scale(p, & xscale, & yscale);
#line 250
  memset(p->preview_row, 255, (unsigned long )(3 * gwidth));
#line 253
  height = p->image_y;
  }
#line 254
  if (p->image_x == 0) {
#line 254
    if (height < p->image_height) {
#line 255
      height ++;
    }
  }
#line 258
  src_offset = 0;
#line 259
  src_y = (float )0.;
#line 259
  src_x = src_y;
#line 260
  dst_y = 0;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (dst_y < gheight)) {
#line 260
      goto while_break;
    }
#line 262
    y = (int )((double )src_y + 0.5);
#line 263
    if (y >= height) {
#line 264
      goto while_break;
    }
#line 265
    src_offset = (y * 3) * p->image_width;
#line 267
    if (p->image_data) {
#line 268
      dst_x = 0;
      {
#line 268
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 268
        if (! (dst_x < gwidth)) {
#line 268
          goto while_break___0;
        }
#line 270
        x = (int )((double )src_x + 0.5);
#line 271
        if (x >= p->image_width) {
#line 272
          goto while_break___0;
        }
#line 274
        *(p->preview_row + 3 * dst_x) = *(p->image_data + (src_offset + 3 * x));
#line 276
        *(p->preview_row + (3 * dst_x + 1)) = *(p->image_data + ((src_offset + 3 * x) + 1));
#line 278
        *(p->preview_row + (3 * dst_x + 2)) = *(p->image_data + ((src_offset + 3 * x) + 2));
#line 280
        src_x += xscale;
#line 268
        dst_x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 282
    __cil_tmp14 = gtk_preview_get_type();
#line 282
    __cil_tmp15 = g_type_check_instance_cast((GTypeInstance *)p->window, __cil_tmp14);
#line 282
    gtk_preview_draw_row((GtkPreview *)((void *)__cil_tmp15), p->preview_row, 0, dst_y,
                         gwidth);
#line 284
    src_x = (float )0.;
#line 285
    src_y += yscale;
    }
#line 260
    dst_y ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 290 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static void display_partial_image(Preview *p ) 
{ 
  GType __cil_tmp2 ;
  GTypeInstance *__cil_tmp3 ;
  GType __cil_tmp4 ;
  GTypeInstance *__cil_tmp5 ;
  GtkPreview *preview ;
  GType __cil_tmp7 ;
  GTypeInstance *__cil_tmp8 ;
  int src_x ;
  int src_y ;

  {
  {
#line 292
  paint_image(p);
  }
#line 294
  if ((((GtkObject *)((void *)__cil_tmp3))->flags & 256U) != 0U) {
#line 294
    if ((((GtkObject *)((void *)__cil_tmp5))->flags & 128U) != 0U) {
      {
#line 296
      __cil_tmp7 = gtk_preview_get_type();
#line 296
      __cil_tmp8 = g_type_check_instance_cast((GTypeInstance *)p->window, __cil_tmp7);
#line 296
      preview = (GtkPreview *)((void *)__cil_tmp8);
#line 299
      src_x = ((p->window)->allocation.width - (int )preview->buffer_width) / 2;
#line 300
      src_y = ((p->window)->allocation.height - (int )preview->buffer_height) / 2;
#line 301
      gtk_preview_put(preview, (p->window)->window, ((p->window)->style)->black_gc,
                      src_x, src_y, 0, 0, p->preview_width, p->preview_height);
      }
    }
  }
  return;
}
}
#line 308 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static void display_maybe(Preview *p ) 
{ 
  time_t now ;

  {
  {
#line 312
  time(& now);
  }
#line 313
  if (now > p->image_last_time_updated) {
    {
#line 315
    p->image_last_time_updated = now;
#line 316
    display_partial_image(p);
    }
  }
  return;
}
}
#line 321 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static void display_image(Preview *p ) 
{ 
  void *__cil_tmp2 ;
  int tmp ;

  {
#line 323
  if (p->params.lines <= 0) {
#line 323
    if (p->image_y < p->image_height) {
      {
#line 325
      p->image_height = p->image_y;
#line 326
      p->image_data = (u_char *)realloc(p->image_data, (unsigned long )((3 * p->image_width) * p->image_height));
      }
    }
  }
  {
#line 330
  display_partial_image(p);
#line 331
  scan_done(p);
  }
  return;
}
}
#line 335 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static void preview_area_resize(GtkWidget *widget ) 
{ 
  float min_x ;
  float max_x ;
  float min_y ;
  float max_y ;
  float xscale ;
  float yscale ;
  float f ;
  Preview *p ;
  GType __cil_tmp10 ;
  GTypeInstance *__cil_tmp11 ;
  gpointer __cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  double factor ;
  GType __cil_tmp16 ;
  GTypeInstance *__cil_tmp17 ;
  GType __cil_tmp18 ;
  GTypeInstance *__cil_tmp19 ;

  {
  {
#line 340
  __cil_tmp10 = gtk_object_get_type();
#line 340
  __cil_tmp11 = g_type_check_instance_cast((GTypeInstance *)widget, __cil_tmp10);
#line 340
  __cil_tmp12 = gtk_object_get_data((GtkObject *)((void *)__cil_tmp11), (gchar *)"PreviewPointer");
#line 340
  p = __cil_tmp12;
#line 342
  p->preview_width = widget->allocation.width;
#line 343
  p->preview_height = widget->allocation.height;
  }
#line 345
  if (p->preview_row) {
    {
#line 346
    p->preview_row = (u_char *)realloc(p->preview_row, (unsigned long )(3 * p->preview_width));
    }
  } else {
    {
#line 348
    p->preview_row = (u_char *)malloc((unsigned long )(3 * p->preview_width));
    }
  }
#line 352
  min_x = p->surface[0];
#line 353
  if ((double )min_x <= - 5000000000.) {
#line 354
    min_x = (float )0.;
  }
#line 356
  max_x = p->surface[2];
#line 357
  if ((double )max_x >= 5000000000.) {
#line 358
    max_x = (float )(p->preview_width - 1);
  }
#line 360
  min_y = p->surface[1];
#line 361
  if ((double )min_y <= - 5000000000.) {
#line 362
    min_y = (float )0.;
  }
#line 364
  max_y = p->surface[3];
#line 365
  if ((double )max_y >= 5000000000.) {
#line 366
    max_y = (float )(p->preview_height - 1);
  }
#line 370
  if ((unsigned int )p->surface_unit == 3U) {
#line 372
    factor = 1. / preferences.length_unit;
#line 373
    min_x *= factor;
#line 374
    max_x *= factor;
#line 375
    min_y *= factor;
#line 376
    max_y *= factor;
  }
  {
#line 379
  get_image_scale(p, & xscale, & yscale);
  }
#line 381
  if ((unsigned int )p->surface_unit == 1U) {
#line 382
    f = (float )(1. / (double )xscale);
  } else
#line 383
  if (p->image_width) {
#line 384
    f = (xscale * (float )p->preview_width) / (float )p->image_width;
  } else {
#line 386
    f = (float )1.;
  }
  {
#line 387
  __cil_tmp16 = gtk_ruler_get_type();
#line 387
  __cil_tmp17 = g_type_check_instance_cast((GTypeInstance *)p->hruler, __cil_tmp16);
#line 387
  gtk_ruler_set_range((GtkRuler *)((void *)__cil_tmp17), (gdouble )(f * min_x), (gdouble )(f * max_x),
                      (gdouble )(f * min_x), (gdouble )20);
  }
#line 390
  if ((unsigned int )p->surface_unit == 1U) {
#line 391
    f = (float )(1. / (double )yscale);
  } else
#line 392
  if (p->image_height) {
#line 393
    f = (yscale * (float )p->preview_height) / (float )p->image_height;
  } else {
#line 395
    f = (float )1.;
  }
  {
#line 396
  __cil_tmp18 = gtk_ruler_get_type();
#line 396
  __cil_tmp19 = g_type_check_instance_cast((GTypeInstance *)p->vruler, __cil_tmp18);
#line 396
  gtk_ruler_set_range((GtkRuler *)((void *)__cil_tmp19), (gdouble )(f * min_y), (gdouble )(f * max_y),
                      (gdouble )(f * min_y), (gdouble )20);
#line 399
  paint_image(p);
#line 400
  update_selection(p);
  }
  return;
}
}
#line 404 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static void get_bounds(SANE_Option_Descriptor *opt , float *minp , float *maxp ) 
{ 
  float min ;
  float max ;
  int i ;

  {
#line 409
  min = (float )(- 5000000000.);
#line 410
  max = (float )5000000000.;
  {
#line 413
  if ((unsigned int )opt->constraint_type == (unsigned int )1) {
#line 413
    goto case_1;
  }
#line 418
  if ((unsigned int )opt->constraint_type == (unsigned int )2) {
#line 418
    goto case_2;
  }
#line 430
  goto switch_default;
  case_1: /* CIL Label */ 
#line 414
  min = (float )(opt->constraint.range)->min;
#line 415
  max = (float )(opt->constraint.range)->max;
#line 416
  goto switch_break;
  case_2: /* CIL Label */ 
#line 419
  min = (float )5000000000.;
#line 420
  max = (float )(- 5000000000.);
#line 421
  i = 1;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! (i <= *(opt->constraint.word_list + 0))) {
#line 421
      goto while_break;
    }
#line 423
    if ((float )*(opt->constraint.word_list + i) < min) {
#line 424
      min = (float )*(opt->constraint.word_list + i);
    }
#line 425
    if ((float )*(opt->constraint.word_list + i) > max) {
#line 426
      max = (float )*(opt->constraint.word_list + i);
    }
#line 421
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 428
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 431
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 433
  if ((unsigned int )opt->type == 2U) {
#line 435
    if ((double )min > - 5000000000.) {
#line 435
      if ((double )min < 5000000000.) {
#line 436
        min = (float )((double )min / (double )(1 << 16));
      }
    }
#line 437
    if ((double )max > - 5000000000.) {
#line 437
      if ((double )max < 5000000000.) {
#line 438
        max = (float )((double )max / (double )(1 << 16));
      }
    }
  }
#line 440
  *minp = min;
#line 441
  *maxp = max;
  return;
}
}
#line 445 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static void save_option(Preview *p , int option , SANE_Word *save_loc , int *valid ) 
{ 
  SANE_Status status ;
  SANE_Status __cil_tmp6 ;

  {
#line 449
  if (option <= 0) {
#line 451
    *valid = 0;
#line 452
    return;
  }
  {
#line 454
  status = sane_control_option((p->dialog)->dev, option, (SANE_Action )0, save_loc,
                               (SANE_Int *)0);
#line 456
  *valid = (unsigned int )status == 0U;
  }
  return;
}
}
#line 460 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static void restore_option(Preview *p , int option , SANE_Word saved_value , int valid ) 
{ 
  SANE_Option_Descriptor *opt ;
  SANE_Status status ;
  SANE_Handle dev ;
  SANE_Status __cil_tmp8 ;
  char buf[256] ;
  SANE_Option_Descriptor *__cil_tmp10 ;
  SANE_String_Const __cil_tmp11 ;

  {
#line 466
  if (! valid) {
#line 467
    return;
  }
  {
#line 469
  dev = (p->dialog)->dev;
#line 470
  status = sane_control_option(dev, option, (SANE_Action )1, & saved_value, (SANE_Int *)0);
  }
#line 472
  if ((unsigned int )status != 0U) {
    {
#line 475
    opt = sane_get_option_descriptor(dev, option);
#line 476
    __cil_tmp11 = sane_strstatus(status);
#line 476
    snprintf((char *)buf, sizeof(buf), "Failed restore value of option %s: %s.", opt->name,
             __cil_tmp11);
#line 478
    gsg_error((char *)buf);
    }
  }
  return;
}
}
#line 483 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static SANE_Status set_option_float(Preview *p , int option , float value ) 
{ 
  SANE_Option_Descriptor *opt ;
  SANE_Handle dev ;
  SANE_Word word ;
  SANE_Status status ;
  SANE_Option_Descriptor *__cil_tmp8 ;
  SANE_Status __cil_tmp9 ;
  char buf[256] ;
  SANE_Option_Descriptor *__cil_tmp11 ;
  SANE_String_Const __cil_tmp12 ;

  {
#line 490
  if (option <= 0) {
#line 491
    return ((SANE_Status )4);
  } else
#line 490
  if ((double )value <= - 5000000000.) {
#line 491
    return ((SANE_Status )4);
  } else
#line 490
  if ((double )value >= 5000000000.) {
#line 491
    return ((SANE_Status )4);
  }
  {
#line 493
  dev = (p->dialog)->dev;
#line 494
  opt = sane_get_option_descriptor(dev, option);
  }
#line 495
  if ((unsigned int )opt->type == 2U) {
#line 496
    word = (SANE_Word )((double )((SANE_Word )(value * (float )(1 << 16))) + 0.5);
  } else {
#line 498
    word = (SANE_Word )((double )value + 0.5);
  }
  {
#line 499
  status = sane_control_option(dev, option, (SANE_Action )1, & word, (SANE_Int *)0);
  }
#line 500
  if ((unsigned int )status != 0U) {
    {
#line 503
    opt = sane_get_option_descriptor(dev, option);
#line 504
    __cil_tmp12 = sane_strstatus(status);
#line 504
    snprintf((char *)buf, sizeof(buf), "Failed to set option %s: %s.", opt->name,
             __cil_tmp12);
#line 506
    gsg_error((char *)buf);
    }
#line 507
    return (status);
  }
#line 509
  return ((SANE_Status )0);
}
}
#line 513 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static void set_option_bool(Preview *p , int option , SANE_Bool value ) 
{ 
  SANE_Handle dev ;
  SANE_Status status ;
  SANE_Status __cil_tmp6 ;
  SANE_String_Const __cil_tmp7 ;

  {
#line 518
  if (option <= 0) {
#line 519
    return;
  }
  {
#line 521
  dev = (p->dialog)->dev;
#line 522
  status = sane_control_option(dev, option, (SANE_Action )1, & value, (SANE_Int *)0);
  }
#line 524
  if ((unsigned int )status != 0U) {
    {
#line 526
    __cil_tmp7 = sane_strstatus(status);
#line 526
    sanei_debug_preview_call(0, "set_option_bool: sane_control_option failed: %s\n\230",
                             __cil_tmp7);
    }
#line 528
    return;
  }
  return;
}
}
#line 533 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static int increment_image_y(Preview *p ) 
{ 
  size_t extra_size ;
  size_t offset ;
  char buf[256] ;
  void *__cil_tmp5 ;
  int *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 538
  p->image_x = 0;
#line 539
  (p->image_y) ++;
#line 540
  if (p->params.lines <= 0) {
#line 540
    if (p->image_y >= p->image_height) {
      {
#line 542
      offset = (size_t )((3 * p->image_width) * p->image_height);
#line 543
      extra_size = (size_t )(96 * p->image_width);
#line 544
      p->image_height += 32;
#line 545
      p->image_data = (u_char *)realloc(p->image_data, offset + extra_size);
      }
#line 546
      if (! p->image_data) {
        {
#line 548
        __cil_tmp6 = __errno_location();
#line 548
        __cil_tmp7 = strerror(*__cil_tmp6);
#line 548
        snprintf((char *)buf, sizeof(buf), "Failed to reallocate image memory: %s.",
                 __cil_tmp7);
#line 551
        gsg_error((char *)buf);
#line 552
        scan_done(p);
        }
#line 553
        return (- 1);
      }
      {
#line 555
      memset(p->image_data + offset, 255, extra_size);
      }
    }
  }
#line 557
  return (0);
}
}
#line 561 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static void input_available(gpointer data , gint source , GdkInputCondition cond ) 
{ 
  SANE_Status status ;
  Preview *p ;
  u_char buf[8192] ;
  SANE_Handle dev ;
  SANE_Int len ;
  int i ;
  int j ;
  SANE_Status __cil_tmp11 ;
  gboolean __cil_tmp12 ;
  SANE_String_Const __cil_tmp13 ;
  gboolean __cil_tmp14 ;
  u_char mask ;
  u_char gl ;
  int tmp ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  guint16 value ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  u_char mask___0 ;
  u_char gl___0 ;
  int tmp___0 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  u_char gl___1 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  guint16 value___0 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  u_char mask___1 ;
  u_char gl___2 ;
  int tmp___1 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  guint16 value___1 ;
  int __cil_tmp48 ;
  gboolean __cil_tmp49 ;

  {
  {
#line 564
  p = data;
#line 570
  sanei_init_debug("preview", & sanei_debug_preview);
#line 572
  sanei_debug_preview_call(4, "input_available: enter\n");
#line 574
  dev = (p->dialog)->dev;
  }
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 577
    status = sane_read(dev, (u_char *)buf, (SANE_Int )sizeof(buf), & len);
    }
#line 578
    if ((unsigned int )status != 0U) {
#line 580
      if ((unsigned int )status == 5U) {
#line 582
        if (p->params.last_frame) {
          {
#line 583
          display_image(p);
          }
        } else {
#line 586
          if (p->input_tag < 0) {
            {
#line 588
            display_maybe(p);
            }
            {
#line 589
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 589
              __cil_tmp12 = gtk_events_pending();
              }
#line 589
              if (! __cil_tmp12) {
#line 589
                goto while_break___0;
              }
              {
#line 590
              gtk_main_iteration();
              }
            }
            while_break___0: /* CIL Label */ ;
            }
          } else {
            {
#line 594
            gdk_input_remove(p->input_tag);
#line 595
            p->input_tag = - 1;
            }
          }
          {
#line 597
          scan_start(p);
          }
#line 598
          goto while_break;
        }
      } else {
        {
#line 603
        __cil_tmp13 = sane_strstatus(status);
#line 603
        snprintf((u_char *)buf, sizeof(buf), "Error during read: %s.", __cil_tmp13);
#line 605
        gsg_error((u_char *)buf);
        }
      }
      {
#line 607
      scan_done(p);
      }
#line 608
      return;
    }
#line 610
    if (! len) {
#line 612
      if (p->input_tag < 0) {
        {
#line 614
        display_maybe(p);
        }
        {
#line 615
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 615
          __cil_tmp14 = gtk_events_pending();
          }
#line 615
          if (! __cil_tmp14) {
#line 615
            goto while_break___1;
          }
          {
#line 616
          gtk_main_iteration();
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 617
        goto while_continue;
      } else {
#line 620
        goto while_break;
      }
    }
    {
#line 625
    if ((unsigned int )p->params.format == (unsigned int )1) {
#line 625
      goto case_1;
    }
#line 628
    if ((unsigned int )p->params.format == 1) {
#line 628
      goto case_1___0;
    }
#line 659
    if ((unsigned int )p->params.format == 8) {
#line 659
      goto case_8;
    }
#line 671
    if ((unsigned int )p->params.format == 16) {
#line 671
      goto case_16;
    }
#line 690
    if ((unsigned int )p->params.format == (unsigned int )0) {
#line 690
      goto case_0;
    }
#line 693
    if ((unsigned int )p->params.format == 1) {
#line 693
      goto case_1___1;
    }
#line 714
    if ((unsigned int )p->params.format == 8) {
#line 714
      goto case_8___0;
    }
#line 726
    if ((unsigned int )p->params.format == 16) {
#line 726
      goto case_16___0;
    }
#line 752
    if ((unsigned int )p->params.format == (unsigned int )4) {
#line 752
      goto case_4;
    }
#line 752
    if ((unsigned int )p->params.format == (unsigned int )3) {
#line 752
      goto case_4;
    }
#line 752
    if ((unsigned int )p->params.format == (unsigned int )2) {
#line 752
      goto case_4;
    }
#line 755
    if ((unsigned int )p->params.format == 1) {
#line 755
      goto case_1___2;
    }
#line 772
    if ((unsigned int )p->params.format == 8) {
#line 772
      goto case_8___1;
    }
#line 783
    if ((unsigned int )p->params.format == 16) {
#line 783
      goto case_16___1;
    }
#line 806
    goto switch_default___2;
    case_1: /* CIL Label */ 
    {
#line 628
    if (p->params.depth == 1) {
#line 628
      goto case_1___0;
    }
#line 659
    if (p->params.depth == 8) {
#line 659
      goto case_8;
    }
#line 671
    if (p->params.depth == 16) {
#line 671
      goto case_16;
    }
#line 685
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 629
    i = 0;
    {
#line 629
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 629
      if (! (i < len)) {
#line 629
        goto while_break___2;
      }
#line 631
      mask = buf[i];
#line 633
      j = 7;
      {
#line 633
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 633
        if (! (j >= 0)) {
#line 633
          goto while_break___3;
        }
#line 635
        if ((int )mask & (1 << j)) {
#line 635
          tmp = 255;
        } else {
#line 635
          tmp = 0;
        }
#line 635
        gl = (u_char )tmp;
#line 637
        *(p->image_data + p->image_offset) = gl;
#line 638
        if (j != 0) {
#line 639
          p->image_offset += 3;
        } else
#line 642
        if (p->image_offset % 3 != 2) {
#line 643
          p->image_offset -= 20;
        } else {
#line 645
          (p->image_offset) ++;
        }
#line 647
        if (p->image_offset % 3 == 0) {
#line 649
          (p->image_x) ++;
#line 649
          if (p->image_x >= p->image_width) {
            {
#line 651
            __cil_tmp19 = increment_image_y(p);
            }
#line 651
            if (__cil_tmp19 < 0) {
#line 652
              return;
            }
          }
        }
#line 633
        j --;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 629
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 657
    goto switch_break___0;
    case_8: /* CIL Label */ 
#line 660
    i = 0;
    {
#line 660
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 660
      if (! (i < len)) {
#line 660
        goto while_break___4;
      }
#line 662
      __cil_tmp20 = p->image_offset;
#line 662
      (p->image_offset) ++;
#line 662
      *(p->image_data + __cil_tmp20) = buf[i];
#line 663
      if (p->image_offset % 3 == 0) {
        {
#line 665
        __cil_tmp21 = increment_image_y(p);
        }
#line 665
        (p->image_x) ++;
#line 665
        if (p->image_x >= p->image_width) {
#line 665
          if (__cil_tmp21 < 0) {
#line 667
            return;
          }
        }
      }
#line 660
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 670
    goto switch_break___0;
    case_16: /* CIL Label */ 
#line 672
    i = 0;
    {
#line 672
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 672
      if (! (i < len)) {
#line 672
        goto while_break___5;
      }
#line 674
      value = (guint16 )buf[i];
#line 675
      if (i % 2 == 1) {
#line 676
        __cil_tmp23 = p->image_offset;
#line 676
        (p->image_offset) ++;
#line 676
        *(p->image_data + __cil_tmp23) = *((guint8 *)(& value));
      }
#line 677
      if (p->image_offset % 6 == 0) {
        {
#line 679
        __cil_tmp24 = increment_image_y(p);
        }
#line 679
        (p->image_x) ++;
#line 679
        if (p->image_x >= p->image_width) {
#line 679
          if (__cil_tmp24 < 0) {
#line 681
            return;
          }
        }
      }
#line 672
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 684
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 686
    goto bad_depth;
    switch_break___0: /* CIL Label */ ;
    }
#line 688
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 693
    if (p->params.depth == 1) {
#line 693
      goto case_1___1;
    }
#line 714
    if (p->params.depth == 8) {
#line 714
      goto case_8___0;
    }
#line 726
    if (p->params.depth == 16) {
#line 726
      goto case_16___0;
    }
#line 745
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 694
    i = 0;
    {
#line 694
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 694
      if (! (i < len)) {
#line 694
        goto while_break___6;
      }
#line 696
      mask___0 = buf[i];
#line 698
      j = 7;
      {
#line 698
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 698
        if (! (j >= 0)) {
#line 698
          goto while_break___7;
        }
#line 700
        if ((int )mask___0 & (1 << j)) {
#line 700
          tmp___0 = 0;
        } else {
#line 700
          tmp___0 = 255;
        }
#line 700
        gl___0 = (u_char )tmp___0;
#line 701
        __cil_tmp28 = p->image_offset;
#line 701
        (p->image_offset) ++;
#line 701
        *(p->image_data + __cil_tmp28) = gl___0;
#line 702
        __cil_tmp29 = p->image_offset;
#line 702
        (p->image_offset) ++;
#line 702
        *(p->image_data + __cil_tmp29) = gl___0;
#line 703
        __cil_tmp30 = p->image_offset;
#line 703
        (p->image_offset) ++;
#line 703
        *(p->image_data + __cil_tmp30) = gl___0;
#line 704
        (p->image_x) ++;
#line 704
        if (p->image_x >= p->image_width) {
          {
#line 706
          __cil_tmp31 = increment_image_y(p);
          }
#line 706
          if (__cil_tmp31 < 0) {
#line 707
            return;
          }
#line 708
          goto while_break___7;
        }
#line 698
        j --;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 694
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 712
    goto switch_break___1;
    case_8___0: /* CIL Label */ 
#line 715
    i = 0;
    {
#line 715
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 715
      if (! (i < len)) {
#line 715
        goto while_break___8;
      }
      {
#line 717
      gl___1 = buf[i];
#line 718
      __cil_tmp33 = p->image_offset;
#line 718
      (p->image_offset) ++;
#line 718
      *(p->image_data + __cil_tmp33) = gl___1;
#line 719
      __cil_tmp34 = p->image_offset;
#line 719
      (p->image_offset) ++;
#line 719
      *(p->image_data + __cil_tmp34) = gl___1;
#line 720
      __cil_tmp35 = p->image_offset;
#line 720
      (p->image_offset) ++;
#line 720
      *(p->image_data + __cil_tmp35) = gl___1;
#line 721
      __cil_tmp36 = increment_image_y(p);
      }
#line 721
      (p->image_x) ++;
#line 721
      if (p->image_x >= p->image_width) {
#line 721
        if (__cil_tmp36 < 0) {
#line 723
          return;
        }
      }
#line 715
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 725
    goto switch_break___1;
    case_16___0: /* CIL Label */ 
#line 727
    i = 0;
    {
#line 727
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 727
      if (! (i < len)) {
#line 727
        goto while_break___9;
      }
#line 729
      value___0 = (guint16 )buf[i];
#line 730
      if (i % 2 == 1) {
#line 732
        __cil_tmp38 = p->image_offset;
#line 732
        (p->image_offset) ++;
#line 732
        *(p->image_data + __cil_tmp38) = *((guint8 *)(& value___0));
#line 733
        __cil_tmp39 = p->image_offset;
#line 733
        (p->image_offset) ++;
#line 733
        *(p->image_data + __cil_tmp39) = *((guint8 *)(& value___0));
#line 734
        __cil_tmp40 = p->image_offset;
#line 734
        (p->image_offset) ++;
#line 734
        *(p->image_data + __cil_tmp40) = *((guint8 *)(& value___0));
      }
#line 736
      if (p->image_offset % 2 == 0) {
        {
#line 738
        __cil_tmp41 = increment_image_y(p);
        }
#line 738
        (p->image_x) ++;
#line 738
        if (p->image_x >= p->image_width) {
#line 738
          if (__cil_tmp41 < 0) {
#line 740
            return;
          }
        }
      }
#line 727
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 743
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 746
    goto bad_depth;
    switch_break___1: /* CIL Label */ ;
    }
#line 748
    goto switch_break;
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 755
    if (p->params.depth == 1) {
#line 755
      goto case_1___2;
    }
#line 772
    if (p->params.depth == 8) {
#line 772
      goto case_8___1;
    }
#line 783
    if (p->params.depth == 16) {
#line 783
      goto case_16___1;
    }
#line 801
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 756
    i = 0;
    {
#line 756
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 756
      if (! (i < len)) {
#line 756
        goto while_break___10;
      }
#line 758
      mask___1 = buf[i];
#line 760
      j = 7;
      {
#line 760
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 760
        if (! (j >= 0)) {
#line 760
          goto while_break___11;
        }
#line 762
        if ((int )mask___1 & (1 << j)) {
#line 762
          tmp___1 = 255;
        } else {
#line 762
          tmp___1 = 0;
        }
        {
#line 762
        gl___2 = (u_char )tmp___1;
#line 763
        *(p->image_data + p->image_offset) = gl___2;
#line 764
        p->image_offset += 3;
#line 765
        __cil_tmp45 = increment_image_y(p);
        }
#line 765
        (p->image_x) ++;
#line 765
        if (p->image_x >= p->image_width) {
#line 765
          if (__cil_tmp45 < 0) {
#line 767
            return;
          }
        }
#line 760
        j --;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 756
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 770
    goto switch_break___2;
    case_8___1: /* CIL Label */ 
#line 773
    i = 0;
    {
#line 773
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 773
      if (! (i < len)) {
#line 773
        goto while_break___12;
      }
      {
#line 775
      *(p->image_data + p->image_offset) = buf[i];
#line 776
      p->image_offset += 3;
#line 777
      __cil_tmp46 = increment_image_y(p);
      }
#line 777
      (p->image_x) ++;
#line 777
      if (p->image_x >= p->image_width) {
#line 777
        if (__cil_tmp46 < 0) {
#line 779
          return;
        }
      }
#line 773
      i ++;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 781
    goto switch_break___2;
    case_16___1: /* CIL Label */ 
#line 784
    i = 0;
    {
#line 784
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 784
      if (! (i < len)) {
#line 784
        goto while_break___13;
      }
#line 786
      value___1 = (guint16 )buf[i];
#line 787
      if (i % 2 == 1) {
#line 789
        *(p->image_data + p->image_offset) = *((guint8 *)(& value___1));
#line 790
        p->image_offset += 3;
      }
#line 792
      if (p->image_offset % 2 == 0) {
        {
#line 794
        __cil_tmp48 = increment_image_y(p);
        }
#line 794
        (p->image_x) ++;
#line 794
        if (p->image_x >= p->image_width) {
#line 794
          if (__cil_tmp48 < 0) {
#line 796
            return;
          }
        }
      }
#line 784
      i ++;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 799
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
#line 802
    goto bad_depth;
    switch_break___2: /* CIL Label */ ;
    }
#line 804
    goto switch_break;
    switch_default___2: /* CIL Label */ 
    {
#line 807
    fprintf(stderr, "preview.input_available: bad frame format %d\n", (unsigned int )p->params.format);
    }
    {
#line 809
    scan_done(p);
    }
#line 810
    return;
    switch_break: /* CIL Label */ ;
    }
#line 812
    if (p->input_tag < 0) {
      {
#line 814
      display_maybe(p);
      }
      {
#line 815
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 815
        __cil_tmp49 = gtk_events_pending();
        }
#line 815
        if (! __cil_tmp49) {
#line 815
          goto while_break___14;
        }
        {
#line 816
        gtk_main_iteration();
        }
      }
      while_break___14: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 819
  display_maybe(p);
  }
#line 820
  return;
  bad_depth: 
  {
#line 823
  snprintf((u_char *)buf, sizeof(buf), "Preview cannot handle depth %d.", p->params.depth);
  }
  {
#line 825
  gsg_error((u_char *)buf);
#line 826
  scan_done(p);
  }
#line 827
  return;
}
}
#line 831 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static void scan_done(Preview *p ) 
{ 
  int i ;

  {
#line 835
  p->scanning = 0;
#line 836
  if (p->input_tag >= 0) {
    {
#line 838
    gdk_input_remove(p->input_tag);
#line 839
    p->input_tag = - 1;
    }
  }
  {
#line 841
  sane_cancel((p->dialog)->dev);
#line 843
  restore_option(p, (p->dialog)->well_known.dpi, p->saved_dpi, p->saved_dpi_valid);
#line 845
  i = 0;
  }
  {
#line 845
  while (1) {
    while_continue: /* CIL Label */ ;
#line 845
    if (! (i < 4)) {
#line 845
      goto while_break;
    }
    {
#line 846
    restore_option(p, (p->dialog)->well_known.coord[i], p->saved_coord[i], p->saved_coord_valid[i]);
    }
#line 845
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 848
  set_option_bool(p, (p->dialog)->well_known.preview, 0);
#line 850
  gtk_widget_set_sensitive(p->cancel, 0);
#line 851
  gtk_widget_set_sensitive(p->preview, ! 0);
#line 852
  gsg_set_sensitivity(p->dialog, ! 0);
#line 853
  gtk_widget_set_sensitive(((((p->dialog)->window)->parent)->parent)->parent, ! 0);
  }
  return;
}
}
#line 857 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static void scan_start(Preview *p ) 
{ 
  SANE_Handle dev ;
  SANE_Status status ;
  char buf[256] ;
  int fd ;
  int y ;
  GType __cil_tmp7 ;
  GTypeInstance *__cil_tmp8 ;
  SANE_Status __cil_tmp9 ;
  SANE_String_Const __cil_tmp10 ;
  SANE_Status __cil_tmp11 ;
  SANE_String_Const __cil_tmp12 ;
  void *__cil_tmp13 ;
  int *__cil_tmp14 ;
  char *__cil_tmp15 ;
  SANE_Status __cil_tmp16 ;
  SANE_Status __cil_tmp17 ;
  gint __cil_tmp18 ;

  {
  {
#line 859
  dev = (p->dialog)->dev;
#line 864
  gtk_widget_set_sensitive(p->cancel, ! 0);
#line 865
  gtk_widget_set_sensitive(p->preview, 0);
#line 866
  gsg_set_sensitivity(p->dialog, 0);
#line 867
  gtk_widget_set_sensitive(((((p->dialog)->window)->parent)->parent)->parent, 0);
#line 870
  memset(p->preview_row, 255, (unsigned long )(3 * p->preview_width));
#line 871
  y = 0;
  }
  {
#line 871
  while (1) {
    while_continue: /* CIL Label */ ;
#line 871
    if (! (y < p->preview_height)) {
#line 871
      goto while_break;
    }
    {
#line 872
    __cil_tmp7 = gtk_preview_get_type();
#line 872
    __cil_tmp8 = g_type_check_instance_cast((GTypeInstance *)p->window, __cil_tmp7);
#line 872
    gtk_preview_draw_row((GtkPreview *)((void *)__cil_tmp8), p->preview_row, 0, y,
                         p->preview_width);
    }
#line 871
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 875
  if (p->input_tag >= 0) {
    {
#line 877
    gdk_input_remove(p->input_tag);
#line 878
    p->input_tag = - 1;
    }
  }
  {
#line 881
  gsg_sync(p->dialog);
#line 883
  status = sane_start(dev);
  }
#line 884
  if ((unsigned int )status != 0U) {
    {
#line 886
    __cil_tmp10 = sane_strstatus(status);
#line 886
    snprintf((char *)buf, sizeof(buf), "Failed to start scanner: %s.", __cil_tmp10);
#line 888
    gsg_error((char *)buf);
#line 889
    scan_done(p);
    }
#line 890
    return;
  }
  {
#line 893
  status = sane_get_parameters(dev, & p->params);
  }
#line 894
  if ((unsigned int )status != 0U) {
    {
#line 896
    __cil_tmp12 = sane_strstatus(status);
#line 896
    snprintf((char *)buf, sizeof(buf), "Failed to obtain parameters: %s.\230", __cil_tmp12);
#line 898
    gsg_error((char *)buf);
#line 899
    scan_done(p);
    }
#line 900
    return;
  }
#line 903
  if ((unsigned int )p->params.format >= 1U) {
#line 903
    if ((unsigned int )p->params.format <= 4U) {
#line 903
      if (p->params.depth == 1) {
#line 903
        if (p->params.pixels_per_line % 8 != 0) {
          {
#line 907
          snprintf((char *)buf, sizeof(buf), "Can\'t handle unaligned 1 bit RGB or three-pass mode.");
#line 909
          gsg_error((char *)buf);
#line 910
          scan_done(p);
          }
#line 911
          return;
        }
      }
    }
  }
#line 914
  p->image_y = 0;
#line 914
  p->image_x = p->image_y;
#line 914
  p->image_offset = p->image_x;
#line 916
  if ((unsigned int )p->params.format >= 2U) {
#line 916
    if ((unsigned int )p->params.format <= 4U) {
#line 918
      p->image_offset = (int )((unsigned int )p->params.format - 2U);
    }
  }
#line 920
  if (! p->image_data) {
    _L: /* CIL Label */ 
    _L___2: /* CIL Label */ 
#line 924
    if (p->image_data) {
      {
#line 925
      free(p->image_data);
      }
    }
#line 927
    p->image_width = p->params.pixels_per_line;
#line 928
    p->image_height = p->params.lines;
#line 929
    if (p->image_height < 0) {
#line 930
      p->image_height = 32;
    }
    {
#line 932
    p->image_data = (u_char *)malloc((unsigned long )((p->image_width * p->image_height) * 3));
    }
#line 933
    if (! p->image_data) {
      {
#line 935
      __cil_tmp14 = __errno_location();
#line 935
      __cil_tmp15 = strerror(*__cil_tmp14);
#line 935
      snprintf((char *)buf, sizeof(buf), "Failed to allocate image memory: %s.", __cil_tmp15);
#line 937
      gsg_error((char *)buf);
#line 938
      scan_done(p);
      }
#line 939
      return;
    }
    {
#line 941
    memset(p->image_data, 255, (unsigned long )((3 * p->image_width) * p->image_height));
    }
  } else
#line 920
  if (p->params.pixels_per_line != p->image_width) {
#line 920
    goto _L;
  } else
#line 920
  if (p->params.lines >= 0) {
#line 920
    if (p->params.lines != p->image_height) {
#line 920
      goto _L;
    }
  }
#line 944
  if (p->selection.active) {
    {
#line 946
    p->previous_selection = p->selection;
#line 947
    p->selection.active = 0;
#line 948
    draw_selection(p);
    }
  }
  {
#line 950
  p->scanning = ! 0;
#line 952
  __cil_tmp17 = sane_get_select_fd(dev, & fd);
  }
  {
#line 952
  __cil_tmp16 = sane_set_io_mode(dev, 1);
  }
#line 952
  if ((unsigned int )__cil_tmp16 == 0U) {
#line 952
    if ((unsigned int )__cil_tmp17 == 0U) {
      {
#line 954
      p->input_tag = gdk_input_add(fd, (GdkInputCondition )5, & input_available, p);
      }
    } else {
      {
      {
#line 958
      input_available(p, - 1, (GdkInputCondition )1);
      }
      }
    }
  } else {
    {
    {
#line 958
    input_available(p, - 1, (GdkInputCondition )1);
    }
    }
  }
  return;
}
}
#line 962 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static void establish_selection(Preview *p ) 
{ 
  float min ;
  float max ;
  float normal ;
  float dev_selection[4] ;
  int i ;
  int tmp ;

  {
  {
#line 967
  memcpy((float *)dev_selection, (float *)p->surface, sizeof(dev_selection));
  }
#line 968
  if (p->selection.active) {
#line 969
    i = 0;
    {
#line 969
    while (1) {
      while_continue: /* CIL Label */ ;
#line 969
      if (! (i < 2)) {
#line 969
        goto while_break;
      }
#line 971
      min = p->surface[i];
#line 972
      if ((double )min <= - 5000000000.) {
#line 973
        min = (float )0.;
      }
#line 974
      max = p->surface[i + 2];
#line 975
      if ((double )max >= 5000000000.) {
#line 976
        max = (float )p->preview_width;
      }
#line 978
      if (i == 0) {
#line 978
        tmp = p->preview_width;
      } else {
#line 978
        tmp = p->preview_height;
      }
#line 978
      normal = (float )(1. / (double )(tmp - 1));
#line 980
      normal *= max - min;
#line 981
      dev_selection[i] = (float )p->selection.coord[i] * normal + min;
#line 982
      dev_selection[i + 2] = (float )p->selection.coord[i + 2] * normal + min;
#line 969
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 984
  i = 0;
  {
#line 984
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 984
    if (! (i < 4)) {
#line 984
      goto while_break___0;
    }
    {
#line 985
    set_option_float(p, (p->dialog)->well_known.coord[i], dev_selection[i]);
    }
#line 984
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 986
  gsg_update_scan_window(p->dialog);
  }
#line 987
  if ((p->dialog)->param_change_callback) {
    {
#line 988
    (*((p->dialog)->param_change_callback))(p->dialog, (p->dialog)->param_change_arg);
    }
  }
  return;
}
}
#line 993 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static int make_preview_image_path(Preview *p , size_t filename_size , char *filename ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 995
  __cil_tmp4 = gsg_make_path(filename_size, filename, (char const   *)0, "preview-\230\001",
                             (p->dialog)->dev_name, ".ppm");
  }
#line 995
  return (__cil_tmp4);
}
}
#line 1000 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static void restore_preview_image(Preview *p ) 
{ 
  u_int psurface_type ;
  u_int psurface_unit ;
  char filename[4096] ;
  int width ;
  int height ;
  float psurface[4] ;
  size_t nread ;
  FILE *in ;
  int __cil_tmp10 ;
  FILE *__cil_tmp11 ;
  int __cil_tmp12 ;
  double __cil_tmp13 ;
  double __cil_tmp14 ;
  double __cil_tmp15 ;
  double __cil_tmp16 ;
  void *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;

  {
  {
#line 1011
  __cil_tmp10 = make_preview_image_path(p, sizeof(filename), (char *)filename);
  }
#line 1011
  if (__cil_tmp10 < 0) {
#line 1012
    return;
  }
  {
#line 1014
  in = fopen((char const   *)((char *)filename), "r");
  }
#line 1015
  if (! in) {
#line 1016
    return;
  }
  {
#line 1020
  __cil_tmp12 = fscanf(in, "P6\n# surface: %g %g %g %g %u %u\n%d %d\n255%*[\n]", (float *)psurface + 0,
                       (float *)psurface + 1, (float *)psurface + 2, (float *)psurface + 3,
                       & psurface_type, & psurface_unit, & width, & height);
  }
#line 1020
  if (__cil_tmp12 != 8) {
#line 1023
    return;
  }
  {
#line 1025
  __cil_tmp16 = fabs((double )(psurface[3] - p->surface[3]));
  }
  {
#line 1025
  __cil_tmp15 = fabs((double )(psurface[2] - p->surface[2]));
  }
  {
#line 1025
  __cil_tmp14 = fabs((double )(psurface[1] - p->surface[1]));
  }
  {
#line 1025
  __cil_tmp13 = fabs((double )(psurface[0] - p->surface[0]));
  }
#line 1025
  if (__cil_tmp13 > 0.00100000000001) {
#line 1031
    return;
  } else
#line 1025
  if (__cil_tmp14 > 0.00100000000001) {
#line 1031
    return;
  } else
#line 1025
  if (__cil_tmp15 > 0.00100000000001) {
#line 1031
    return;
  } else
#line 1025
  if (__cil_tmp16 > 0.00100000000001) {
#line 1031
    return;
  } else
#line 1025
  if (psurface_type != (unsigned int )p->surface_type) {
#line 1031
    return;
  } else
#line 1025
  if (psurface_unit != (unsigned int )p->surface_unit) {
#line 1031
    return;
  }
#line 1033
  p->image_width = width;
#line 1034
  p->image_height = height;
#line 1035
  if (width == 0) {
#line 1036
    return;
  } else
#line 1035
  if (height == 0) {
#line 1036
    return;
  }
  {
#line 1037
  p->image_data = (u_char *)malloc((unsigned long )((3 * width) * height));
  }
#line 1038
  if (! p->image_data) {
#line 1039
    return;
  }
  {
#line 1041
  nread = fread(p->image_data, (unsigned long )3, (unsigned long )(width * height),
                in);
#line 1043
  p->image_y = (int )(nread / (unsigned long )width);
#line 1044
  p->image_x = (int )(nread % (unsigned long )width);
  }
  return;
}
}
#line 1049 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static gint expose_handler(GtkWidget *window , GdkEvent *event , gpointer data ) 
{ 
  Preview *p ;

  {
  {
#line 1051
  p = data;
#line 1053
  p->selection.active = 0;
#line 1054
  update_selection(p);
  }
#line 1055
  return (0);
}
}
#line 1059 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static gint event_handler(GtkWidget *window , GdkEvent *event , gpointer data ) 
{ 
  Preview *p ;
  int i ;
  int tmp ;
  GdkGC *__cil_tmp7 ;

  {
#line 1061
  p = data;
#line 1064
  if ((int )event->type == 2) {
#line 1066
    if (! p->gc) {
      {
#line 1068
      p->gc = gdk_gc_new((p->window)->window);
#line 1069
      gdk_gc_set_function(p->gc, (GdkFunction )1);
#line 1070
      gdk_gc_set_line_attributes(p->gc, 1, (GdkLineStyle )1, (GdkCapStyle )1, (GdkJoinStyle )0);
#line 1072
      paint_image(p);
      }
    } else {
      {
#line 1076
      p->selection.active = 0;
#line 1077
      draw_selection(p);
      }
    }
  } else
#line 1080
  if (! p->scanning) {
    {
#line 1084
    if ((int )event->type == 14) {
#line 1084
      goto case_14;
    }
#line 1084
    if ((int )event->type == 15) {
#line 1084
      goto case_14;
    }
#line 1087
    if ((int )event->type == 4) {
#line 1087
      goto case_4;
    }
#line 1093
    if ((int )event->type == 7) {
#line 1093
      goto case_7;
    }
#line 1126
    if ((int )event->type == 3) {
#line 1126
      goto case_3;
    }
#line 1136
    goto switch_default;
    case_14: /* CIL Label */ 
    case_15: /* CIL Label */ 
#line 1085
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1088
    p->selection.coord[0] = (int )event->button.x;
#line 1089
    p->selection.coord[1] = (int )event->button.y;
#line 1090
    p->selection_drag = ! 0;
#line 1091
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1094
    if (! p->selection_drag) {
#line 1095
      goto switch_break;
    }
#line 1096
    p->selection_drag = 0;
#line 1098
    p->selection.coord[2] = (int )event->button.x;
#line 1099
    p->selection.coord[3] = (int )event->button.y;
#line 1100
    p->selection.active = p->selection.coord[0] != p->selection.coord[2] || p->selection.coord[1] != p->selection.coord[3];
#line 1104
    if (p->selection.active) {
#line 1106
      i = 0;
      {
#line 1106
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1106
        if (! (i < 2)) {
#line 1106
          goto while_break;
        }
#line 1107
        if (p->selection.coord[i] > p->selection.coord[i + 2]) {
#line 1109
          tmp = p->selection.coord[i];
#line 1110
          p->selection.coord[i] = p->selection.coord[i + 2];
#line 1111
          p->selection.coord[i + 2] = tmp;
        }
#line 1106
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1113
      if (p->selection.coord[0] < 0) {
#line 1114
        p->selection.coord[0] = 0;
      }
#line 1115
      if (p->selection.coord[1] < 0) {
#line 1116
        p->selection.coord[1] = 0;
      }
#line 1117
      if (p->selection.coord[2] >= p->preview_width) {
#line 1118
        p->selection.coord[2] = p->preview_width - 1;
      }
#line 1119
      if (p->selection.coord[3] >= p->preview_height) {
#line 1120
        p->selection.coord[3] = p->preview_height - 1;
      }
    }
    {
#line 1122
    draw_selection(p);
#line 1123
    establish_selection(p);
    }
#line 1124
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1127
    if (p->selection_drag) {
      {
#line 1129
      p->selection.active = ! 0;
#line 1130
      p->selection.coord[2] = (int )event->motion.x;
#line 1131
      p->selection.coord[3] = (int )event->motion.y;
#line 1132
      draw_selection(p);
      }
    }
#line 1134
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1141
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1143
  return (0);
}
}
#line 1147 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static void start_button_clicked(GtkWidget *widget , gpointer data ) 
{ 


  {
  {
#line 1149
  preview_scan(data);
  }
  return;
}
}
#line 1153 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static void cancel_button_clicked(GtkWidget *widget , gpointer data ) 
{ 


  {
  {
#line 1155
  scan_done(data);
  }
  return;
}
}
#line 1159 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
static void top_destroyed(GtkWidget *widget , gpointer call_data ) 
{ 
  Preview *p ;

  {
#line 1161
  p = call_data;
#line 1163
  p->top = (GtkWidget *)((void *)0);
  return;
}
}
#line 1167 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
Preview *preview_new(GSGDialog *dialog___0 ) 
{ 
  static int first_time ;
  GtkWidget *table ;
  GtkWidget *frame ;
  GtkSignalFunc signal_func ;
  GtkWidgetClass *class ;
  GtkBox *vbox ;
  GtkBox *hbox ;
  Preview *p ;
  void *__cil_tmp10 ;
  GdkColormap *__cil_tmp11 ;
  GtkWidget *__cil_tmp12 ;
  GType __cil_tmp13 ;
  GTypeInstance *__cil_tmp14 ;
  GType __cil_tmp15 ;
  GTypeInstance *__cil_tmp16 ;
  GType __cil_tmp17 ;
  GTypeInstance *__cil_tmp18 ;
  GType __cil_tmp19 ;
  GTypeInstance *__cil_tmp20 ;
  GType __cil_tmp21 ;
  GTypeInstance *__cil_tmp22 ;
  GType __cil_tmp23 ;
  GTypeInstance *__cil_tmp24 ;
  GtkWidget *__cil_tmp25 ;
  GType __cil_tmp26 ;
  GTypeInstance *__cil_tmp27 ;
  GType __cil_tmp28 ;
  GTypeInstance *__cil_tmp29 ;
  GType __cil_tmp30 ;
  GTypeInstance *__cil_tmp31 ;
  GtkWidget *__cil_tmp32 ;
  GType __cil_tmp33 ;
  GTypeInstance *__cil_tmp34 ;
  GType __cil_tmp35 ;
  GTypeInstance *__cil_tmp36 ;
  GtkWidget *__cil_tmp37 ;
  GType __cil_tmp38 ;
  GTypeInstance *__cil_tmp39 ;
  GtkWidget *__cil_tmp40 ;
  GType __cil_tmp41 ;
  GTypeInstance *__cil_tmp42 ;
  GtkWidget *__cil_tmp43 ;
  GType __cil_tmp44 ;
  GTypeInstance *__cil_tmp45 ;
  GType __cil_tmp46 ;
  GTypeInstance *__cil_tmp47 ;
  GType __cil_tmp48 ;
  GTypeInstance *__cil_tmp49 ;
  GType __cil_tmp50 ;
  GTypeInstance *__cil_tmp51 ;
  GType __cil_tmp52 ;
  GTypeInstance *__cil_tmp53 ;
  GType __cil_tmp54 ;
  GTypeInstance *__cil_tmp55 ;
  GType __cil_tmp56 ;
  GTypeClass *__cil_tmp57 ;
  GType __cil_tmp58 ;
  GTypeInstance *__cil_tmp59 ;
  GType __cil_tmp60 ;
  GTypeInstance *__cil_tmp61 ;
  GType __cil_tmp62 ;
  GTypeInstance *__cil_tmp63 ;
  GType __cil_tmp64 ;
  GTypeClass *__cil_tmp65 ;
  GType __cil_tmp66 ;
  GTypeInstance *__cil_tmp67 ;
  GType __cil_tmp68 ;
  GTypeInstance *__cil_tmp69 ;
  GtkWidget *__cil_tmp70 ;
  GType __cil_tmp71 ;
  GTypeInstance *__cil_tmp72 ;
  GType __cil_tmp73 ;
  GTypeInstance *__cil_tmp74 ;
  GType __cil_tmp75 ;
  GTypeInstance *__cil_tmp76 ;
  GtkWidget *__cil_tmp77 ;
  GType __cil_tmp78 ;
  GTypeInstance *__cil_tmp79 ;
  GType __cil_tmp80 ;
  GTypeInstance *__cil_tmp81 ;
  GtkWidget *__cil_tmp82 ;
  GType __cil_tmp83 ;
  GTypeInstance *__cil_tmp84 ;
  GType __cil_tmp85 ;
  GTypeInstance *__cil_tmp86 ;

  {
  {
#line 1169
  first_time = 1;
#line 1176
  p = (Preview *)malloc(sizeof(*p));
  }
#line 1177
  if (! p) {
#line 1178
    return ((Preview *)0);
  }
  {
#line 1179
  memset(p, 0, sizeof(*p));
#line 1181
  p->dialog = dialog___0;
#line 1182
  p->input_tag = - 1;
  }
#line 1184
  if (first_time) {
    {
#line 1186
    first_time = 0;
#line 1187
    gtk_preview_set_gamma(preferences.preview_gamma);
#line 1188
    gtk_preview_set_install_cmap(preferences.preview_own_cmap);
    }
  }
  {
#line 1194
  __cil_tmp11 = gtk_preview_get_cmap();
#line 1194
  gtk_widget_push_colormap(__cil_tmp11);
#line 1196
  p->top = gtk_dialog_new();
#line 1197
  __cil_tmp13 = gtk_object_get_type();
#line 1197
  __cil_tmp14 = g_type_check_instance_cast((GTypeInstance *)p->top, __cil_tmp13);
#line 1197
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp14), (gchar *)"destroy",
                          (GCallback )(& top_destroyed), (GtkCallbackMarshal )((void *)0),
                          p, (GDestroyNotify )((void *)0), 0, 0);
#line 1199
  __cil_tmp15 = gtk_window_get_type();
#line 1199
  __cil_tmp16 = g_type_check_instance_cast((GTypeInstance *)p->top, __cil_tmp15);
#line 1199
  gtk_window_set_title((GtkWindow *)((void *)__cil_tmp16), (gchar *)"xscanimage preview");
#line 1200
  __cil_tmp19 = gtk_box_get_type();
#line 1200
  __cil_tmp20 = g_type_check_instance_cast((GTypeInstance *)((GtkDialog *)((void *)__cil_tmp18))->vbox,
                                           __cil_tmp19);
#line 1200
  vbox = (GtkBox *)((void *)__cil_tmp20);
#line 1201
  __cil_tmp23 = gtk_box_get_type();
#line 1201
  __cil_tmp24 = g_type_check_instance_cast((GTypeInstance *)((GtkDialog *)((void *)__cil_tmp22))->action_area,
                                           __cil_tmp23);
#line 1201
  hbox = (GtkBox *)((void *)__cil_tmp24);
#line 1204
  table = gtk_table_new((guint )2, (guint )2, 0);
#line 1205
  __cil_tmp26 = gtk_table_get_type();
#line 1205
  __cil_tmp27 = g_type_check_instance_cast((GTypeInstance *)table, __cil_tmp26);
#line 1205
  gtk_table_set_col_spacing((GtkTable *)((void *)__cil_tmp27), (guint )0, (guint )1);
#line 1206
  __cil_tmp28 = gtk_table_get_type();
#line 1206
  __cil_tmp29 = g_type_check_instance_cast((GTypeInstance *)table, __cil_tmp28);
#line 1206
  gtk_table_set_row_spacing((GtkTable *)((void *)__cil_tmp29), (guint )0, (guint )1);
#line 1207
  __cil_tmp30 = gtk_container_get_type();
#line 1207
  __cil_tmp31 = g_type_check_instance_cast((GTypeInstance *)table, __cil_tmp30);
#line 1207
  gtk_container_set_border_width((GtkContainer *)((void *)__cil_tmp31), (guint )2);
#line 1208
  gtk_box_pack_start(vbox, table, ! 0, ! 0, (guint )0);
#line 1212
  frame = gtk_frame_new((gchar *)0);
#line 1213
  __cil_tmp33 = gtk_frame_get_type();
#line 1213
  __cil_tmp34 = g_type_check_instance_cast((GTypeInstance *)frame, __cil_tmp33);
#line 1213
  gtk_frame_set_shadow_type((GtkFrame *)((void *)__cil_tmp34), (GtkShadowType )2);
#line 1214
  __cil_tmp35 = gtk_table_get_type();
#line 1214
  __cil_tmp36 = g_type_check_instance_cast((GTypeInstance *)table, __cil_tmp35);
#line 1214
  gtk_table_attach((GtkTable *)((void *)__cil_tmp36), frame, (guint )0, (guint )1,
                   (guint )0, (guint )1, (GtkAttachOptions )4, (GtkAttachOptions )4,
                   (guint )0, (guint )0);
#line 1218
  p->hruler = gtk_hruler_new();
#line 1219
  __cil_tmp38 = gtk_table_get_type();
#line 1219
  __cil_tmp39 = g_type_check_instance_cast((GTypeInstance *)table, __cil_tmp38);
#line 1219
  gtk_table_attach((GtkTable *)((void *)__cil_tmp39), p->hruler, (guint )1, (guint )2,
                   (guint )0, (guint )1, (GtkAttachOptions )4, (GtkAttachOptions )0,
                   (guint )0, (guint )0);
#line 1223
  p->vruler = gtk_vruler_new();
#line 1224
  __cil_tmp41 = gtk_table_get_type();
#line 1224
  __cil_tmp42 = g_type_check_instance_cast((GTypeInstance *)table, __cil_tmp41);
#line 1224
  gtk_table_attach((GtkTable *)((void *)__cil_tmp42), p->vruler, (guint )0, (guint )1,
                   (guint )1, (guint )2, (GtkAttachOptions )0, (GtkAttachOptions )4,
                   (guint )0, (guint )0);
#line 1229
  p->window = gtk_preview_new((GtkPreviewType )0);
#line 1230
  __cil_tmp44 = gtk_preview_get_type();
#line 1230
  __cil_tmp45 = g_type_check_instance_cast((GTypeInstance *)p->window, __cil_tmp44);
#line 1230
  gtk_preview_set_expand((GtkPreview *)((void *)__cil_tmp45), ! 0);
#line 1231
  gtk_widget_set_events(p->window, 782);
#line 1236
  __cil_tmp46 = gtk_object_get_type();
#line 1236
  __cil_tmp47 = g_type_check_instance_cast((GTypeInstance *)p->window, __cil_tmp46);
#line 1236
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp47), (gchar *)"event", (GtkSignalFunc )(& event_handler),
                          (GtkCallbackMarshal )((void *)0), p, (GDestroyNotify )((void *)0),
                          0, 0);
#line 1238
  __cil_tmp48 = gtk_object_get_type();
#line 1238
  __cil_tmp49 = g_type_check_instance_cast((GTypeInstance *)p->window, __cil_tmp48);
#line 1238
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp49), (gchar *)"expose_event",
                          (GtkSignalFunc )(& expose_handler), (GtkCallbackMarshal )((void *)0),
                          p, (GDestroyNotify )((void *)0), 0, 1);
#line 1240
  __cil_tmp50 = gtk_object_get_type();
#line 1240
  __cil_tmp51 = g_type_check_instance_cast((GTypeInstance *)p->window, __cil_tmp50);
#line 1240
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp51), (gchar *)"size_allocate",
                          (GtkSignalFunc )(& preview_area_resize), (GtkCallbackMarshal )((void *)0),
                          (gpointer )0, (GDestroyNotify )((void *)0), 0, 1);
#line 1242
  __cil_tmp52 = gtk_object_get_type();
#line 1242
  __cil_tmp53 = g_type_check_instance_cast((GTypeInstance *)p->window, __cil_tmp52);
#line 1242
  gtk_object_set_data((GtkObject *)((void *)__cil_tmp53), (gchar *)"PreviewPointer",
                      p);
#line 1248
  __cil_tmp56 = gtk_widget_get_type();
#line 1248
  __cil_tmp57 = g_type_check_class_cast((GTypeClass *)((GtkObjectClass *)((GTypeInstance *)((GtkObject *)((void *)__cil_tmp55)))->g_class),
                                        __cil_tmp56);
#line 1248
  class = (GtkWidgetClass *)((void *)__cil_tmp57);
#line 1252
  signal_func = (GtkSignalFunc )class->motion_notify_event;
#line 1253
  __cil_tmp58 = gtk_object_get_type();
#line 1253
  __cil_tmp59 = g_type_check_instance_cast((GTypeInstance *)p->window, __cil_tmp58);
  }
  {
#line 1253
  __cil_tmp60 = gtk_object_get_type();
#line 1253
  __cil_tmp61 = g_type_check_instance_cast((GTypeInstance *)p->hruler, __cil_tmp60);
#line 1253
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp59), (gchar *)"motion_notify_event\370:V",
                          signal_func, (GtkCallbackMarshal )((void *)0), (GtkObject *)((void *)__cil_tmp61),
                          (GDestroyNotify )((void *)0), 1, 0);
#line 1257
  __cil_tmp64 = gtk_widget_get_type();
#line 1257
  __cil_tmp65 = g_type_check_class_cast((GTypeClass *)((GtkObjectClass *)((GTypeInstance *)((GtkObject *)((void *)__cil_tmp63)))->g_class),
                                        __cil_tmp64);
#line 1257
  class = (GtkWidgetClass *)((void *)__cil_tmp65);
#line 1261
  signal_func = (GtkSignalFunc )class->motion_notify_event;
#line 1262
  __cil_tmp66 = gtk_object_get_type();
#line 1262
  __cil_tmp67 = g_type_check_instance_cast((GTypeInstance *)p->window, __cil_tmp66);
  }
  {
#line 1262
  __cil_tmp68 = gtk_object_get_type();
#line 1262
  __cil_tmp69 = g_type_check_instance_cast((GTypeInstance *)p->vruler, __cil_tmp68);
#line 1262
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp67), (gchar *)"motion_notify_event",
                          signal_func, (GtkCallbackMarshal )((void *)0), (GtkObject *)((void *)__cil_tmp69),
                          (GDestroyNotify )((void *)0), 1, 0);
#line 1265
  p->viewport = gtk_frame_new((gchar *)0);
#line 1266
  __cil_tmp71 = gtk_frame_get_type();
#line 1266
  __cil_tmp72 = g_type_check_instance_cast((GTypeInstance *)p->viewport, __cil_tmp71);
#line 1266
  gtk_frame_set_shadow_type((GtkFrame *)((void *)__cil_tmp72), (GtkShadowType )1);
#line 1267
  __cil_tmp73 = gtk_container_get_type();
#line 1267
  __cil_tmp74 = g_type_check_instance_cast((GTypeInstance *)p->viewport, __cil_tmp73);
#line 1267
  gtk_container_add((GtkContainer *)((void *)__cil_tmp74), p->window);
#line 1269
  __cil_tmp75 = gtk_table_get_type();
#line 1269
  __cil_tmp76 = g_type_check_instance_cast((GTypeInstance *)table, __cil_tmp75);
#line 1269
  gtk_table_attach((GtkTable *)((void *)__cil_tmp76), p->viewport, (guint )1, (guint )2,
                   (guint )1, (guint )2, (GtkAttachOptions )7, (GtkAttachOptions )7,
                   (guint )0, (guint )0);
#line 1273
  preview_update(p);
#line 1278
  p->preview = gtk_button_new_with_label((gchar *)"Acquire Preview");
#line 1279
  __cil_tmp78 = gtk_object_get_type();
#line 1279
  __cil_tmp79 = g_type_check_instance_cast((GTypeInstance *)p->preview, __cil_tmp78);
#line 1279
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp79), (gchar *)"clicked",
                          (GtkSignalFunc )(& start_button_clicked), (GtkCallbackMarshal )((void *)0),
                          p, (GDestroyNotify )((void *)0), 0, 0);
#line 1281
  __cil_tmp80 = gtk_box_get_type();
#line 1281
  __cil_tmp81 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp80);
#line 1281
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp81), p->preview, ! 0, ! 0, (guint )0);
#line 1282
  gtk_widget_show(p->preview);
#line 1285
  p->cancel = gtk_button_new_with_label((gchar *)"Cancel Preview");
#line 1286
  __cil_tmp83 = gtk_object_get_type();
#line 1286
  __cil_tmp84 = g_type_check_instance_cast((GTypeInstance *)p->cancel, __cil_tmp83);
#line 1286
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp84), (gchar *)"clicked",
                          (GtkSignalFunc )(& cancel_button_clicked), (GtkCallbackMarshal )((void *)0),
                          p, (GDestroyNotify )((void *)0), 0, 0);
#line 1288
  __cil_tmp85 = gtk_box_get_type();
#line 1288
  __cil_tmp86 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp85);
#line 1288
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp86), p->cancel, ! 0, ! 0, (guint )0);
#line 1289
  gtk_widget_set_sensitive(p->cancel, 0);
#line 1291
  gtk_widget_show(p->cancel);
#line 1292
  gtk_widget_show(p->viewport);
#line 1293
  gtk_widget_show(p->window);
#line 1294
  gtk_widget_show(p->hruler);
#line 1295
  gtk_widget_show(p->vruler);
#line 1296
  gtk_widget_show(frame);
#line 1297
  gtk_widget_show(table);
#line 1298
  gtk_widget_show(p->top);
#line 1300
  gtk_widget_pop_colormap();
  }
#line 1304
  return (p);
}
}
#line 1308 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
void preview_update(Preview *p ) 
{ 
  float val ;
  float width ;
  float height ;
  float max_width ;
  float max_height ;
  SANE_Option_Descriptor *opt ;
  int i ;
  int surface_changed ;
  SANE_Value_Type type ;
  SANE_Unit unit ;
  float min ;
  float max ;
  double tmp ;
  SANE_Option_Descriptor *__cil_tmp15 ;
  int tmp___0 ;
  int tmp___1 ;
  gint __cil_tmp18 ;
  gint __cil_tmp19 ;
  GType __cil_tmp20 ;
  GTypeInstance *__cil_tmp21 ;
  GType __cil_tmp22 ;
  GTypeInstance *__cil_tmp23 ;
  GType __cil_tmp24 ;
  GTypeInstance *__cil_tmp25 ;

  {
#line 1317
  surface_changed = 0;
#line 1318
  unit = (SANE_Unit )1;
#line 1319
  type = (SANE_Value_Type )1;
#line 1320
  i = 0;
  {
#line 1320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1320
    if (! (i < 4)) {
#line 1320
      goto while_break;
    }
#line 1322
    if (i & 2) {
#line 1322
      tmp = 5000000000.;
    } else {
#line 1322
      tmp = - 5000000000.;
    }
#line 1322
    val = (float )tmp;
#line 1323
    if ((p->dialog)->well_known.coord[i] > 0) {
      {
#line 1325
      opt = sane_get_option_descriptor((p->dialog)->dev, (p->dialog)->well_known.coord[i]);
#line 1328
      unit = opt->unit;
#line 1329
      type = opt->type;
#line 1331
      get_bounds(opt, & min, & max);
      }
#line 1332
      if (i & 2) {
#line 1333
        val = max;
      } else {
#line 1335
        val = min;
      }
    }
#line 1337
    if (p->surface[i] != val) {
#line 1339
      surface_changed = 1;
#line 1340
      p->surface[i] = val;
    }
#line 1320
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1343
  if ((unsigned int )p->surface_unit != (unsigned int )unit) {
#line 1345
    surface_changed = 1;
#line 1346
    p->surface_unit = unit;
  }
#line 1348
  if ((unsigned int )p->surface_type != (unsigned int )type) {
#line 1350
    surface_changed = 1;
#line 1351
    p->surface_type = type;
  }
#line 1353
  if (p->image_data) {
#line 1353
    if (surface_changed) {
      {
#line 1355
      free(p->image_data);
#line 1356
      p->image_data = (u_char *)0;
#line 1357
      p->image_width = 0;
#line 1358
      p->image_height = 0;
      }
    }
  }
#line 1363
  width = p->surface[2] - p->surface[0];
#line 1364
  height = p->surface[3] - p->surface[1];
#line 1365
  if ((unsigned int )p->surface_type == 1U) {
#line 1367
    width += 1.;
#line 1368
    height += 1.;
  } else {
#line 1372
    width += (double )1. / (double )(1 << 16);
#line 1373
    height += (double )1. / (double )(1 << 16);
  }
#line 1378
  if ((double )width >= 5000000000.) {
#line 1379
    p->aspect = (float )1.;
  } else
#line 1378
  if ((double )height >= 5000000000.) {
#line 1379
    p->aspect = (float )1.;
  } else {
#line 1381
    p->aspect = width / height;
  }
#line 1383
  if (surface_changed) {
    {
#line 1385
    __cil_tmp18 = gdk_screen_width();
#line 1385
    max_width = (float )(0.5 * (double )__cil_tmp18);
#line 1386
    __cil_tmp19 = gdk_screen_height();
#line 1386
    max_height = (float )(0.5 * (double )__cil_tmp19);
    }
  } else {
#line 1390
    max_width = (float )(p->window)->allocation.width;
#line 1391
    max_height = (float )(p->window)->allocation.height;
  }
#line 1394
  if ((unsigned int )p->surface_unit != 1U) {
#line 1396
    width = max_width;
#line 1397
    height = width / p->aspect;
#line 1399
    if (height > max_height) {
#line 1401
      height = max_height;
#line 1402
      width = height * p->aspect;
    }
  } else {
#line 1407
    if (width > max_width) {
#line 1408
      width = max_width;
    }
#line 1410
    if (height > max_height) {
#line 1411
      height = max_height;
    }
  }
#line 1415
  if (width / height != p->aspect) {
#line 1417
    if ((double )p->aspect > 1.) {
#line 1418
      height = width / p->aspect;
    } else {
#line 1420
      width = height * p->aspect;
    }
  }
#line 1423
  p->preview_width = (int )((double )width + 0.5);
#line 1424
  p->preview_height = (int )((double )height + 0.5);
#line 1425
  if (surface_changed) {
    {
#line 1427
    __cil_tmp20 = gtk_widget_get_type();
#line 1427
    __cil_tmp21 = g_type_check_instance_cast((GTypeInstance *)p->window, __cil_tmp20);
#line 1427
    gtk_widget_set_usize((GtkWidget *)((void *)__cil_tmp21), p->preview_width, p->preview_height);
    }
#line 1429
    if ((((GtkObject *)((void *)__cil_tmp23))->flags & 256U) != 0U) {
#line 1429
      if ((((GtkObject *)((void *)__cil_tmp25))->flags & 128U) != 0U) {
        {
#line 1430
        preview_area_resize(p->window);
        }
      }
    }
#line 1432
    if (preferences.preserve_preview) {
      {
#line 1433
      restore_preview_image(p);
      }
    }
  }
  {
#line 1435
  update_selection(p);
  }
  return;
}
}
#line 1439 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
void preview_scan(Preview *p ) 
{ 
  float min ;
  float max ;
  float swidth ;
  float sheight ;
  float width ;
  float height ;
  float dpi ;
  SANE_Option_Descriptor *opt ;
  gint gwidth ;
  gint gheight ;
  int i ;
  SANE_Status status ;
  SANE_Option_Descriptor *__cil_tmp14 ;
  SANE_Status __cil_tmp15 ;

  {
  {
#line 1441
  dpi = (float )0;
#line 1448
  save_option(p, (p->dialog)->well_known.dpi, & p->saved_dpi, & p->saved_dpi_valid);
#line 1450
  i = 0;
  }
  {
#line 1450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1450
    if (! (i < 4)) {
#line 1450
      goto while_break;
    }
    {
#line 1451
    save_option(p, (p->dialog)->well_known.coord[i], & p->saved_coord[i], (int *)p->saved_coord_valid + i);
    }
#line 1450
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1456
  if ((p->dialog)->well_known.dpi > 0) {
    {
#line 1458
    opt = sane_get_option_descriptor((p->dialog)->dev, (p->dialog)->well_known.dpi);
#line 1461
    gwidth = p->preview_width;
#line 1462
    gheight = p->preview_height;
#line 1464
    height = (float )gheight;
#line 1465
    width = height * p->aspect;
    }
#line 1466
    if (width > (float )gwidth) {
#line 1468
      width = (float )gwidth;
#line 1469
      height = width / p->aspect;
    }
#line 1472
    swidth = p->surface[2] - p->surface[0];
#line 1473
    if ((double )swidth < 5000000000.) {
#line 1474
      dpi = (float )((25.4 * (double )width) / (double )swidth);
    } else {
#line 1477
      sheight = p->surface[3] - p->surface[1];
#line 1478
      if ((double )sheight < 5000000000.) {
#line 1479
        dpi = (float )((25.4 * (double )height) / (double )sheight);
      } else {
#line 1481
        dpi = (float )18.;
      }
    }
    {
#line 1483
    get_bounds(opt, & min, & max);
    }
#line 1484
    if (dpi < min) {
#line 1485
      dpi = min;
    }
#line 1486
    if (dpi > max) {
#line 1487
      dpi = max;
    }
    {
#line 1488
    status = set_option_float(p, (p->dialog)->well_known.dpi, dpi);
    }
#line 1489
    if ((unsigned int )status != 0U) {
#line 1490
      return;
    }
  }
#line 1495
  i = 0;
  {
#line 1495
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1495
    if (! (i < 4)) {
#line 1495
      goto while_break___0;
    }
    {
#line 1496
    set_option_float(p, (p->dialog)->well_known.coord[i], p->surface[i]);
    }
#line 1495
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1497
  set_option_bool(p, (p->dialog)->well_known.preview, 1);
#line 1500
  scan_start(p);
  }
  return;
}
}
#line 1504 "/root/oss-experiment/data/sane-frontends-1.0.14/src/preview.c"
void preview_destroy(Preview *p ) 
{ 
  char filename[4096] ;
  FILE *out ;
  int __cil_tmp4 ;
  FILE *__cil_tmp5 ;

  {
#line 1509
  if (p->scanning) {
    {
#line 1510
    scan_done(p);
    }
  } else {
    {
#line 1511
    __cil_tmp4 = make_preview_image_path(p, sizeof(filename), (char *)filename);
    }
#line 1511
    if (p->image_data) {
#line 1511
      if (preferences.preserve_preview) {
#line 1511
        if (__cil_tmp4 >= 0) {
          {
#line 1515
          out = fopen((char const   *)((char *)filename), "w");
          }
#line 1516
          if (out) {
            {
#line 1519
            fprintf(out, "P6\n# surface: %g %g %g %g %u %u\n%d %d\n255\n\314\370:V",
                    (double )p->surface[0], (double )p->surface[1], (double )p->surface[2],
                    (double )p->surface[3], (unsigned int )p->surface_type, (unsigned int )p->surface_unit,
                    p->image_width, p->image_height);
#line 1523
            fwrite(p->image_data, (unsigned long )3, (unsigned long )(p->image_width * p->image_height),
                   out);
#line 1524
            fclose(out);
            }
          }
        }
      }
    }
  }
#line 1527
  if (p->image_data) {
    {
#line 1528
    free(p->image_data);
    }
  }
#line 1529
  if (p->preview_row) {
    {
#line 1530
    free(p->preview_row);
    }
  }
#line 1531
  if (p->gc) {
    {
#line 1532
    g_object_unref(p->gc);
    }
  }
#line 1533
  if (p->top) {
    {
#line 1534
    gtk_widget_destroy(p->top);
    }
  }
  {
#line 1535
  free(p);
  }
  return;
}
}
#line 30 "/root/oss-experiment/data/sane-frontends-1.0.14/src/progress.h"
Progress_t *progress_new(char *title , char *text , GtkSignalFunc callback , gpointer callback_data ) ;
#line 31
void progress_free(Progress_t *p ) ;
#line 32
void progress_update(Progress_t *p , gfloat newval ) ;
#line 26 "/root/oss-experiment/data/sane-frontends-1.0.14/src/progress.c"
static int const   progress_x  =    5;
#line 27 "/root/oss-experiment/data/sane-frontends-1.0.14/src/progress.c"
static int const   progress_y  =    5;
#line 30 "/root/oss-experiment/data/sane-frontends-1.0.14/src/progress.c"
void progress_cancel(GtkWidget *widget , gpointer data ) 
{ 
  Progress_t *p ;

  {
  {
#line 32
  p = (Progress_t *)data;
#line 34
  (*(p->callback))();
  }
  return;
}
}
#line 39 "/root/oss-experiment/data/sane-frontends-1.0.14/src/progress.c"
Progress_t *progress_new(char *title , char *text , GtkSignalFunc callback , gpointer callback_data ) 
{ 
  GtkWidget *button ;
  GtkWidget *label ;
  GtkBox *vbox ;
  GtkBox *hbox ;
  Progress_t *p ;
  void *__cil_tmp10 ;
  GtkWidget *__cil_tmp11 ;
  GType __cil_tmp12 ;
  GTypeInstance *__cil_tmp13 ;
  GType __cil_tmp14 ;
  GTypeInstance *__cil_tmp15 ;
  GType __cil_tmp16 ;
  GTypeInstance *__cil_tmp17 ;
  GType __cil_tmp18 ;
  GTypeInstance *__cil_tmp19 ;
  GType __cil_tmp20 ;
  GTypeInstance *__cil_tmp21 ;
  GType __cil_tmp22 ;
  GTypeInstance *__cil_tmp23 ;
  GtkWidget *__cil_tmp24 ;
  GType __cil_tmp25 ;
  GTypeInstance *__cil_tmp26 ;
  GtkWidget *__cil_tmp27 ;
  GtkWidget *__cil_tmp28 ;
  GType __cil_tmp29 ;
  GTypeInstance *__cil_tmp30 ;
  GType __cil_tmp31 ;
  GTypeInstance *__cil_tmp32 ;
  GType __cil_tmp33 ;
  GTypeInstance *__cil_tmp34 ;

  {
  {
#line 46
  __cil_tmp10 = malloc(sizeof(Progress_t ));
#line 46
  p = (Progress_t *)__cil_tmp10;
#line 47
  p->callback = callback;
#line 49
  p->shell = gtk_dialog_new();
#line 50
  gtk_widget_set_uposition(p->shell, progress_x, progress_y);
#line 51
  __cil_tmp12 = gtk_window_get_type();
#line 51
  __cil_tmp13 = g_type_check_instance_cast((GTypeInstance *)p->shell, __cil_tmp12);
#line 51
  gtk_window_set_title((GtkWindow *)((void *)__cil_tmp13), title);
#line 52
  __cil_tmp16 = gtk_box_get_type();
#line 52
  __cil_tmp17 = g_type_check_instance_cast((GTypeInstance *)((GtkDialog *)((void *)__cil_tmp15))->vbox,
                                           __cil_tmp16);
#line 52
  vbox = (GtkBox *)((void *)__cil_tmp17);
#line 53
  __cil_tmp20 = gtk_box_get_type();
#line 53
  __cil_tmp21 = g_type_check_instance_cast((GTypeInstance *)((GtkDialog *)((void *)__cil_tmp19))->action_area,
                                           __cil_tmp20);
#line 53
  hbox = (GtkBox *)((void *)__cil_tmp21);
#line 55
  __cil_tmp22 = gtk_container_get_type();
#line 55
  __cil_tmp23 = g_type_check_instance_cast((GTypeInstance *)vbox, __cil_tmp22);
#line 55
  gtk_container_set_border_width((GtkContainer *)((void *)__cil_tmp23), (guint )7);
#line 57
  label = gtk_label_new(text);
#line 58
  __cil_tmp25 = gtk_misc_get_type();
#line 58
  __cil_tmp26 = g_type_check_instance_cast((GTypeInstance *)label, __cil_tmp25);
#line 58
  gtk_misc_set_alignment((GtkMisc *)((void *)__cil_tmp26), (gfloat )0., (gfloat )0.5);
#line 59
  gtk_box_pack_start(vbox, label, 0, ! 0, (guint )0);
#line 61
  p->pbar = gtk_progress_bar_new();
#line 62
  gtk_widget_set_usize(p->pbar, 200, 20);
#line 63
  gtk_box_pack_start(vbox, p->pbar, ! 0, ! 0, (guint )0);
#line 65
  button = gtk_toggle_button_new_with_label((gchar *)"Cancel");
#line 66
  __cil_tmp29 = gtk_object_get_type();
#line 66
  __cil_tmp30 = g_type_check_instance_cast((GTypeInstance *)button, __cil_tmp29);
#line 66
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp30), (gchar *)"clicked",
                          (GtkSignalFunc )(& progress_cancel), (GtkCallbackMarshal )((void *)0),
                          p, (GDestroyNotify )((void *)0), 0, 0);
#line 68
  gtk_box_pack_start(hbox, button, ! 0, ! 0, (guint )0);
#line 70
  gtk_widget_show(label);
#line 71
  gtk_widget_show(p->pbar);
#line 72
  gtk_widget_show(button);
#line 73
  __cil_tmp31 = gtk_widget_get_type();
#line 73
  __cil_tmp32 = g_type_check_instance_cast((GTypeInstance *)p->shell, __cil_tmp31);
#line 73
  gtk_widget_show((GtkWidget *)((void *)__cil_tmp32));
#line 74
  __cil_tmp33 = gtk_progress_bar_get_type();
#line 74
  __cil_tmp34 = g_type_check_instance_cast((GTypeInstance *)p->pbar, __cil_tmp33);
#line 74
  gtk_progress_bar_update((GtkProgressBar *)((void *)__cil_tmp34), (gdouble )0);
  }
#line 75
  return (p);
}
}
#line 79 "/root/oss-experiment/data/sane-frontends-1.0.14/src/progress.c"
void progress_free(Progress_t *p ) 
{ 


  {
#line 81
  if (p) {
    {
#line 83
    gtk_widget_destroy(p->shell);
#line 84
    free(p);
    }
  }
  return;
}
}
#line 89 "/root/oss-experiment/data/sane-frontends-1.0.14/src/progress.c"
void progress_update(Progress_t *p , gfloat newval ) 
{ 
  GType __cil_tmp3 ;
  GTypeInstance *__cil_tmp4 ;

  {
#line 91
  if (p) {
    {
#line 92
    __cil_tmp3 = gtk_progress_bar_get_type();
#line 92
    __cil_tmp4 = g_type_check_instance_cast((GTypeInstance *)p->pbar, __cil_tmp3);
#line 92
    gtk_progress_bar_update((GtkProgressBar *)((void *)__cil_tmp4), (gdouble )newval);
    }
  }
  return;
}
}
#line 398 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h"
extern  __attribute__((__nothrow__)) __ssize_t readahead(int __fd , __off64_t __offset ,
                                                         size_t __count ) ;
#line 406
extern int sync_file_range(int __fd , __off64_t __offset , __off64_t __count , unsigned int __flags ) ;
#line 414
extern __ssize_t vmsplice(int __fdout , struct iovec *__iov , size_t __count , unsigned int __flags ) ;
#line 421
extern __ssize_t splice(int __fdin , __off64_t *__offin , int __fdout , __off64_t *__offout ,
                        size_t __len , unsigned int __flags ) ;
#line 429
extern __ssize_t tee(int __fdin , int __fdout , size_t __len , unsigned int __flags ) ;
#line 437
extern int fallocate(int __fd , int __mode , __off_t __offset , __off_t __len ) ;
#line 448
extern int fallocate64(int __fd , int __mode , __off64_t __offset , __off64_t __len ) ;
#line 454
extern  __attribute__((__nothrow__)) int name_to_handle_at(int __dfd , char const   *__name ,
                                                           struct file_handle *__handle ,
                                                           int *__mnt_id , int __flags ) ;
#line 462
extern int open_by_handle_at(int __mountdirfd , struct file_handle *__handle , int __flags ) ;
#line 149 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 158
extern int fcntl64(int __fd , int __cmd  , ...) ;
#line 181
__inline extern int open(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 191
__inline extern int open64(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 205
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 216
__inline extern int openat64(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 227
extern int creat(char const   *__file , mode_t __mode ) ;
#line 237
extern int creat64(char const   *__file , mode_t __mode ) ;
#line 273
extern  __attribute__((__nothrow__)) int posix_fadvise(int __fd , __off_t __offset ,
                                                       __off_t __len , int __advise ) ;
#line 285
extern  __attribute__((__nothrow__)) int posix_fadvise64(int __fd , __off64_t __offset ,
                                                         __off64_t __len , int __advise ) ;
#line 295
extern int posix_fallocate(int __fd , __off_t __offset , __off_t __len ) ;
#line 306
extern int posix_fallocate64(int __fd , __off64_t __offset , __off64_t __len ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
extern int __open_2(char const   *__path , int __oflag ) ;
#line 27
extern int __open_alias(char const   *__path , int __oflag  , ...) ;
#line 35
extern void __open_too_many_args(void) ;
#line 37
extern void __open_missing_mode(void) ;
#line 41
__inline extern int open(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int open(char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 43
  __cil_tmp3 = __builtin_va_arg_pack_len();
  }
#line 43
  if (__cil_tmp3 > 1) {
    {
#line 44
    __open_too_many_args();
    }
  }
  {
#line 46
  __cil_tmp4 = __builtin_constant_p(__oflag);
  }
#line 46
  if (__cil_tmp4) {
    {
#line 48
    __cil_tmp5 = __builtin_va_arg_pack_len();
    }
#line 48
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 48
      if (__cil_tmp5 < 1) {
        {
#line 50
        __open_missing_mode();
#line 51
        __cil_tmp6 = __open_2(__path, __oflag);
        }
#line 51
        return (__cil_tmp6);
      }
    } else
#line 48
    if ((__oflag & 4259840) == 4259840) {
#line 48
      goto _L;
    }
    {
#line 53
    __cil_tmp7 = __builtin_va_arg_pack();
#line 53
    __cil_tmp8 = __open_alias(__path, __oflag, __cil_tmp7);
    }
#line 53
    return (__cil_tmp8);
  }
  {
#line 56
  __cil_tmp9 = __builtin_va_arg_pack_len();
  }
#line 56
  if (__cil_tmp9 < 1) {
    {
#line 57
    __cil_tmp10 = __open_2(__path, __oflag);
    }
#line 57
    return (__cil_tmp10);
  }
  {
#line 59
  __cil_tmp11 = __builtin_va_arg_pack();
#line 59
  __cil_tmp12 = __open_alias(__path, __oflag, __cil_tmp11);
  }
#line 59
  return (__cil_tmp12);
}
}
#line 64
extern int __open64_2(char const   *__path , int __oflag ) ;
#line 65
extern int __open64_alias(char const   *__path , int __oflag  , ...) ;
#line 67
extern void __open64_too_many_args(void) ;
#line 69
extern void __open64_missing_mode(void) ;
#line 73
__inline extern int open64(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int open64(char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 75
  __cil_tmp3 = __builtin_va_arg_pack_len();
  }
#line 75
  if (__cil_tmp3 > 1) {
    {
#line 76
    __open64_too_many_args();
    }
  }
  {
#line 78
  __cil_tmp4 = __builtin_constant_p(__oflag);
  }
#line 78
  if (__cil_tmp4) {
    {
#line 80
    __cil_tmp5 = __builtin_va_arg_pack_len();
    }
#line 80
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 80
      if (__cil_tmp5 < 1) {
        {
#line 82
        __open64_missing_mode();
#line 83
        __cil_tmp6 = __open64_2(__path, __oflag);
        }
#line 83
        return (__cil_tmp6);
      }
    } else
#line 80
    if ((__oflag & 4259840) == 4259840) {
#line 80
      goto _L;
    }
    {
#line 85
    __cil_tmp7 = __builtin_va_arg_pack();
#line 85
    __cil_tmp8 = __open64_alias(__path, __oflag, __cil_tmp7);
    }
#line 85
    return (__cil_tmp8);
  }
  {
#line 88
  __cil_tmp9 = __builtin_va_arg_pack_len();
  }
#line 88
  if (__cil_tmp9 < 1) {
    {
#line 89
    __cil_tmp10 = __open64_2(__path, __oflag);
    }
#line 89
    return (__cil_tmp10);
  }
  {
#line 91
  __cil_tmp11 = __builtin_va_arg_pack();
#line 91
  __cil_tmp12 = __open64_alias(__path, __oflag, __cil_tmp11);
  }
#line 91
  return (__cil_tmp12);
}
}
#line 98
extern int __openat_2(int __fd , char const   *__path , int __oflag ) ;
#line 100
extern int __openat_alias(int __fd , char const   *__path , int __oflag  , ...) ;
#line 111
extern void __openat_too_many_args(void) ;
#line 113
extern void __openat_missing_mode(void) ;
#line 117
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 119
  __cil_tmp4 = __builtin_va_arg_pack_len();
  }
#line 119
  if (__cil_tmp4 > 1) {
    {
#line 120
    __openat_too_many_args();
    }
  }
  {
#line 122
  __cil_tmp5 = __builtin_constant_p(__oflag);
  }
#line 122
  if (__cil_tmp5) {
    {
#line 124
    __cil_tmp6 = __builtin_va_arg_pack_len();
    }
#line 124
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 124
      if (__cil_tmp6 < 1) {
        {
#line 126
        __openat_missing_mode();
#line 127
        __cil_tmp7 = __openat_2(__fd, __path, __oflag);
        }
#line 127
        return (__cil_tmp7);
      }
    } else
#line 124
    if ((__oflag & 4259840) == 4259840) {
#line 124
      goto _L;
    }
    {
#line 129
    __cil_tmp8 = __builtin_va_arg_pack();
#line 129
    __cil_tmp9 = __openat_alias(__fd, __path, __oflag, __cil_tmp8);
    }
#line 129
    return (__cil_tmp9);
  }
  {
#line 132
  __cil_tmp10 = __builtin_va_arg_pack_len();
  }
#line 132
  if (__cil_tmp10 < 1) {
    {
#line 133
    __cil_tmp11 = __openat_2(__fd, __path, __oflag);
    }
#line 133
    return (__cil_tmp11);
  }
  {
#line 135
  __cil_tmp12 = __builtin_va_arg_pack();
#line 135
  __cil_tmp13 = __openat_alias(__fd, __path, __oflag, __cil_tmp12);
  }
#line 135
  return (__cil_tmp13);
}
}
#line 140
extern int __openat64_2(int __fd , char const   *__path , int __oflag ) ;
#line 142
extern int __openat64_alias(int __fd , char const   *__path , int __oflag  , ...) ;
#line 145
extern void __openat64_too_many_args(void) ;
#line 147
extern void __openat64_missing_mode(void) ;
#line 151
__inline extern int openat64(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 151 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int openat64(int __fd , char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 153
  __cil_tmp4 = __builtin_va_arg_pack_len();
  }
#line 153
  if (__cil_tmp4 > 1) {
    {
#line 154
    __openat64_too_many_args();
    }
  }
  {
#line 156
  __cil_tmp5 = __builtin_constant_p(__oflag);
  }
#line 156
  if (__cil_tmp5) {
    {
#line 158
    __cil_tmp6 = __builtin_va_arg_pack_len();
    }
#line 158
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 158
      if (__cil_tmp6 < 1) {
        {
#line 160
        __openat64_missing_mode();
#line 161
        __cil_tmp7 = __openat64_2(__fd, __path, __oflag);
        }
#line 161
        return (__cil_tmp7);
      }
    } else
#line 158
    if ((__oflag & 4259840) == 4259840) {
#line 158
      goto _L;
    }
    {
#line 163
    __cil_tmp8 = __builtin_va_arg_pack();
#line 163
    __cil_tmp9 = __openat64_alias(__fd, __path, __oflag, __cil_tmp8);
    }
#line 163
    return (__cil_tmp9);
  }
  {
#line 166
  __cil_tmp10 = __builtin_va_arg_pack_len();
  }
#line 166
  if (__cil_tmp10 < 1) {
    {
#line 167
    __cil_tmp11 = __openat64_2(__fd, __path, __oflag);
    }
#line 167
    return (__cil_tmp11);
  }
  {
#line 169
  __cil_tmp12 = __builtin_va_arg_pack();
#line 169
  __cil_tmp13 = __openat64_alias(__fd, __path, __oflag, __cil_tmp12);
  }
#line 169
  return (__cil_tmp13);
}
}
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 39
  __cil_tmp4 = __builtin_object_size(__resolved, 1);
#line 39
  sz = __cil_tmp4;
  }
#line 41
  if (sz == 0xffffffffffffffffUL) {
    {
#line 42
    __cil_tmp5 = __realpath_alias(__name, __resolved);
    }
#line 42
    return (__cil_tmp5);
  }
  {
#line 45
  __cil_tmp7 = __builtin_constant_p(4096UL <= sz / sizeof(char ));
  }
  {
#line 45
  __cil_tmp6 = __builtin_constant_p(4096);
  }
#line 45
  if (__cil_tmp6) {
#line 45
    if (__cil_tmp7) {
#line 45
      if (! (4096UL <= sz / sizeof(char ))) {
        {
#line 46
        __cil_tmp8 = __realpath_chk_warn(__name, __resolved, sz);
        }
#line 46
        return (__cil_tmp8);
      }
    }
  }
  {
#line 48
  __cil_tmp9 = __realpath_chk(__name, __resolved, sz);
  }
#line 48
  return (__cil_tmp9);
}
}
#line 113 "/root/oss-experiment/data/sane-frontends-1.0.14/src/../include/sane/sanei_debug.h"
int sanei_debug_xscanimage  =    0;
#line 146
static void sanei_debug_xscanimage_call(int level , char const   *msg  , ...) ;
#line 153 "/root/oss-experiment/data/sane-frontends-1.0.14/src/../include/sane/sanei_debug.h"
static void sanei_debug_xscanimage_call(int level , char const   *msg  , ...) 
{ 
  va_list ap ;

  {
  {
#line 157
  __builtin_va_start((void *)ap, msg);
#line 158
  sanei_debug_msg(level, sanei_debug_xscanimage, "xscanimage", msg, (void *)ap);
#line 159
  __builtin_va_end((void *)ap);
  }
  return;
}
}
#line 47 "/usr/include/babl-0.1/babl/babl-version.h"
void babl_get_version(int *major , int *minor , int *micro ) ;
#line 38 "/usr/include/babl-0.1/babl/babl.h"
void babl_init(void) ;
#line 46
void babl_exit(void) ;
#line 54
Babl *babl_type(char const   *name ) ;
#line 63
Babl *babl_sampling(int horizontal , int vertical ) ;
#line 73
Babl *babl_component(char const   *name ) ;
#line 81
Babl *babl_model(char const   *name ) ;
#line 90
Babl *babl_model_with_space(char const   *name , Babl *space ) ;
#line 101
Babl *babl_space(char const   *name ) ;
#line 133
Babl *babl_space_from_icc(char const   *icc_data , int icc_length , BablIccIntent intent ,
                          char const   **error ) ;
#line 144
double babl_space_get_gamma(Babl *space ) ;
#line 147
Babl *babl_icc_make_space(char const   *icc_data , int icc_length , BablIccIntent intent ,
                          char const   **error ) ;
#line 167
char *babl_icc_get_key(char const   *icc_data , int icc_length , char const   *key ,
                       char const   *language , char const   *country ) ;
#line 182
Babl *babl_format(char const   *encoding ) ;
#line 194
Babl *babl_format_with_space(char const   *encoding , Babl *space ) ;
#line 203
int babl_format_exists(char const   *name ) ;
#line 210
Babl *babl_format_get_space(Babl *format ) ;
#line 220
Babl *babl_fish(void const   *source_format , void const   *destination_format ) ;
#line 238
Babl *babl_fast_fish(void const   *source_format , void const   *destination_format ,
                     char const   *performance ) ;
#line 248
long babl_process(Babl *babl_fish , void const   *source , void *destination , long n ) ;
#line 254
long babl_process_rows(Babl *babl_fish , void const   *source , int source_stride ,
                       void *dest , int dest_stride , long n , int rows ) ;
#line 268
char const   *babl_get_name(Babl *babl ) ;
#line 275
int babl_format_has_alpha(Babl *format ) ;
#line 282
int babl_format_get_bytes_per_pixel(Babl *format ) ;
#line 289
Babl *babl_format_get_model(Babl *format ) ;
#line 332
BablModelFlag babl_get_model_flags(Babl *model ) ;
#line 339
int babl_format_get_n_components(Babl *format ) ;
#line 347
Babl *babl_format_get_type(Babl *format , int component_index ) ;
#line 364
Babl *babl_type_new(void *first_arg  , ...) ;
#line 375
Babl *babl_component_new(void *first_arg  , ...) ;
#line 389
Babl *babl_model_new(void *first_arg  , ...) ;
#line 411
Babl *babl_format_new(void const   *first_arg  , ...) ;
#line 423
Babl *babl_format_n(Babl *type , int components ) ;
#line 431
int babl_format_is_format_n(Babl *format ) ;
#line 445
Babl *babl_conversion_new(void const   *first_arg  , ...) ;
#line 453
Babl *babl_conversion_get_source_space(Babl *conversion ) ;
#line 460
Babl *babl_conversion_get_destination_space(Babl *conversion ) ;
#line 471
Babl *babl_new_palette(char const   *name , Babl **format_u8 , Babl **format_u8_with_alpha ) ;
#line 484
Babl *babl_new_palette_with_space(char const   *name , Babl *space , Babl **format_u8 ,
                                  Babl **format_u8_with_alpha ) ;
#line 494
int babl_format_is_palette(Babl *format ) ;
#line 506
void babl_palette_set_palette(Babl *babl , Babl *format , void *data , int count ) ;
#line 517
void babl_palette_reset(Babl *babl ) ;
#line 528
void babl_set_user_data(Babl *babl , void *data ) ;
#line 535
void *babl_get_user_data(Babl *babl ) ;
#line 568
Babl *babl_space_from_chromaticities(char const   *name , double wx , double wy ,
                                     double rx , double ry , double gx , double gy ,
                                     double bx , double by , Babl *trc_red , Babl *trc_green ,
                                     Babl *trc_blue , BablSpaceFlags flags ) ;
#line 585
Babl *babl_trc_gamma(double gamma ) ;
#line 593
Babl *babl_trc(char const   *name ) ;
#line 600
Babl *babl_space_with_trc(Babl *space , Babl *trc ) ;
#line 622
void babl_space_get(Babl *space , double *xw , double *yw , double *xr , double *yr ,
                    double *xg , double *yg , double *xb , double *yb , Babl **red_trc ,
                    Babl **green_trc , Babl **blue_trc ) ;
#line 641
void babl_space_get_rgb_luminance(Babl *space , double *red_luminance , double *green_luminance ,
                                  double *blue_luminance ) ;
#line 652
int babl_model_is(Babl *babl , char const   *model_name ) ;
#line 669
char const   *babl_space_get_icc(Babl *babl , int *length ) ;
#line 697
Babl *babl_space_from_rgbxyz_matrix(char const   *name , double wx , double wy , double wz ,
                                    double rx , double gx , double bx , double ry ,
                                    double gy , double by , double rz , double gz ,
                                    double bz , Babl *trc_red , Babl *trc_green ,
                                    Babl *trc_blue ) ;
#line 711
char const   *babl_format_get_encoding(Babl *babl ) ;
#line 713
int babl_space_is_cmyk(Babl *space ) ;
#line 714
int babl_space_is_gray(Babl *space ) ;
#line 724
BablFishProcess babl_fish_get_process(Babl *babl ) ;
#line 53 "/usr/include/gegl-0.4/gegl-enums.h"
GType gegl_dither_method_get_type(void) ;
#line 63
GType gegl_distance_metric_get_type(void) ;
#line 73
GType gegl_orientation_get_type(void) ;
#line 101
GType gegl_babl_variant_get_type(void) ;
#line 112
GType gegl_cache_policy_get_type(void) ;
#line 53 "/usr/include/gegl-0.4/gegl-types.h"
GType gegl_config_get_type(void) ;
#line 59
GType gegl_stats_get_type(void) ;
#line 72
GType gegl_operation_get_type(void) ;
#line 76 "/usr/include/gegl-0.4/gegl-types.h"
__inline static void glib_autoptr_clear_GeglOperation(GeglOperation *_ptr ) 
{ 


  {
#line 76
  if (_ptr) {
    {
#line 76
    g_object_unref((GeglOperation *)_ptr);
    }
  }
  return;
}
}
#line 76 "/usr/include/gegl-0.4/gegl-types.h"
__inline static void glib_autoptr_cleanup_GeglOperation(GeglOperation **_ptr ) 
{ 


  {
  {
#line 76
  glib_autoptr_clear_GeglOperation(*_ptr);
  }
  return;
}
}
#line 79
GType gegl_node_get_type(void) ;
#line 83 "/usr/include/gegl-0.4/gegl-types.h"
__inline static void glib_autoptr_clear_GeglNode(GeglNode *_ptr ) 
{ 


  {
#line 83
  if (_ptr) {
    {
#line 83
    g_object_unref((GeglNode *)_ptr);
    }
  }
  return;
}
}
#line 83 "/usr/include/gegl-0.4/gegl-types.h"
__inline static void glib_autoptr_cleanup_GeglNode(GeglNode **_ptr ) 
{ 


  {
  {
#line 83
  glib_autoptr_clear_GeglNode(*_ptr);
  }
  return;
}
}
#line 86
GType gegl_processor_get_type(void) ;
#line 90 "/usr/include/gegl-0.4/gegl-types.h"
__inline static void glib_autoptr_clear_GeglProcessor(GeglProcessor *_ptr ) 
{ 


  {
#line 90
  if (_ptr) {
    {
#line 90
    g_object_unref((GeglProcessor *)_ptr);
    }
  }
  return;
}
}
#line 90 "/usr/include/gegl-0.4/gegl-types.h"
__inline static void glib_autoptr_cleanup_GeglProcessor(GeglProcessor **_ptr ) 
{ 


  {
  {
#line 90
  glib_autoptr_clear_GeglProcessor(*_ptr);
  }
  return;
}
}
#line 93
GType gegl_random_get_type(void) ;
#line 43 "/usr/include/gegl-0.4/gegl-buffer-matrix2.h"
gboolean gegl_buffer_matrix2_is_identity(GeglBufferMatrix2 *matrix ) ;
#line 53
gboolean gegl_buffer_matrix2_is_scale(GeglBufferMatrix2 *matrix ) ;
#line 61
gdouble gegl_buffer_matrix2_determinant(GeglBufferMatrix2 *matrix ) ;
#line 63 "/usr/include/gegl-0.4/gegl-buffer-enums.h"
GType gegl_abyss_policy_get_type(void) ;
#line 74
GType gegl_access_mode_get_type(void) ;
#line 86
GType gegl_sampler_type_get_type(void) ;
#line 96
GType gegl_rectangle_alignment_get_type(void) ;
#line 68 "/usr/include/gegl-0.4/gegl-buffer.h"
GeglBuffer *gegl_buffer_new(GeglRectangle *extent , Babl *format ) ;
#line 82
GeglBuffer *gegl_buffer_new_for_backend(GeglRectangle *extent , GeglTileBackend *backend ) ;
#line 92
void gegl_buffer_add_handler(GeglBuffer *buffer , gpointer handler ) ;
#line 102
void gegl_buffer_remove_handler(GeglBuffer *buffer , gpointer handler ) ;
#line 115
GeglBuffer *gegl_buffer_open(gchar *path ) ;
#line 126
void gegl_buffer_save(GeglBuffer *buffer , gchar *path , GeglRectangle *roi ) ;
#line 140
GeglBuffer *gegl_buffer_load(gchar *path ) ;
#line 149
void gegl_buffer_flush(GeglBuffer *buffer ) ;
#line 161
GeglBuffer *gegl_buffer_create_sub_buffer(GeglBuffer *buffer , GeglRectangle *extent ) ;
#line 172
GeglRectangle *gegl_buffer_get_extent(GeglBuffer *buffer ) ;
#line 186
gboolean gegl_buffer_set_extent(GeglBuffer *buffer , GeglRectangle *extent ) ;
#line 198
gboolean gegl_buffer_set_abyss(GeglBuffer *buffer , GeglRectangle *abyss ) ;
#line 271
void gegl_buffer_get(GeglBuffer *buffer , GeglRectangle *rect , gdouble scale , Babl *format ,
                     gpointer dest , gint rowstride , GeglAbyssPolicy repeat_mode ) ;
#line 294
void gegl_buffer_set(GeglBuffer *buffer , GeglRectangle *rect , gint mipmap_level ,
                     Babl *format , void const   *src , gint rowstride ) ;
#line 313
void gegl_buffer_set_color_from_pixel(GeglBuffer *buffer , GeglRectangle *rect , gconstpointer pixel ,
                                      Babl *pixel_format ) ;
#line 331
void gegl_buffer_set_pattern(GeglBuffer *buffer , GeglRectangle *rect , GeglBuffer *pattern ,
                             gint x_offset , gint y_offset ) ;
#line 349
Babl *gegl_buffer_get_format(GeglBuffer *buffer ) ;
#line 365
Babl *gegl_buffer_set_format(GeglBuffer *buffer , Babl *format ) ;
#line 376
void gegl_buffer_clear(GeglBuffer *buffer , GeglRectangle *roi ) ;
#line 396
void gegl_buffer_copy(GeglBuffer *src , GeglRectangle *src_rect , GeglAbyssPolicy repeat_mode ,
                      GeglBuffer *dst , GeglRectangle *dst_rect ) ;
#line 413
GeglBuffer *gegl_buffer_dup(GeglBuffer *buffer ) ;
#line 444
void gegl_buffer_sample_at_level(GeglBuffer *buffer , gdouble x , gdouble y , GeglBufferMatrix2 *scale ,
                                 gpointer dest , Babl *format , gint level , GeglSamplerType sampler_type ,
                                 GeglAbyssPolicy repeat_mode ) ;
#line 480
void gegl_buffer_sample(GeglBuffer *buffer , gdouble x , gdouble y , GeglBufferMatrix2 *scale ,
                        gpointer dest , Babl *format , GeglSamplerType sampler_type ,
                        GeglAbyssPolicy repeat_mode ) ;
#line 501
void gegl_buffer_sample_cleanup(GeglBuffer *buffer ) ;
#line 516
GeglSamplerGetFun gegl_sampler_get_fun(GeglSampler *sampler ) ;
#line 534
GeglSampler *gegl_buffer_sampler_new(GeglBuffer *buffer , Babl *format , GeglSamplerType sampler_type ) ;
#line 554
GeglSampler *gegl_buffer_sampler_new_at_level(GeglBuffer *buffer , Babl *format ,
                                              GeglSamplerType sampler_type , gint level ) ;
#line 575
void gegl_sampler_get(GeglSampler *sampler , gdouble x , gdouble y , GeglBufferMatrix2 *scale ,
                      void *output , GeglAbyssPolicy repeat_mode ) ;
#line 617
GeglRectangle *gegl_sampler_get_context_rect(GeglSampler *sampler ) ;
#line 630
GeglBuffer *gegl_buffer_linear_new(GeglRectangle *extent , Babl *format ) ;
#line 651
GeglBuffer *gegl_buffer_linear_new_from_data(gpointer data , Babl *format , GeglRectangle *extent ,
                                             gint rowstride , GDestroyNotify destroy_fn ,
                                             gpointer destroy_fn_data ) ;
#line 671
gpointer gegl_buffer_linear_open(GeglBuffer *buffer , GeglRectangle *extent , gint *rowstride ,
                                 Babl *format ) ;
#line 686
void gegl_buffer_linear_close(GeglBuffer *buffer , gpointer linear ) ;
#line 697
GeglRectangle *gegl_buffer_get_abyss(GeglBuffer *buffer ) ;
#line 709
gboolean gegl_buffer_share_storage(GeglBuffer *buffer1 , GeglBuffer *buffer2 ) ;
#line 728
glong gegl_buffer_signal_connect(GeglBuffer *buffer , char const   *detailed_signal ,
                                 GCallback c_handler , gpointer data ) ;
#line 742
void gegl_buffer_freeze_changed(GeglBuffer *buffer ) ;
#line 753
void gegl_buffer_thaw_changed(GeglBuffer *buffer ) ;
#line 768
void gegl_buffer_flush_ext(GeglBuffer *buffer , GeglRectangle *rect ) ;
#line 59 "/usr/include/gegl-0.4/gegl-buffer-iterator.h"
GeglBufferIterator *gegl_buffer_iterator_empty_new(int max_slots ) ;
#line 79
GeglBufferIterator *gegl_buffer_iterator_new(GeglBuffer *buffer , GeglRectangle *roi ,
                                             gint level , Babl *format , GeglAccessMode access_mode ,
                                             GeglAbyssPolicy abyss_policy , gint max_slots ) ;
#line 118
gint gegl_buffer_iterator_add(GeglBufferIterator *iterator , GeglBuffer *buffer ,
                              GeglRectangle *roi , gint level , Babl *format , GeglAccessMode access_mode ,
                              GeglAbyssPolicy abyss_policy ) ;
#line 133
void gegl_buffer_iterator_stop(GeglBufferIterator *iterator ) ;
#line 147
gboolean gegl_buffer_iterator_next(GeglBufferIterator *iterator ) ;
#line 26 "/usr/include/gegl-0.4/gegl-rectangle.h"
GType gegl_rectangle_get_type(void) ;
#line 75
GeglRectangle *gegl_rectangle_new(gint x , gint y , guint width , guint height ) ;
#line 90
void gegl_rectangle_set(GeglRectangle *rectangle , gint x , gint y , guint width ,
                        guint height ) ;
#line 105
gboolean gegl_rectangle_equal(GeglRectangle *rectangle1 , GeglRectangle *rectangle2 ) ;
#line 120
gboolean gegl_rectangle_equal_coords(GeglRectangle *rectangle , gint x , gint y ,
                                     gint width , gint height ) ;
#line 134
gboolean gegl_rectangle_is_empty(GeglRectangle *rectangle ) ;
#line 144
GeglRectangle *gegl_rectangle_dup(GeglRectangle *rectangle ) ;
#line 156
void gegl_rectangle_copy(GeglRectangle *destination , GeglRectangle *source ) ;
#line 184
gboolean gegl_rectangle_align(GeglRectangle *destination , GeglRectangle *rectangle ,
                              GeglRectangle *tile , GeglRectangleAlignment alignment ) ;
#line 205
gboolean gegl_rectangle_align_to_buffer(GeglRectangle *destination , GeglRectangle *rectangle ,
                                        GeglBuffer *buffer , GeglRectangleAlignment alignment ) ;
#line 221
void gegl_rectangle_bounding_box(GeglRectangle *destination , GeglRectangle *source1 ,
                                 GeglRectangle *source2 ) ;
#line 239
gboolean gegl_rectangle_intersect(GeglRectangle *dest , GeglRectangle *src1 , GeglRectangle *src2 ) ;
#line 256
gint gegl_rectangle_subtract(GeglRectangle destination[4] , GeglRectangle *minuend ,
                             GeglRectangle *subtrahend ) ;
#line 274
gboolean gegl_rectangle_subtract_bounding_box(GeglRectangle *destination , GeglRectangle *minuend ,
                                              GeglRectangle *subtrahend ) ;
#line 292
gint gegl_rectangle_xor(GeglRectangle destination[4] , GeglRectangle *source1 , GeglRectangle *source2 ) ;
#line 305
gboolean gegl_rectangle_contains(GeglRectangle *parent , GeglRectangle *child ) ;
#line 313
GeglRectangle gegl_rectangle_infinite_plane(void) ;
#line 322
gboolean gegl_rectangle_is_infinite_plane(GeglRectangle *rectangle ) ;
#line 330
void gegl_rectangle_dump(GeglRectangle *rectangle ) ;
#line 339
gint _gegl_float_epsilon_zero(float value ) ;
#line 340
gint _gegl_float_epsilon_equal(float v1 , float v2 ) ;
#line 36 "/usr/include/gegl-0.4/gegl-memory.h"
gpointer gegl_malloc(gsize n_bytes ) ;
#line 47
gpointer gegl_try_malloc(gsize n_bytes ) ;
#line 55
void gegl_free(gpointer mem ) ;
#line 64
gpointer gegl_calloc(gsize size , gint n_memb ) ;
#line 77
gboolean gegl_memeq_zero(gconstpointer ptr , gsize size ) ;
#line 89
void gegl_memset_pattern(gpointer dst_ptr , gconstpointer src_ptr , gint pattern_size ,
                         gint count ) ;
#line 31 "/usr/include/gegl-0.4/gegl-scratch.h"
gpointer gegl_scratch_alloc(gsize size ) ;
#line 41
gpointer gegl_scratch_alloc0(gsize size ) ;
#line 52
void gegl_scratch_free(gpointer ptr ) ;
#line 776 "/usr/include/gegl-0.4/gegl-buffer.h"
GType gegl_buffer_get_type(void) ;
#line 780 "/usr/include/gegl-0.4/gegl-buffer.h"
__inline static void glib_autoptr_clear_GeglBuffer(GeglBuffer *_ptr ) 
{ 


  {
#line 780
  if (_ptr) {
    {
#line 780
    g_object_unref((GeglBuffer *)_ptr);
    }
  }
  return;
}
}
#line 780 "/usr/include/gegl-0.4/gegl-buffer.h"
__inline static void glib_autoptr_cleanup_GeglBuffer(GeglBuffer **_ptr ) 
{ 


  {
  {
#line 780
  glib_autoptr_clear_GeglBuffer(*_ptr);
  }
  return;
}
}
#line 47 "/usr/include/gegl-0.4/gegl-color.h"
GType gegl_color_get_type(void) ;
#line 75
GeglColor *gegl_color_new(gchar *string ) ;
#line 85
GeglColor *gegl_color_duplicate(GeglColor *color ) ;
#line 98
void gegl_color_get_rgba(GeglColor *color , gdouble *red , gdouble *green , gdouble *blue ,
                         gdouble *alpha ) ;
#line 114
void gegl_color_set_rgba(GeglColor *color , gdouble red , gdouble green , gdouble blue ,
                         gdouble alpha ) ;
#line 127
void gegl_color_set_pixel(GeglColor *color , Babl *format , void const   *pixel ) ;
#line 138
void gegl_color_get_pixel(GeglColor *color , Babl *format , void *pixel ) ;
#line 148
GType gegl_param_color_get_type(void) ;
#line 162
GParamSpec *gegl_param_spec_color(gchar *name , gchar *nick , gchar *blurb , GeglColor *default_color ,
                                  GParamFlags flags ) ;
#line 180
GParamSpec *gegl_param_spec_color_from_string(gchar *name , gchar *nick , gchar *blurb ,
                                              gchar *default_color_string , GParamFlags flags ) ;
#line 194
GeglColor *gegl_param_spec_color_get_default(GParamSpec *self ) ;
#line 204
Babl *gegl_color_get_format(GeglColor *color ) ;
#line 53 "/usr/include/gegl-0.4/gegl-curve.h"
GType gegl_curve_get_type(void) ;
#line 65
GeglCurve *gegl_curve_new(gdouble y_min , gdouble y_max ) ;
#line 76
GeglCurve *gegl_curve_new_default(void) ;
#line 86
GeglCurve *gegl_curve_duplicate(GeglCurve *curve ) ;
#line 98
void gegl_curve_get_y_bounds(GeglCurve *curve , gdouble *min_y , gdouble *max_y ) ;
#line 111
guint gegl_curve_add_point(GeglCurve *curve , gdouble x , gdouble y ) ;
#line 124
void gegl_curve_get_point(GeglCurve *curve , guint index , gdouble *x , gdouble *y ) ;
#line 138
void gegl_curve_set_point(GeglCurve *curve , guint index , gdouble x , gdouble y ) ;
#line 151
guint gegl_curve_num_points(GeglCurve *curve ) ;
#line 161
gdouble gegl_curve_calc_value(GeglCurve *curve , gdouble x ) ;
#line 175
void gegl_curve_calc_values(GeglCurve *curve , gdouble x_min , gdouble x_max , guint num_samples ,
                            gdouble *xs , gdouble *ys ) ;
#line 188
GType gegl_param_curve_get_type(void) ;
#line 202
GParamSpec *gegl_param_spec_curve(gchar *name , gchar *nick , gchar *blurb , GeglCurve *default_curve ,
                                  GParamFlags flags ) ;
#line 50 "/usr/include/gegl-0.4/gegl-matrix.h"
GType gegl_matrix3_get_type(void) ;
#line 57
GeglMatrix3 *gegl_matrix3_new(void) ;
#line 65
void gegl_matrix3_identity(GeglMatrix3 *matrix ) ;
#line 73
void gegl_matrix3_round_error(GeglMatrix3 *matrix ) ;
#line 84
gboolean gegl_matrix3_equal(GeglMatrix3 *matrix1 , GeglMatrix3 *matrix2 ) ;
#line 95
gboolean gegl_matrix3_is_identity(GeglMatrix3 *matrix ) ;
#line 105
gboolean gegl_matrix3_is_scale(GeglMatrix3 *matrix ) ;
#line 115
gboolean gegl_matrix3_is_translate(GeglMatrix3 *matrix ) ;
#line 125
gboolean gegl_matrix3_is_affine(GeglMatrix3 *matrix ) ;
#line 134
void gegl_matrix3_copy_into(GeglMatrix3 *dst , GeglMatrix3 *src ) ;
#line 143
GeglMatrix3 *gegl_matrix3_copy(GeglMatrix3 *matrix ) ;
#line 151
gdouble gegl_matrix3_determinant(GeglMatrix3 *matrix ) ;
#line 159
void gegl_matrix3_invert(GeglMatrix3 *matrix ) ;
#line 169
void gegl_matrix3_multiply(GeglMatrix3 *left , GeglMatrix3 *right , GeglMatrix3 *product ) ;
#line 189
void gegl_matrix3_originate(GeglMatrix3 *matrix , gdouble x , gdouble y ) ;
#line 204
void gegl_matrix3_transform_point(GeglMatrix3 *matrix , gdouble *x , gdouble *y ) ;
#line 216
void gegl_matrix3_parse_string(GeglMatrix3 *matrix , gchar *string ) ;
#line 228
gchar *gegl_matrix3_to_string(GeglMatrix3 *matrix ) ;
#line 50 "/usr/include/gegl-0.4/gegl-path.h"
GType gegl_path_get_type(void) ;
#line 103
GeglPath *gegl_path_new(void) ;
#line 115
GeglPath *gegl_path_new_from_string(gchar *instructions ) ;
#line 125
gboolean gegl_path_is_empty(GeglPath *path ) ;
#line 135
gint gegl_path_get_n_nodes(GeglPath *path ) ;
#line 145
gdouble gegl_path_get_length(GeglPath *path ) ;
#line 157
gboolean gegl_path_get_node(GeglPath *path , gint index , GeglPathItem *node ) ;
#line 170
gchar *gegl_path_to_string(GeglPath *path ) ;
#line 183
void gegl_path_set_matrix(GeglPath *path , GeglMatrix3 *matrix ) ;
#line 193
void gegl_path_get_matrix(GeglPath *path , GeglMatrix3 *matrix ) ;
#line 210
gdouble gegl_path_closest_point(GeglPath *path , gdouble x , gdouble y , gdouble *on_path_x ,
                                gdouble *on_path_y , gint *node_pos_before ) ;
#line 228
gint gegl_path_calc_y_for_x(GeglPath *path , gdouble x , gdouble *y ) ;
#line 242
gboolean gegl_path_calc(GeglPath *path , gdouble pos , gdouble *x , gdouble *y ) ;
#line 257
void gegl_path_calc_values(GeglPath *path , guint num_samples , gdouble *xs , gdouble *ys ) ;
#line 272
void gegl_path_get_bounds(GeglPath *self , gdouble *min_x , gdouble *max_x , gdouble *min_y ,
                          gdouble *max_y ) ;
#line 297
void gegl_path_foreach(GeglPath *path , GeglNodeFunction each_item , gpointer user_data ) ;
#line 310
void gegl_path_foreach_flat(GeglPath *path , GeglNodeFunction each_item , gpointer user_data ) ;
#line 321
void gegl_path_clear(GeglPath *path ) ;
#line 332
void gegl_path_insert_node(GeglPath *path , gint pos , GeglPathItem *node ) ;
#line 343
void gegl_path_replace_node(GeglPath *path , gint pos , GeglPathItem *node ) ;
#line 353
void gegl_path_remove_node(GeglPath *path , gint pos ) ;
#line 364
void gegl_path_parse_string(GeglPath *path , gchar *instructions ) ;
#line 376
void gegl_path_append(GeglPath *path  , ...) ;
#line 386
void gegl_path_freeze(GeglPath *path ) ;
#line 394
void gegl_path_thaw(GeglPath *path ) ;
#line 408
GParamSpec *gegl_param_spec_path(gchar *name , gchar *nick , gchar *blurb , GeglPath *default_path ,
                                 GParamFlags flags ) ;
#line 416
GType gegl_param_path_get_type(void) ;
#line 428
void gegl_path_add_type(gchar type , gint items , gchar *description ) ;
#line 452
GeglPathList *gegl_path_list_append(GeglPathList *head  , ...) ;
#line 460
GeglPathList *gegl_path_list_destroy(GeglPathList *path ) ;
#line 479
void gegl_path_add_flattener(GeglFlattenerFunc func ) ;
#line 488
GeglPathList *gegl_path_get_path(GeglPath *path ) ;
#line 496
GeglPathList *gegl_path_get_flat_path(GeglPath *path ) ;
#line 511
void gegl_path_point_lerp(GeglPathPoint *dest , GeglPathPoint *a , GeglPathPoint *b ,
                          gfloat t ) ;
#line 523
gdouble gegl_path_point_dist(GeglPathPoint *a , GeglPathPoint *b ) ;
#line 535
void gegl_path_dirty(GeglPath *path ) ;
#line 44 "/usr/include/gegl-0.4/gegl-utils.h"
void gegl_create_chain_argv(char **ops , GeglNode *op_start , GeglNode *op_end , double time ,
                            int rel_dim , char const   *path_root , GError **error ) ;
#line 63
void gegl_create_chain(char const   *ops , GeglNode *op_start , GeglNode *op_end ,
                       double time , int rel_dim , char const   *path_root , GError **error ) ;
#line 80
gchar *gegl_serialize(GeglNode *start , GeglNode *end , char const   *basepath , GeglSerializeFlag serialize_flags ) ;
#line 92
GeglNode *gegl_node_new_from_serialized(gchar *chaindata , gchar *path_root ) ;
#line 106
void gegl_node_set_time(GeglNode *node , double time ) ;
#line 118
void gegl_buffer_set_color(GeglBuffer *buffer , GeglRectangle *rect , GeglColor *color ) ;
#line 122
Babl *gegl_babl_variant(Babl *format , GeglBablVariant variant ) ;
#line 57 "/usr/include/gegl-0.4/gegl-operations-util.h"
gchar **gegl_list_operations(guint *n_operations_p ) ;
#line 67
gboolean gegl_has_operation(gchar *operation_type ) ;
#line 77
GParamSpec **gegl_operation_list_properties(gchar *operation_type , guint *n_properties_p ) ;
#line 89
GParamSpec *gegl_operation_find_property(gchar *operation_type , gchar *property_name ) ;
#line 102
gchar *gegl_operation_get_property_key(gchar *operation_type , gchar *property_name ,
                                       gchar *property_key_name ) ;
#line 116
gchar **gegl_operation_list_property_keys(gchar *operation_type , gchar *property_name ,
                                          guint *n_keys ) ;
#line 120
gchar *gegl_param_spec_get_property_key(GParamSpec *pspec , gchar *key_name ) ;
#line 123
void gegl_param_spec_set_property_key(GParamSpec *pspec , gchar *key_name , gchar *value ) ;
#line 128 "/usr/include/gegl-0.4/gegl-operations-util.h"
__inline static gdouble gegl_coordinate_relative_to_pixel(gdouble relative , gdouble pixel_dim ) 
{ 


  {
#line 130
  return (relative * pixel_dim);
}
}
#line 134 "/usr/include/gegl-0.4/gegl-operations-util.h"
__inline static gdouble gegl_coordinate_pixel_to_relative(gdouble pixel , gdouble pixel_dim ) 
{ 


  {
#line 136
  return (pixel / pixel_dim);
}
}
#line 148
gchar **gegl_operation_list_keys(gchar *operation_type , guint *n_keys ) ;
#line 151
gchar *gegl_operation_get_key(gchar *operation_type , gchar *key_name ) ;
#line 58 "/usr/include/gegl-0.4/gegl-init.h"
void gegl_init(gint *argc , gchar ***argv ) ;
#line 68
GOptionGroup *gegl_get_option_group(void) ;
#line 77
void gegl_exit(void) ;
#line 85
void gegl_load_module_directory(gchar *path ) ;
#line 95
GeglConfig *gegl_config(void) ;
#line 105
GeglStats *gegl_stats(void) ;
#line 113
void gegl_reset_stats(void) ;
#line 115
gboolean gegl_is_main_thread(void) ;
#line 49 "/usr/include/gegl-0.4/gegl-version.h"
void gegl_get_version(int *major , int *minor , int *micro ) ;
#line 43 "/usr/include/gegl-0.4/gegl-random.h"
GeglRandom *gegl_random_new_with_seed(guint32 seed ) ;
#line 51
GeglRandom *gegl_random_new(void) ;
#line 59
GeglRandom *gegl_random_duplicate(GeglRandom *rand ) ;
#line 68
void gegl_random_free(GeglRandom *rand ) ;
#line 77
void gegl_random_set_seed(GeglRandom *rand , guint32 seed ) ;
#line 95
gfloat gegl_random_float_range(GeglRandom *rand , gint x , gint y , gint z , gint n ,
                               gfloat min , gfloat max ) ;
#line 118
gint32 gegl_random_int_range(GeglRandom *rand , gint x , gint y , gint z , gint n ,
                             gint min , gint max ) ;
#line 137
guint32 gegl_random_int(GeglRandom *rand , gint x , gint y , gint z , gint n ) ;
#line 154
gfloat gegl_random_float(GeglRandom *rand , gint x , gint y , gint z , gint n ) ;
#line 160 "/usr/include/gegl-0.4/gegl-random.h"
__inline static void glib_autoptr_clear_GeglRandom(GeglRandom *_ptr ) 
{ 


  {
#line 160
  if (_ptr) {
    {
#line 160
    gegl_random_free((GeglRandom *)_ptr);
    }
  }
  return;
}
}
#line 160 "/usr/include/gegl-0.4/gegl-random.h"
__inline static void glib_autoptr_cleanup_GeglRandom(GeglRandom **_ptr ) 
{ 


  {
  {
#line 160
  glib_autoptr_clear_GeglRandom(*_ptr);
  }
  return;
}
}
#line 160 "/usr/include/gegl-0.4/gegl-random.h"
__inline static void glib_listautoptr_cleanup_GeglRandom(GList **_l ) 
{ 


  {
  {
#line 160
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& gegl_random_free)));
  }
  return;
}
}
#line 160 "/usr/include/gegl-0.4/gegl-random.h"
__inline static void glib_slistautoptr_cleanup_GeglRandom(GSList **_l ) 
{ 


  {
  {
#line 160
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& gegl_random_free)));
  }
  return;
}
}
#line 160 "/usr/include/gegl-0.4/gegl-random.h"
__inline static void glib_queueautoptr_cleanup_GeglRandom(GQueue **_q ) 
{ 


  {
#line 160
  if (*_q) {
    {
#line 160
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& gegl_random_free)));
    }
  }
  return;
}
}
#line 82 "/usr/include/gegl-0.4/gegl-parallel.h"
void gegl_parallel_distribute(gint max_n , GeglParallelDistributeFunc func , gpointer user_data ) ;
#line 98
void gegl_parallel_distribute_range(gsize size , gdouble thread_cost , GeglParallelDistributeRangeFunc func ,
                                    gpointer user_data ) ;
#line 116
void gegl_parallel_distribute_area(GeglRectangle *area , gdouble thread_cost , GeglSplitStrategy split_strategy ,
                                   GeglParallelDistributeAreaFunc func , gpointer user_data ) ;
#line 64 "/usr/include/gegl-0.4/gegl-node.h"
GeglNode *gegl_node_new(void) ;
#line 87
GeglNode *gegl_node_new_child(GeglNode *parent , gchar *first_property_name  , ...) ;
#line 115
gboolean gegl_node_connect_from(GeglNode *sink , gchar *input_pad_name , GeglNode *source ,
                                gchar *output_pad_name ) ;
#line 131
gboolean gegl_node_connect_to(GeglNode *source , gchar *output_pad_name , GeglNode *sink ,
                              gchar *input_pad_name ) ;
#line 145
void gegl_node_link(GeglNode *source , GeglNode *sink ) ;
#line 157
void gegl_node_link_many(GeglNode *source , GeglNode *first_sink  , ...) ;
#line 170
gboolean gegl_node_disconnect(GeglNode *node , gchar *input_pad ) ;
#line 202
void gegl_node_set(GeglNode *node , gchar *first_property_name  , ...) ;
#line 215
void gegl_node_set_valist(GeglNode *node , gchar *first_property_name , va_list args ) ;
#line 234
void gegl_node_get(GeglNode *node , gchar *first_property_name  , ...) ;
#line 247
void gegl_node_get_valist(GeglNode *node , gchar *first_property_name , va_list args ) ;
#line 283
void gegl_node_blit(GeglNode *node , gdouble scale , GeglRectangle *roi , Babl *format ,
                    gpointer destination_buf , gint rowstride , GeglBlitFlags flags ) ;
#line 300
void gegl_node_blit_buffer(GeglNode *node , GeglBuffer *buffer , GeglRectangle *roi ,
                           int level , GeglAbyssPolicy abyss_policy ) ;
#line 343
void gegl_node_process(GeglNode *sink_node ) ;
#line 364
GeglNode *gegl_node_add_child(GeglNode *graph , GeglNode *child ) ;
#line 378
GeglNode *gegl_node_remove_child(GeglNode *graph , GeglNode *child ) ;
#line 389
GeglNode *gegl_node_get_parent(GeglNode *node ) ;
#line 417
GeglNode *gegl_node_detect(GeglNode *node , gint x , gint y ) ;
#line 430
GParamSpec *gegl_node_find_property(GeglNode *node , gchar *property_name ) ;
#line 442
GeglRectangle gegl_node_get_bounding_box(GeglNode *node ) ;
#line 452
GSList *gegl_node_get_children(GeglNode *node ) ;
#line 468
gint gegl_node_get_consumers(GeglNode *node , gchar *output_pad , GeglNode ***nodes ,
                             gchar ***pads ) ;
#line 484
GeglNode *gegl_node_get_input_proxy(GeglNode *node , gchar *pad_name ) ;
#line 495
gchar *gegl_node_get_operation(GeglNode *node ) ;
#line 504
GeglOperation *gegl_node_get_gegl_operation(GeglNode *node ) ;
#line 517
GeglNode *gegl_node_get_output_proxy(GeglNode *node , gchar *pad_name ) ;
#line 530
GeglNode *gegl_node_get_producer(GeglNode *node , gchar *input_pad_name , gchar **output_pad_name ) ;
#line 541
gboolean gegl_node_has_pad(GeglNode *node , gchar *pad_name ) ;
#line 554
gchar **gegl_node_list_input_pads(GeglNode *node ) ;
#line 566
gchar **gegl_node_list_output_pads(GeglNode *node ) ;
#line 594
GeglNode *gegl_node_create_child(GeglNode *parent , gchar *operation ) ;
#line 608
void gegl_node_get_property(GeglNode *node , gchar *property_name , GValue *value ) ;
#line 621
void gegl_node_set_property(GeglNode *node , gchar *property_name , GValue *value ) ;
#line 643
GeglNode *gegl_node_new_from_xml(gchar *xmldata , gchar *path_root ) ;
#line 656
GeglNode *gegl_node_new_from_file(gchar *path ) ;
#line 670
gchar *gegl_node_to_xml(GeglNode *node , gchar *path_root ) ;
#line 685
gchar *gegl_node_to_xml_full(GeglNode *head , GeglNode *tail , gchar *path_root ) ;
#line 689
gboolean gegl_node_get_passthrough(GeglNode *node ) ;
#line 691
void gegl_node_set_passthrough(GeglNode *node , gboolean passthrough ) ;
#line 694
gboolean gegl_node_is_graph(GeglNode *node ) ;
#line 696
void gegl_node_progress(GeglNode *node , gdouble progress , gchar *message ) ;
#line 698
char const   *gegl_operation_get_op_version(gchar *op_name ) ;
#line 42 "/usr/include/gegl-0.4/gegl-processor.h"
GeglProcessor *gegl_node_new_processor(GeglNode *node , GeglRectangle *rectangle ) ;
#line 45
void gegl_processor_set_level(GeglProcessor *processor , gint level ) ;
#line 47
void gegl_processor_set_scale(GeglProcessor *processor , gdouble scale ) ;
#line 58
void gegl_processor_set_rectangle(GeglProcessor *processor , GeglRectangle *rectangle ) ;
#line 79
gboolean gegl_processor_work(GeglProcessor *processor , gdouble *progress ) ;
#line 92
GeglBuffer *gegl_processor_get_buffer(GeglProcessor *processor ) ;
#line 35 "/usr/include/gegl-0.4/gegl-apply.h"
void gegl_apply_op(GeglBuffer *buffer , gchar *operation_name  , ...) ;
#line 50
GeglBuffer *gegl_filter_op(GeglBuffer *source_buffer , gchar *operation_name  , ...) ;
#line 66
void gegl_render_op(GeglBuffer *source_buffer , GeglBuffer *target_buffer , gchar *operation_name 
                    , ...) ;
#line 83
void gegl_apply_op_valist(GeglBuffer *buffer , gchar *operation_name , va_list var_args ) ;
#line 98
GeglBuffer *gegl_filter_op_valist(GeglBuffer *source_buffer , gchar *operation_name ,
                                  va_list var_args ) ;
#line 113
void gegl_render_op_valist(GeglBuffer *source_buffer , GeglBuffer *target_buffer ,
                           gchar *operation_name , va_list var_args ) ;
#line 28 "/usr/include/gimp-2.0/libgimpconfig/gimpconfigenums.h"
GType gimp_color_management_mode_get_type(void) ;
#line 48
GType gimp_color_rendering_intent_get_type(void) ;
#line 59 "/usr/include/gimp-2.0/libgimpbase/gimpbaseenums.h"
GType gimp_add_mask_type_get_type(void) ;
#line 98
GType gimp_blend_mode_get_type(void) ;
#line 126
GType gimp_brush_generated_shape_get_type(void) ;
#line 149
GType gimp_bucket_fill_mode_get_type(void) ;
#line 175
GType gimp_cap_style_get_type(void) ;
#line 196
GType gimp_channel_ops_get_type(void) ;
#line 226
GType gimp_channel_type_get_type(void) ;
#line 258
GType gimp_check_size_get_type(void) ;
#line 281
GType gimp_check_type_get_type(void) ;
#line 305
GType gimp_clone_type_get_type(void) ;
#line 337
GType gimp_color_tag_get_type(void) ;
#line 368
GType gimp_component_type_get_type(void) ;
#line 403
GType gimp_convert_palette_type_get_type(void) ;
#line 434
GType gimp_convolve_type_get_type(void) ;
#line 461
GType gimp_desaturate_mode_get_type(void) ;
#line 488
GType gimp_dodge_burn_type_get_type(void) ;
#line 519
GType gimp_fill_type_get_type(void) ;
#line 548
GType gimp_foreground_extract_mode_get_type(void) ;
#line 569
GType gimp_gradient_blend_color_space_get_type(void) ;
#line 589
GType gimp_gradient_segment_color_get_type(void) ;
#line 612
GType gimp_gradient_segment_type_get_type(void) ;
#line 643
GType gimp_gradient_type_get_type(void) ;
#line 673
GType gimp_grid_style_get_type(void) ;
#line 706
GType gimp_hue_range_get_type(void) ;
#line 743
GType gimp_icon_type_get_type(void) ;
#line 767
GType gimp_image_base_type_get_type(void) ;
#line 790
GType gimp_image_type_get_type(void) ;
#line 813
GType gimp_ink_blob_type_get_type(void) ;
#line 836
GType gimp_interpolation_type_get_type(void) ;
#line 862
GType gimp_join_style_get_type(void) ;
#line 881
GType gimp_mask_apply_mode_get_type(void) ;
#line 901
GType gimp_merge_type_get_type(void) ;
#line 922
GType gimp_message_handler_type_get_type(void) ;
#line 942
GType gimp_offset_type_get_type(void) ;
#line 962
GType gimp_orientation_type_get_type(void) ;
#line 981
GType gimp_paint_application_mode_get_type(void) ;
#line 1023
GType gimp_pdb_arg_type_get_type(void) ;
#line 1068
GType gimp_pdb_error_handler_get_type(void) ;
#line 1088
GType gimp_pdb_proc_type_get_type(void) ;
#line 1111
GType gimp_pdb_status_type_get_type(void) ;
#line 1144
GType gimp_precision_get_type(void) ;
#line 1176
GType gimp_progress_command_get_type(void) ;
#line 1200
GType gimp_repeat_mode_get_type(void) ;
#line 1221
GType gimp_rotation_type_get_type(void) ;
#line 1241
GType gimp_run_mode_get_type(void) ;
#line 1269
GType gimp_select_criterion_get_type(void) ;
#line 1296
GType gimp_size_type_get_type(void) ;
#line 1315
GType gimp_stack_trace_mode_get_type(void) ;
#line 1334
GType gimp_stroke_method_get_type(void) ;
#line 1356
GType gimp_text_direction_get_type(void) ;
#line 1380
GType gimp_text_hint_style_get_type(void) ;
#line 1402
GType gimp_text_justification_get_type(void) ;
#line 1426
GType gimp_transfer_mode_get_type(void) ;
#line 1451
GType gimp_transform_direction_get_type(void) ;
#line 1471
GType gimp_transform_resize_get_type(void) ;
#line 1525
GType gimp_user_directory_get_type(void) ;
#line 1549
GType gimp_vectors_stroke_type_get_type(void) ;
#line 94 "/usr/include/gimp-2.0/libgimpbase/gimpbasetypes.h"
void gimp_type_set_translation_domain(GType type , gchar *domain ) ;
#line 96
gchar *gimp_type_get_translation_domain(GType type ) ;
#line 98
void gimp_type_set_translation_context(GType type , gchar *context ) ;
#line 100
gchar *gimp_type_get_translation_context(GType type ) ;
#line 102
void gimp_enum_set_value_descriptions(GType enum_type , GimpEnumDesc *descriptions ) ;
#line 104
GimpEnumDesc *gimp_enum_get_value_descriptions(GType enum_type ) ;
#line 106
void gimp_flags_set_value_descriptions(GType flags_type , GimpFlagsDesc *descriptions ) ;
#line 108
GimpFlagsDesc *gimp_flags_get_value_descriptions(GType flags_type ) ;
#line 61 "/usr/include/gimp-2.0/libgimpbase/gimpchecks.h"
void gimp_checks_get_shades(GimpCheckType type , guchar *light , guchar *dark ) ;
#line 67 "/usr/include/gimp-2.0/libgimpbase/gimpcpuaccel.h"
GimpCpuAccelFlags gimp_cpu_accel_get_support(void) ;
#line 71
void gimp_cpu_accel_set_use(gboolean use ) ;
#line 60 "/usr/include/gimp-2.0/libgimpbase/gimpdatafiles.h"
gboolean gimp_datafiles_check_extension(gchar *filename , gchar *extension ) ;
#line 64
void gimp_datafiles_read_directories(gchar *path_str , GFileTest flags , GimpDatafileLoaderFunc loader_func ,
                                     gpointer user_data ) ;
#line 45 "/usr/include/gimp-2.0/libgimpbase/gimpenv.h"
extern guint gimp_major_version ;
#line 46
extern guint gimp_minor_version ;
#line 47
extern guint gimp_micro_version ;
#line 50
gchar *gimp_directory(void) ;
#line 51
gchar *gimp_installation_directory(void) ;
#line 52
gchar *gimp_data_directory(void) ;
#line 53
gchar *gimp_locale_directory(void) ;
#line 54
gchar *gimp_sysconf_directory(void) ;
#line 55
gchar *gimp_plug_in_directory(void) ;
#line 56
gchar *gimp_cache_directory(void) ;
#line 57
gchar *gimp_temp_directory(void) ;
#line 59
GFile *gimp_directory_file(gchar *first_element  , ...) ;
#line 61
GFile *gimp_installation_directory_file(gchar *first_element  , ...) ;
#line 63
GFile *gimp_data_directory_file(gchar *first_element  , ...) ;
#line 65
GFile *gimp_locale_directory_file(gchar *first_element  , ...) ;
#line 67
GFile *gimp_sysconf_directory_file(gchar *first_element  , ...) ;
#line 69
GFile *gimp_plug_in_directory_file(gchar *first_element  , ...) ;
#line 74
gchar *gimp_user_directory(GimpUserDirectory type ) ;
#line 77
gchar *gimp_gtkrc(void) ;
#line 78
gchar *gimp_personal_rc_file(gchar *basename ) ;
#line 80
GList *gimp_path_parse(gchar *path , gint max_paths , gboolean check , GList **check_failed ) ;
#line 84
gchar *gimp_path_to_str(GList *path ) ;
#line 85
void gimp_path_free(GList *path ) ;
#line 87
gchar *gimp_path_get_user_writable_dir(GList *path ) ;
#line 91
void gimp_env_init(gboolean plug_in ) ;
#line 38 "/usr/include/gimp-2.0/libgimpbase/gimpmemsize.h"
GType gimp_memsize_get_type(void) ;
#line 40
gchar *gimp_memsize_serialize(guint64 memsize ) ;
#line 41
gboolean gimp_memsize_deserialize(gchar *string , guint64 *memsize ) ;
#line 45
gchar *gimp_memsize_to_string(guint64 memsize ) ;
#line 55
GType gimp_param_memsize_get_type(void) ;
#line 57
GParamSpec *gimp_param_spec_memsize(gchar *name , gchar *nick , gchar *blurb , guint64 minimum ,
                                    guint64 maximum , guint64 default_value , GParamFlags flags ) ;
#line 98 "/usr/include/gimp-2.0/libgimpbase/gimpmetadata.h"
GType gimp_metadata_get_type(void) ;
#line 100
GimpMetadata *gimp_metadata_new(void) ;
#line 101
GimpMetadata *gimp_metadata_duplicate(GimpMetadata *metadata ) ;
#line 103
GimpMetadata *gimp_metadata_deserialize(gchar *metadata_xml ) ;
#line 104
gchar *gimp_metadata_serialize(GimpMetadata *metadata ) ;
#line 105
gchar *gimp_metadata_get_guid(void) ;
#line 107
void gimp_metadata_add_xmp_history(GimpMetadata *metadata , gchar *state_status ) ;
#line 110
GimpMetadata *gimp_metadata_load_from_file(GFile *file , GError **error ) ;
#line 112
gboolean gimp_metadata_save_to_file(GimpMetadata *metadata , GFile *file , GError **error ) ;
#line 116
gboolean gimp_metadata_set_from_exif(GimpMetadata *metadata , guchar *exif_data ,
                                     gint exif_data_length , GError **error ) ;
#line 120
gboolean gimp_metadata_set_from_iptc(GimpMetadata *metadata , guchar *iptc_data ,
                                     gint iptc_data_length , GError **error ) ;
#line 124
gboolean gimp_metadata_set_from_xmp(GimpMetadata *metadata , guchar *xmp_data , gint xmp_data_length ,
                                    GError **error ) ;
#line 129
void gimp_metadata_set_pixel_size(GimpMetadata *metadata , gint width , gint height ) ;
#line 132
void gimp_metadata_set_bits_per_sample(GimpMetadata *metadata , gint bits_per_sample ) ;
#line 135
gboolean gimp_metadata_get_resolution(GimpMetadata *metadata , gdouble *xres , gdouble *yres ,
                                      GimpUnit *unit ) ;
#line 139
void gimp_metadata_set_resolution(GimpMetadata *metadata , gdouble xres , gdouble yres ,
                                  GimpUnit unit ) ;
#line 145
GimpMetadataColorspace gimp_metadata_get_colorspace(GimpMetadata *metadata ) ;
#line 146
void gimp_metadata_set_colorspace(GimpMetadata *metadata , GimpMetadataColorspace colorspace ) ;
#line 149
gboolean gimp_metadata_is_tag_supported(gchar *tag , gchar *mime_type ) ;
#line 41 "/usr/include/gimp-2.0/libgimpbase/gimpparasite.h"
GType gimp_parasite_get_type(void) ;
#line 51
GType gimp_param_parasite_get_type(void) ;
#line 53
GParamSpec *gimp_param_spec_parasite(gchar *name , gchar *nick , gchar *blurb , GParamFlags flags ) ;
#line 88
GimpParasite *gimp_parasite_new(gchar *name , guint32 flags , guint32 size , gconstpointer data ) ;
#line 92
void gimp_parasite_free(GimpParasite *parasite ) ;
#line 94
GimpParasite *gimp_parasite_copy(GimpParasite *parasite ) ;
#line 96
gboolean gimp_parasite_compare(GimpParasite *a , GimpParasite *b ) ;
#line 99
gboolean gimp_parasite_is_type(GimpParasite *parasite , gchar *name ) ;
#line 101
gboolean gimp_parasite_is_persistent(GimpParasite *parasite ) ;
#line 102
gboolean gimp_parasite_is_undoable(GimpParasite *parasite ) ;
#line 103
gboolean gimp_parasite_has_flag(GimpParasite *parasite , gulong flag ) ;
#line 105
gulong gimp_parasite_flags(GimpParasite *parasite ) ;
#line 106
gchar *gimp_parasite_name(GimpParasite *parasite ) ;
#line 107
gconstpointer gimp_parasite_data(GimpParasite *parasite ) ;
#line 108
glong gimp_parasite_data_size(GimpParasite *parasite ) ;
#line 31 "/usr/include/gimp-2.0/libgimpbase/gimprectangle.h"
gboolean gimp_rectangle_intersect(gint x1 , gint y1 , gint width1 , gint height1 ,
                                  gint x2 , gint y2 , gint width2 , gint height2 ,
                                  gint *dest_x , gint *dest_y , gint *dest_width ,
                                  gint *dest_height ) ;
#line 44
void gimp_rectangle_union(gint x1 , gint y1 , gint width1 , gint height1 , gint x2 ,
                          gint y2 , gint width2 , gint height2 , gint *dest_x , gint *dest_y ,
                          gint *dest_width , gint *dest_height ) ;
#line 42 "/usr/include/gimp-2.0/libgimpbase/gimpunit.h"
GType gimp_unit_get_type(void) ;
#line 52
GType gimp_param_unit_get_type(void) ;
#line 54
GParamSpec *gimp_param_spec_unit(gchar *name , gchar *nick , gchar *blurb , gboolean allow_pixels ,
                                 gboolean allow_percent , GimpUnit default_value ,
                                 GParamFlags flags ) ;
#line 64
gint gimp_unit_get_number_of_units(void) ;
#line 65
gint gimp_unit_get_number_of_built_in_units(void) ;
#line 67
GimpUnit gimp_unit_new(gchar *identifier , gdouble factor , gint digits , gchar *symbol ,
                       gchar *abbreviation , gchar *singular , gchar *plural ) ;
#line 75
gboolean gimp_unit_get_deletion_flag(GimpUnit unit ) ;
#line 76
void gimp_unit_set_deletion_flag(GimpUnit unit , gboolean deletion_flag ) ;
#line 79
gdouble gimp_unit_get_factor(GimpUnit unit ) ;
#line 81
gint gimp_unit_get_digits(GimpUnit unit ) ;
#line 82
gint gimp_unit_get_scaled_digits(GimpUnit unit , gdouble resolution ) ;
#line 85
gchar *gimp_unit_get_identifier(GimpUnit unit ) ;
#line 87
gchar *gimp_unit_get_symbol(GimpUnit unit ) ;
#line 88
gchar *gimp_unit_get_abbreviation(GimpUnit unit ) ;
#line 89
gchar *gimp_unit_get_singular(GimpUnit unit ) ;
#line 90
gchar *gimp_unit_get_plural(GimpUnit unit ) ;
#line 92
gchar *gimp_unit_format_string(gchar *format , GimpUnit unit ) ;
#line 95
gdouble gimp_pixels_to_units(gdouble pixels , GimpUnit unit , gdouble resolution ) ;
#line 98
gdouble gimp_units_to_pixels(gdouble value , GimpUnit unit , gdouble resolution ) ;
#line 101
gdouble gimp_units_to_points(gdouble value , GimpUnit unit , gdouble resolution ) ;
#line 105
gboolean gimp_unit_is_metric(GimpUnit unit ) ;
#line 29 "/usr/include/gimp-2.0/libgimpbase/gimputils.h"
gchar *gimp_utf8_strtrim(gchar *str , gint max_chars ) ;
#line 31
gchar *gimp_any_to_utf8(gchar *str , gssize len , gchar *warning_format  , ...) ;
#line 35
gchar *gimp_filename_to_utf8(gchar *filename ) ;
#line 37
gchar *gimp_file_get_utf8_name(GFile *file ) ;
#line 38
gboolean gimp_file_has_extension(GFile *file , gchar *extension ) ;
#line 40
gboolean gimp_file_show_in_file_manager(GFile *file , GError **error ) ;
#line 43
gchar *gimp_strip_uline(gchar *str ) ;
#line 44
gchar *gimp_escape_uline(gchar *str ) ;
#line 46
gchar *gimp_canonicalize_identifier(gchar *identifier ) ;
#line 48
GimpEnumDesc *gimp_enum_get_desc(GEnumClass *enum_class , gint value ) ;
#line 50
gboolean gimp_enum_get_value(GType enum_type , gint value , gchar **value_name , gchar **value_nick ,
                             gchar **value_desc , gchar **value_help ) ;
#line 56
gchar *gimp_enum_value_get_desc(GEnumClass *enum_class , GEnumValue *enum_value ) ;
#line 58
gchar *gimp_enum_value_get_help(GEnumClass *enum_class , GEnumValue *enum_value ) ;
#line 60
gchar *gimp_enum_value_get_abbrev(GEnumClass *enum_class , GEnumValue *enum_value ) ;
#line 63
GimpFlagsDesc *gimp_flags_get_first_desc(GFlagsClass *flags_class , guint value ) ;
#line 65
gboolean gimp_flags_get_first_value(GType flags_type , guint value , gchar **value_name ,
                                    gchar **value_nick , gchar **value_desc , gchar **value_help ) ;
#line 71
gchar *gimp_flags_value_get_desc(GFlagsClass *flags_class , GFlagsValue *flags_value ) ;
#line 73
gchar *gimp_flags_value_get_help(GFlagsClass *flags_class , GFlagsValue *flags_value ) ;
#line 75
gchar *gimp_flags_value_get_abbrev(GFlagsClass *flags_class , GFlagsValue *flags_value ) ;
#line 78
gboolean gimp_stack_trace_available(gboolean optimal ) ;
#line 79
gboolean gimp_stack_trace_print(gchar *prog_name , gpointer stream , gchar **trace ) ;
#line 82
void gimp_stack_trace_query(gchar *prog_name ) ;
#line 41 "/usr/include/gimp-2.0/libgimpbase/gimpvaluearray.h"
GType gimp_value_array_get_type(void) ;
#line 43
GimpValueArray *gimp_value_array_new(gint n_prealloced ) ;
#line 45
GimpValueArray *gimp_value_array_ref(GimpValueArray *value_array ) ;
#line 46
void gimp_value_array_unref(GimpValueArray *value_array ) ;
#line 48
gint gimp_value_array_length(GimpValueArray *value_array ) ;
#line 50
GValue *gimp_value_array_index(GimpValueArray *value_array , gint index ) ;
#line 53
GimpValueArray *gimp_value_array_prepend(GimpValueArray *value_array , GValue *value ) ;
#line 55
GimpValueArray *gimp_value_array_append(GimpValueArray *value_array , GValue *value ) ;
#line 57
GimpValueArray *gimp_value_array_insert(GimpValueArray *value_array , gint index ,
                                        GValue *value ) ;
#line 61
GimpValueArray *gimp_value_array_remove(GimpValueArray *value_array , gint index ) ;
#line 63
void gimp_value_array_truncate(GimpValueArray *value_array , gint n_values ) ;
#line 93
GType gimp_param_value_array_get_type(void) ;
#line 95
GParamSpec *gimp_param_spec_value_array(gchar *name , gchar *nick , gchar *blurb ,
                                        GParamSpec *element_spec , GParamFlags flags ) ;
#line 41 "/usr/include/gimp-2.0/libgimpbase/gimpsignal.h"
GimpSignalHandlerFunc gimp_signal_private(gint signum , GimpSignalHandlerFunc handler ,
                                          gint flags ) ;
#line 34 "/usr/include/gimp-2.0/libgimpcolor/gimpadaptivesupersample.h"
gulong gimp_adaptive_supersample_area(gint x1 , gint y1 , gint x2 , gint y2 , gint max_depth ,
                                      gdouble threshold , GimpRenderFunc render_func ,
                                      gpointer render_data , GimpPutPixelFunc put_pixel_func ,
                                      gpointer put_pixel_data , GimpProgressFunc progress_func ,
                                      gpointer progress_data ) ;
#line 34 "/usr/include/gimp-2.0/libgimpcolor/gimpbilinear.h"
gdouble gimp_bilinear(gdouble x , gdouble y , gdouble *values ) ;
#line 37
guchar gimp_bilinear_8(gdouble x , gdouble y , guchar *values ) ;
#line 40
guint16 gimp_bilinear_16(gdouble x , gdouble y , guint16 *values ) ;
#line 43
guint32 gimp_bilinear_32(gdouble x , gdouble y , guint32 *values ) ;
#line 46
GimpRGB gimp_bilinear_rgb(gdouble x , gdouble y , GimpRGB *values ) ;
#line 49
GimpRGB gimp_bilinear_rgba(gdouble x , gdouble y , GimpRGB *values ) ;
#line 54
void gimp_bilinear_pixels_8(guchar *dest , gdouble x , gdouble y , guint bpp , gboolean has_alpha ,
                            guchar **values ) ;
#line 27 "/usr/include/gimp-2.0/libgimpcolor/gimpcairo.h"
void gimp_cairo_set_source_rgb(cairo_t *cr , GimpRGB *color ) ;
#line 29
void gimp_cairo_set_source_rgba(cairo_t *cr , GimpRGB *color ) ;
#line 32
cairo_pattern_t *gimp_cairo_checkerboard_create(cairo_t *cr , gint size , GimpRGB *light ,
                                                GimpRGB *dark ) ;
#line 37
Babl *gimp_cairo_surface_get_format(cairo_surface_t *surface ) ;
#line 38
GeglBuffer *gimp_cairo_surface_create_buffer(cairo_surface_t *surface ) ;
#line 68 "/usr/include/gimp-2.0/libgimpcolor/gimpcolormanaged.h"
GType gimp_color_managed_get_type(void) ;
#line 71
GType gimp_color_managed_interface_get_type(void) ;
#line 73
guint8 *gimp_color_managed_get_icc_profile(GimpColorManaged *managed , gsize *len ) ;
#line 75
GimpColorProfile *gimp_color_managed_get_color_profile(GimpColorManaged *managed ) ;
#line 77
void gimp_color_managed_profile_changed(GimpColorManaged *managed ) ;
#line 65 "/usr/include/gimp-2.0/libgimpcolor/gimpcolorprofile.h"
GType gimp_color_profile_get_type(void) ;
#line 67
GimpColorProfile *gimp_color_profile_new_rgb_srgb(void) ;
#line 68
GimpColorProfile *gimp_color_profile_new_rgb_srgb_linear(void) ;
#line 69
GimpColorProfile *gimp_color_profile_new_rgb_adobe(void) ;
#line 71
GimpColorProfile *gimp_color_profile_new_d65_gray_srgb_trc(void) ;
#line 72
GimpColorProfile *gimp_color_profile_new_d65_gray_linear(void) ;
#line 73
GimpColorProfile *gimp_color_profile_new_d50_gray_lab_trc(void) ;
#line 76
GimpColorProfile *gimp_color_profile_new_srgb_trc_from_color_profile(GimpColorProfile *profile ) ;
#line 78
GimpColorProfile *gimp_color_profile_new_linear_from_color_profile(GimpColorProfile *profile ) ;
#line 80
GimpColorProfile *gimp_color_profile_new_from_file(GFile *file , GError **error ) ;
#line 83
GimpColorProfile *gimp_color_profile_new_from_icc_profile(guint8 *data , gsize length ,
                                                          GError **error ) ;
#line 86
GimpColorProfile *gimp_color_profile_new_from_lcms_profile(gpointer lcms_profile ,
                                                           GError **error ) ;
#line 89
gboolean gimp_color_profile_save_to_file(GimpColorProfile *profile , GFile *file ,
                                         GError **error ) ;
#line 93
guint8 *gimp_color_profile_get_icc_profile(GimpColorProfile *profile , gsize *length ) ;
#line 95
gpointer gimp_color_profile_get_lcms_profile(GimpColorProfile *profile ) ;
#line 97
gchar *gimp_color_profile_get_description(GimpColorProfile *profile ) ;
#line 98
gchar *gimp_color_profile_get_manufacturer(GimpColorProfile *profile ) ;
#line 99
gchar *gimp_color_profile_get_model(GimpColorProfile *profile ) ;
#line 100
gchar *gimp_color_profile_get_copyright(GimpColorProfile *profile ) ;
#line 102
gchar *gimp_color_profile_get_label(GimpColorProfile *profile ) ;
#line 103
gchar *gimp_color_profile_get_summary(GimpColorProfile *profile ) ;
#line 105
gboolean gimp_color_profile_is_equal(GimpColorProfile *profile1 , GimpColorProfile *profile2 ) ;
#line 108
gboolean gimp_color_profile_is_rgb(GimpColorProfile *profile ) ;
#line 109
gboolean gimp_color_profile_is_gray(GimpColorProfile *profile ) ;
#line 110
gboolean gimp_color_profile_is_cmyk(GimpColorProfile *profile ) ;
#line 112
gboolean gimp_color_profile_is_linear(GimpColorProfile *profile ) ;
#line 114
Babl *gimp_color_profile_get_space(GimpColorProfile *profile , GimpColorRenderingIntent intent ,
                                   GError **error ) ;
#line 117
Babl *gimp_color_profile_get_format(GimpColorProfile *profile , Babl *format , GimpColorRenderingIntent intent ,
                                    GError **error ) ;
#line 122
Babl *gimp_color_profile_get_lcms_format(Babl *format , guint32 *lcms_format ) ;
#line 36 "/usr/include/gimp-2.0/libgimpcolor/gimpcolorspace.h"
void gimp_rgb_to_hsv(GimpRGB *rgb , GimpHSV *hsv ) ;
#line 38
void gimp_rgb_to_hsl(GimpRGB *rgb , GimpHSL *hsl ) ;
#line 40
void gimp_rgb_to_cmyk(GimpRGB *rgb , gdouble pullout , GimpCMYK *cmyk ) ;
#line 44
void gimp_hsv_to_rgb(GimpHSV *hsv , GimpRGB *rgb ) ;
#line 46
void gimp_hsl_to_rgb(GimpHSL *hsl , GimpRGB *rgb ) ;
#line 48
void gimp_cmyk_to_rgb(GimpCMYK *cmyk , GimpRGB *rgb ) ;
#line 52
void gimp_rgb_to_hwb(GimpRGB *rgb , gdouble *hue , gdouble *whiteness , gdouble *blackness ) ;
#line 58
void gimp_hwb_to_rgb(gdouble hue , gdouble whiteness , gdouble blackness , GimpRGB *rgb ) ;
#line 67
void gimp_rgb_to_hsv_int(gint *red , gint *green , gint *blue ) ;
#line 72
void gimp_hsv_to_rgb_int(gint *hue , gint *saturation , gint *value ) ;
#line 77
void gimp_rgb_to_cmyk_int(gint *red , gint *green , gint *blue , gint *pullout ) ;
#line 83
void gimp_cmyk_to_rgb_int(gint *cyan , gint *magenta , gint *yellow , gint *black ) ;
#line 89
void gimp_rgb_to_hsl_int(gint *red , gint *green , gint *blue ) ;
#line 94
gint gimp_rgb_to_l_int(gint red , gint green , gint blue ) ;
#line 99
void gimp_hsl_to_rgb_int(gint *hue , gint *saturation , gint *lightness ) ;
#line 107
void gimp_rgb_to_hsv4(guchar *rgb , gdouble *hue , gdouble *saturation , gdouble *value ) ;
#line 113
void gimp_hsv_to_rgb4(guchar *rgb , gdouble hue , gdouble saturation , gdouble value ) ;
#line 88 "/usr/include/gimp-2.0/libgimpcolor/gimpcolortransform.h"
GType gimp_color_transform_get_type(void) ;
#line 91
GimpColorTransform *gimp_color_transform_new(GimpColorProfile *src_profile , Babl *src_format ,
                                             GimpColorProfile *dest_profile , Babl *dest_format ,
                                             GimpColorRenderingIntent rendering_intent ,
                                             GimpColorTransformFlags flags ) ;
#line 99
GimpColorTransform *gimp_color_transform_new_proofing(GimpColorProfile *src_profile ,
                                                      Babl *src_format , GimpColorProfile *dest_profile ,
                                                      Babl *dest_format , GimpColorProfile *proof_profile ,
                                                      GimpColorRenderingIntent proof_intent ,
                                                      GimpColorRenderingIntent display_intent ,
                                                      GimpColorTransformFlags flags ) ;
#line 108
void gimp_color_transform_process_pixels(GimpColorTransform *transform , Babl *src_format ,
                                         gconstpointer src_pixels , Babl *dest_format ,
                                         gpointer dest_pixels , gsize length ) ;
#line 115
void gimp_color_transform_process_buffer(GimpColorTransform *transform , GeglBuffer *src_buffer ,
                                         GeglRectangle *src_rect , GeglBuffer *dest_buffer ,
                                         GeglRectangle *dest_rect ) ;
#line 121
gboolean gimp_color_transform_can_gegl_copy(GimpColorProfile *src_profile , GimpColorProfile *dest_profile ) ;
#line 38 "/usr/include/gimp-2.0/libgimpcolor/gimpcmyk.h"
GType gimp_cmyk_get_type(void) ;
#line 40
void gimp_cmyk_set(GimpCMYK *cmyk , gdouble cyan , gdouble magenta , gdouble yellow ,
                   gdouble black ) ;
#line 45
void gimp_cmyk_set_uchar(GimpCMYK *cmyk , guchar cyan , guchar magenta , guchar yellow ,
                         guchar black ) ;
#line 50
void gimp_cmyk_get_uchar(GimpCMYK *cmyk , guchar *cyan , guchar *magenta , guchar *yellow ,
                         guchar *black ) ;
#line 56
void gimp_cmyka_set(GimpCMYK *cmyka , gdouble cyan , gdouble magenta , gdouble yellow ,
                    gdouble black , gdouble alpha ) ;
#line 62
void gimp_cmyka_set_uchar(GimpCMYK *cmyka , guchar cyan , guchar magenta , guchar yellow ,
                          guchar black , guchar alpha ) ;
#line 68
void gimp_cmyka_get_uchar(GimpCMYK *cmyka , guchar *cyan , guchar *magenta , guchar *yellow ,
                          guchar *black , guchar *alpha ) ;
#line 37 "/usr/include/gimp-2.0/libgimpcolor/gimphsl.h"
GType gimp_hsl_get_type(void) ;
#line 39
void gimp_hsl_set(GimpHSL *hsl , gdouble h , gdouble s , gdouble l ) ;
#line 43
void gimp_hsl_set_alpha(GimpHSL *hsl , gdouble a ) ;
#line 37 "/usr/include/gimp-2.0/libgimpcolor/gimphsv.h"
GType gimp_hsv_get_type(void) ;
#line 39
void gimp_hsv_set(GimpHSV *hsv , gdouble hue , gdouble saturation , gdouble value ) ;
#line 43
void gimp_hsv_clamp(GimpHSV *hsv ) ;
#line 45
void gimp_hsva_set(GimpHSV *hsva , gdouble hue , gdouble saturation , gdouble value ,
                   gdouble alpha ) ;
#line 34 "/usr/include/gimp-2.0/libgimpcolor/gimppixbuf.h"
Babl *gimp_pixbuf_get_format(GdkPixbuf *pixbuf ) ;
#line 35
GeglBuffer *gimp_pixbuf_create_buffer(GdkPixbuf *pixbuf ) ;
#line 37
guint8 *gimp_pixbuf_get_icc_profile(GdkPixbuf *pixbuf , gsize *length ) ;
#line 38 "/usr/include/gimp-2.0/libgimpcolor/gimprgb.h"
GType gimp_rgb_get_type(void) ;
#line 40
void gimp_value_get_rgb(GValue *value , GimpRGB *rgb ) ;
#line 42
void gimp_value_set_rgb(GValue *value , GimpRGB *rgb ) ;
#line 54
GType gimp_param_rgb_get_type(void) ;
#line 56
GParamSpec *gimp_param_spec_rgb(gchar *name , gchar *nick , gchar *blurb , gboolean has_alpha ,
                                GimpRGB *default_value , GParamFlags flags ) ;
#line 63
void gimp_param_spec_rgb_get_default(GParamSpec *pspec , GimpRGB *default_value ) ;
#line 65
gboolean gimp_param_spec_rgb_has_alpha(GParamSpec *pspec ) ;
#line 84
void gimp_rgb_set(GimpRGB *rgb , gdouble red , gdouble green , gdouble blue ) ;
#line 88
void gimp_rgb_set_alpha(GimpRGB *rgb , gdouble alpha ) ;
#line 91
void gimp_rgb_set_pixel(GimpRGB *rgb , Babl *format , gconstpointer pixel ) ;
#line 94
void gimp_rgb_get_pixel(GimpRGB *rgb , Babl *format , gpointer pixel ) ;
#line 98
void gimp_rgb_set_uchar(GimpRGB *rgb , guchar red , guchar green , guchar blue ) ;
#line 102
void gimp_rgb_get_uchar(GimpRGB *rgb , guchar *red , guchar *green , guchar *blue ) ;
#line 107
gboolean gimp_rgb_parse_name(GimpRGB *rgb , gchar *name , gint len ) ;
#line 110
gboolean gimp_rgb_parse_hex(GimpRGB *rgb , gchar *hex , gint len ) ;
#line 113
gboolean gimp_rgb_parse_css(GimpRGB *rgb , gchar *css , gint len ) ;
#line 117
void gimp_rgb_add(GimpRGB *rgb1 , GimpRGB *rgb2 ) ;
#line 119
void gimp_rgb_subtract(GimpRGB *rgb1 , GimpRGB *rgb2 ) ;
#line 121
void gimp_rgb_multiply(GimpRGB *rgb1 , gdouble factor ) ;
#line 123
gdouble gimp_rgb_distance(GimpRGB *rgb1 , GimpRGB *rgb2 ) ;
#line 126
gdouble gimp_rgb_max(GimpRGB *rgb ) ;
#line 127
gdouble gimp_rgb_min(GimpRGB *rgb ) ;
#line 128
void gimp_rgb_clamp(GimpRGB *rgb ) ;
#line 130
void gimp_rgb_gamma(GimpRGB *rgb , gdouble gamma ) ;
#line 133
gdouble gimp_rgb_luminance(GimpRGB *rgb ) ;
#line 134
guchar gimp_rgb_luminance_uchar(GimpRGB *rgb ) ;
#line 137
gdouble gimp_rgb_intensity(GimpRGB *rgb ) ;
#line 139
guchar gimp_rgb_intensity_uchar(GimpRGB *rgb ) ;
#line 141
void gimp_rgb_composite(GimpRGB *color1 , GimpRGB *color2 , GimpRGBCompositeMode mode ) ;
#line 146
gint gimp_rgb_list_names(gchar ***names , GimpRGB **colors ) ;
#line 150
void gimp_rgba_set(GimpRGB *rgba , gdouble red , gdouble green , gdouble blue , gdouble alpha ) ;
#line 156
void gimp_rgba_set_pixel(GimpRGB *rgba , Babl *format , gconstpointer pixel ) ;
#line 159
void gimp_rgba_get_pixel(GimpRGB *rgba , Babl *format , gpointer pixel ) ;
#line 163
void gimp_rgba_set_uchar(GimpRGB *rgba , guchar red , guchar green , guchar blue ,
                         guchar alpha ) ;
#line 168
void gimp_rgba_get_uchar(GimpRGB *rgba , guchar *red , guchar *green , guchar *blue ,
                         guchar *alpha ) ;
#line 174
gboolean gimp_rgba_parse_css(GimpRGB *rgba , gchar *css , gint len ) ;
#line 178
void gimp_rgba_add(GimpRGB *rgba1 , GimpRGB *rgba2 ) ;
#line 180
void gimp_rgba_subtract(GimpRGB *rgba1 , GimpRGB *rgba2 ) ;
#line 182
void gimp_rgba_multiply(GimpRGB *rgba , gdouble factor ) ;
#line 185
gdouble gimp_rgba_distance(GimpRGB *rgba1 , GimpRGB *rgba2 ) ;
#line 30 "/usr/include/gimp-2.0/libgimpconfig/gimpconfigwriter.h"
GimpConfigWriter *gimp_config_writer_new_file(gchar *filename , gboolean atomic ,
                                              gchar *header , GError **error ) ;
#line 34
GimpConfigWriter *gimp_config_writer_new_gfile(GFile *file , gboolean atomic , gchar *header ,
                                               GError **error ) ;
#line 38
GimpConfigWriter *gimp_config_writer_new_stream(GOutputStream *output , gchar *header ,
                                                GError **error ) ;
#line 41
GimpConfigWriter *gimp_config_writer_new_fd(gint fd ) ;
#line 42
GimpConfigWriter *gimp_config_writer_new_string(GString *string ) ;
#line 44
void gimp_config_writer_open(GimpConfigWriter *writer , gchar *name ) ;
#line 46
void gimp_config_writer_comment_mode(GimpConfigWriter *writer , gboolean enable ) ;
#line 49
void gimp_config_writer_print(GimpConfigWriter *writer , gchar *string , gint len ) ;
#line 52
void gimp_config_writer_printf(GimpConfigWriter *writer , gchar *format  , ...) ;
#line 55
void gimp_config_writer_identifier(GimpConfigWriter *writer , gchar *identifier ) ;
#line 57
void gimp_config_writer_string(GimpConfigWriter *writer , gchar *string ) ;
#line 59
void gimp_config_writer_data(GimpConfigWriter *writer , gint length , guint8 *data ) ;
#line 62
void gimp_config_writer_comment(GimpConfigWriter *writer , gchar *comment ) ;
#line 64
void gimp_config_writer_linefeed(GimpConfigWriter *writer ) ;
#line 67
void gimp_config_writer_revert(GimpConfigWriter *writer ) ;
#line 68
void gimp_config_writer_close(GimpConfigWriter *writer ) ;
#line 69
gboolean gimp_config_writer_finish(GimpConfigWriter *writer , gchar *footer , GError **error ) ;
#line 74 "/usr/include/gimp-2.0/libgimpconfig/gimpconfig-iface.h"
GType gimp_config_get_type(void) ;
#line 77
GType gimp_config_interface_get_type(void) ;
#line 79
gboolean gimp_config_serialize_to_file(GimpConfig *config , gchar *filename , gchar *header ,
                                       gchar *footer , gpointer data , GError **error ) ;
#line 85
gboolean gimp_config_serialize_to_gfile(GimpConfig *config , GFile *file , gchar *header ,
                                        gchar *footer , gpointer data , GError **error ) ;
#line 91
gboolean gimp_config_serialize_to_stream(GimpConfig *config , GOutputStream *output ,
                                         gchar *header , gchar *footer , gpointer data ,
                                         GError **error ) ;
#line 97
gboolean gimp_config_serialize_to_fd(GimpConfig *config , gint fd , gpointer data ) ;
#line 100
gchar *gimp_config_serialize_to_string(GimpConfig *config , gpointer data ) ;
#line 102
gboolean gimp_config_deserialize_file(GimpConfig *config , gchar *filename , gpointer data ,
                                      GError **error ) ;
#line 106
gboolean gimp_config_deserialize_gfile(GimpConfig *config , GFile *file , gpointer data ,
                                       GError **error ) ;
#line 110
gboolean gimp_config_deserialize_stream(GimpConfig *config , GInputStream *input ,
                                        gpointer data , GError **error ) ;
#line 114
gboolean gimp_config_deserialize_string(GimpConfig *config , gchar *text , gint text_len ,
                                        gpointer data , GError **error ) ;
#line 119
gboolean gimp_config_deserialize_return(GScanner *scanner , GTokenType expected_token ,
                                        gint nest_level ) ;
#line 123
gboolean gimp_config_serialize(GimpConfig *config , GimpConfigWriter *writer , gpointer data ) ;
#line 126
gboolean gimp_config_deserialize(GimpConfig *config , GScanner *scanner , gint nest_level ,
                                 gpointer data ) ;
#line 130
gpointer gimp_config_duplicate(GimpConfig *config ) ;
#line 131
gboolean gimp_config_is_equal_to(GimpConfig *a , GimpConfig *b ) ;
#line 133
void gimp_config_reset(GimpConfig *config ) ;
#line 134
gboolean gimp_config_copy(GimpConfig *src , GimpConfig *dest , GParamFlags flags ) ;
#line 54 "/usr/include/gimp-2.0/libgimpconfig/gimpconfig-error.h"
GQuark gimp_config_error_quark(void) ;
#line 34 "/usr/include/gimp-2.0/libgimpconfig/gimpconfig-serialize.h"
gboolean gimp_config_serialize_properties(GimpConfig *config , GimpConfigWriter *writer ) ;
#line 36
gboolean gimp_config_serialize_changed_properties(GimpConfig *config , GimpConfigWriter *writer ) ;
#line 39
gboolean gimp_config_serialize_property(GimpConfig *config , GParamSpec *param_spec ,
                                        GimpConfigWriter *writer ) ;
#line 42
gboolean gimp_config_serialize_property_by_name(GimpConfig *config , gchar *prop_name ,
                                                GimpConfigWriter *writer ) ;
#line 45
gboolean gimp_config_serialize_value(GValue *value , GString *str , gboolean escaped ) ;
#line 34 "/usr/include/gimp-2.0/libgimpconfig/gimpconfig-deserialize.h"
gboolean gimp_config_deserialize_properties(GimpConfig *config , GScanner *scanner ,
                                            gint nest_level ) ;
#line 37
GTokenType gimp_config_deserialize_property(GimpConfig *config , GScanner *scanner ,
                                            gint nest_level ) ;
#line 34 "/usr/include/gimp-2.0/libgimpconfig/gimpconfig-utils.h"
GList *gimp_config_diff(GObject *a , GObject *b , GParamFlags flags ) ;
#line 38
gboolean gimp_config_sync(GObject *src , GObject *dest , GParamFlags flags ) ;
#line 42
void gimp_config_reset_properties(GObject *object ) ;
#line 43
void gimp_config_reset_property(GObject *object , gchar *property_name ) ;
#line 46
void gimp_config_string_append_escaped(GString *string , gchar *val ) ;
#line 41 "/usr/include/gimp-2.0/libgimpconfig/gimpconfig-path.h"
GType gimp_config_path_get_type(void) ;
#line 70
GType gimp_param_config_path_get_type(void) ;
#line 72
GParamSpec *gimp_param_spec_config_path(gchar *name , gchar *nick , gchar *blurb ,
                                        GimpConfigPathType type , gchar *default_value ,
                                        GParamFlags flags ) ;
#line 79
GimpConfigPathType gimp_param_spec_config_path_type(GParamSpec *pspec ) ;
#line 86
gchar *gimp_config_path_expand(gchar *path , gboolean recode , GError **error ) ;
#line 89
GList *gimp_config_path_expand_to_files(gchar *path , GError **error ) ;
#line 92
gchar *gimp_config_path_unexpand(gchar *path , gboolean recode , GError **error ) ;
#line 96
GFile *gimp_file_new_for_config_path(gchar *path , GError **error ) ;
#line 98
gchar *gimp_file_get_config_path(GFile *file , GError **error ) ;
#line 101
gchar *gimp_config_build_data_path(gchar *name ) ;
#line 102
gchar *gimp_config_build_writable_path(gchar *name ) ;
#line 103
gchar *gimp_config_build_plug_in_path(gchar *name ) ;
#line 31 "/usr/include/gimp-2.0/libgimpconfig/gimpscanner.h"
GScanner *gimp_scanner_new_file(gchar *filename , GError **error ) ;
#line 33
GScanner *gimp_scanner_new_gfile(GFile *file , GError **error ) ;
#line 35
GScanner *gimp_scanner_new_stream(GInputStream *input , GError **error ) ;
#line 37
GScanner *gimp_scanner_new_string(gchar *text , gint text_len , GError **error ) ;
#line 40
void gimp_scanner_destroy(GScanner *scanner ) ;
#line 42
gboolean gimp_scanner_parse_token(GScanner *scanner , GTokenType token ) ;
#line 44
gboolean gimp_scanner_parse_identifier(GScanner *scanner , gchar *identifier ) ;
#line 46
gboolean gimp_scanner_parse_string(GScanner *scanner , gchar **dest ) ;
#line 48
gboolean gimp_scanner_parse_string_no_validate(GScanner *scanner , gchar **dest ) ;
#line 50
gboolean gimp_scanner_parse_data(GScanner *scanner , gint length , guint8 **dest ) ;
#line 53
gboolean gimp_scanner_parse_int(GScanner *scanner , gint *dest ) ;
#line 55
gboolean gimp_scanner_parse_int64(GScanner *scanner , gint64 *dest ) ;
#line 57
gboolean gimp_scanner_parse_float(GScanner *scanner , gdouble *dest ) ;
#line 59
gboolean gimp_scanner_parse_boolean(GScanner *scanner , gboolean *dest ) ;
#line 61
gboolean gimp_scanner_parse_color(GScanner *scanner , GimpRGB *dest ) ;
#line 63
gboolean gimp_scanner_parse_matrix2(GScanner *scanner , GimpMatrix2 *dest ) ;
#line 81 "/usr/include/gimp-2.0/libgimpconfig/gimpcolorconfig.h"
GType gimp_color_config_get_type(void) ;
#line 84
GimpColorManagementMode gimp_color_config_get_mode(GimpColorConfig *config ) ;
#line 87
GimpColorRenderingIntent gimp_color_config_get_display_intent(GimpColorConfig *config ) ;
#line 88
gboolean gimp_color_config_get_display_bpc(GimpColorConfig *config ) ;
#line 89
gboolean gimp_color_config_get_display_optimize(GimpColorConfig *config ) ;
#line 90
gboolean gimp_color_config_get_display_profile_from_gdk(GimpColorConfig *config ) ;
#line 93
GimpColorRenderingIntent gimp_color_config_get_simulation_intent(GimpColorConfig *config ) ;
#line 94
gboolean gimp_color_config_get_simulation_bpc(GimpColorConfig *config ) ;
#line 95
gboolean gimp_color_config_get_simulation_optimize(GimpColorConfig *config ) ;
#line 96
gboolean gimp_color_config_get_simulation_gamut_check(GimpColorConfig *config ) ;
#line 98
GimpColorProfile *gimp_color_config_get_rgb_color_profile(GimpColorConfig *config ,
                                                          GError **error ) ;
#line 100
GimpColorProfile *gimp_color_config_get_gray_color_profile(GimpColorConfig *config ,
                                                           GError **error ) ;
#line 102
GimpColorProfile *gimp_color_config_get_cmyk_color_profile(GimpColorConfig *config ,
                                                           GError **error ) ;
#line 104
GimpColorProfile *gimp_color_config_get_display_color_profile(GimpColorConfig *config ,
                                                              GError **error ) ;
#line 106
GimpColorProfile *gimp_color_config_get_simulation_color_profile(GimpColorConfig *config ,
                                                                 GError **error ) ;
#line 41 "/usr/include/gimp-2.0/libgimpmath/gimpmatrix.h"
GType gimp_matrix2_get_type(void) ;
#line 47
GType gimp_param_matrix2_get_type(void) ;
#line 49
GParamSpec *gimp_param_spec_matrix2(gchar *name , gchar *nick , gchar *blurb , GimpMatrix2 *default_value ,
                                    GParamFlags flags ) ;
#line 56
void gimp_matrix2_identity(GimpMatrix2 *matrix ) ;
#line 57
void gimp_matrix2_mult(GimpMatrix2 *matrix1 , GimpMatrix2 *matrix2 ) ;
#line 60
gdouble gimp_matrix2_determinant(GimpMatrix2 *matrix ) ;
#line 61
void gimp_matrix2_invert(GimpMatrix2 *matrix ) ;
#line 63
void gimp_matrix2_transform_point(GimpMatrix2 *matrix , gdouble x , gdouble y , gdouble *newx ,
                                  gdouble *newy ) ;
#line 77
GType gimp_matrix3_get_type(void) ;
#line 83
GType gimp_param_matrix3_get_type(void) ;
#line 85
GParamSpec *gimp_param_spec_matrix3(gchar *name , gchar *nick , gchar *blurb , GimpMatrix3 *default_value ,
                                    GParamFlags flags ) ;
#line 92
void gimp_matrix3_identity(GimpMatrix3 *matrix ) ;
#line 93
void gimp_matrix3_mult(GimpMatrix3 *matrix1 , GimpMatrix3 *matrix2 ) ;
#line 95
void gimp_matrix3_translate(GimpMatrix3 *matrix , gdouble x , gdouble y ) ;
#line 98
void gimp_matrix3_scale(GimpMatrix3 *matrix , gdouble x , gdouble y ) ;
#line 101
void gimp_matrix3_rotate(GimpMatrix3 *matrix , gdouble theta ) ;
#line 103
void gimp_matrix3_xshear(GimpMatrix3 *matrix , gdouble amount ) ;
#line 105
void gimp_matrix3_yshear(GimpMatrix3 *matrix , gdouble amount ) ;
#line 107
void gimp_matrix3_affine(GimpMatrix3 *matrix , gdouble a , gdouble b , gdouble c ,
                         gdouble d , gdouble e , gdouble f ) ;
#line 115
gdouble gimp_matrix3_determinant(GimpMatrix3 *matrix ) ;
#line 116
void gimp_matrix3_invert(GimpMatrix3 *matrix ) ;
#line 118
gboolean gimp_matrix3_is_identity(GimpMatrix3 *matrix ) ;
#line 119
gboolean gimp_matrix3_is_diagonal(GimpMatrix3 *matrix ) ;
#line 120
gboolean gimp_matrix3_is_affine(GimpMatrix3 *matrix ) ;
#line 121
gboolean gimp_matrix3_is_simple(GimpMatrix3 *matrix ) ;
#line 123
gboolean gimp_matrix3_equal(GimpMatrix3 *matrix1 , GimpMatrix3 *matrix2 ) ;
#line 126
void gimp_matrix3_transform_point(GimpMatrix3 *matrix , gdouble x , gdouble y , gdouble *newx ,
                                  gdouble *newy ) ;
#line 137
void gimp_matrix4_identity(GimpMatrix4 *matrix ) ;
#line 138
void gimp_matrix4_mult(GimpMatrix4 *matrix1 , GimpMatrix4 *matrix2 ) ;
#line 141
void gimp_matrix4_to_deg(GimpMatrix4 *matrix , gdouble *a , gdouble *b , gdouble *c ) ;
#line 146
gdouble gimp_matrix4_transform_point(GimpMatrix4 *matrix , gdouble x , gdouble y ,
                                     gdouble z , gdouble *newx , gdouble *newy , gdouble *newz ) ;
#line 20 "/usr/include/gimp-2.0/libgimpmath/gimpmd5.h"
void gimp_md5_get_digest(gchar *buffer , gint buffer_size , guchar digest[16] ) ;
#line 40 "/usr/include/gimp-2.0/libgimpmath/gimpvector.h"
GimpVector2 gimp_vector2_new(gdouble x , gdouble y ) ;
#line 42
void gimp_vector2_set(GimpVector2 *vector , gdouble x , gdouble y ) ;
#line 45
gdouble gimp_vector2_length(GimpVector2 *vector ) ;
#line 46
gdouble gimp_vector2_length_val(GimpVector2 vector ) ;
#line 47
void gimp_vector2_mul(GimpVector2 *vector , gdouble factor ) ;
#line 49
GimpVector2 gimp_vector2_mul_val(GimpVector2 vector , gdouble factor ) ;
#line 51
void gimp_vector2_normalize(GimpVector2 *vector ) ;
#line 52
GimpVector2 gimp_vector2_normalize_val(GimpVector2 vector ) ;
#line 53
void gimp_vector2_neg(GimpVector2 *vector ) ;
#line 54
GimpVector2 gimp_vector2_neg_val(GimpVector2 vector ) ;
#line 55
void gimp_vector2_add(GimpVector2 *result , GimpVector2 *vector1 , GimpVector2 *vector2 ) ;
#line 58
GimpVector2 gimp_vector2_add_val(GimpVector2 vector1 , GimpVector2 vector2 ) ;
#line 60
void gimp_vector2_sub(GimpVector2 *result , GimpVector2 *vector1 , GimpVector2 *vector2 ) ;
#line 63
GimpVector2 gimp_vector2_sub_val(GimpVector2 vector1 , GimpVector2 vector2 ) ;
#line 65
gdouble gimp_vector2_inner_product(GimpVector2 *vector1 , GimpVector2 *vector2 ) ;
#line 67
gdouble gimp_vector2_inner_product_val(GimpVector2 vector1 , GimpVector2 vector2 ) ;
#line 69
GimpVector2 gimp_vector2_cross_product(GimpVector2 *vector1 , GimpVector2 *vector2 ) ;
#line 71
GimpVector2 gimp_vector2_cross_product_val(GimpVector2 vector1 , GimpVector2 vector2 ) ;
#line 73
void gimp_vector2_rotate(GimpVector2 *vector , gdouble alpha ) ;
#line 75
GimpVector2 gimp_vector2_rotate_val(GimpVector2 vector , gdouble alpha ) ;
#line 77
GimpVector2 gimp_vector2_normal(GimpVector2 *vector ) ;
#line 78
GimpVector2 gimp_vector2_normal_val(GimpVector2 vector ) ;
#line 83
GimpVector3 gimp_vector3_new(gdouble x , gdouble y , gdouble z ) ;
#line 86
void gimp_vector3_set(GimpVector3 *vector , gdouble x , gdouble y , gdouble z ) ;
#line 90
gdouble gimp_vector3_length(GimpVector3 *vector ) ;
#line 91
gdouble gimp_vector3_length_val(GimpVector3 vector ) ;
#line 92
void gimp_vector3_mul(GimpVector3 *vector , gdouble factor ) ;
#line 94
GimpVector3 gimp_vector3_mul_val(GimpVector3 vector , gdouble factor ) ;
#line 96
void gimp_vector3_normalize(GimpVector3 *vector ) ;
#line 97
GimpVector3 gimp_vector3_normalize_val(GimpVector3 vector ) ;
#line 98
void gimp_vector3_neg(GimpVector3 *vector ) ;
#line 99
GimpVector3 gimp_vector3_neg_val(GimpVector3 vector ) ;
#line 100
void gimp_vector3_add(GimpVector3 *result , GimpVector3 *vector1 , GimpVector3 *vector2 ) ;
#line 103
GimpVector3 gimp_vector3_add_val(GimpVector3 vector1 , GimpVector3 vector2 ) ;
#line 105
void gimp_vector3_sub(GimpVector3 *result , GimpVector3 *vector1 , GimpVector3 *vector2 ) ;
#line 108
GimpVector3 gimp_vector3_sub_val(GimpVector3 vector1 , GimpVector3 vector2 ) ;
#line 110
gdouble gimp_vector3_inner_product(GimpVector3 *vector1 , GimpVector3 *vector2 ) ;
#line 112
gdouble gimp_vector3_inner_product_val(GimpVector3 vector1 , GimpVector3 vector2 ) ;
#line 114
GimpVector3 gimp_vector3_cross_product(GimpVector3 *vector1 , GimpVector3 *vector2 ) ;
#line 116
GimpVector3 gimp_vector3_cross_product_val(GimpVector3 vector1 , GimpVector3 vector2 ) ;
#line 118
void gimp_vector3_rotate(GimpVector3 *vector , gdouble alpha , gdouble beta , gdouble gamma ) ;
#line 122
GimpVector3 gimp_vector3_rotate_val(GimpVector3 vector , gdouble alpha , gdouble beta ,
                                    gdouble gamma ) ;
#line 130
void gimp_vector_2d_to_3d(gint sx , gint sy , gint w , gint h , gint x , gint y ,
                          GimpVector3 *vp , GimpVector3 *p ) ;
#line 139
GimpVector3 gimp_vector_2d_to_3d_val(gint sx , gint sy , gint w , gint h , gint x ,
                                     gint y , GimpVector3 vp , GimpVector3 p ) ;
#line 148
void gimp_vector_3d_to_2d(gint sx , gint sy , gint w , gint h , gdouble *x , gdouble *y ,
                          GimpVector3 *vp , GimpVector3 *p ) ;
#line 29 "/usr/include/gimp-2.0/libgimp/gimpenums.h"
GType gimp_brush_application_mode_get_type(void) ;
#line 40
GType gimp_convert_dither_type_get_type(void) ;
#line 53
GType gimp_histogram_channel_get_type(void) ;
#line 68
GType gimp_layer_color_space_get_type(void) ;
#line 80
GType gimp_layer_composite_mode_get_type(void) ;
#line 94
GType gimp_layer_mode_get_type(void) ;
#line 163
void gimp_enums_init(void) ;
#line 165
gchar **gimp_enums_get_type_names(gint *n_type_names ) ;
#line 33 "/usr/include/gimp-2.0/libgimp/gimpbrushes.h"
gdouble gimp_brushes_get_opacity(void) ;
#line 35
gboolean gimp_brushes_set_opacity(gdouble opacity ) ;
#line 37
GimpLayerMode gimp_brushes_get_paint_mode(void) ;
#line 39
gboolean gimp_brushes_set_paint_mode(GimpLayerMode paint_mode ) ;
#line 41
gboolean gimp_brushes_set_brush(gchar *name ) ;
#line 42 "/usr/include/gimp-2.0/libgimp/gimpbrushselect.h"
gchar *gimp_brush_select_new(gchar *title , gchar *brush_name , gdouble opacity ,
                             gint spacing , GimpLayerMode paint_mode , GimpRunBrushCallback callback ,
                             gpointer data ) ;
#line 49
void gimp_brush_select_destroy(gchar *brush_callback ) ;
#line 33 "/usr/include/gimp-2.0/libgimp/gimpchannel.h"
gint32 gimp_channel_new(gint32 image_ID , gchar *name , guint width , guint height ,
                        gdouble opacity , GimpRGB *color ) ;
#line 45 "/usr/include/gimp-2.0/libgimp/gimpdrawable.h"
GeglBuffer *gimp_drawable_get_buffer(gint32 drawable_ID ) ;
#line 46
GeglBuffer *gimp_drawable_get_shadow_buffer(gint32 drawable_ID ) ;
#line 48
Babl *gimp_drawable_get_format(gint32 drawable_ID ) ;
#line 49
Babl *gimp_drawable_get_thumbnail_format(gint32 drawable_ID ) ;
#line 52
GimpDrawable *gimp_drawable_get(gint32 drawable_ID ) ;
#line 54
void gimp_drawable_detach(GimpDrawable *drawable ) ;
#line 56
void gimp_drawable_flush(GimpDrawable *drawable ) ;
#line 58
GimpTile *gimp_drawable_get_tile(GimpDrawable *drawable , gboolean shadow , gint row ,
                                 gint col ) ;
#line 63
GimpTile *gimp_drawable_get_tile2(GimpDrawable *drawable , gboolean shadow , gint x ,
                                  gint y ) ;
#line 69
void gimp_drawable_get_color_uchar(gint32 drawable_ID , GimpRGB *color , guchar *color_uchar ) ;
#line 73
guchar *gimp_drawable_get_thumbnail_data(gint32 drawable_ID , gint *width , gint *height ,
                                         gint *bpp ) ;
#line 77
guchar *gimp_drawable_get_sub_thumbnail_data(gint32 drawable_ID , gint src_x , gint src_y ,
                                             gint src_width , gint src_height , gint *dest_width ,
                                             gint *dest_height , gint *bpp ) ;
#line 87
gboolean gimp_drawable_is_valid(gint32 drawable_ID ) ;
#line 89
gboolean gimp_drawable_is_layer(gint32 drawable_ID ) ;
#line 91
gboolean gimp_drawable_is_text_layer(gint32 drawable_ID ) ;
#line 93
gboolean gimp_drawable_is_layer_mask(gint32 drawable_ID ) ;
#line 95
gboolean gimp_drawable_is_channel(gint32 drawable_ID ) ;
#line 97
gboolean gimp_drawable_delete(gint32 drawable_ID ) ;
#line 99
gint32 gimp_drawable_get_image(gint32 drawable_ID ) ;
#line 101
gchar *gimp_drawable_get_name(gint32 drawable_ID ) ;
#line 103
gboolean gimp_drawable_set_name(gint32 drawable_ID , gchar *name ) ;
#line 106
gboolean gimp_drawable_get_visible(gint32 drawable_ID ) ;
#line 108
gboolean gimp_drawable_set_visible(gint32 drawable_ID , gboolean visible ) ;
#line 111
gboolean gimp_drawable_get_linked(gint32 drawable_ID ) ;
#line 113
gboolean gimp_drawable_set_linked(gint32 drawable_ID , gboolean linked ) ;
#line 116
gint gimp_drawable_get_tattoo(gint32 drawable_ID ) ;
#line 118
gboolean gimp_drawable_set_tattoo(gint32 drawable_ID , gint tattoo ) ;
#line 121
GimpParasite *gimp_drawable_parasite_find(gint32 drawable_ID , gchar *name ) ;
#line 124
gboolean gimp_drawable_parasite_attach(gint32 drawable_ID , GimpParasite *parasite ) ;
#line 127
gboolean gimp_drawable_parasite_detach(gint32 drawable_ID , gchar *name ) ;
#line 130
gboolean gimp_drawable_parasite_list(gint32 drawable_ID , gint *num_parasites , gchar ***parasites ) ;
#line 134
gboolean gimp_drawable_attach_new_parasite(gint32 drawable_ID , gchar *name , gint flags ,
                                           gint size , gconstpointer data ) ;
#line 34 "/usr/include/gimp-2.0/libgimp/gimpedit.h"
gint32 gimp_edit_paste_as_new(void) ;
#line 37
gint32 gimp_edit_named_paste_as_new(gchar *buffer_name ) ;
#line 36 "/usr/include/gimp-2.0/libgimp/gimpfontselect.h"
gchar *gimp_font_select_new(gchar *title , gchar *font_name , GimpRunFontCallback callback ,
                            gpointer data ) ;
#line 40
void gimp_font_select_destroy(gchar *font_callback ) ;
#line 33 "/usr/include/gimp-2.0/libgimp/gimpgimprc.h"
GimpColorConfig *gimp_get_color_configuration(void) ;
#line 33 "/usr/include/gimp-2.0/libgimp/gimpgradients.h"
gchar *gimp_gradients_get_gradient(void) ;
#line 35
gboolean gimp_gradients_set_gradient(gchar *name ) ;
#line 38 "/usr/include/gimp-2.0/libgimp/gimpgradientselect.h"
gchar *gimp_gradient_select_new(gchar *title , gchar *gradient_name , gint sample_size ,
                                GimpRunGradientCallback callback , gpointer data ) ;
#line 43
void gimp_gradient_select_destroy(gchar *gradient_callback ) ;
#line 33 "/usr/include/gimp-2.0/libgimp/gimpimage.h"
guchar *gimp_image_get_colormap(gint32 image_ID , gint *num_colors ) ;
#line 35
gboolean gimp_image_set_colormap(gint32 image_ID , guchar *colormap , gint num_colors ) ;
#line 39
guchar *gimp_image_get_thumbnail_data(gint32 image_ID , gint *width , gint *height ,
                                      gint *bpp ) ;
#line 44
GimpMetadata *gimp_image_get_metadata(gint32 image_ID ) ;
#line 45
gboolean gimp_image_set_metadata(gint32 image_ID , GimpMetadata *metadata ) ;
#line 49
guchar *gimp_image_get_cmap(gint32 image_ID , gint *num_colors ) ;
#line 52
gboolean gimp_image_set_cmap(gint32 image_ID , guchar *cmap , gint num_colors ) ;
#line 56
gint gimp_image_get_layer_position(gint32 image_ID , gint32 layer_ID ) ;
#line 59
gboolean gimp_image_raise_layer(gint32 image_ID , gint32 layer_ID ) ;
#line 62
gboolean gimp_image_lower_layer(gint32 image_ID , gint32 layer_ID ) ;
#line 65
gboolean gimp_image_raise_layer_to_top(gint32 image_ID , gint32 layer_ID ) ;
#line 68
gboolean gimp_image_lower_layer_to_bottom(gint32 image_ID , gint32 layer_ID ) ;
#line 71
gint gimp_image_get_channel_position(gint32 image_ID , gint32 channel_ID ) ;
#line 74
gboolean gimp_image_raise_channel(gint32 image_ID , gint32 channel_ID ) ;
#line 77
gboolean gimp_image_lower_channel(gint32 image_ID , gint32 channel_ID ) ;
#line 80
gint gimp_image_get_vectors_position(gint32 image_ID , gint32 vectors_ID ) ;
#line 83
gboolean gimp_image_raise_vectors(gint32 image_ID , gint32 vectors_ID ) ;
#line 86
gboolean gimp_image_lower_vectors(gint32 image_ID , gint32 vectors_ID ) ;
#line 89
gboolean gimp_image_raise_vectors_to_top(gint32 image_ID , gint32 vectors_ID ) ;
#line 92
gboolean gimp_image_lower_vectors_to_bottom(gint32 image_ID , gint32 vectors_ID ) ;
#line 95
GimpParasite *gimp_image_parasite_find(gint32 image_ID , gchar *name ) ;
#line 98
gboolean gimp_image_parasite_attach(gint32 image_ID , GimpParasite *parasite ) ;
#line 101
gboolean gimp_image_parasite_detach(gint32 image_ID , gchar *name ) ;
#line 104
gboolean gimp_image_parasite_list(gint32 image_ID , gint *num_parasites , gchar ***parasites ) ;
#line 108
gboolean gimp_image_attach_new_parasite(gint32 image_ID , gchar *name , gint flags ,
                                        gint size , gconstpointer data ) ;
#line 33 "/usr/include/gimp-2.0/libgimp/gimpimagecolorprofile.h"
GimpColorProfile *gimp_image_get_color_profile(gint32 image_ID ) ;
#line 34
gboolean gimp_image_set_color_profile(gint32 image_ID , GimpColorProfile *profile ) ;
#line 37
GimpColorProfile *gimp_image_get_effective_color_profile(gint32 image_ID ) ;
#line 39
gboolean gimp_image_convert_color_profile(gint32 image_ID , GimpColorProfile *profile ,
                                          GimpColorRenderingIntent intent , gboolean bpc ) ;
#line 33 "/usr/include/gimp-2.0/libgimp/gimplayer.h"
gint32 gimp_layer_new(gint32 image_ID , gchar *name , gint width , gint height , GimpImageType type ,
                      gdouble opacity , GimpLayerMode mode ) ;
#line 40
gint32 gimp_layer_copy(gint32 layer_ID ) ;
#line 42
gint32 gimp_layer_new_from_pixbuf(gint32 image_ID , gchar *name , GdkPixbuf *pixbuf ,
                                  gdouble opacity , GimpLayerMode mode , gdouble progress_start ,
                                  gdouble progress_end ) ;
#line 49
gint32 gimp_layer_new_from_surface(gint32 image_ID , gchar *name , cairo_surface_t *surface ,
                                   gdouble progress_start , gdouble progress_end ) ;
#line 56
gboolean gimp_layer_get_preserve_trans(gint32 layer_ID ) ;
#line 58
gboolean gimp_layer_set_preserve_trans(gint32 layer_ID , gboolean preserve_trans ) ;
#line 33 "/usr/include/gimp-2.0/libgimp/gimppalette.h"
gboolean gimp_palette_get_foreground(GimpRGB *foreground ) ;
#line 35
gboolean gimp_palette_get_background(GimpRGB *background ) ;
#line 37
gboolean gimp_palette_set_foreground(GimpRGB *foreground ) ;
#line 39
gboolean gimp_palette_set_background(GimpRGB *background ) ;
#line 41
gboolean gimp_palette_set_default_colors(void) ;
#line 43
gboolean gimp_palette_swap_colors(void) ;
#line 33 "/usr/include/gimp-2.0/libgimp/gimppalettes.h"
gboolean gimp_palettes_set_palette(gchar *name ) ;
#line 36 "/usr/include/gimp-2.0/libgimp/gimppaletteselect.h"
gchar *gimp_palette_select_new(gchar *title , gchar *palette_name , GimpRunPaletteCallback callback ,
                               gpointer data ) ;
#line 40
void gimp_palette_select_destroy(gchar *palette_callback ) ;
#line 33 "/usr/include/gimp-2.0/libgimp/gimppatterns.h"
gboolean gimp_patterns_set_pattern(gchar *name ) ;
#line 40 "/usr/include/gimp-2.0/libgimp/gimppatternselect.h"
gchar *gimp_pattern_select_new(gchar *title , gchar *pattern_name , GimpRunPatternCallback callback ,
                               gpointer data ) ;
#line 44
void gimp_pattern_select_destroy(gchar *pattern_callback ) ;
#line 51 "/usr/include/gimp-2.0/libgimp/gimppixbuf.h"
GdkPixbuf *gimp_image_get_thumbnail(gint32 image_ID , gint width , gint height , GimpPixbufTransparency alpha ) ;
#line 55
GdkPixbuf *gimp_drawable_get_thumbnail(gint32 drawable_ID , gint width , gint height ,
                                       GimpPixbufTransparency alpha ) ;
#line 59
GdkPixbuf *gimp_drawable_get_sub_thumbnail(gint32 drawable_ID , gint src_x , gint src_y ,
                                           gint src_width , gint src_height , gint dest_width ,
                                           gint dest_height , GimpPixbufTransparency alpha ) ;
#line 51 "/usr/include/gimp-2.0/libgimp/gimppixelfetcher.h"
GimpPixelFetcher *gimp_pixel_fetcher_new(GimpDrawable *drawable , gboolean shadow ) ;
#line 54
void gimp_pixel_fetcher_destroy(GimpPixelFetcher *pf ) ;
#line 57
void gimp_pixel_fetcher_set_edge_mode(GimpPixelFetcher *pf , GimpPixelFetcherEdgeMode mode ) ;
#line 60
void gimp_pixel_fetcher_set_bg_color(GimpPixelFetcher *pf , GimpRGB *color ) ;
#line 64
void gimp_pixel_fetcher_get_pixel(GimpPixelFetcher *pf , gint x , gint y , guchar *pixel ) ;
#line 69
void gimp_pixel_fetcher_put_pixel(GimpPixelFetcher *pf , gint x , gint y , guchar *pixel ) ;
#line 48 "/usr/include/gimp-2.0/libgimp/gimppixelrgn.h"
void gimp_pixel_rgn_init(GimpPixelRgn *pr , GimpDrawable *drawable , gint x , gint y ,
                         gint width , gint height , gint dirty , gint shadow ) ;
#line 57
void gimp_pixel_rgn_resize(GimpPixelRgn *pr , gint x , gint y , gint width , gint height ) ;
#line 63
void gimp_pixel_rgn_get_pixel(GimpPixelRgn *pr , guchar *buf , gint x , gint y ) ;
#line 68
void gimp_pixel_rgn_get_row(GimpPixelRgn *pr , guchar *buf , gint x , gint y , gint width ) ;
#line 74
void gimp_pixel_rgn_get_col(GimpPixelRgn *pr , guchar *buf , gint x , gint y , gint height ) ;
#line 80
void gimp_pixel_rgn_get_rect(GimpPixelRgn *pr , guchar *buf , gint x , gint y , gint width ,
                             gint height ) ;
#line 87
void gimp_pixel_rgn_set_pixel(GimpPixelRgn *pr , guchar *buf , gint x , gint y ) ;
#line 92
void gimp_pixel_rgn_set_row(GimpPixelRgn *pr , guchar *buf , gint x , gint y , gint width ) ;
#line 98
void gimp_pixel_rgn_set_col(GimpPixelRgn *pr , guchar *buf , gint x , gint y , gint height ) ;
#line 104
void gimp_pixel_rgn_set_rect(GimpPixelRgn *pr , guchar *buf , gint x , gint y , gint width ,
                             gint height ) ;
#line 111
gpointer gimp_pixel_rgns_register(gint nrgns  , ...) ;
#line 114
gpointer gimp_pixel_rgns_register2(gint nrgns , GimpPixelRgn **prs ) ;
#line 117
gpointer gimp_pixel_rgns_process(gpointer pri_ptr ) ;
#line 33 "/usr/include/gimp-2.0/libgimp/gimpplugin.h"
gboolean gimp_plugin_icon_register(gchar *procedure_name , GimpIconType icon_type ,
                                   guint8 *icon_data ) ;
#line 33 "/usr/include/gimp-2.0/libgimp/gimpproceduraldb.h"
gboolean gimp_procedural_db_proc_info(gchar *procedure , gchar **blurb , gchar **help ,
                                      gchar **author , gchar **copyright , gchar **date ,
                                      GimpPDBProcType *proc_type , gint *num_args ,
                                      gint *num_values , GimpParamDef **args , GimpParamDef **return_vals ) ;
#line 44
gboolean gimp_procedural_db_get_data(gchar *identifier , gpointer data ) ;
#line 46
gboolean gimp_procedural_db_set_data(gchar *identifier , gconstpointer data , guint32 bytes ) ;
#line 59 "/usr/include/gimp-2.0/libgimp/gimpprogress.h"
gchar *gimp_progress_install_vtable(GimpProgressVtable *vtable , gpointer user_data ) ;
#line 61
gpointer gimp_progress_uninstall(gchar *progress_callback ) ;
#line 63
gboolean gimp_progress_init(gchar *message ) ;
#line 64
gboolean gimp_progress_init_printf(gchar *format  , ...) ;
#line 67
gboolean gimp_progress_set_text_printf(gchar *format  , ...) ;
#line 70
gboolean gimp_progress_update(gdouble percentage ) ;
#line 84
gchar *gimp_progress_install(GimpProgressStartCallback start_callback , GimpProgressEndCallback end_callback ,
                             GimpProgressTextCallback text_callback , GimpProgressValueCallback value_callback ,
                             gpointer user_data ) ;
#line 63 "/usr/include/gimp-2.0/libgimp/gimpregioniterator.h"
GimpRgnIterator *gimp_rgn_iterator_new(GimpDrawable *drawable , GimpRunMode unused ) ;
#line 66
void gimp_rgn_iterator_free(GimpRgnIterator *iter ) ;
#line 68
void gimp_rgn_iterator_src(GimpRgnIterator *iter , GimpRgnFuncSrc func , gpointer data ) ;
#line 72
void gimp_rgn_iterator_dest(GimpRgnIterator *iter , GimpRgnFuncDest func , gpointer data ) ;
#line 76
void gimp_rgn_iterator_src_dest(GimpRgnIterator *iter , GimpRgnFuncSrcDest func ,
                                gpointer data ) ;
#line 82
void gimp_rgn_iterate1(GimpDrawable *drawable , GimpRunMode unused , GimpRgnFunc1 func ,
                       gpointer data ) ;
#line 88
void gimp_rgn_iterate2(GimpDrawable *drawable , GimpRunMode unused , GimpRgnFunc2 func ,
                       gpointer data ) ;
#line 33 "/usr/include/gimp-2.0/libgimp/gimpselection.h"
gint32 gimp_selection_float(gint32 image_ID , gint32 drawable_ID , gint offx , gint offy ) ;
#line 39
gboolean gimp_selection_clear(gint32 image_ID ) ;
#line 48 "/usr/include/gimp-2.0/libgimp/gimptile.h"
void gimp_tile_ref(GimpTile *tile ) ;
#line 50
void gimp_tile_ref_zero(GimpTile *tile ) ;
#line 52
void gimp_tile_unref(GimpTile *tile , gboolean dirty ) ;
#line 55
void gimp_tile_flush(GimpTile *tile ) ;
#line 58
void gimp_tile_cache_size(gulong kilobytes ) ;
#line 60
void gimp_tile_cache_ntiles(gulong ntiles ) ;
#line 65
void _gimp_tile_ref_nocache(GimpTile *tile , gboolean init ) ;
#line 68
void _gimp_tile_cache_flush_drawable(GimpDrawable *drawable ) ;
#line 34 "/usr/include/gimp-2.0/libgimp/gimpvectors.h"
gboolean gimp_vectors_is_valid(gint32 vectors_ID ) ;
#line 36
gint32 gimp_vectors_get_image(gint32 vectors_ID ) ;
#line 38
gchar *gimp_vectors_get_name(gint32 vectors_ID ) ;
#line 40
gboolean gimp_vectors_set_name(gint32 vectors_ID , gchar *name ) ;
#line 43
gboolean gimp_vectors_get_visible(gint32 vectors_ID ) ;
#line 45
gboolean gimp_vectors_set_visible(gint32 vectors_ID , gboolean visible ) ;
#line 48
gboolean gimp_vectors_get_linked(gint32 vectors_ID ) ;
#line 50
gboolean gimp_vectors_set_linked(gint32 vectors_ID , gboolean linked ) ;
#line 53
gint gimp_vectors_get_tattoo(gint32 vectors_ID ) ;
#line 55
gboolean gimp_vectors_set_tattoo(gint32 vectors_ID , gint tattoo ) ;
#line 58
GimpParasite *gimp_vectors_parasite_find(gint32 vectors_ID , gchar *name ) ;
#line 61
gboolean gimp_vectors_parasite_attach(gint32 vectors_ID , GimpParasite *parasite ) ;
#line 64
gboolean gimp_vectors_parasite_detach(gint32 vectors_ID , gchar *name ) ;
#line 67
gboolean gimp_vectors_parasite_list(gint32 vectors_ID , gint *num_parasites , gchar ***parasites ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimp_pdb.h"
gchar *gimp_version(void) ;
#line 36
gint gimp_getpid(void) ;
#line 37
gboolean gimp_attach_parasite(GimpParasite *parasite ) ;
#line 38
gboolean gimp_detach_parasite(gchar *name ) ;
#line 39
GimpParasite *gimp_get_parasite(gchar *name ) ;
#line 40
gchar **gimp_get_parasite_list(gint *num_parasites ) ;
#line 41
gchar *gimp_temp_name(gchar *extension ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpbrush_pdb.h"
gchar *gimp_brush_new(gchar *name ) ;
#line 36
gchar *gimp_brush_duplicate(gchar *name ) ;
#line 37
gboolean gimp_brush_is_generated(gchar *name ) ;
#line 38
gchar *gimp_brush_rename(gchar *name , gchar *new_name ) ;
#line 40
gboolean gimp_brush_delete(gchar *name ) ;
#line 41
gboolean gimp_brush_is_editable(gchar *name ) ;
#line 42
gboolean gimp_brush_get_info(gchar *name , gint *width , gint *height , gint *mask_bpp ,
                             gint *color_bpp ) ;
#line 47
gboolean gimp_brush_get_pixels(gchar *name , gint *width , gint *height , gint *mask_bpp ,
                               gint *num_mask_bytes , guint8 **mask_bytes , gint *color_bpp ,
                               gint *num_color_bytes , guint8 **color_bytes ) ;
#line 56
gboolean gimp_brush_get_spacing(gchar *name , gint *spacing ) ;
#line 58
gboolean gimp_brush_set_spacing(gchar *name , gint spacing ) ;
#line 60
GimpBrushGeneratedShape gimp_brush_get_shape(gchar *name ) ;
#line 61
GimpBrushGeneratedShape gimp_brush_set_shape(gchar *name , GimpBrushGeneratedShape shape_in ) ;
#line 63
gdouble gimp_brush_get_radius(gchar *name ) ;
#line 64
gdouble gimp_brush_set_radius(gchar *name , gdouble radius_in ) ;
#line 66
gint gimp_brush_get_spikes(gchar *name ) ;
#line 67
gint gimp_brush_set_spikes(gchar *name , gint spikes_in ) ;
#line 69
gdouble gimp_brush_get_hardness(gchar *name ) ;
#line 70
gdouble gimp_brush_set_hardness(gchar *name , gdouble hardness_in ) ;
#line 72
gdouble gimp_brush_get_aspect_ratio(gchar *name ) ;
#line 73
gdouble gimp_brush_set_aspect_ratio(gchar *name , gdouble aspect_ratio_in ) ;
#line 75
gdouble gimp_brush_get_angle(gchar *name ) ;
#line 76
gdouble gimp_brush_set_angle(gchar *name , gdouble angle_in ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpbrushes_pdb.h"
gboolean gimp_brushes_refresh(void) ;
#line 36
gchar **gimp_brushes_get_list(gchar *filter , gint *num_brushes ) ;
#line 39
gchar *gimp_brushes_get_brush(gint *width , gint *height , gint *spacing ) ;
#line 43
gint gimp_brushes_get_spacing(void) ;
#line 45
gboolean gimp_brushes_set_spacing(gint spacing ) ;
#line 47
gchar *gimp_brushes_get_brush_data(gchar *name , gdouble *opacity , gint *spacing ,
                                   GimpLayerMode *paint_mode , gint *width , gint *height ,
                                   gint *length , guint8 **mask_data ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpbrushselect_pdb.h"
gboolean gimp_brushes_popup(gchar *brush_callback , gchar *popup_title , gchar *initial_brush ,
                            gdouble opacity , gint spacing , GimpLayerMode paint_mode ) ;
#line 41
gboolean gimp_brushes_close_popup(gchar *brush_callback ) ;
#line 42
gboolean gimp_brushes_set_popup(gchar *brush_callback , gchar *brush_name , gdouble opacity ,
                                gint spacing , GimpLayerMode paint_mode ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpbuffer_pdb.h"
gchar **gimp_buffers_get_list(gchar *filter , gint *num_buffers ) ;
#line 37
gchar *gimp_buffer_rename(gchar *buffer_name , gchar *new_name ) ;
#line 39
gboolean gimp_buffer_delete(gchar *buffer_name ) ;
#line 40
gint gimp_buffer_get_width(gchar *buffer_name ) ;
#line 41
gint gimp_buffer_get_height(gchar *buffer_name ) ;
#line 42
gint gimp_buffer_get_bytes(gchar *buffer_name ) ;
#line 43
GimpImageBaseType gimp_buffer_get_image_type(gchar *buffer_name ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpchannel_pdb.h"
gint32 _gimp_channel_new(gint32 image_ID , gint width , gint height , gchar *name ,
                         gdouble opacity , GimpRGB *color ) ;
#line 41
gint32 gimp_channel_new_from_component(gint32 image_ID , GimpChannelType component ,
                                       gchar *name ) ;
#line 44
gint32 gimp_channel_copy(gint32 channel_ID ) ;
#line 45
gboolean gimp_channel_combine_masks(gint32 channel1_ID , gint32 channel2_ID , GimpChannelOps operation ,
                                    gint offx , gint offy ) ;
#line 50
gboolean gimp_channel_get_show_masked(gint32 channel_ID ) ;
#line 51
gboolean gimp_channel_set_show_masked(gint32 channel_ID , gboolean show_masked ) ;
#line 53
gdouble gimp_channel_get_opacity(gint32 channel_ID ) ;
#line 54
gboolean gimp_channel_set_opacity(gint32 channel_ID , gdouble opacity ) ;
#line 56
gboolean gimp_channel_get_color(gint32 channel_ID , GimpRGB *color ) ;
#line 58
gboolean gimp_channel_set_color(gint32 channel_ID , GimpRGB *color ) ;
#line 36 "/usr/include/gimp-2.0/libgimp/gimpcolor_pdb.h"
gboolean gimp_brightness_contrast(gint32 drawable_ID , gint brightness , gint contrast ) ;
#line 40
gboolean gimp_levels(gint32 drawable_ID , GimpHistogramChannel channel , gint low_input ,
                     gint high_input , gdouble gamma , gint low_output , gint high_output ) ;
#line 48
gboolean gimp_levels_auto(gint32 drawable_ID ) ;
#line 50
gboolean gimp_levels_stretch(gint32 drawable_ID ) ;
#line 52
gboolean gimp_posterize(gint32 drawable_ID , gint levels ) ;
#line 55
gboolean gimp_desaturate(gint32 drawable_ID ) ;
#line 57
gboolean gimp_desaturate_full(gint32 drawable_ID , GimpDesaturateMode desaturate_mode ) ;
#line 60
gboolean gimp_equalize(gint32 drawable_ID , gboolean mask_only ) ;
#line 63
gboolean gimp_invert(gint32 drawable_ID ) ;
#line 65
gboolean gimp_curves_spline(gint32 drawable_ID , GimpHistogramChannel channel , gint num_points ,
                            guint8 *control_pts ) ;
#line 70
gboolean gimp_curves_explicit(gint32 drawable_ID , GimpHistogramChannel channel ,
                              gint num_bytes , guint8 *curve ) ;
#line 75
gboolean gimp_color_balance(gint32 drawable_ID , GimpTransferMode transfer_mode ,
                            gboolean preserve_lum , gdouble cyan_red , gdouble magenta_green ,
                            gdouble yellow_blue ) ;
#line 82
gboolean gimp_colorize(gint32 drawable_ID , gdouble hue , gdouble saturation , gdouble lightness ) ;
#line 87
gboolean gimp_histogram(gint32 drawable_ID , GimpHistogramChannel channel , gint start_range ,
                        gint end_range , gdouble *mean , gdouble *std_dev , gdouble *median ,
                        gdouble *pixels , gdouble *count , gdouble *percentile ) ;
#line 98
gboolean gimp_hue_saturation(gint32 drawable_ID , GimpHueRange hue_range , gdouble hue_offset ,
                             gdouble lightness , gdouble saturation ) ;
#line 104
gboolean gimp_threshold(gint32 drawable_ID , gint low_threshold , gint high_threshold ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpcontext_pdb.h"
gboolean gimp_context_push(void) ;
#line 36
gboolean gimp_context_pop(void) ;
#line 37
gboolean gimp_context_set_defaults(void) ;
#line 38
gboolean gimp_context_list_paint_methods(gint *num_paint_methods , gchar ***paint_methods ) ;
#line 40
gchar *gimp_context_get_paint_method(void) ;
#line 41
gboolean gimp_context_set_paint_method(gchar *name ) ;
#line 42
GimpStrokeMethod gimp_context_get_stroke_method(void) ;
#line 43
gboolean gimp_context_set_stroke_method(GimpStrokeMethod stroke_method ) ;
#line 44
gboolean gimp_context_get_foreground(GimpRGB *foreground ) ;
#line 45
gboolean gimp_context_set_foreground(GimpRGB *foreground ) ;
#line 46
gboolean gimp_context_get_background(GimpRGB *background ) ;
#line 47
gboolean gimp_context_set_background(GimpRGB *background ) ;
#line 48
gboolean gimp_context_set_default_colors(void) ;
#line 49
gboolean gimp_context_swap_colors(void) ;
#line 50
gdouble gimp_context_get_opacity(void) ;
#line 51
gboolean gimp_context_set_opacity(gdouble opacity ) ;
#line 52
GimpLayerMode gimp_context_get_paint_mode(void) ;
#line 53
gboolean gimp_context_set_paint_mode(GimpLayerMode paint_mode ) ;
#line 54
gdouble gimp_context_get_line_width(void) ;
#line 55
gboolean gimp_context_set_line_width(gdouble line_width ) ;
#line 56
GimpUnit gimp_context_get_line_width_unit(void) ;
#line 57
gboolean gimp_context_set_line_width_unit(GimpUnit line_width_unit ) ;
#line 58
GimpCapStyle gimp_context_get_line_cap_style(void) ;
#line 59
gboolean gimp_context_set_line_cap_style(GimpCapStyle cap_style ) ;
#line 60
GimpJoinStyle gimp_context_get_line_join_style(void) ;
#line 61
gboolean gimp_context_set_line_join_style(GimpJoinStyle join_style ) ;
#line 62
gdouble gimp_context_get_line_miter_limit(void) ;
#line 63
gboolean gimp_context_set_line_miter_limit(gdouble miter_limit ) ;
#line 64
gdouble gimp_context_get_line_dash_offset(void) ;
#line 65
gboolean gimp_context_set_line_dash_offset(gdouble dash_offset ) ;
#line 66
gboolean gimp_context_get_line_dash_pattern(gint *num_dashes , gdouble **dashes ) ;
#line 68
gboolean gimp_context_set_line_dash_pattern(gint num_dashes , gdouble *dashes ) ;
#line 70
gchar *gimp_context_get_brush(void) ;
#line 71
gboolean gimp_context_set_brush(gchar *name ) ;
#line 72
gdouble gimp_context_get_brush_size(void) ;
#line 73
gboolean gimp_context_set_brush_size(gdouble size ) ;
#line 74
gboolean gimp_context_set_brush_default_size(void) ;
#line 75
gdouble gimp_context_get_brush_aspect_ratio(void) ;
#line 76
gboolean gimp_context_set_brush_aspect_ratio(gdouble aspect ) ;
#line 77
gdouble gimp_context_get_brush_angle(void) ;
#line 78
gboolean gimp_context_set_brush_angle(gdouble angle ) ;
#line 79
gdouble gimp_context_get_brush_spacing(void) ;
#line 80
gboolean gimp_context_set_brush_spacing(gdouble spacing ) ;
#line 81
gboolean gimp_context_set_brush_default_spacing(void) ;
#line 82
gdouble gimp_context_get_brush_hardness(void) ;
#line 83
gboolean gimp_context_set_brush_hardness(gdouble hardness ) ;
#line 84
gboolean gimp_context_set_brush_default_hardness(void) ;
#line 85
gdouble gimp_context_get_brush_force(void) ;
#line 86
gboolean gimp_context_set_brush_force(gdouble force ) ;
#line 87
gchar *gimp_context_get_dynamics(void) ;
#line 88
gboolean gimp_context_set_dynamics(gchar *name ) ;
#line 89
gchar *gimp_context_get_mypaint_brush(void) ;
#line 90
gboolean gimp_context_set_mypaint_brush(gchar *name ) ;
#line 91
gchar *gimp_context_get_pattern(void) ;
#line 92
gboolean gimp_context_set_pattern(gchar *name ) ;
#line 93
gchar *gimp_context_get_gradient(void) ;
#line 94
gboolean gimp_context_set_gradient(gchar *name ) ;
#line 95
gboolean gimp_context_set_gradient_fg_bg_rgb(void) ;
#line 96
gboolean gimp_context_set_gradient_fg_bg_hsv_cw(void) ;
#line 97
gboolean gimp_context_set_gradient_fg_bg_hsv_ccw(void) ;
#line 98
gboolean gimp_context_set_gradient_fg_transparent(void) ;
#line 99
GimpGradientBlendColorSpace gimp_context_get_gradient_blend_color_space(void) ;
#line 100
gboolean gimp_context_set_gradient_blend_color_space(GimpGradientBlendColorSpace blend_color_space ) ;
#line 101
GimpRepeatMode gimp_context_get_gradient_repeat_mode(void) ;
#line 102
gboolean gimp_context_set_gradient_repeat_mode(GimpRepeatMode repeat_mode ) ;
#line 103
gboolean gimp_context_get_gradient_reverse(void) ;
#line 104
gboolean gimp_context_set_gradient_reverse(gboolean reverse ) ;
#line 105
gchar *gimp_context_get_palette(void) ;
#line 106
gboolean gimp_context_set_palette(gchar *name ) ;
#line 107
gchar *gimp_context_get_font(void) ;
#line 108
gboolean gimp_context_set_font(gchar *name ) ;
#line 109
gboolean gimp_context_get_antialias(void) ;
#line 110
gboolean gimp_context_set_antialias(gboolean antialias ) ;
#line 111
gboolean gimp_context_get_feather(void) ;
#line 112
gboolean gimp_context_set_feather(gboolean feather ) ;
#line 113
gboolean gimp_context_get_feather_radius(gdouble *feather_radius_x , gdouble *feather_radius_y ) ;
#line 115
gboolean gimp_context_set_feather_radius(gdouble feather_radius_x , gdouble feather_radius_y ) ;
#line 117
gboolean gimp_context_get_sample_merged(void) ;
#line 118
gboolean gimp_context_set_sample_merged(gboolean sample_merged ) ;
#line 119
GimpSelectCriterion gimp_context_get_sample_criterion(void) ;
#line 120
gboolean gimp_context_set_sample_criterion(GimpSelectCriterion sample_criterion ) ;
#line 121
gdouble gimp_context_get_sample_threshold(void) ;
#line 122
gboolean gimp_context_set_sample_threshold(gdouble sample_threshold ) ;
#line 123
gint gimp_context_get_sample_threshold_int(void) ;
#line 124
gboolean gimp_context_set_sample_threshold_int(gint sample_threshold ) ;
#line 125
gboolean gimp_context_get_sample_transparent(void) ;
#line 126
gboolean gimp_context_set_sample_transparent(gboolean sample_transparent ) ;
#line 127
gboolean gimp_context_get_diagonal_neighbors(void) ;
#line 128
gboolean gimp_context_set_diagonal_neighbors(gboolean diagonal_neighbors ) ;
#line 129
GeglDistanceMetric gimp_context_get_distance_metric(void) ;
#line 130
gboolean gimp_context_set_distance_metric(GeglDistanceMetric metric ) ;
#line 131
GimpInterpolationType gimp_context_get_interpolation(void) ;
#line 132
gboolean gimp_context_set_interpolation(GimpInterpolationType interpolation ) ;
#line 133
GimpTransformDirection gimp_context_get_transform_direction(void) ;
#line 134
gboolean gimp_context_set_transform_direction(GimpTransformDirection transform_direction ) ;
#line 135
GimpTransformResize gimp_context_get_transform_resize(void) ;
#line 136
gboolean gimp_context_set_transform_resize(GimpTransformResize transform_resize ) ;
#line 138
gint gimp_context_get_transform_recursion(void) ;
#line 140
gboolean gimp_context_set_transform_recursion(gint transform_recursion ) ;
#line 141
gdouble gimp_context_get_ink_size(void) ;
#line 142
gboolean gimp_context_set_ink_size(gdouble size ) ;
#line 143
gdouble gimp_context_get_ink_angle(void) ;
#line 144
gboolean gimp_context_set_ink_angle(gdouble angle ) ;
#line 145
gdouble gimp_context_get_ink_size_sensitivity(void) ;
#line 146
gboolean gimp_context_set_ink_size_sensitivity(gdouble size ) ;
#line 147
gdouble gimp_context_get_ink_tilt_sensitivity(void) ;
#line 148
gboolean gimp_context_set_ink_tilt_sensitivity(gdouble tilt ) ;
#line 149
gdouble gimp_context_get_ink_speed_sensitivity(void) ;
#line 150
gboolean gimp_context_set_ink_speed_sensitivity(gdouble speed ) ;
#line 151
GimpInkBlobType gimp_context_get_ink_blob_type(void) ;
#line 152
gboolean gimp_context_set_ink_blob_type(GimpInkBlobType type ) ;
#line 153
gdouble gimp_context_get_ink_blob_aspect_ratio(void) ;
#line 154
gboolean gimp_context_set_ink_blob_aspect_ratio(gdouble aspect ) ;
#line 155
gdouble gimp_context_get_ink_blob_angle(void) ;
#line 156
gboolean gimp_context_set_ink_blob_angle(gdouble angle ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpdebug_pdb.h"
gboolean gimp_debug_timer_start(void) ;
#line 36
gdouble gimp_debug_timer_end(void) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpdisplay_pdb.h"
gboolean gimp_display_is_valid(gint32 display_ID ) ;
#line 36
gint32 gimp_display_new(gint32 image_ID ) ;
#line 37
gboolean gimp_display_delete(gint32 display_ID ) ;
#line 38
gint gimp_display_get_window_handle(gint32 display_ID ) ;
#line 39
gboolean gimp_displays_flush(void) ;
#line 40
gboolean gimp_displays_reconnect(gint32 old_image_ID , gint32 new_image_ID ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpdrawable_pdb.h"
gchar *_gimp_drawable_get_format(gint32 drawable_ID ) ;
#line 36
gchar *_gimp_drawable_get_thumbnail_format(gint32 drawable_ID ) ;
#line 37
GimpImageType gimp_drawable_type(gint32 drawable_ID ) ;
#line 38
GimpImageType gimp_drawable_type_with_alpha(gint32 drawable_ID ) ;
#line 39
gboolean gimp_drawable_has_alpha(gint32 drawable_ID ) ;
#line 40
gboolean gimp_drawable_is_rgb(gint32 drawable_ID ) ;
#line 41
gboolean gimp_drawable_is_gray(gint32 drawable_ID ) ;
#line 42
gboolean gimp_drawable_is_indexed(gint32 drawable_ID ) ;
#line 43
gint gimp_drawable_bpp(gint32 drawable_ID ) ;
#line 44
gint gimp_drawable_width(gint32 drawable_ID ) ;
#line 45
gint gimp_drawable_height(gint32 drawable_ID ) ;
#line 46
gboolean gimp_drawable_offsets(gint32 drawable_ID , gint *offset_x , gint *offset_y ) ;
#line 50
gboolean gimp_drawable_set_image(gint32 drawable_ID , gint32 image_ID ) ;
#line 52
gboolean gimp_drawable_mask_bounds(gint32 drawable_ID , gint *x1 , gint *y1 , gint *x2 ,
                                   gint *y2 ) ;
#line 57
gboolean gimp_drawable_mask_intersect(gint32 drawable_ID , gint *x , gint *y , gint *width ,
                                      gint *height ) ;
#line 62
gboolean gimp_drawable_merge_shadow(gint32 drawable_ID , gboolean undo ) ;
#line 64
gboolean gimp_drawable_free_shadow(gint32 drawable_ID ) ;
#line 65
gboolean gimp_drawable_update(gint32 drawable_ID , gint x , gint y , gint width ,
                              gint height ) ;
#line 70
guint8 *gimp_drawable_get_pixel(gint32 drawable_ID , gint x_coord , gint y_coord ,
                                gint *num_channels ) ;
#line 74
gboolean gimp_drawable_set_pixel(gint32 drawable_ID , gint x_coord , gint y_coord ,
                                 gint num_channels , guint8 *pixel ) ;
#line 79
gboolean gimp_drawable_fill(gint32 drawable_ID , GimpFillType fill_type ) ;
#line 81
gboolean gimp_drawable_offset(gint32 drawable_ID , gboolean wrap_around , GimpOffsetType fill_type ,
                              gint offset_x , gint offset_y ) ;
#line 86
gboolean _gimp_drawable_thumbnail(gint32 drawable_ID , gint width , gint height ,
                                  gint *actual_width , gint *actual_height , gint *bpp ,
                                  gint *thumbnail_data_count , guint8 **thumbnail_data ) ;
#line 94
gboolean _gimp_drawable_sub_thumbnail(gint32 drawable_ID , gint src_x , gint src_y ,
                                      gint src_width , gint src_height , gint dest_width ,
                                      gint dest_height , gint *width , gint *height ,
                                      gint *bpp , gint *thumbnail_data_count , guint8 **thumbnail_data ) ;
#line 106
gboolean gimp_drawable_foreground_extract(gint32 drawable_ID , GimpForegroundExtractMode mode ,
                                          gint32 mask_ID ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpdrawablecolor_pdb.h"
gboolean gimp_drawable_brightness_contrast(gint32 drawable_ID , gdouble brightness ,
                                           gdouble contrast ) ;
#line 38
gboolean gimp_drawable_color_balance(gint32 drawable_ID , GimpTransferMode transfer_mode ,
                                     gboolean preserve_lum , gdouble cyan_red , gdouble magenta_green ,
                                     gdouble yellow_blue ) ;
#line 44
gboolean gimp_drawable_colorize_hsl(gint32 drawable_ID , gdouble hue , gdouble saturation ,
                                    gdouble lightness ) ;
#line 48
gboolean gimp_drawable_curves_explicit(gint32 drawable_ID , GimpHistogramChannel channel ,
                                       gint num_values , gdouble *values ) ;
#line 52
gboolean gimp_drawable_curves_spline(gint32 drawable_ID , GimpHistogramChannel channel ,
                                     gint num_points , gdouble *points ) ;
#line 56
gboolean gimp_drawable_desaturate(gint32 drawable_ID , GimpDesaturateMode desaturate_mode ) ;
#line 58
gboolean gimp_drawable_equalize(gint32 drawable_ID , gboolean mask_only ) ;
#line 60
gboolean gimp_drawable_histogram(gint32 drawable_ID , GimpHistogramChannel channel ,
                                 gdouble start_range , gdouble end_range , gdouble *mean ,
                                 gdouble *std_dev , gdouble *median , gdouble *pixels ,
                                 gdouble *count , gdouble *percentile ) ;
#line 70
gboolean gimp_drawable_hue_saturation(gint32 drawable_ID , GimpHueRange hue_range ,
                                      gdouble hue_offset , gdouble lightness , gdouble saturation ,
                                      gdouble overlap ) ;
#line 76
gboolean gimp_drawable_invert(gint32 drawable_ID , gboolean linear ) ;
#line 78
gboolean gimp_drawable_levels(gint32 drawable_ID , GimpHistogramChannel channel ,
                              gdouble low_input , gdouble high_input , gboolean clamp_input ,
                              gdouble gamma , gdouble low_output , gdouble high_output ,
                              gboolean clamp_output ) ;
#line 87
gboolean gimp_drawable_levels_stretch(gint32 drawable_ID ) ;
#line 88
gboolean gimp_drawable_posterize(gint32 drawable_ID , gint levels ) ;
#line 90
gboolean gimp_drawable_threshold(gint32 drawable_ID , GimpHistogramChannel channel ,
                                 gdouble low_threshold , gdouble high_threshold ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpdrawableedit_pdb.h"
gboolean gimp_drawable_edit_clear(gint32 drawable_ID ) ;
#line 36
gboolean gimp_drawable_edit_fill(gint32 drawable_ID , GimpFillType fill_type ) ;
#line 38
gboolean gimp_drawable_edit_bucket_fill(gint32 drawable_ID , GimpFillType fill_type ,
                                        gdouble x , gdouble y ) ;
#line 42
gboolean gimp_drawable_edit_gradient_fill(gint32 drawable_ID , GimpGradientType gradient_type ,
                                          gdouble offset , gboolean supersample ,
                                          gint supersample_max_depth , gdouble supersample_threshold ,
                                          gboolean dither , gdouble x1 , gdouble y1 ,
                                          gdouble x2 , gdouble y2 ) ;
#line 53
gboolean gimp_drawable_edit_stroke_selection(gint32 drawable_ID ) ;
#line 54
gboolean gimp_drawable_edit_stroke_item(gint32 drawable_ID , gint32 item_ID ) ;
#line 36 "/usr/include/gimp-2.0/libgimp/gimpdrawabletransform_pdb.h"
gint32 gimp_drawable_transform_flip_simple(gint32 drawable_ID , GimpOrientationType flip_type ,
                                           gboolean auto_center , gdouble axis , gboolean clip_result ) ;
#line 42
gint32 gimp_drawable_transform_flip(gint32 drawable_ID , gdouble x0 , gdouble y0 ,
                                    gdouble x1 , gdouble y1 , GimpTransformDirection transform_direction ,
                                    GimpInterpolationType interpolation , gboolean supersample ,
                                    gint recursion_level , gboolean clip_result ) ;
#line 53
gint32 gimp_drawable_transform_flip_default(gint32 drawable_ID , gdouble x0 , gdouble y0 ,
                                            gdouble x1 , gdouble y1 , gboolean interpolate ,
                                            gboolean clip_result ) ;
#line 61
gint32 gimp_drawable_transform_perspective(gint32 drawable_ID , gdouble x0 , gdouble y0 ,
                                           gdouble x1 , gdouble y1 , gdouble x2 ,
                                           gdouble y2 , gdouble x3 , gdouble y3 ,
                                           GimpTransformDirection transform_direction ,
                                           GimpInterpolationType interpolation , gboolean supersample ,
                                           gint recursion_level , GimpTransformResize clip_result ) ;
#line 76
gint32 gimp_drawable_transform_perspective_default(gint32 drawable_ID , gdouble x0 ,
                                                   gdouble y0 , gdouble x1 , gdouble y1 ,
                                                   gdouble x2 , gdouble y2 , gdouble x3 ,
                                                   gdouble y3 , gboolean interpolate ,
                                                   GimpTransformResize clip_result ) ;
#line 88
gint32 gimp_drawable_transform_rotate_simple(gint32 drawable_ID , GimpRotationType rotate_type ,
                                             gboolean auto_center , gint center_x ,
                                             gint center_y , gboolean clip_result ) ;
#line 95
gint32 gimp_drawable_transform_rotate(gint32 drawable_ID , gdouble angle , gboolean auto_center ,
                                      gint center_x , gint center_y , GimpTransformDirection transform_direction ,
                                      GimpInterpolationType interpolation , gboolean supersample ,
                                      gint recursion_level , GimpTransformResize clip_result ) ;
#line 106
gint32 gimp_drawable_transform_rotate_default(gint32 drawable_ID , gdouble angle ,
                                              gboolean auto_center , gint center_x ,
                                              gint center_y , gboolean interpolate ,
                                              GimpTransformResize clip_result ) ;
#line 114
gint32 gimp_drawable_transform_scale(gint32 drawable_ID , gdouble x0 , gdouble y0 ,
                                     gdouble x1 , gdouble y1 , GimpTransformDirection transform_direction ,
                                     GimpInterpolationType interpolation , gboolean supersample ,
                                     gint recursion_level , GimpTransformResize clip_result ) ;
#line 125
gint32 gimp_drawable_transform_scale_default(gint32 drawable_ID , gdouble x0 , gdouble y0 ,
                                             gdouble x1 , gdouble y1 , gboolean interpolate ,
                                             GimpTransformResize clip_result ) ;
#line 133
gint32 gimp_drawable_transform_shear(gint32 drawable_ID , GimpOrientationType shear_type ,
                                     gdouble magnitude , GimpTransformDirection transform_direction ,
                                     GimpInterpolationType interpolation , gboolean supersample ,
                                     gint recursion_level , GimpTransformResize clip_result ) ;
#line 142
gint32 gimp_drawable_transform_shear_default(gint32 drawable_ID , GimpOrientationType shear_type ,
                                             gdouble magnitude , gboolean interpolate ,
                                             GimpTransformResize clip_result ) ;
#line 148
gint32 gimp_drawable_transform_2d(gint32 drawable_ID , gdouble source_x , gdouble source_y ,
                                  gdouble scale_x , gdouble scale_y , gdouble angle ,
                                  gdouble dest_x , gdouble dest_y , GimpTransformDirection transform_direction ,
                                  GimpInterpolationType interpolation , gboolean supersample ,
                                  gint recursion_level , GimpTransformResize clip_result ) ;
#line 162
gint32 gimp_drawable_transform_2d_default(gint32 drawable_ID , gdouble source_x ,
                                          gdouble source_y , gdouble scale_x , gdouble scale_y ,
                                          gdouble angle , gdouble dest_x , gdouble dest_y ,
                                          gboolean interpolate , GimpTransformResize clip_result ) ;
#line 173
gint32 gimp_drawable_transform_matrix(gint32 drawable_ID , gdouble coeff_0_0 , gdouble coeff_0_1 ,
                                      gdouble coeff_0_2 , gdouble coeff_1_0 , gdouble coeff_1_1 ,
                                      gdouble coeff_1_2 , gdouble coeff_2_0 , gdouble coeff_2_1 ,
                                      gdouble coeff_2_2 , GimpTransformDirection transform_direction ,
                                      GimpInterpolationType interpolation , gboolean supersample ,
                                      gint recursion_level , GimpTransformResize clip_result ) ;
#line 189
gint32 gimp_drawable_transform_matrix_default(gint32 drawable_ID , gdouble coeff_0_0 ,
                                              gdouble coeff_0_1 , gdouble coeff_0_2 ,
                                              gdouble coeff_1_0 , gdouble coeff_1_1 ,
                                              gdouble coeff_1_2 , gdouble coeff_2_0 ,
                                              gdouble coeff_2_1 , gdouble coeff_2_2 ,
                                              gboolean interpolate , GimpTransformResize clip_result ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpdynamics_pdb.h"
gboolean gimp_dynamics_refresh(void) ;
#line 36
gchar **gimp_dynamics_get_list(gchar *filter , gint *num_dynamics ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpedit_pdb.h"
gboolean gimp_edit_cut(gint32 drawable_ID ) ;
#line 36
gboolean gimp_edit_copy(gint32 drawable_ID ) ;
#line 37
gboolean gimp_edit_copy_visible(gint32 image_ID ) ;
#line 38
gint32 gimp_edit_paste(gint32 drawable_ID , gboolean paste_into ) ;
#line 40
gint32 gimp_edit_paste_as_new_image(void) ;
#line 41
gchar *gimp_edit_named_cut(gint32 drawable_ID , gchar *buffer_name ) ;
#line 43
gchar *gimp_edit_named_copy(gint32 drawable_ID , gchar *buffer_name ) ;
#line 45
gchar *gimp_edit_named_copy_visible(gint32 image_ID , gchar *buffer_name ) ;
#line 47
gint32 gimp_edit_named_paste(gint32 drawable_ID , gchar *buffer_name , gboolean paste_into ) ;
#line 50
gint32 gimp_edit_named_paste_as_new_image(gchar *buffer_name ) ;
#line 52
gboolean gimp_edit_clear(gint32 drawable_ID ) ;
#line 54
gboolean gimp_edit_fill(gint32 drawable_ID , GimpFillType fill_type ) ;
#line 57
gboolean gimp_edit_bucket_fill(gint32 drawable_ID , GimpBucketFillMode fill_mode ,
                               GimpLayerMode paint_mode , gdouble opacity , gdouble threshold ,
                               gboolean sample_merged , gdouble x , gdouble y ) ;
#line 66
gboolean gimp_edit_bucket_fill_full(gint32 drawable_ID , GimpBucketFillMode fill_mode ,
                                    GimpLayerMode paint_mode , gdouble opacity , gdouble threshold ,
                                    gboolean sample_merged , gboolean fill_transparent ,
                                    GimpSelectCriterion select_criterion , gdouble x ,
                                    gdouble y ) ;
#line 77
gboolean gimp_edit_blend(gint32 drawable_ID , GimpBlendMode blend_mode , GimpLayerMode paint_mode ,
                         GimpGradientType gradient_type , gdouble opacity , gdouble offset ,
                         GimpRepeatMode repeat , gboolean reverse , gboolean supersample ,
                         gint max_depth , gdouble threshold , gboolean dither , gdouble x1 ,
                         gdouble y1 , gdouble x2 , gdouble y2 ) ;
#line 94
gboolean gimp_edit_stroke(gint32 drawable_ID ) ;
#line 96
gboolean gimp_edit_stroke_vectors(gint32 drawable_ID , gint32 vectors_ID ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpfileops_pdb.h"
gint32 gimp_file_load(GimpRunMode run_mode , gchar *filename , gchar *raw_filename ) ;
#line 38
gint32 gimp_file_load_layer(GimpRunMode run_mode , gint32 image_ID , gchar *filename ) ;
#line 41
gint *gimp_file_load_layers(GimpRunMode run_mode , gint32 image_ID , gchar *filename ,
                            gint *num_layers ) ;
#line 45
gboolean gimp_file_save(GimpRunMode run_mode , gint32 image_ID , gint32 drawable_ID ,
                        gchar *filename , gchar *raw_filename ) ;
#line 50
gboolean gimp_file_save_thumbnail(gint32 image_ID , gchar *filename ) ;
#line 52
gboolean gimp_register_magic_load_handler(gchar *procedure_name , gchar *extensions ,
                                          gchar *prefixes , gchar *magics ) ;
#line 56
gboolean gimp_register_load_handler(gchar *procedure_name , gchar *extensions , gchar *prefixes ) ;
#line 59
gboolean gimp_register_save_handler(gchar *procedure_name , gchar *extensions , gchar *prefixes ) ;
#line 62
gboolean gimp_register_file_handler_priority(gchar *procedure_name , gint priority ) ;
#line 64
gboolean gimp_register_file_handler_mime(gchar *procedure_name , gchar *mime_types ) ;
#line 66
gboolean gimp_register_file_handler_uri(gchar *procedure_name ) ;
#line 67
gboolean gimp_register_file_handler_raw(gchar *procedure_name ) ;
#line 68
gboolean gimp_register_thumbnail_loader(gchar *load_proc , gchar *thumb_proc ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpfloatingsel_pdb.h"
gboolean gimp_floating_sel_remove(gint32 floating_sel_ID ) ;
#line 36
gboolean gimp_floating_sel_anchor(gint32 floating_sel_ID ) ;
#line 37
gboolean gimp_floating_sel_to_layer(gint32 floating_sel_ID ) ;
#line 38
gboolean gimp_floating_sel_attach(gint32 layer_ID , gint32 drawable_ID ) ;
#line 41
gboolean gimp_floating_sel_rigor(gint32 floating_sel_ID , gboolean undo ) ;
#line 44
gboolean gimp_floating_sel_relax(gint32 floating_sel_ID , gboolean undo ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpfonts_pdb.h"
gboolean gimp_fonts_refresh(void) ;
#line 36
gchar **gimp_fonts_get_list(gchar *filter , gint *num_fonts ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpfontselect_pdb.h"
gboolean gimp_fonts_popup(gchar *font_callback , gchar *popup_title , gchar *initial_font ) ;
#line 38
gboolean gimp_fonts_close_popup(gchar *font_callback ) ;
#line 39
gboolean gimp_fonts_set_popup(gchar *font_callback , gchar *font_name ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpgimprc_pdb.h"
gchar *gimp_gimprc_query(gchar *token ) ;
#line 36
gboolean gimp_gimprc_set(gchar *token , gchar *value ) ;
#line 38
gchar *gimp_get_default_comment(void) ;
#line 39
GimpUnit gimp_get_default_unit(void) ;
#line 40
gboolean gimp_get_monitor_resolution(gdouble *xres , gdouble *yres ) ;
#line 43
gchar *gimp_get_theme_dir(void) ;
#line 45
gchar *gimp_get_icon_theme_dir(void) ;
#line 46
gchar *_gimp_get_color_configuration(void) ;
#line 47
gchar *gimp_get_module_load_inhibit(void) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpgradient_pdb.h"
gchar *gimp_gradient_new(gchar *name ) ;
#line 36
gchar *gimp_gradient_duplicate(gchar *name ) ;
#line 37
gboolean gimp_gradient_is_editable(gchar *name ) ;
#line 38
gchar *gimp_gradient_rename(gchar *name , gchar *new_name ) ;
#line 40
gboolean gimp_gradient_delete(gchar *name ) ;
#line 41
gint gimp_gradient_get_number_of_segments(gchar *name ) ;
#line 42
gboolean gimp_gradient_get_uniform_samples(gchar *name , gint num_samples , gboolean reverse ,
                                           gint *num_color_samples , gdouble **color_samples ) ;
#line 47
gboolean gimp_gradient_get_custom_samples(gchar *name , gint num_samples , gdouble *positions ,
                                          gboolean reverse , gint *num_color_samples ,
                                          gdouble **color_samples ) ;
#line 53
gboolean gimp_gradient_segment_get_left_color(gchar *name , gint segment , GimpRGB *color ,
                                              gdouble *opacity ) ;
#line 57
gboolean gimp_gradient_segment_set_left_color(gchar *name , gint segment , GimpRGB *color ,
                                              gdouble opacity ) ;
#line 61
gboolean gimp_gradient_segment_get_right_color(gchar *name , gint segment , GimpRGB *color ,
                                               gdouble *opacity ) ;
#line 65
gboolean gimp_gradient_segment_set_right_color(gchar *name , gint segment , GimpRGB *color ,
                                               gdouble opacity ) ;
#line 69
gboolean gimp_gradient_segment_get_left_pos(gchar *name , gint segment , gdouble *pos ) ;
#line 72
gboolean gimp_gradient_segment_set_left_pos(gchar *name , gint segment , gdouble pos ,
                                            gdouble *final_pos ) ;
#line 76
gboolean gimp_gradient_segment_get_middle_pos(gchar *name , gint segment , gdouble *pos ) ;
#line 79
gboolean gimp_gradient_segment_set_middle_pos(gchar *name , gint segment , gdouble pos ,
                                              gdouble *final_pos ) ;
#line 83
gboolean gimp_gradient_segment_get_right_pos(gchar *name , gint segment , gdouble *pos ) ;
#line 86
gboolean gimp_gradient_segment_set_right_pos(gchar *name , gint segment , gdouble pos ,
                                             gdouble *final_pos ) ;
#line 90
gboolean gimp_gradient_segment_get_blending_function(gchar *name , gint segment ,
                                                     GimpGradientSegmentType *blend_func ) ;
#line 93
gboolean gimp_gradient_segment_get_coloring_type(gchar *name , gint segment , GimpGradientSegmentColor *coloring_type ) ;
#line 96
gboolean gimp_gradient_segment_range_set_blending_function(gchar *name , gint start_segment ,
                                                           gint end_segment , GimpGradientSegmentType blending_function ) ;
#line 100
gboolean gimp_gradient_segment_range_set_coloring_type(gchar *name , gint start_segment ,
                                                       gint end_segment , GimpGradientSegmentColor coloring_type ) ;
#line 104
gboolean gimp_gradient_segment_range_flip(gchar *name , gint start_segment , gint end_segment ) ;
#line 107
gboolean gimp_gradient_segment_range_replicate(gchar *name , gint start_segment ,
                                               gint end_segment , gint replicate_times ) ;
#line 111
gboolean gimp_gradient_segment_range_split_midpoint(gchar *name , gint start_segment ,
                                                    gint end_segment ) ;
#line 114
gboolean gimp_gradient_segment_range_split_uniform(gchar *name , gint start_segment ,
                                                   gint end_segment , gint split_parts ) ;
#line 118
gboolean gimp_gradient_segment_range_delete(gchar *name , gint start_segment , gint end_segment ) ;
#line 121
gboolean gimp_gradient_segment_range_redistribute_handles(gchar *name , gint start_segment ,
                                                          gint end_segment ) ;
#line 124
gboolean gimp_gradient_segment_range_blend_colors(gchar *name , gint start_segment ,
                                                  gint end_segment ) ;
#line 127
gboolean gimp_gradient_segment_range_blend_opacity(gchar *name , gint start_segment ,
                                                   gint end_segment ) ;
#line 130
gdouble gimp_gradient_segment_range_move(gchar *name , gint start_segment , gint end_segment ,
                                         gdouble delta , gboolean control_compress ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpgradients_pdb.h"
gboolean gimp_gradients_refresh(void) ;
#line 36
gchar **gimp_gradients_get_list(gchar *filter , gint *num_gradients ) ;
#line 39
gdouble *gimp_gradients_sample_uniform(gint num_samples , gboolean reverse ) ;
#line 42
gdouble *gimp_gradients_sample_custom(gint num_samples , gdouble *positions , gboolean reverse ) ;
#line 46
gchar *gimp_gradients_get_gradient_data(gchar *name , gint sample_size , gboolean reverse ,
                                        gint *width , gdouble **grad_data ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpgradientselect_pdb.h"
gboolean gimp_gradients_popup(gchar *gradient_callback , gchar *popup_title , gchar *initial_gradient ,
                              gint sample_size ) ;
#line 39
gboolean gimp_gradients_close_popup(gchar *gradient_callback ) ;
#line 40
gboolean gimp_gradients_set_popup(gchar *gradient_callback , gchar *gradient_name ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimphelp_pdb.h"
gboolean gimp_help(gchar *help_domain , gchar *help_id ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpimage_pdb.h"
gboolean gimp_image_is_valid(gint32 image_ID ) ;
#line 36
gint *gimp_image_list(gint *num_images ) ;
#line 37
gint32 gimp_image_new(gint width , gint height , GimpImageBaseType type ) ;
#line 40
gint32 gimp_image_new_with_precision(gint width , gint height , GimpImageBaseType type ,
                                     GimpPrecision precision ) ;
#line 44
gint32 gimp_image_duplicate(gint32 image_ID ) ;
#line 45
gboolean gimp_image_delete(gint32 image_ID ) ;
#line 46
GimpImageBaseType gimp_image_base_type(gint32 image_ID ) ;
#line 47
GimpPrecision gimp_image_get_precision(gint32 image_ID ) ;
#line 48
GimpLayerMode gimp_image_get_default_new_layer_mode(gint32 image_ID ) ;
#line 49
gint gimp_image_width(gint32 image_ID ) ;
#line 50
gint gimp_image_height(gint32 image_ID ) ;
#line 52
gboolean gimp_image_free_shadow(gint32 image_ID ) ;
#line 53
gint *gimp_image_get_layers(gint32 image_ID , gint *num_layers ) ;
#line 55
gint *gimp_image_get_channels(gint32 image_ID , gint *num_channels ) ;
#line 57
gint *gimp_image_get_vectors(gint32 image_ID , gint *num_vectors ) ;
#line 59
gint32 gimp_image_get_active_drawable(gint32 image_ID ) ;
#line 60
gboolean gimp_image_unset_active_channel(gint32 image_ID ) ;
#line 61
gint32 gimp_image_get_floating_sel(gint32 image_ID ) ;
#line 62
gint32 gimp_image_floating_sel_attached_to(gint32 image_ID ) ;
#line 63
gboolean gimp_image_pick_color(gint32 image_ID , gint32 drawable_ID , gdouble x ,
                               gdouble y , gboolean sample_merged , gboolean sample_average ,
                               gdouble average_radius , GimpRGB *color ) ;
#line 71
gint32 gimp_image_pick_correlate_layer(gint32 image_ID , gint x , gint y ) ;
#line 75
gboolean gimp_image_add_layer(gint32 image_ID , gint32 layer_ID , gint position ) ;
#line 78
gboolean gimp_image_insert_layer(gint32 image_ID , gint32 layer_ID , gint32 parent_ID ,
                                 gint position ) ;
#line 82
gboolean gimp_image_remove_layer(gint32 image_ID , gint32 layer_ID ) ;
#line 84
gboolean gimp_image_freeze_layers(gint32 image_ID ) ;
#line 85
gboolean gimp_image_thaw_layers(gint32 image_ID ) ;
#line 87
gboolean gimp_image_add_channel(gint32 image_ID , gint32 channel_ID , gint position ) ;
#line 90
gboolean gimp_image_insert_channel(gint32 image_ID , gint32 channel_ID , gint32 parent_ID ,
                                   gint position ) ;
#line 94
gboolean gimp_image_remove_channel(gint32 image_ID , gint32 channel_ID ) ;
#line 96
gboolean gimp_image_freeze_channels(gint32 image_ID ) ;
#line 97
gboolean gimp_image_thaw_channels(gint32 image_ID ) ;
#line 99
gboolean gimp_image_add_vectors(gint32 image_ID , gint32 vectors_ID , gint position ) ;
#line 102
gboolean gimp_image_insert_vectors(gint32 image_ID , gint32 vectors_ID , gint32 parent_ID ,
                                   gint position ) ;
#line 106
gboolean gimp_image_remove_vectors(gint32 image_ID , gint32 vectors_ID ) ;
#line 108
gboolean gimp_image_freeze_vectors(gint32 image_ID ) ;
#line 109
gboolean gimp_image_thaw_vectors(gint32 image_ID ) ;
#line 110
gint gimp_image_get_item_position(gint32 image_ID , gint32 item_ID ) ;
#line 112
gboolean gimp_image_raise_item(gint32 image_ID , gint32 item_ID ) ;
#line 114
gboolean gimp_image_lower_item(gint32 image_ID , gint32 item_ID ) ;
#line 116
gboolean gimp_image_raise_item_to_top(gint32 image_ID , gint32 item_ID ) ;
#line 118
gboolean gimp_image_lower_item_to_bottom(gint32 image_ID , gint32 item_ID ) ;
#line 120
gboolean gimp_image_reorder_item(gint32 image_ID , gint32 item_ID , gint32 parent_ID ,
                                 gint position ) ;
#line 124
gint32 gimp_image_flatten(gint32 image_ID ) ;
#line 125
gint32 gimp_image_merge_visible_layers(gint32 image_ID , GimpMergeType merge_type ) ;
#line 127
gint32 gimp_image_merge_down(gint32 image_ID , gint32 merge_layer_ID , GimpMergeType merge_type ) ;
#line 130
gint32 gimp_image_merge_layer_group(gint32 image_ID , gint32 layer_group_ID ) ;
#line 132
guint8 *_gimp_image_get_colormap(gint32 image_ID , gint *num_bytes ) ;
#line 134
gboolean _gimp_image_set_colormap(gint32 image_ID , gint num_bytes , guint8 *colormap ) ;
#line 137
gchar *_gimp_image_get_metadata(gint32 image_ID ) ;
#line 138
gboolean _gimp_image_set_metadata(gint32 image_ID , gchar *metadata_string ) ;
#line 140
gboolean gimp_image_clean_all(gint32 image_ID ) ;
#line 141
gboolean gimp_image_is_dirty(gint32 image_ID ) ;
#line 142
gboolean _gimp_image_thumbnail(gint32 image_ID , gint width , gint height , gint *actual_width ,
                               gint *actual_height , gint *bpp , gint *thumbnail_data_count ,
                               guint8 **thumbnail_data ) ;
#line 150
gint32 gimp_image_get_active_layer(gint32 image_ID ) ;
#line 151
gboolean gimp_image_set_active_layer(gint32 image_ID , gint32 active_layer_ID ) ;
#line 153
gint32 gimp_image_get_active_channel(gint32 image_ID ) ;
#line 154
gboolean gimp_image_set_active_channel(gint32 image_ID , gint32 active_channel_ID ) ;
#line 156
gint32 gimp_image_get_active_vectors(gint32 image_ID ) ;
#line 157
gboolean gimp_image_set_active_vectors(gint32 image_ID , gint32 active_vectors_ID ) ;
#line 159
gint32 gimp_image_get_selection(gint32 image_ID ) ;
#line 160
gboolean gimp_image_get_component_active(gint32 image_ID , GimpChannelType component ) ;
#line 162
gboolean gimp_image_set_component_active(gint32 image_ID , GimpChannelType component ,
                                         gboolean active ) ;
#line 165
gboolean gimp_image_get_component_visible(gint32 image_ID , GimpChannelType component ) ;
#line 167
gboolean gimp_image_set_component_visible(gint32 image_ID , GimpChannelType component ,
                                          gboolean visible ) ;
#line 170
gchar *gimp_image_get_filename(gint32 image_ID ) ;
#line 171
gboolean gimp_image_set_filename(gint32 image_ID , gchar *filename ) ;
#line 173
gchar *gimp_image_get_uri(gint32 image_ID ) ;
#line 174
gchar *gimp_image_get_xcf_uri(gint32 image_ID ) ;
#line 175
gchar *gimp_image_get_imported_uri(gint32 image_ID ) ;
#line 176
gchar *gimp_image_get_exported_uri(gint32 image_ID ) ;
#line 177
gchar *gimp_image_get_name(gint32 image_ID ) ;
#line 178
gboolean gimp_image_get_resolution(gint32 image_ID , gdouble *xresolution , gdouble *yresolution ) ;
#line 181
gboolean gimp_image_set_resolution(gint32 image_ID , gdouble xresolution , gdouble yresolution ) ;
#line 184
GimpUnit gimp_image_get_unit(gint32 image_ID ) ;
#line 185
gboolean gimp_image_set_unit(gint32 image_ID , GimpUnit unit ) ;
#line 187
gint gimp_image_get_tattoo_state(gint32 image_ID ) ;
#line 188
gboolean gimp_image_set_tattoo_state(gint32 image_ID , gint tattoo_state ) ;
#line 190
gint32 gimp_image_get_layer_by_tattoo(gint32 image_ID , gint tattoo ) ;
#line 192
gint32 gimp_image_get_channel_by_tattoo(gint32 image_ID , gint tattoo ) ;
#line 194
gint32 gimp_image_get_vectors_by_tattoo(gint32 image_ID , gint tattoo ) ;
#line 196
gint32 gimp_image_get_layer_by_name(gint32 image_ID , gchar *name ) ;
#line 198
gint32 gimp_image_get_channel_by_name(gint32 image_ID , gchar *name ) ;
#line 200
gint32 gimp_image_get_vectors_by_name(gint32 image_ID , gchar *name ) ;
#line 202
gboolean gimp_image_attach_parasite(gint32 image_ID , GimpParasite *parasite ) ;
#line 204
gboolean gimp_image_detach_parasite(gint32 image_ID , gchar *name ) ;
#line 206
GimpParasite *gimp_image_get_parasite(gint32 image_ID , gchar *name ) ;
#line 208
gchar **gimp_image_get_parasite_list(gint32 image_ID , gint *num_parasites ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpimagecolorprofile_pdb.h"
guint8 *_gimp_image_get_color_profile(gint32 image_ID , gint *num_bytes ) ;
#line 37
guint8 *_gimp_image_get_effective_color_profile(gint32 image_ID , gint *num_bytes ) ;
#line 39
gboolean _gimp_image_set_color_profile(gint32 image_ID , gint num_bytes , guint8 *color_profile ) ;
#line 42
gboolean gimp_image_set_color_profile_from_file(gint32 image_ID , gchar *uri ) ;
#line 44
gboolean _gimp_image_convert_color_profile(gint32 image_ID , gint num_bytes , guint8 *color_profile ,
                                           GimpColorRenderingIntent intent , gboolean bpc ) ;
#line 49
gboolean gimp_image_convert_color_profile_from_file(gint32 image_ID , gchar *uri ,
                                                    GimpColorRenderingIntent intent ,
                                                    gboolean bpc ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpimageconvert_pdb.h"
gboolean gimp_image_convert_rgb(gint32 image_ID ) ;
#line 36
gboolean gimp_image_convert_grayscale(gint32 image_ID ) ;
#line 37
gboolean gimp_image_convert_indexed(gint32 image_ID , GimpConvertDitherType dither_type ,
                                    GimpConvertPaletteType palette_type , gint num_cols ,
                                    gboolean alpha_dither , gboolean remove_unused ,
                                    gchar *palette ) ;
#line 44
gboolean gimp_image_convert_set_dither_matrix(gint width , gint height , gint matrix_length ,
                                              guint8 *matrix ) ;
#line 48
gboolean gimp_image_convert_precision(gint32 image_ID , GimpPrecision precision ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpimagegrid_pdb.h"
gboolean gimp_image_grid_get_spacing(gint32 image_ID , gdouble *xspacing , gdouble *yspacing ) ;
#line 38
gboolean gimp_image_grid_set_spacing(gint32 image_ID , gdouble xspacing , gdouble yspacing ) ;
#line 41
gboolean gimp_image_grid_get_offset(gint32 image_ID , gdouble *xoffset , gdouble *yoffset ) ;
#line 44
gboolean gimp_image_grid_set_offset(gint32 image_ID , gdouble xoffset , gdouble yoffset ) ;
#line 47
gboolean gimp_image_grid_get_foreground_color(gint32 image_ID , GimpRGB *fgcolor ) ;
#line 49
gboolean gimp_image_grid_set_foreground_color(gint32 image_ID , GimpRGB *fgcolor ) ;
#line 51
gboolean gimp_image_grid_get_background_color(gint32 image_ID , GimpRGB *bgcolor ) ;
#line 53
gboolean gimp_image_grid_set_background_color(gint32 image_ID , GimpRGB *bgcolor ) ;
#line 55
GimpGridStyle gimp_image_grid_get_style(gint32 image_ID ) ;
#line 56
gboolean gimp_image_grid_set_style(gint32 image_ID , GimpGridStyle style ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpimageguides_pdb.h"
gint32 gimp_image_add_hguide(gint32 image_ID , gint yposition ) ;
#line 37
gint32 gimp_image_add_vguide(gint32 image_ID , gint xposition ) ;
#line 39
gboolean gimp_image_delete_guide(gint32 image_ID , gint32 guide_ID ) ;
#line 41
gint32 gimp_image_find_next_guide(gint32 image_ID , gint32 guide_ID ) ;
#line 43
GimpOrientationType gimp_image_get_guide_orientation(gint32 image_ID , gint32 guide_ID ) ;
#line 45
gint gimp_image_get_guide_position(gint32 image_ID , gint32 guide_ID ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpimagesamplepoints_pdb.h"
gint32 gimp_image_add_sample_point(gint32 image_ID , gint position_x , gint position_y ) ;
#line 38
gboolean gimp_image_delete_sample_point(gint32 image_ID , gint32 sample_point_ID ) ;
#line 40
gint32 gimp_image_find_next_sample_point(gint32 image_ID , gint32 sample_point_ID ) ;
#line 42
gint gimp_image_get_sample_point_position(gint32 image_ID , gint32 sample_point_ID ,
                                          gint *position_y ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpimageselect_pdb.h"
gboolean gimp_image_select_color(gint32 image_ID , GimpChannelOps operation , gint32 drawable_ID ,
                                 GimpRGB *color ) ;
#line 39
gboolean gimp_image_select_contiguous_color(gint32 image_ID , GimpChannelOps operation ,
                                            gint32 drawable_ID , gdouble x , gdouble y ) ;
#line 44
gboolean gimp_image_select_rectangle(gint32 image_ID , GimpChannelOps operation ,
                                     gdouble x , gdouble y , gdouble width , gdouble height ) ;
#line 50
gboolean gimp_image_select_round_rectangle(gint32 image_ID , GimpChannelOps operation ,
                                           gdouble x , gdouble y , gdouble width ,
                                           gdouble height , gdouble corner_radius_x ,
                                           gdouble corner_radius_y ) ;
#line 58
gboolean gimp_image_select_ellipse(gint32 image_ID , GimpChannelOps operation , gdouble x ,
                                   gdouble y , gdouble width , gdouble height ) ;
#line 64
gboolean gimp_image_select_polygon(gint32 image_ID , GimpChannelOps operation , gint num_segs ,
                                   gdouble *segs ) ;
#line 68
gboolean gimp_image_select_item(gint32 image_ID , GimpChannelOps operation , gint32 item_ID ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpimagetransform_pdb.h"
gboolean gimp_image_resize(gint32 image_ID , gint new_width , gint new_height , gint offx ,
                           gint offy ) ;
#line 40
gboolean gimp_image_resize_to_layers(gint32 image_ID ) ;
#line 41
gboolean gimp_image_scale(gint32 image_ID , gint new_width , gint new_height ) ;
#line 45
gboolean gimp_image_scale_full(gint32 image_ID , gint new_width , gint new_height ,
                               GimpInterpolationType interpolation ) ;
#line 49
gboolean gimp_image_crop(gint32 image_ID , gint new_width , gint new_height , gint offx ,
                         gint offy ) ;
#line 54
gboolean gimp_image_flip(gint32 image_ID , GimpOrientationType flip_type ) ;
#line 56
gboolean gimp_image_rotate(gint32 image_ID , GimpRotationType rotate_type ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpimageundo_pdb.h"
gboolean gimp_image_undo_group_start(gint32 image_ID ) ;
#line 36
gboolean gimp_image_undo_group_end(gint32 image_ID ) ;
#line 37
gboolean gimp_image_undo_is_enabled(gint32 image_ID ) ;
#line 38
gboolean gimp_image_undo_disable(gint32 image_ID ) ;
#line 39
gboolean gimp_image_undo_enable(gint32 image_ID ) ;
#line 40
gboolean gimp_image_undo_freeze(gint32 image_ID ) ;
#line 41
gboolean gimp_image_undo_thaw(gint32 image_ID ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpitem_pdb.h"
gboolean gimp_item_is_valid(gint32 item_ID ) ;
#line 36
gint32 gimp_item_get_image(gint32 item_ID ) ;
#line 37
gboolean gimp_item_delete(gint32 item_ID ) ;
#line 38
gboolean gimp_item_is_drawable(gint32 item_ID ) ;
#line 39
gboolean gimp_item_is_layer(gint32 item_ID ) ;
#line 40
gboolean gimp_item_is_text_layer(gint32 item_ID ) ;
#line 41
gboolean gimp_item_is_channel(gint32 item_ID ) ;
#line 42
gboolean gimp_item_is_layer_mask(gint32 item_ID ) ;
#line 43
gboolean gimp_item_is_selection(gint32 item_ID ) ;
#line 44
gboolean gimp_item_is_vectors(gint32 item_ID ) ;
#line 45
gboolean gimp_item_is_group(gint32 item_ID ) ;
#line 46
gint32 gimp_item_get_parent(gint32 item_ID ) ;
#line 47
gint *gimp_item_get_children(gint32 item_ID , gint *num_children ) ;
#line 49
gboolean gimp_item_get_expanded(gint32 item_ID ) ;
#line 50
gboolean gimp_item_set_expanded(gint32 item_ID , gboolean expanded ) ;
#line 52
gchar *gimp_item_get_name(gint32 item_ID ) ;
#line 53
gboolean gimp_item_set_name(gint32 item_ID , gchar *name ) ;
#line 55
gboolean gimp_item_get_visible(gint32 item_ID ) ;
#line 56
gboolean gimp_item_set_visible(gint32 item_ID , gboolean visible ) ;
#line 58
gboolean gimp_item_get_linked(gint32 item_ID ) ;
#line 59
gboolean gimp_item_set_linked(gint32 item_ID , gboolean linked ) ;
#line 61
gboolean gimp_item_get_lock_content(gint32 item_ID ) ;
#line 62
gboolean gimp_item_set_lock_content(gint32 item_ID , gboolean lock_content ) ;
#line 64
gboolean gimp_item_get_lock_position(gint32 item_ID ) ;
#line 65
gboolean gimp_item_set_lock_position(gint32 item_ID , gboolean lock_position ) ;
#line 67
GimpColorTag gimp_item_get_color_tag(gint32 item_ID ) ;
#line 68
gboolean gimp_item_set_color_tag(gint32 item_ID , GimpColorTag color_tag ) ;
#line 70
gint gimp_item_get_tattoo(gint32 item_ID ) ;
#line 71
gboolean gimp_item_set_tattoo(gint32 item_ID , gint tattoo ) ;
#line 73
gboolean gimp_item_attach_parasite(gint32 item_ID , GimpParasite *parasite ) ;
#line 75
gboolean gimp_item_detach_parasite(gint32 item_ID , gchar *name ) ;
#line 77
GimpParasite *gimp_item_get_parasite(gint32 item_ID , gchar *name ) ;
#line 79
gchar **gimp_item_get_parasite_list(gint32 item_ID , gint *num_parasites ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpitemtransform_pdb.h"
gint32 gimp_item_transform_translate(gint32 item_ID , gdouble off_x , gdouble off_y ) ;
#line 38
gint32 gimp_item_transform_flip_simple(gint32 item_ID , GimpOrientationType flip_type ,
                                       gboolean auto_center , gdouble axis ) ;
#line 42
gint32 gimp_item_transform_flip(gint32 item_ID , gdouble x0 , gdouble y0 , gdouble x1 ,
                                gdouble y1 ) ;
#line 47
gint32 gimp_item_transform_perspective(gint32 item_ID , gdouble x0 , gdouble y0 ,
                                       gdouble x1 , gdouble y1 , gdouble x2 , gdouble y2 ,
                                       gdouble x3 , gdouble y3 ) ;
#line 56
gint32 gimp_item_transform_rotate_simple(gint32 item_ID , GimpRotationType rotate_type ,
                                         gboolean auto_center , gdouble center_x ,
                                         gdouble center_y ) ;
#line 61
gint32 gimp_item_transform_rotate(gint32 item_ID , gdouble angle , gboolean auto_center ,
                                  gdouble center_x , gdouble center_y ) ;
#line 66
gint32 gimp_item_transform_scale(gint32 item_ID , gdouble x0 , gdouble y0 , gdouble x1 ,
                                 gdouble y1 ) ;
#line 71
gint32 gimp_item_transform_shear(gint32 item_ID , GimpOrientationType shear_type ,
                                 gdouble magnitude ) ;
#line 74
gint32 gimp_item_transform_2d(gint32 item_ID , gdouble source_x , gdouble source_y ,
                              gdouble scale_x , gdouble scale_y , gdouble angle ,
                              gdouble dest_x , gdouble dest_y ) ;
#line 82
gint32 gimp_item_transform_matrix(gint32 item_ID , gdouble coeff_0_0 , gdouble coeff_0_1 ,
                                  gdouble coeff_0_2 , gdouble coeff_1_0 , gdouble coeff_1_1 ,
                                  gdouble coeff_1_2 , gdouble coeff_2_0 , gdouble coeff_2_1 ,
                                  gdouble coeff_2_2 ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimplayer_pdb.h"
gint32 _gimp_layer_new(gint32 image_ID , gint width , gint height , GimpImageType type ,
                       gchar *name , gdouble opacity , GimpLayerMode mode ) ;
#line 42
gint32 gimp_layer_new_from_visible(gint32 image_ID , gint32 dest_image_ID , gchar *name ) ;
#line 45
gint32 gimp_layer_new_from_drawable(gint32 drawable_ID , gint32 dest_image_ID ) ;
#line 47
gint32 gimp_layer_group_new(gint32 image_ID ) ;
#line 48
gint32 _gimp_layer_copy(gint32 layer_ID , gboolean add_alpha ) ;
#line 50
gboolean gimp_layer_add_alpha(gint32 layer_ID ) ;
#line 51
gboolean gimp_layer_flatten(gint32 layer_ID ) ;
#line 52
gboolean gimp_layer_scale(gint32 layer_ID , gint new_width , gint new_height , gboolean local_origin ) ;
#line 57
gboolean gimp_layer_scale_full(gint32 layer_ID , gint new_width , gint new_height ,
                               gboolean local_origin , GimpInterpolationType interpolation ) ;
#line 62
gboolean gimp_layer_resize(gint32 layer_ID , gint new_width , gint new_height , gint offx ,
                           gint offy ) ;
#line 67
gboolean gimp_layer_resize_to_image_size(gint32 layer_ID ) ;
#line 69
gboolean gimp_layer_translate(gint32 layer_ID , gint offx , gint offy ) ;
#line 72
gboolean gimp_layer_set_offsets(gint32 layer_ID , gint offx , gint offy ) ;
#line 75
gint32 gimp_layer_create_mask(gint32 layer_ID , GimpAddMaskType mask_type ) ;
#line 77
gint32 gimp_layer_get_mask(gint32 layer_ID ) ;
#line 78
gint32 gimp_layer_from_mask(gint32 mask_ID ) ;
#line 79
gboolean gimp_layer_add_mask(gint32 layer_ID , gint32 mask_ID ) ;
#line 81
gboolean gimp_layer_remove_mask(gint32 layer_ID , GimpMaskApplyMode mode ) ;
#line 83
gboolean gimp_layer_is_floating_sel(gint32 layer_ID ) ;
#line 84
gboolean gimp_layer_get_lock_alpha(gint32 layer_ID ) ;
#line 85
gboolean gimp_layer_set_lock_alpha(gint32 layer_ID , gboolean lock_alpha ) ;
#line 87
gboolean gimp_layer_get_apply_mask(gint32 layer_ID ) ;
#line 88
gboolean gimp_layer_set_apply_mask(gint32 layer_ID , gboolean apply_mask ) ;
#line 90
gboolean gimp_layer_get_show_mask(gint32 layer_ID ) ;
#line 91
gboolean gimp_layer_set_show_mask(gint32 layer_ID , gboolean show_mask ) ;
#line 93
gboolean gimp_layer_get_edit_mask(gint32 layer_ID ) ;
#line 94
gboolean gimp_layer_set_edit_mask(gint32 layer_ID , gboolean edit_mask ) ;
#line 96
gdouble gimp_layer_get_opacity(gint32 layer_ID ) ;
#line 97
gboolean gimp_layer_set_opacity(gint32 layer_ID , gdouble opacity ) ;
#line 99
GimpLayerMode gimp_layer_get_mode(gint32 layer_ID ) ;
#line 100
gboolean gimp_layer_set_mode(gint32 layer_ID , GimpLayerMode mode ) ;
#line 102
GimpLayerColorSpace gimp_layer_get_blend_space(gint32 layer_ID ) ;
#line 103
gboolean gimp_layer_set_blend_space(gint32 layer_ID , GimpLayerColorSpace blend_space ) ;
#line 105
GimpLayerColorSpace gimp_layer_get_composite_space(gint32 layer_ID ) ;
#line 106
gboolean gimp_layer_set_composite_space(gint32 layer_ID , GimpLayerColorSpace composite_space ) ;
#line 108
GimpLayerCompositeMode gimp_layer_get_composite_mode(gint32 layer_ID ) ;
#line 109
gboolean gimp_layer_set_composite_mode(gint32 layer_ID , GimpLayerCompositeMode composite_mode ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpmessage_pdb.h"
gboolean gimp_message(gchar *message ) ;
#line 36
GimpMessageHandlerType gimp_message_get_handler(void) ;
#line 37
gboolean gimp_message_set_handler(GimpMessageHandlerType handler ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimppainttools_pdb.h"
gboolean gimp_airbrush(gint32 drawable_ID , gdouble pressure , gint num_strokes ,
                       gdouble *strokes ) ;
#line 39
gboolean gimp_airbrush_default(gint32 drawable_ID , gint num_strokes , gdouble *strokes ) ;
#line 42
gboolean gimp_clone(gint32 drawable_ID , gint32 src_drawable_ID , GimpCloneType clone_type ,
                    gdouble src_x , gdouble src_y , gint num_strokes , gdouble *strokes ) ;
#line 49
gboolean gimp_clone_default(gint32 drawable_ID , gint num_strokes , gdouble *strokes ) ;
#line 52
gboolean gimp_convolve(gint32 drawable_ID , gdouble pressure , GimpConvolveType convolve_type ,
                       gint num_strokes , gdouble *strokes ) ;
#line 57
gboolean gimp_convolve_default(gint32 drawable_ID , gint num_strokes , gdouble *strokes ) ;
#line 60
gboolean gimp_dodgeburn(gint32 drawable_ID , gdouble exposure , GimpDodgeBurnType dodgeburn_type ,
                        GimpTransferMode dodgeburn_mode , gint num_strokes , gdouble *strokes ) ;
#line 66
gboolean gimp_dodgeburn_default(gint32 drawable_ID , gint num_strokes , gdouble *strokes ) ;
#line 69
gboolean gimp_eraser(gint32 drawable_ID , gint num_strokes , gdouble *strokes , GimpBrushApplicationMode hardness ,
                     GimpPaintApplicationMode method ) ;
#line 74
gboolean gimp_eraser_default(gint32 drawable_ID , gint num_strokes , gdouble *strokes ) ;
#line 77
gboolean gimp_heal(gint32 drawable_ID , gint32 src_drawable_ID , gdouble src_x , gdouble src_y ,
                   gint num_strokes , gdouble *strokes ) ;
#line 83
gboolean gimp_heal_default(gint32 drawable_ID , gint num_strokes , gdouble *strokes ) ;
#line 86
gboolean gimp_paintbrush(gint32 drawable_ID , gdouble fade_out , gint num_strokes ,
                         gdouble *strokes , GimpPaintApplicationMode method , gdouble gradient_length ) ;
#line 92
gboolean gimp_paintbrush_default(gint32 drawable_ID , gint num_strokes , gdouble *strokes ) ;
#line 95
gboolean gimp_pencil(gint32 drawable_ID , gint num_strokes , gdouble *strokes ) ;
#line 98
gboolean gimp_smudge(gint32 drawable_ID , gdouble pressure , gint num_strokes , gdouble *strokes ) ;
#line 102
gboolean gimp_smudge_default(gint32 drawable_ID , gint num_strokes , gdouble *strokes ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimppalette_pdb.h"
gchar *gimp_palette_new(gchar *name ) ;
#line 36
gchar *gimp_palette_duplicate(gchar *name ) ;
#line 37
gchar *gimp_palette_rename(gchar *name , gchar *new_name ) ;
#line 39
gboolean gimp_palette_delete(gchar *name ) ;
#line 40
gboolean gimp_palette_is_editable(gchar *name ) ;
#line 41
gboolean gimp_palette_get_info(gchar *name , gint *num_colors ) ;
#line 43
GimpRGB *gimp_palette_get_colors(gchar *name , gint *num_colors ) ;
#line 45
gint gimp_palette_get_columns(gchar *name ) ;
#line 46
gboolean gimp_palette_set_columns(gchar *name , gint columns ) ;
#line 48
gboolean gimp_palette_add_entry(gchar *name , gchar *entry_name , GimpRGB *color ,
                                gint *entry_num ) ;
#line 52
gboolean gimp_palette_delete_entry(gchar *name , gint entry_num ) ;
#line 54
gboolean gimp_palette_entry_get_color(gchar *name , gint entry_num , GimpRGB *color ) ;
#line 57
gboolean gimp_palette_entry_set_color(gchar *name , gint entry_num , GimpRGB *color ) ;
#line 60
gboolean gimp_palette_entry_get_name(gchar *name , gint entry_num , gchar **entry_name ) ;
#line 63
gboolean gimp_palette_entry_set_name(gchar *name , gint entry_num , gchar *entry_name ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimppalettes_pdb.h"
gboolean gimp_palettes_refresh(void) ;
#line 36
gchar **gimp_palettes_get_list(gchar *filter , gint *num_palettes ) ;
#line 39
gchar *gimp_palettes_get_palette(gint *num_colors ) ;
#line 41
gchar *gimp_palettes_get_palette_entry(gchar *name , gint entry_num , gint *num_colors ,
                                       GimpRGB *color ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimppaletteselect_pdb.h"
gboolean gimp_palettes_popup(gchar *palette_callback , gchar *popup_title , gchar *initial_palette ) ;
#line 38
gboolean gimp_palettes_close_popup(gchar *palette_callback ) ;
#line 39
gboolean gimp_palettes_set_popup(gchar *palette_callback , gchar *palette_name ) ;
#line 36 "/usr/include/gimp-2.0/libgimp/gimppaths_pdb.h"
gchar **gimp_path_list(gint32 image_ID , gint *num_paths ) ;
#line 39
gchar *gimp_path_get_current(gint32 image_ID ) ;
#line 41
gboolean gimp_path_set_current(gint32 image_ID , gchar *name ) ;
#line 44
gboolean gimp_path_delete(gint32 image_ID , gchar *name ) ;
#line 47
gint gimp_path_get_points(gint32 image_ID , gchar *name , gint *path_closed , gint *num_path_point_details ,
                          gdouble **points_pairs ) ;
#line 53
gboolean gimp_path_set_points(gint32 image_ID , gchar *name , gint ptype , gint num_path_points ,
                              gdouble *points_pairs ) ;
#line 59
gboolean gimp_path_stroke_current(gint32 image_ID ) ;
#line 61
gint gimp_path_get_point_at_dist(gint32 image_ID , gdouble distance , gint *y_point ,
                                 gdouble *slope ) ;
#line 66
gint gimp_path_get_tattoo(gint32 image_ID , gchar *name ) ;
#line 69
gboolean gimp_path_set_tattoo(gint32 image_ID , gchar *name , gint tattovalue ) ;
#line 73
gchar *gimp_get_path_by_tattoo(gint32 image_ID , gint tattoo ) ;
#line 76
gboolean gimp_path_get_locked(gint32 image_ID , gchar *name ) ;
#line 79
gboolean gimp_path_set_locked(gint32 image_ID , gchar *name , gboolean locked ) ;
#line 83
gboolean gimp_path_to_selection(gint32 image_ID , gchar *name , GimpChannelOps op ,
                                gboolean antialias , gboolean feather , gdouble feather_radius_x ,
                                gdouble feather_radius_y ) ;
#line 91
gboolean gimp_path_import(gint32 image_ID , gchar *filename , gboolean merge , gboolean scale ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimppattern_pdb.h"
gboolean gimp_pattern_get_info(gchar *name , gint *width , gint *height , gint *bpp ) ;
#line 39
gboolean gimp_pattern_get_pixels(gchar *name , gint *width , gint *height , gint *bpp ,
                                 gint *num_color_bytes , guint8 **color_bytes ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimppatterns_pdb.h"
gboolean gimp_patterns_refresh(void) ;
#line 36
gchar **gimp_patterns_get_list(gchar *filter , gint *num_patterns ) ;
#line 39
gchar *gimp_patterns_get_pattern(gint *width , gint *height ) ;
#line 42
gchar *gimp_patterns_get_pattern_data(gchar *name , gint *width , gint *height , gint *mask_bpp ,
                                      gint *length , guint8 **mask_data ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimppatternselect_pdb.h"
gboolean gimp_patterns_popup(gchar *pattern_callback , gchar *popup_title , gchar *initial_pattern ) ;
#line 38
gboolean gimp_patterns_close_popup(gchar *pattern_callback ) ;
#line 39
gboolean gimp_patterns_set_popup(gchar *pattern_callback , gchar *pattern_name ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpplugin_pdb.h"
gboolean gimp_plugin_domain_register(gchar *domain_name , gchar *domain_path ) ;
#line 37
gboolean gimp_plugin_help_register(gchar *domain_name , gchar *domain_uri ) ;
#line 39
gboolean gimp_plugin_menu_register(gchar *procedure_name , gchar *menu_path ) ;
#line 41
gboolean gimp_plugin_menu_branch_register(gchar *menu_path , gchar *menu_name ) ;
#line 43
gboolean _gimp_plugin_icon_register(gchar *procedure_name , GimpIconType icon_type ,
                                    gint icon_data_length , guint8 *icon_data ) ;
#line 47
gboolean gimp_plugin_set_pdb_error_handler(GimpPDBErrorHandler handler ) ;
#line 48
GimpPDBErrorHandler gimp_plugin_get_pdb_error_handler(void) ;
#line 49
gboolean gimp_plugin_enable_precision(void) ;
#line 50
gboolean gimp_plugin_precision_enabled(void) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpproceduraldb_pdb.h"
gchar *gimp_procedural_db_temp_name(void) ;
#line 36
gboolean gimp_procedural_db_dump(gchar *filename ) ;
#line 37
gboolean gimp_procedural_db_query(gchar *name , gchar *blurb , gchar *help , gchar *author ,
                                  gchar *copyright , gchar *date , gchar *proc_type ,
                                  gint *num_matches , gchar ***procedure_names ) ;
#line 46
gboolean gimp_procedural_db_proc_exists(gchar *procedure_name ) ;
#line 47
gboolean _gimp_procedural_db_proc_info(gchar *procedure_name , gchar **blurb , gchar **help ,
                                       gchar **author , gchar **copyright , gchar **date ,
                                       GimpPDBProcType *proc_type , gint *num_args ,
                                       gint *num_values ) ;
#line 56
gboolean gimp_procedural_db_proc_arg(gchar *procedure_name , gint arg_num , GimpPDBArgType *arg_type ,
                                     gchar **arg_name , gchar **arg_desc ) ;
#line 61
gboolean gimp_procedural_db_proc_val(gchar *procedure_name , gint val_num , GimpPDBArgType *val_type ,
                                     gchar **val_name , gchar **val_desc ) ;
#line 66
gboolean _gimp_procedural_db_get_data(gchar *identifier , gint *bytes , guint8 **data ) ;
#line 69
gint gimp_procedural_db_get_data_size(gchar *identifier ) ;
#line 70
gboolean _gimp_procedural_db_set_data(gchar *identifier , gint bytes , guint8 *data ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpprogress_pdb.h"
gboolean _gimp_progress_init(gchar *message , gint32 gdisplay_ID ) ;
#line 37
gboolean _gimp_progress_update(gdouble percentage ) ;
#line 38
gboolean gimp_progress_pulse(void) ;
#line 39
gboolean gimp_progress_set_text(gchar *message ) ;
#line 40
gboolean gimp_progress_end(void) ;
#line 41
gint gimp_progress_get_window_handle(void) ;
#line 42
gboolean _gimp_progress_install(gchar *progress_callback ) ;
#line 43
gboolean _gimp_progress_uninstall(gchar *progress_callback ) ;
#line 44
gboolean gimp_progress_cancel(gchar *progress_callback ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpselection_pdb.h"
gboolean gimp_selection_bounds(gint32 image_ID , gboolean *non_empty , gint *x1 ,
                               gint *y1 , gint *x2 , gint *y2 ) ;
#line 41
gint gimp_selection_value(gint32 image_ID , gint x , gint y ) ;
#line 44
gboolean gimp_selection_is_empty(gint32 image_ID ) ;
#line 45
gboolean gimp_selection_translate(gint32 image_ID , gint offx , gint offy ) ;
#line 48
gint32 _gimp_selection_float(gint32 drawable_ID , gint offx , gint offy ) ;
#line 51
gboolean gimp_selection_invert(gint32 image_ID ) ;
#line 52
gboolean gimp_selection_sharpen(gint32 image_ID ) ;
#line 53
gboolean gimp_selection_all(gint32 image_ID ) ;
#line 54
gboolean gimp_selection_none(gint32 image_ID ) ;
#line 55
gboolean gimp_selection_feather(gint32 image_ID , gdouble radius ) ;
#line 57
gboolean gimp_selection_border(gint32 image_ID , gint radius ) ;
#line 59
gboolean gimp_selection_grow(gint32 image_ID , gint steps ) ;
#line 61
gboolean gimp_selection_shrink(gint32 image_ID , gint steps ) ;
#line 63
gboolean gimp_selection_flood(gint32 image_ID ) ;
#line 65
gboolean gimp_selection_layer_alpha(gint32 layer_ID ) ;
#line 67
gboolean gimp_selection_load(gint32 channel_ID ) ;
#line 68
gint32 gimp_selection_save(gint32 image_ID ) ;
#line 70
gboolean gimp_selection_combine(gint32 channel_ID , GimpChannelOps operation ) ;
#line 36 "/usr/include/gimp-2.0/libgimp/gimpselectiontools_pdb.h"
gboolean gimp_by_color_select(gint32 drawable_ID , GimpRGB *color , gint threshold ,
                              GimpChannelOps operation , gboolean antialias , gboolean feather ,
                              gdouble feather_radius , gboolean sample_merged ) ;
#line 45
gboolean gimp_by_color_select_full(gint32 drawable_ID , GimpRGB *color , gint threshold ,
                                   GimpChannelOps operation , gboolean antialias ,
                                   gboolean feather , gdouble feather_radius_x , gdouble feather_radius_y ,
                                   gboolean sample_merged , gboolean select_transparent ,
                                   GimpSelectCriterion select_criterion ) ;
#line 57
gboolean gimp_ellipse_select(gint32 image_ID , gdouble x , gdouble y , gdouble width ,
                             gdouble height , GimpChannelOps operation , gboolean antialias ,
                             gboolean feather , gdouble feather_radius ) ;
#line 67
gboolean gimp_free_select(gint32 image_ID , gint num_segs , gdouble *segs , GimpChannelOps operation ,
                          gboolean antialias , gboolean feather , gdouble feather_radius ) ;
#line 75
gboolean gimp_fuzzy_select(gint32 drawable_ID , gdouble x , gdouble y , gint threshold ,
                           GimpChannelOps operation , gboolean antialias , gboolean feather ,
                           gdouble feather_radius , gboolean sample_merged ) ;
#line 85
gboolean gimp_fuzzy_select_full(gint32 drawable_ID , gdouble x , gdouble y , gint threshold ,
                                GimpChannelOps operation , gboolean antialias , gboolean feather ,
                                gdouble feather_radius_x , gdouble feather_radius_y ,
                                gboolean sample_merged , gboolean select_transparent ,
                                GimpSelectCriterion select_criterion ) ;
#line 98
gboolean gimp_rect_select(gint32 image_ID , gdouble x , gdouble y , gdouble width ,
                          gdouble height , GimpChannelOps operation , gboolean feather ,
                          gdouble feather_radius ) ;
#line 107
gboolean gimp_round_rect_select(gint32 image_ID , gdouble x , gdouble y , gdouble width ,
                                gdouble height , gdouble corner_radius_x , gdouble corner_radius_y ,
                                GimpChannelOps operation , gboolean antialias , gboolean feather ,
                                gdouble feather_radius_x , gdouble feather_radius_y ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimptextlayer_pdb.h"
gint32 gimp_text_layer_new(gint32 image_ID , gchar *text , gchar *fontname , gdouble size ,
                           GimpUnit unit ) ;
#line 40
gchar *gimp_text_layer_get_text(gint32 layer_ID ) ;
#line 41
gboolean gimp_text_layer_set_text(gint32 layer_ID , gchar *text ) ;
#line 43
gchar *gimp_text_layer_get_markup(gint32 layer_ID ) ;
#line 44
gchar *gimp_text_layer_get_font(gint32 layer_ID ) ;
#line 45
gboolean gimp_text_layer_set_font(gint32 layer_ID , gchar *font ) ;
#line 47
gdouble gimp_text_layer_get_font_size(gint32 layer_ID , GimpUnit *unit ) ;
#line 49
gboolean gimp_text_layer_set_font_size(gint32 layer_ID , gdouble font_size , GimpUnit unit ) ;
#line 52
gboolean gimp_text_layer_get_antialias(gint32 layer_ID ) ;
#line 53
gboolean gimp_text_layer_set_antialias(gint32 layer_ID , gboolean antialias ) ;
#line 55
GimpTextHintStyle gimp_text_layer_get_hint_style(gint32 layer_ID ) ;
#line 56
gboolean gimp_text_layer_set_hint_style(gint32 layer_ID , GimpTextHintStyle style ) ;
#line 58
gboolean gimp_text_layer_get_kerning(gint32 layer_ID ) ;
#line 59
gboolean gimp_text_layer_set_kerning(gint32 layer_ID , gboolean kerning ) ;
#line 61
gchar *gimp_text_layer_get_language(gint32 layer_ID ) ;
#line 62
gboolean gimp_text_layer_set_language(gint32 layer_ID , gchar *language ) ;
#line 64
GimpTextDirection gimp_text_layer_get_base_direction(gint32 layer_ID ) ;
#line 65
gboolean gimp_text_layer_set_base_direction(gint32 layer_ID , GimpTextDirection direction ) ;
#line 67
GimpTextJustification gimp_text_layer_get_justification(gint32 layer_ID ) ;
#line 68
gboolean gimp_text_layer_set_justification(gint32 layer_ID , GimpTextJustification justify ) ;
#line 70
gboolean gimp_text_layer_get_color(gint32 layer_ID , GimpRGB *color ) ;
#line 72
gboolean gimp_text_layer_set_color(gint32 layer_ID , GimpRGB *color ) ;
#line 74
gdouble gimp_text_layer_get_indent(gint32 layer_ID ) ;
#line 75
gboolean gimp_text_layer_set_indent(gint32 layer_ID , gdouble indent ) ;
#line 77
gdouble gimp_text_layer_get_line_spacing(gint32 layer_ID ) ;
#line 78
gboolean gimp_text_layer_set_line_spacing(gint32 layer_ID , gdouble line_spacing ) ;
#line 80
gdouble gimp_text_layer_get_letter_spacing(gint32 layer_ID ) ;
#line 81
gboolean gimp_text_layer_set_letter_spacing(gint32 layer_ID , gdouble letter_spacing ) ;
#line 83
gboolean gimp_text_layer_resize(gint32 layer_ID , gdouble width , gdouble height ) ;
#line 87
gboolean gimp_text_layer_get_hinting(gint32 layer_ID , gboolean *autohint ) ;
#line 90
gboolean gimp_text_layer_set_hinting(gint32 layer_ID , gboolean hinting , gboolean autohint ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimptexttool_pdb.h"
gint32 gimp_text_fontname(gint32 image_ID , gint32 drawable_ID , gdouble x , gdouble y ,
                          gchar *text , gint border , gboolean antialias , gdouble size ,
                          GimpSizeType size_type , gchar *fontname ) ;
#line 45
gboolean gimp_text_get_extents_fontname(gchar *text , gdouble size , GimpSizeType size_type ,
                                        gchar *fontname , gint *width , gint *height ,
                                        gint *ascent , gint *descent ) ;
#line 54
gint32 gimp_text(gint32 image_ID , gint32 drawable_ID , gdouble x , gdouble y , gchar *text ,
                 gint border , gboolean antialias , gdouble size , GimpSizeType size_type ,
                 gchar *foundry , gchar *family , gchar *weight , gchar *slant , gchar *set_width ,
                 gchar *spacing , gchar *registry , gchar *encoding ) ;
#line 72
gboolean gimp_text_get_extents(gchar *text , gdouble size , GimpSizeType size_type ,
                               gchar *foundry , gchar *family , gchar *weight , gchar *slant ,
                               gchar *set_width , gchar *spacing , gchar *registry ,
                               gchar *encoding , gint *width , gint *height , gint *ascent ,
                               gint *descent ) ;
#line 36 "/usr/include/gimp-2.0/libgimp/gimptransformtools_pdb.h"
gint32 gimp_flip(gint32 drawable_ID , GimpOrientationType flip_type ) ;
#line 39
gint32 gimp_perspective(gint32 drawable_ID , gboolean interpolation , gdouble x0 ,
                        gdouble y0 , gdouble x1 , gdouble y1 , gdouble x2 , gdouble y2 ,
                        gdouble x3 , gdouble y3 ) ;
#line 50
gint32 gimp_rotate(gint32 drawable_ID , gboolean interpolation , gdouble angle ) ;
#line 54
gint32 gimp_scale(gint32 drawable_ID , gboolean interpolation , gdouble x0 , gdouble y0 ,
                  gdouble x1 , gdouble y1 ) ;
#line 61
gint32 gimp_shear(gint32 drawable_ID , gboolean interpolation , GimpOrientationType shear_type ,
                  gdouble magnitude ) ;
#line 66
gint32 gimp_transform_2d(gint32 drawable_ID , gboolean interpolation , gdouble source_x ,
                         gdouble source_y , gdouble scale_x , gdouble scale_y , gdouble angle ,
                         gdouble dest_x , gdouble dest_y ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpunit_pdb.h"
gint _gimp_unit_get_number_of_units(void) ;
#line 36
gint _gimp_unit_get_number_of_built_in_units(void) ;
#line 37
GimpUnit _gimp_unit_new(gchar *identifier , gdouble factor , gint digits , gchar *symbol ,
                        gchar *abbreviation , gchar *singular , gchar *plural ) ;
#line 44
gboolean _gimp_unit_get_deletion_flag(GimpUnit unit_id ) ;
#line 45
gboolean _gimp_unit_set_deletion_flag(GimpUnit unit_id , gboolean deletion_flag ) ;
#line 47
gchar *_gimp_unit_get_identifier(GimpUnit unit_id ) ;
#line 48
gdouble _gimp_unit_get_factor(GimpUnit unit_id ) ;
#line 49
gint _gimp_unit_get_digits(GimpUnit unit_id ) ;
#line 50
gchar *_gimp_unit_get_symbol(GimpUnit unit_id ) ;
#line 51
gchar *_gimp_unit_get_abbreviation(GimpUnit unit_id ) ;
#line 52
gchar *_gimp_unit_get_singular(GimpUnit unit_id ) ;
#line 53
gchar *_gimp_unit_get_plural(GimpUnit unit_id ) ;
#line 35 "/usr/include/gimp-2.0/libgimp/gimpvectors_pdb.h"
gint32 gimp_vectors_new(gint32 image_ID , gchar *name ) ;
#line 37
gint32 gimp_vectors_new_from_text_layer(gint32 image_ID , gint32 layer_ID ) ;
#line 39
gint32 gimp_vectors_copy(gint32 vectors_ID ) ;
#line 40
gint *gimp_vectors_get_strokes(gint32 vectors_ID , gint *num_strokes ) ;
#line 42
gdouble gimp_vectors_stroke_get_length(gint32 vectors_ID , gint stroke_id , gdouble precision ) ;
#line 45
gboolean gimp_vectors_stroke_get_point_at_dist(gint32 vectors_ID , gint stroke_id ,
                                               gdouble dist , gdouble precision ,
                                               gdouble *x_point , gdouble *y_point ,
                                               gdouble *slope , gboolean *valid ) ;
#line 53
gboolean gimp_vectors_remove_stroke(gint32 vectors_ID , gint stroke_id ) ;
#line 55
gboolean gimp_vectors_stroke_close(gint32 vectors_ID , gint stroke_id ) ;
#line 57
gboolean gimp_vectors_stroke_translate(gint32 vectors_ID , gint stroke_id , gint off_x ,
                                       gint off_y ) ;
#line 61
gboolean gimp_vectors_stroke_scale(gint32 vectors_ID , gint stroke_id , gdouble scale_x ,
                                   gdouble scale_y ) ;
#line 65
gboolean gimp_vectors_stroke_rotate(gint32 vectors_ID , gint stroke_id , gdouble center_x ,
                                    gdouble center_y , gdouble angle ) ;
#line 70
gboolean gimp_vectors_stroke_flip(gint32 vectors_ID , gint stroke_id , GimpOrientationType flip_type ,
                                  gdouble axis ) ;
#line 74
gboolean gimp_vectors_stroke_flip_free(gint32 vectors_ID , gint stroke_id , gdouble x1 ,
                                       gdouble y1 , gdouble x2 , gdouble y2 ) ;
#line 80
GimpVectorsStrokeType gimp_vectors_stroke_get_points(gint32 vectors_ID , gint stroke_id ,
                                                     gint *num_points , gdouble **controlpoints ,
                                                     gboolean *closed ) ;
#line 85
gint gimp_vectors_stroke_new_from_points(gint32 vectors_ID , GimpVectorsStrokeType type ,
                                         gint num_points , gdouble *controlpoints ,
                                         gboolean closed ) ;
#line 90
gdouble *gimp_vectors_stroke_interpolate(gint32 vectors_ID , gint stroke_id , gdouble precision ,
                                         gint *num_coords , gboolean *closed ) ;
#line 95
gint gimp_vectors_bezier_stroke_new_moveto(gint32 vectors_ID , gdouble x0 , gdouble y0 ) ;
#line 98
gboolean gimp_vectors_bezier_stroke_lineto(gint32 vectors_ID , gint stroke_id , gdouble x0 ,
                                           gdouble y0 ) ;
#line 102
gboolean gimp_vectors_bezier_stroke_conicto(gint32 vectors_ID , gint stroke_id , gdouble x0 ,
                                            gdouble y0 , gdouble x1 , gdouble y1 ) ;
#line 108
gboolean gimp_vectors_bezier_stroke_cubicto(gint32 vectors_ID , gint stroke_id , gdouble x0 ,
                                            gdouble y0 , gdouble x1 , gdouble y1 ,
                                            gdouble x2 , gdouble y2 ) ;
#line 116
gint gimp_vectors_bezier_stroke_new_ellipse(gint32 vectors_ID , gdouble x0 , gdouble y0 ,
                                            gdouble radius_x , gdouble radius_y ,
                                            gdouble angle ) ;
#line 123
gboolean gimp_vectors_to_selection(gint32 vectors_ID , GimpChannelOps operation ,
                                   gboolean antialias , gboolean feather , gdouble feather_radius_x ,
                                   gdouble feather_radius_y ) ;
#line 129
gboolean gimp_vectors_import_from_file(gint32 image_ID , gchar *filename , gboolean merge ,
                                       gboolean scale , gint *num_vectors , gint32 **vectors_ids ) ;
#line 135
gboolean gimp_vectors_import_from_string(gint32 image_ID , gchar *string , gint length ,
                                         gboolean merge , gboolean scale , gint *num_vectors ,
                                         gint32 **vectors_ids ) ;
#line 142
gboolean gimp_vectors_export_to_file(gint32 image_ID , gchar *filename , gint32 vectors_ID ) ;
#line 145
gchar *gimp_vectors_export_to_string(gint32 image_ID , gint32 vectors_ID ) ;
#line 226 "/usr/include/gimp-2.0/libgimp/gimp.h"
gint gimp_main(GimpPlugInInfo *info , gint argc , gchar *argv[] ) ;
#line 233
void gimp_quit(void) ;
#line 238
void gimp_install_procedure(gchar *name , gchar *blurb , gchar *help , gchar *author ,
                            gchar *copyright , gchar *date , gchar *menu_label , gchar *image_types ,
                            GimpPDBProcType type , gint n_params , gint n_return_vals ,
                            GimpParamDef *params , GimpParamDef *return_vals ) ;
#line 254
void gimp_install_temp_proc(gchar *name , gchar *blurb , gchar *help , gchar *author ,
                            gchar *copyright , gchar *date , gchar *menu_label , gchar *image_types ,
                            GimpPDBProcType type , gint n_params , gint n_return_vals ,
                            GimpParamDef *params , GimpParamDef *return_vals , GimpRunProc run_proc ) ;
#line 271
void gimp_uninstall_temp_proc(gchar *name ) ;
#line 275
void gimp_extension_ack(void) ;
#line 279
void gimp_extension_enable(void) ;
#line 283
void gimp_extension_process(guint timeout ) ;
#line 289
GimpParam *gimp_run_procedure(gchar *name , gint *n_return_vals  , ...) ;
#line 297
GimpParam *gimp_run_procedure2(gchar *name , gint *n_return_vals , gint n_params ,
                               GimpParam *params ) ;
#line 306
void gimp_destroy_params(GimpParam *params , gint n_params ) ;
#line 313
void gimp_destroy_paramdefs(GimpParamDef *paramdefs , gint n_params ) ;
#line 318
gchar *gimp_get_pdb_error(void) ;
#line 322
GimpPDBStatusType gimp_get_pdb_status(void) ;
#line 326
guint gimp_tile_width(void) ;
#line 327
guint gimp_tile_height(void) ;
#line 328
gint gimp_shm_ID(void) ;
#line 329
guchar *gimp_shm_addr(void) ;
#line 330
gboolean gimp_show_tool_tips(void) ;
#line 331
gboolean gimp_show_help_button(void) ;
#line 332
gboolean gimp_export_color_profile(void) ;
#line 333
gboolean gimp_export_exif(void) ;
#line 334
gboolean gimp_export_xmp(void) ;
#line 335
gboolean gimp_export_iptc(void) ;
#line 336
GimpCheckSize gimp_check_size(void) ;
#line 337
GimpCheckType gimp_check_type(void) ;
#line 338
gint32 gimp_default_display(void) ;
#line 339
gchar *gimp_wm_class(void) ;
#line 340
gchar *gimp_display_name(void) ;
#line 341
gint gimp_monitor_number(void) ;
#line 342
guint32 gimp_user_time(void) ;
#line 343
gchar *gimp_icon_theme_dir(void) ;
#line 345
gchar *gimp_get_progname(void) ;
#line 348
gdouble gimp_gamma(void) ;
#line 350
gboolean gimp_install_cmap(void) ;
#line 352
gint gimp_min_colors(void) ;
#line 355
GimpParasite *gimp_parasite_find(gchar *name ) ;
#line 357
gboolean gimp_parasite_attach(GimpParasite *parasite ) ;
#line 359
gboolean gimp_parasite_detach(gchar *name ) ;
#line 361
gboolean gimp_parasite_list(gint *num_parasites , gchar ***parasites ) ;
#line 364
gboolean gimp_attach_new_parasite(gchar *name , gint flags , gint size , gconstpointer data ) ;
#line 89 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void query(void) ;
#line 91
static void run(gchar *name , gint nparams , GimpParam *param , gint *nreturn_vals ,
                GimpParam **return_vals ) ;
#line 98 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
GimpPlugInInfo PLUG_IN_INFO  =    {(GimpInitProc )((void *)0), (GimpQuitProc )((void *)0), & query, & run};
#line 152
static struct __anonstruct_2166 scan_win ;
#line 154
static char const   *prog_name ;
#line 155
static GtkWidget *choose_device_dialog ;
#line 156
static GSGDialog *dialog ;
#line 157
static SANE_Device **devlist ;
#line 158 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static gint seldev  =    - 1;
#line 159 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static gint defdev  =    - 1;
#line 160
static gint ndevs ;
#line 161
static gboolean little_endian ;
#line 162 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static struct option long_options[3]  = {      {"help:V", 0, (int *)((void *)0), 'h'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 169
static int gtk_quit_flag ;
#line 174
int main(int argc , char **argv ) ;
#line 175
static void interface(int argc , char **argv ) ;
#line 176
static void scan_start___0(void) ;
#line 177
static void scan_done___0(void) ;
#line 181 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static gboolean calc_little_endian(void) 
{ 
  SANE_Int testvalue ;
  u_int8_t *firstbyte ;

  {
#line 183
  testvalue = 255;
#line 184
  firstbyte = (u_int8_t *)(& testvalue);
#line 186
  if ((int )*firstbyte == 255) {
#line 187
    return (! 0);
  }
#line 188
  return (0);
}
}
#line 194 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static int encode_devname(char const   *devname , int n , char *buf ) 
{ 
  static char const   hexdigit___0[17] ;
  char *dst ;
  char *limit ;
  char const   *src ;
  char ch ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 196
  hexdigit___0 = "0123456789abcdef\360i\356\371:V";
#line 201
  sanei_init_debug("xscanimage\205\372:V", & sanei_debug_xscanimage);
#line 203
  sanei_debug_xscanimage_call(4, "encode_devname\n");
#line 204
  limit = buf + n;
#line 205
  dst = buf;
  }
#line 205
  src = devname;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (! *src) {
#line 205
      goto while_break;
    }
#line 207
    if (dst >= limit) {
#line 208
      return (- 1);
    }
#line 210
    ch = *src;
#line 213
    if ((int )ch >= 48) {
#line 213
      if ((int )ch <= 57) {
#line 215
        __cil_tmp9 = dst;
#line 215
        dst ++;
#line 215
        *__cil_tmp9 = ch;
      } else {
#line 213
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 213
    if ((int )ch >= 97) {
#line 213
      if ((int )ch <= 122) {
#line 215
        __cil_tmp9 = dst;
#line 215
        dst ++;
#line 215
        *__cil_tmp9 = ch;
      } else {
#line 213
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 213
    if ((int )ch >= 65) {
#line 213
      if ((int )ch <= 90) {
#line 215
        __cil_tmp9 = dst;
#line 215
        dst ++;
#line 215
        *__cil_tmp9 = ch;
      } else {
#line 213
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 220
      if (dst + 4 >= limit) {
#line 221
        return (- 1);
      }
#line 223
      __cil_tmp10 = dst;
#line 223
      dst ++;
#line 223
      *__cil_tmp10 = (char )'-';
#line 224
      if ((int )ch == 45) {
#line 225
        __cil_tmp11 = dst;
#line 225
        dst ++;
#line 225
        *__cil_tmp11 = (char )'-';
      } else {
#line 228
        __cil_tmp12 = dst;
#line 228
        dst ++;
#line 228
        *__cil_tmp12 = hexdigit___0[((int )ch >> 4) & 15];
#line 229
        __cil_tmp13 = dst;
#line 229
        dst ++;
#line 229
        *__cil_tmp13 = hexdigit___0[(int )ch & 15];
#line 230
        __cil_tmp14 = dst;
#line 230
        dst ++;
#line 230
        *__cil_tmp14 = (char )'-';
      }
    }
#line 205
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  if (dst >= limit) {
#line 235
    return (- 1);
  }
  {
#line 236
  *dst = (char )'\000';
#line 237
  sanei_debug_xscanimage_call(4, "encode_devname: %s --> %s\n\377\377\377\377\377\377\230\001",
                              devname, buf);
  }
#line 239
  return (0);
}
}
#line 243 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static int decode_devname(char const   *encoded_devname , int n , char *buf ) 
{ 
  char *dst ;
  char *limit ;
  char const   *src ;
  char ch ;
  char val ;
  char const   *__cil_tmp9 ;
  char const   *__cil_tmp10 ;
  char const   *__cil_tmp11 ;

  {
  {
#line 249
  sanei_init_debug("xscanimage\366\371:V", & sanei_debug_xscanimage);
#line 251
  sanei_debug_xscanimage_call(4, "decode_devname\n\377\220");
#line 252
  limit = buf + n;
#line 253
  dst = buf;
  }
#line 253
  src = encoded_devname;
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    if (! *src) {
#line 253
      goto while_break;
    }
#line 255
    if (dst >= limit) {
#line 256
      return (- 1);
    }
#line 258
    __cil_tmp9 = src;
#line 258
    src ++;
#line 258
    ch = *__cil_tmp9;
#line 261
    if ((int )ch != 45) {
#line 262
      *dst = ch;
    } else {
#line 267
      __cil_tmp10 = src;
#line 267
      src ++;
#line 267
      ch = *__cil_tmp10;
#line 268
      if ((int )ch == 45) {
#line 269
        *dst = ch;
      } else {
#line 272
        if ((int )ch >= 97) {
#line 272
          if ((int )ch <= 102) {
#line 273
            val = (char )(((int )ch - 97) + 10);
          } else {
#line 275
            val = (char )((int )ch - 48);
          }
        } else {
#line 275
          val = (char )((int )ch - 48);
        }
#line 276
        val <<= 4;
#line 278
        __cil_tmp11 = src;
#line 278
        src ++;
#line 278
        ch = *__cil_tmp11;
#line 279
        if ((int )ch >= 97) {
#line 279
          if ((int )ch <= 102) {
#line 280
            val |= ((int )ch - 97) + 10;
          } else {
#line 282
            val |= (int )ch - 48;
          }
        } else {
#line 282
          val |= (int )ch - 48;
        }
#line 284
        *dst = val;
#line 286
        src ++;
      }
    }
#line 253
    dst ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  if (dst >= limit) {
#line 291
    return (- 1);
  }
  {
#line 292
  *dst = (char )'\000';
#line 293
  sanei_debug_xscanimage_call(4, "deccode_devname: %s -> %s\n\377\377\377\377\377\377\230\001",
                              encoded_devname, buf);
  }
#line 294
  return (0);
}
}
#line 298 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void query(void) 
{ 
  static GimpParamDef args[1] ;
  static GimpParamDef *return_vals ;
  static int nargs ;
  static int nreturn_vals ;
  char mpath[1024] ;
  char name[1024] ;
  size_t len ;
  int i ;
  int j ;
  SANE_Status status ;
  SANE_Status __cil_tmp11 ;
  SANE_String_Const __cil_tmp12 ;
  SANE_Status __cil_tmp13 ;
  SANE_String_Const __cil_tmp14 ;
  int __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  size_t __cil_tmp17 ;
  size_t __cil_tmp18 ;
  size_t __cil_tmp19 ;

  {
#line 300
  args[0].type = (GimpPDBArgType )0;
#line 300
  args[0].name = "run_mode\323\001 \372\001";
  {
#line 300
  args[0].description = "Interactive, non-interactive\377\377\377\377\250";
#line 303
  return_vals = (GimpParamDef *)((void *)0);
#line 304
  nargs = (int )(sizeof(args) / sizeof(args[0]));
#line 305
  nreturn_vals = 0;
#line 312
  sanei_init_debug("xscanimage\377\377\377\377\377\377\230\001", & sanei_debug_xscanimage);
#line 314
  sanei_debug_xscanimage_call(4, "query\n");
#line 315
  gimp_install_procedure((gchar *)"xscanimage\327\372:V", (gchar *)"Front-end to the SANE interface",
                         (gchar *)"This function provides access to scanners and other image acquisition devices through the SANE (Scanner Access Now Easy) interface.",
                         (gchar *)"Andy Beck, Tristan Tarrant, and David Mosberger\377\323\001 \372\001",
                         (gchar *)"Andy Beck, Tristan Tarrant, and David Mosberger",
                         (gchar *)"8th June 1997V", (gchar *)"<Toolbox>/File/Acquire/xscanimage/Device dialog...\356\371:V",
                         (gchar *)0, (GimpPDBProcType )2, nargs, nreturn_vals, (GimpParamDef *)args,
                         return_vals);
#line 327
  status = sane_init((SANE_Int *)0, (SANE_Auth_Callback )0);
  }
#line 328
  if ((unsigned int )status != 0U) {
    {
#line 330
    __cil_tmp12 = sane_strstatus(status);
#line 330
    sanei_debug_xscanimage_call(0, "query: sane_init failed: %s\n:V", __cil_tmp12);
#line 332
    exit(1);
    }
  }
  {
#line 335
  status = sane_get_devices(& devlist, 0);
  }
#line 336
  if ((unsigned int )status != 0U) {
    {
#line 338
    __cil_tmp14 = sane_strstatus(status);
#line 338
    sanei_debug_xscanimage_call(0, "query: sane_get_devices failed: %s\n\372:V", __cil_tmp14);
#line 340
    exit(1);
    }
  }
#line 343
  i = 0;
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! *(devlist + i)) {
#line 343
      goto while_break;
    }
    {
#line 345
    strcpy((char *)name, "xscanimage-\372:V");
#line 346
    __cil_tmp15 = encode_devname((*(devlist + i))->name, (int )(sizeof(name) - 11UL),
                                 (char *)name + 11);
    }
#line 346
    if (__cil_tmp15 < 0) {
#line 348
      goto while_continue;
    }
    {
#line 350
    strncpy((char *)mpath, "<Toolbox>/File/Acquire/xscanimage/\254\372:V", sizeof(mpath));
#line 351
    len = strlen((char const   *)((char *)mpath));
#line 352
    j = 0;
    }
    {
#line 352
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 352
      if (! *((*(devlist + i))->name + j)) {
#line 352
        goto while_break___0;
      }
#line 354
      if ((int )*((*(devlist + i))->name + j) == 47) {
#line 355
        __cil_tmp17 = len;
#line 355
        len ++;
#line 355
        mpath[__cil_tmp17] = (char )'\'';
      } else {
#line 357
        __cil_tmp18 = len;
#line 357
        len ++;
#line 357
        mpath[__cil_tmp18] = *((*(devlist + i))->name + j);
      }
#line 352
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 359
    __cil_tmp19 = len;
#line 359
    len ++;
#line 359
    mpath[__cil_tmp19] = (char )'\000';
#line 361
    gimp_install_procedure((char *)name, (gchar *)"Front-end to the SANE interface",
                           (gchar *)"This function provides access to scanners and other image acquisition devices through the SANE (Scanner Access Now Easy) interface.\372:V",
                           (gchar *)"Andy Beck, Tristan Tarrant, and David Mosberger",
                           (gchar *)"Andy Beck, Tristan Tarrant, and David Mosberger",
                           (gchar *)"8th June 1997V", (char *)mpath, (gchar *)0, (GimpPDBProcType )2,
                           nargs, nreturn_vals, (GimpParamDef *)args, return_vals);
    }
#line 343
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 371
  sane_exit();
#line 372
  sanei_debug_xscanimage_call(4, "query: finished\n\220");
  }
  return;
}
}
#line 377 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void run(gchar *name , gint nparams , GimpParam *param , gint *nreturn_vals ,
                GimpParam **return_vals ) 
{ 
  static GimpParam values[2] ;
  GimpRunMode run_mode ;
  char devname[1024] ;
  char *args[2] ;
  int nargs ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 395
  sanei_debug_xscanimage_call(4, "run\n:V");
#line 396
  run_mode = (GimpRunMode )(param + 0)->data.d_int32;
#line 397
  scan_win.mode = 1;
#line 399
  *nreturn_vals = 1;
#line 400
  *return_vals = (GimpParam *)values;
#line 402
  values[0].type = (GimpPDBArgType )21;
#line 403
  values[0].data.d_status = (GimpPDBStatusType )1;
#line 405
  nargs = 0;
#line 406
  __cil_tmp11 = nargs;
#line 406
  nargs ++;
#line 406
  args[__cil_tmp11] = "xscanimage\377\377\377\377\377\377\220";
#line 408
  seldev = - 1;
#line 409
  __cil_tmp12 = strncmp(name, "xscanimage-\372:V", (unsigned long )11);
  }
#line 409
  if (__cil_tmp12 == 0) {
    {
#line 411
    __cil_tmp13 = decode_devname(name + 11, (int )sizeof(devname), (char *)devname);
    }
#line 411
    if (__cil_tmp13 < 0) {
#line 412
      return;
    }
#line 413
    __cil_tmp14 = nargs;
#line 413
    nargs ++;
#line 413
    args[__cil_tmp14] = (char *)devname;
  }
  {
#line 418
  if ((unsigned int )run_mode == (unsigned int )0) {
#line 418
    goto case_0;
  }
#line 426
  if ((unsigned int )run_mode == (unsigned int )1) {
#line 426
    goto case_1;
  }
#line 430
  if ((unsigned int )run_mode == (unsigned int )2) {
#line 430
    goto case_2;
  }
#line 434
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 420
  gimp_extension_ack();
  }
  {
#line 422
  interface(nargs, (char **)args);
#line 423
  values[0].data.d_status = (GimpPDBStatusType )3;
  }
#line 424
  goto switch_break;
  case_1: /* CIL Label */ 
#line 428
  goto switch_break;
  case_2: /* CIL Label */ 
#line 432
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 435
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 437
  sanei_debug_xscanimage_call(4, "run: finished\n\377\377\220");
  }
  return;
}
}
#line 441 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void null_print_func(gchar *msg ) 
{ 


  {
  return;
}
}
#line 448 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static SANE_Word get_resolution(SANE_Handle dev ) 
{ 
  SANE_Status status ;
  SANE_Word resolution ;
  SANE_Int num_options ;
  SANE_Int i ;
  SANE_Option_Descriptor *option_desc ;
  SANE_Status __cil_tmp7 ;
  SANE_Option_Descriptor *__cil_tmp8 ;
  int __cil_tmp9 ;
  SANE_Status __cil_tmp10 ;
  SANE_Int __cil_tmp11 ;

  {
  {
#line 455
  sanei_debug_xscanimage_call(4, "get_resolution\n\377\220");
#line 456
  status = sane_control_option(dev, 0, (SANE_Action )0, & num_options, (SANE_Int *)0);
  }
#line 458
  if ((unsigned int )status != 0U) {
#line 459
    return (0);
  }
#line 461
  i = 1;
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    if (! (i < num_options)) {
#line 461
      goto while_break;
    }
    {
#line 463
    option_desc = sane_get_option_descriptor(dev, i);
    }
#line 464
    if (option_desc) {
#line 465
      if (option_desc->name) {
        {
#line 467
        __cil_tmp9 = strncmp(option_desc->name, "resolution@\372:V", sizeof("resolution\236\372:V"));
        }
#line 467
        if (__cil_tmp9 == 0) {
          {
#line 470
          status = sane_control_option(dev, i, (SANE_Action )0, & resolution, (SANE_Int *)0);
          }
#line 472
          if ((unsigned int )status == 0U) {
#line 474
            if ((unsigned int )option_desc->type == 1U) {
#line 475
              return (resolution);
            } else
#line 476
            if ((unsigned int )option_desc->type == 2U) {
#line 477
              return ((SANE_Word )((double )resolution / (double )(1 << 16)));
            }
          }
#line 479
          return (0);
        }
      }
    }
#line 461
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 483
  sanei_debug_xscanimage_call(4, "get_resolution: finished\nd@\372:V");
  }
#line 484
  return (0);
}
}
#line 488 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void update_preview(GSGDialog *dialog___0 , void *arg ) 
{ 


  {
#line 490
  if (scan_win.preview) {
    {
#line 491
    preview_update(scan_win.preview);
    }
  }
  return;
}
}
#line 496 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void update_param(GSGDialog *dialog___0 , void *arg ) 
{ 
  SANE_Parameters params ;
  gchar buf[200] ;
  SANE_Status __cil_tmp5 ;
  double size ;
  char const   *unit ;
  GType __cil_tmp8 ;
  GTypeInstance *__cil_tmp9 ;

  {
  {
#line 501
  sanei_debug_xscanimage_call(4, "update_param\nV");
  }
#line 502
  if (! scan_win.info_label) {
#line 503
    return;
  }
  {
#line 505
  __cil_tmp5 = sane_get_parameters(dialog___0->dev, & params);
  }
#line 505
  if ((unsigned int )__cil_tmp5 == 0U) {
#line 508
    size = (double )params.bytes_per_line * (double )params.lines;
#line 509
    unit = "B\377\377\377\377\377\377\377\220";
#line 511
    if (params.lines == -1) {
      {
#line 513
      snprintf((gchar *)buf, sizeof(buf), "%dxunknown: unknown size\230\001", params.pixels_per_line);
      }
    } else {
#line 518
      if ((unsigned int )params.format >= 2U) {
#line 518
        if ((unsigned int )params.format <= 4U) {
#line 520
          size *= (double )3;
        }
      }
#line 522
      if (size >= (double )1048576) {
#line 524
        size /= (double )1048576;
#line 525
        unit = "MB\247\372:V";
      } else
#line 527
      if (size >= (double )1024) {
#line 529
        size /= (double )1024;
#line 530
        unit = "KB\377\377\377\377\377\377\220";
      }
      {
#line 532
      snprintf((gchar *)buf, sizeof(buf), "%dx%d: %1.1f %s", params.pixels_per_line,
               params.lines, size, unit);
      }
    }
  } else {
    {
#line 537
    snprintf((gchar *)buf, sizeof(buf), "Invalid parameters.\377\377\377\377\377\220");
    }
  }
  {
#line 538
  __cil_tmp8 = gtk_label_get_type();
#line 538
  __cil_tmp9 = g_type_check_instance_cast((GTypeInstance *)scan_win.info_label, __cil_tmp8);
#line 538
  gtk_label_set_text((GtkLabel *)((void *)__cil_tmp9), (gchar *)buf);
  }
#line 540
  if (scan_win.preview) {
    {
#line 541
    preview_update(scan_win.preview);
    }
  }
  {
#line 542
  sanei_debug_xscanimage_call(4, "update_param: finished\n");
  }
  return;
}
}
#line 546 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void pref_xscanimage_save(void) 
{ 
  char filename[4096] ;
  int fd ;
  int __cil_tmp3 ;
  char buf[256] ;
  int *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 551
  sanei_debug_xscanimage_call(4, "pref_xscanimage_save\nV");
#line 553
  gsg_make_path(sizeof(filename), (char *)filename, "xscanimagei\372:V", "xscanimageP\372:V",
                (char const   *)0, ".rc\372:V");
#line 555
  fd = open((char const   *)((char *)filename), 577, 438);
  }
#line 556
  if (fd < 0) {
    {
#line 560
    __cil_tmp5 = __errno_location();
#line 560
    __cil_tmp6 = strerror(*__cil_tmp5);
#line 560
    snprintf((char *)buf, sizeof(buf), "Failed to create file: %s.\377\377\377\377\377\377\230",
             __cil_tmp6);
#line 562
    gsg_error((char *)buf);
    }
#line 563
    return;
  }
  {
#line 565
  preferences_save(fd);
#line 566
  close(fd);
#line 567
  sanei_debug_xscanimage_call(4, "pref_xscanimage_save: finished\n");
  }
  return;
}
}
#line 571 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void pref_xscanimage_restore(void) 
{ 
  char filename[4096] ;
  int fd ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 576
  sanei_debug_xscanimage_call(4, "pref_xscanimage_restore\n\220");
#line 577
  gsg_make_path(sizeof(filename), (char *)filename, "xscanimage\236\372:V", "xscanimage\324\372:V",
                (char const   *)0, ".rc\377\377\377\377\377\220");
#line 579
  fd = open((char const   *)((char *)filename), 0);
  }
#line 580
  if (fd >= 0) {
    {
#line 582
    preferences_restore(fd);
#line 583
    close(fd);
    }
  }
#line 585
  if (! preferences.filename) {
    {
#line 586
    __cil_tmp4 = strdup("out.pnm");
#line 586
    preferences.filename = (char const   *)__cil_tmp4;
    }
  }
  {
#line 587
  sanei_debug_xscanimage_call(4, "pref_xscanimage_restore: finished\n\365\371:V");
  }
  return;
}
}
#line 591 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void quit_xscanimage(void) 
{ 
  Preview *preview ;
  gboolean __cil_tmp2 ;

  {
  {
#line 593
  sanei_debug_xscanimage_call(4, "quit_xscanimage\n\220");
  }
#line 594
  if (scan_win.preview) {
    {
#line 596
    preview = scan_win.preview;
#line 597
    scan_win.preview = (Preview *)0;
#line 598
    preview_destroy(preview);
    }
  }
  {
#line 600
  while (1) {
    while_continue: /* CIL Label */ ;
#line 600
    if (! gsg_message_dialog_active) {
#line 600
      goto while_break;
    }
    {
#line 602
    __cil_tmp2 = gtk_events_pending();
    }
#line 602
    if (! __cil_tmp2) {
      {
#line 603
      usleep((__useconds_t )100000);
      }
    }
    {
#line 604
    gtk_main_iteration();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 606
  pref_xscanimage_save();
  }
#line 607
  if (dialog) {
#line 607
    if (dialog->dev) {
      {
#line 608
      sane_close(dialog->dev);
      }
    }
  }
  {
#line 609
  sane_exit();
  }
#line 610
  if (gtk_quit_flag == 1) {
    {
#line 611
    gtk_main_quit();
    }
  }
#line 613
  if (scan_win.mode == 1) {
    {
#line 614
    gimp_quit();
    }
  }
  {
#line 616
  sanei_debug_xscanimage_call(4, "quit_xscanimage: exiting\nHh\372:V");
#line 617
  exit(0);
  }
}
}
#line 623 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static gint scan_win_delete(GtkWidget *w , gpointer data ) 
{ 


  {
  {
#line 625
  quit_xscanimage();
  }
#line 626
  return (0);
}
}
#line 630 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void preview_window_destroyed(GtkWidget *widget , gpointer call_data ) 
{ 
  GType __cil_tmp3 ;
  GTypeInstance *__cil_tmp4 ;

  {
  {
#line 632
  __cil_tmp3 = gtk_toggle_button_get_type();
#line 632
  __cil_tmp4 = g_type_check_instance_cast((GTypeInstance *)call_data, __cil_tmp3);
#line 632
  gtk_toggle_button_set_active((GtkToggleButton *)((void *)__cil_tmp4), 0);
  }
  return;
}
}
#line 638 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void scan_preview(GtkWidget *widget , gpointer call_data ) 
{ 
  GType __cil_tmp3 ;
  GTypeInstance *__cil_tmp4 ;
  Preview *__cil_tmp5 ;
  GType __cil_tmp6 ;
  GTypeInstance *__cil_tmp7 ;
  GType __cil_tmp8 ;
  GTypeInstance *__cil_tmp9 ;

  {
  {
#line 640
  sanei_debug_xscanimage_call(4, "scan_preview\nV");
  }
#line 642
  if (((GtkToggleButton *)((void *)__cil_tmp4))->active) {
#line 644
    if (! scan_win.preview) {
      {
#line 646
      scan_win.preview = preview_new(dialog);
      }
#line 647
      if (scan_win.preview) {
#line 647
        if ((scan_win.preview)->top) {
          {
#line 648
          __cil_tmp6 = gtk_object_get_type();
#line 648
          __cil_tmp7 = g_type_check_instance_cast((GTypeInstance *)(scan_win.preview)->top,
                                                  __cil_tmp6);
#line 648
          gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp7), (gchar *)"destroy",
                                  (GCallback )(& preview_window_destroyed), (GtkCallbackMarshal )((void *)0),
                                  widget, (GDestroyNotify )((void *)0), 0, 0);
          }
        } else {
          {
          {
#line 653
          __cil_tmp8 = gtk_toggle_button_get_type();
          }
          {
#line 653
          __cil_tmp9 = g_type_check_instance_cast((GTypeInstance *)widget, __cil_tmp8);
          }
          {
#line 653
          gtk_toggle_button_set_active((GtkToggleButton *)((void *)__cil_tmp9), 0);
          }
          }
        }
      } else {
        {
        {
#line 653
        __cil_tmp8 = gtk_toggle_button_get_type();
        }
        {
#line 653
        __cil_tmp9 = g_type_check_instance_cast((GTypeInstance *)widget, __cil_tmp8);
        }
        {
#line 653
        gtk_toggle_button_set_active((GtkToggleButton *)((void *)__cil_tmp9), 0);
        }
        }
      }
#line 654
      if (scan_win.progress) {
        {
#line 655
        gtk_widget_set_sensitive((scan_win.preview)->preview, 0);
        }
      }
    }
  } else
#line 658
  if (scan_win.preview) {
    {
#line 660
    preview_destroy(scan_win.preview);
#line 661
    scan_win.preview = (Preview *)0;
    }
  }
  {
#line 663
  sanei_debug_xscanimage_call(4, "scan_preview: finished\n");
  }
  return;
}
}
#line 668 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void advance(void) 
{ 
  int tile_height ;
  guint __cil_tmp2 ;
  int height ;

  {
  {
#line 670
  sanei_debug_xscanimage_call(4, "advance\n\220");
#line 672
  (scan_win.x) ++;
  }
#line 672
  if (scan_win.x >= scan_win.param.pixels_per_line) {
    {
#line 674
    __cil_tmp2 = gimp_tile_height();
#line 674
    tile_height = (int )__cil_tmp2;
#line 676
    scan_win.x = 0;
#line 677
    (scan_win.y) ++;
    }
#line 678
    if (scan_win.y % tile_height == 0) {
      {
#line 680
      gimp_pixel_rgn_set_rect(& scan_win.region, scan_win.tile, 0, scan_win.y - tile_height,
                              scan_win.param.pixels_per_line, tile_height);
      }
#line 684
      if ((unsigned int )scan_win.param.format >= 2U) {
#line 684
        if ((unsigned int )scan_win.param.format <= 4U) {
#line 689
          scan_win.tile_offset %= (unsigned int )3;
#line 690
          if (! scan_win.first_frame) {
#line 693
            height = tile_height;
#line 694
            if (scan_win.y + height >= scan_win.param.lines) {
#line 695
              height = scan_win.param.lines - scan_win.y;
            }
            {
#line 696
            gimp_pixel_rgn_get_rect(& scan_win.region, scan_win.tile, 0, scan_win.y,
                                    scan_win.param.pixels_per_line, height);
            }
          }
        } else {
#line 703
          scan_win.tile_offset = (unsigned int )0;
        }
      } else {
#line 703
        scan_win.tile_offset = (unsigned int )0;
      }
    }
  }
  {
#line 706
  sanei_debug_xscanimage_call(4, "advance: finished\n2\372:V");
  }
  return;
}
}
#line 712 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void write_swapped_words(FILE *f , char *buf , guint len ) 
{ 
  char tmp_buf[2] ;
  char tmp ;
  unsigned int i ;
  char *__cil_tmp7 ;

  {
  {
#line 718
  sanei_debug_xscanimage_call(4, "write_swapped_words\n:V");
  }
#line 719
  if (! len) {
#line 720
    return;
  }
#line 721
  if (scan_win.have_odd_byte) {
    {
#line 723
    __cil_tmp7 = buf;
#line 723
    buf ++;
#line 723
    tmp_buf[0] = *__cil_tmp7;
#line 724
    tmp_buf[1] = (char )scan_win.odd_byte;
#line 725
    fwrite((char *)tmp_buf, (unsigned long )1, (unsigned long )2, f);
#line 726
    len --;
#line 727
    scan_win.have_odd_byte = 0;
    }
  }
#line 729
  if (len) {
#line 731
    i = (unsigned int )1;
    {
#line 731
    while (1) {
      while_continue: /* CIL Label */ ;
#line 731
      if (! (i < len)) {
#line 731
        goto while_break;
      }
#line 733
      tmp = *(buf + i);
#line 734
      *(buf + i) = *(buf + (i - 1U));
#line 735
      *(buf + (i - 1U)) = tmp;
#line 731
      i += (unsigned int )2;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 737
    fwrite(buf, (unsigned long )1, (unsigned long )(len & 4294967294U), f);
    }
#line 738
    if (len & 1U) {
#line 740
      scan_win.have_odd_byte = ! 0;
#line 741
      scan_win.odd_byte = (guint8 )*(buf + (len - 1U));
    }
  }
  {
#line 744
  sanei_debug_xscanimage_call(4, "write_swapped_words: finished\n");
  }
  return;
}
}
#line 748 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void input_available___0(gpointer data , gint source , GdkInputCondition cond ) 
{ 
  SANE_Handle dev ;
  static char buf[32768] ;
  SANE_Status status ;
  SANE_Int len ;
  int i ;
  SANE_Status __cil_tmp9 ;
  gboolean __cil_tmp10 ;
  SANE_String_Const __cil_tmp11 ;
  gboolean __cil_tmp12 ;
  gboolean __cil_tmp13 ;
  u_char mask ;
  int j ;
  u_char gl ;
  int tmp ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  u_char mask___0 ;
  int j___0 ;
  u_char gl___0 ;
  int tmp___0 ;
  unsigned int __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  u_char mask___1 ;
  int j___1 ;
  u_char gl___1 ;
  int tmp___1 ;

  {
  {
#line 750
  dev = dialog->dev;
#line 756
  sanei_debug_xscanimage_call(4, "input_available\n\220");
  }
  {
#line 757
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 759
    status = sane_read(dev, (unsigned char *)((char *)buf), (SANE_Int )sizeof(buf),
                       & len);
    }
#line 760
    if ((unsigned int )status != 0U) {
#line 762
      if ((unsigned int )status == 5U) {
#line 764
        if (! scan_win.param.last_frame) {
#line 766
          if (scan_win.input_tag < 0) {
            {
#line 768
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 768
              __cil_tmp10 = gtk_events_pending();
              }
#line 768
              if (! __cil_tmp10) {
#line 768
                goto while_break___0;
              }
              {
#line 769
              gtk_main_iteration();
              }
            }
            while_break___0: /* CIL Label */ ;
            }
          } else {
            {
#line 773
            gdk_input_remove(scan_win.input_tag);
#line 774
            scan_win.input_tag = - 1;
            }
          }
          {
#line 776
          scan_start___0();
          }
#line 777
          goto while_break;
        }
      } else {
        {
#line 782
        __cil_tmp11 = sane_strstatus(status);
#line 782
        snprintf((char *)buf, sizeof(buf), "Error during read: %s.\377\377\230", __cil_tmp11);
#line 784
        gsg_error((char *)buf);
        }
      }
      {
#line 786
      scan_done___0();
      }
#line 787
      return;
    }
#line 789
    if (! len) {
#line 791
      if (scan_win.input_tag < 0) {
        {
#line 793
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 793
          __cil_tmp12 = gtk_events_pending();
          }
#line 793
          if (! __cil_tmp12) {
#line 793
            goto while_break___1;
          }
          {
#line 794
          gtk_main_iteration();
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 795
        goto while_continue;
      } else {
#line 798
        goto while_break;
      }
    }
    {
#line 801
    scan_win.bytes_read += (unsigned long )len;
#line 802
    progress_update(scan_win.progress, (float )scan_win.bytes_read / (gfloat )scan_win.num_bytes);
    }
#line 804
    if (scan_win.input_tag < 0) {
      {
#line 805
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 805
        __cil_tmp13 = gtk_events_pending();
        }
#line 805
        if (! __cil_tmp13) {
#line 805
          goto while_break___2;
        }
        {
#line 806
        gtk_main_iteration();
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 810
    if ((unsigned int )scan_win.param.format == (unsigned int )0) {
#line 810
      goto case_0;
    }
#line 823
    if ((unsigned int )scan_win.param.format == 1) {
#line 823
      goto case_1;
    }
#line 841
    if ((unsigned int )scan_win.param.format == 8) {
#line 841
      goto case_8;
    }
#line 856
    if ((unsigned int )scan_win.param.format == (unsigned int )1) {
#line 856
      goto case_1___0;
    }
#line 869
    if ((unsigned int )scan_win.param.format == 1) {
#line 869
      goto case_1___1;
    }
#line 890
    if ((unsigned int )scan_win.param.format == 8) {
#line 890
      goto case_8___0;
    }
#line 908
    if ((unsigned int )scan_win.param.format == (unsigned int )4) {
#line 908
      goto case_4;
    }
#line 908
    if ((unsigned int )scan_win.param.format == (unsigned int )3) {
#line 908
      goto case_4;
    }
#line 908
    if ((unsigned int )scan_win.param.format == (unsigned int )2) {
#line 908
      goto case_4;
    }
#line 920
    if ((unsigned int )scan_win.param.format == 1) {
#line 920
      goto case_1___2;
    }
#line 940
    if ((unsigned int )scan_win.param.format == 8) {
#line 940
      goto case_8___1;
    }
#line 953
    goto switch_default___1;
    case_0: /* CIL Label */ 
#line 811
    if (scan_win.mode == 0) {
#line 813
      if (scan_win.param.depth > 8) {
#line 813
        if (little_endian) {
          {
#line 814
          write_swapped_words(scan_win.out, (char *)buf, (guint )len);
          }
        } else {
          {
          {
#line 816
          fwrite((char *)buf, (unsigned long )1, (unsigned long )len, scan_win.out);
          }
          }
        }
      } else {
        {
        {
#line 816
        fwrite((char *)buf, (unsigned long )1, (unsigned long )len, scan_win.out);
        }
        }
      }
    } else {
      {
#line 823
      if (scan_win.param.depth == 1) {
#line 823
        goto case_1;
      }
#line 841
      if (scan_win.param.depth == 8) {
#line 841
        goto case_8;
      }
#line 849
      goto switch_default;
      case_1: /* CIL Label */ 
#line 824
      i = 0;
      {
#line 824
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 824
        if (! (i < len)) {
#line 824
          goto while_break___3;
        }
#line 829
        mask = (u_char )buf[i];
#line 830
        j = 7;
        {
#line 830
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 830
          if (! (j >= 0)) {
#line 830
            goto while_break___4;
          }
#line 832
          if ((int )mask & (1 << j)) {
#line 832
            tmp = 0;
          } else {
#line 832
            tmp = 255;
          }
          {
#line 832
          gl = (u_char )tmp;
#line 833
          __cil_tmp18 = scan_win.tile_offset;
#line 833
          (scan_win.tile_offset) ++;
#line 833
          *(scan_win.tile + __cil_tmp18) = gl;
#line 834
          advance();
          }
#line 835
          if (scan_win.x == 0) {
#line 836
            goto while_break___4;
          }
#line 830
          j --;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 824
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 839
      goto switch_break___0;
      case_8: /* CIL Label */ 
#line 842
      i = 0;
      {
#line 842
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 842
        if (! (i < len)) {
#line 842
          goto while_break___5;
        }
        {
#line 844
        __cil_tmp19 = scan_win.tile_offset;
#line 844
        (scan_win.tile_offset) ++;
#line 844
        *(scan_win.tile + __cil_tmp19) = (guchar )buf[i];
#line 845
        advance();
        }
#line 842
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 847
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 850
      goto bad_depth;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 854
    goto switch_break;
    case_1___0: /* CIL Label */ 
#line 857
    if (scan_win.mode == 0) {
#line 859
      if (scan_win.param.depth > 8) {
#line 859
        if (little_endian) {
          {
#line 860
          write_swapped_words(scan_win.out, (char *)buf, (guint )len);
          }
        } else {
          {
          {
#line 862
          fwrite((char *)buf, (unsigned long )1, (unsigned long )len, scan_win.out);
          }
          }
        }
      } else {
        {
        {
#line 862
        fwrite((char *)buf, (unsigned long )1, (unsigned long )len, scan_win.out);
        }
        }
      }
    } else {
      {
#line 869
      if (scan_win.param.depth == 1) {
#line 869
        goto case_1___1;
      }
#line 890
      if (scan_win.param.depth == 8) {
#line 890
        goto case_8___0;
      }
#line 899
      goto switch_default___0;
      case_1___1: /* CIL Label */ 
#line 870
      if ((unsigned int )scan_win.param.format == 1U) {
#line 871
        goto bad_depth;
      }
#line 872
      i = 0;
      {
#line 872
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 872
        if (! (i < len)) {
#line 872
          goto while_break___6;
        }
#line 877
        mask___0 = (u_char )buf[i];
#line 878
        j___0 = 0;
        {
#line 878
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 878
          if (! (j___0 < 8)) {
#line 878
            goto while_break___7;
          }
#line 880
          if ((int )mask___0 & 1) {
#line 880
            tmp___0 = 255;
          } else {
#line 880
            tmp___0 = 0;
          }
          {
#line 880
          gl___0 = (u_char )tmp___0;
#line 881
          mask___0 >>= 1;
#line 882
          __cil_tmp24 = scan_win.tile_offset;
#line 882
          (scan_win.tile_offset) ++;
#line 882
          *(scan_win.tile + __cil_tmp24) = gl___0;
#line 883
          advance();
          }
#line 884
          if (scan_win.x == 0) {
#line 885
            goto while_break___7;
          }
#line 878
          j___0 ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 872
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 888
      goto switch_break___1;
      case_8___0: /* CIL Label */ 
#line 891
      i = 0;
      {
#line 891
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 891
        if (! (i < len)) {
#line 891
          goto while_break___8;
        }
#line 893
        __cil_tmp25 = scan_win.tile_offset;
#line 893
        (scan_win.tile_offset) ++;
#line 893
        *(scan_win.tile + __cil_tmp25) = (guchar )buf[i];
#line 894
        if (scan_win.tile_offset % 3U == 0U) {
          {
#line 895
          advance();
          }
        }
#line 891
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 897
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
#line 900
      goto bad_depth;
      switch_break___1: /* CIL Label */ ;
      }
    }
#line 904
    goto switch_break;
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 909
    if (scan_win.mode == 0) {
#line 910
      i = 0;
      {
#line 910
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 910
        if (! (i < len)) {
#line 910
          goto while_break___9;
        }
        {
#line 912
        fwrite((char *)buf + i, (unsigned long )1, (unsigned long )1, scan_win.out);
#line 913
        fseek(scan_win.out, (long )2, 1);
        }
#line 910
        i ++;
      }
      while_break___9: /* CIL Label */ ;
      }
    } else {
      {
#line 920
      if (scan_win.param.depth == 1) {
#line 920
        goto case_1___2;
      }
#line 940
      if (scan_win.param.depth == 8) {
#line 940
        goto case_8___1;
      }
#line 918
      goto switch_break___2;
      case_1___2: /* CIL Label */ 
#line 921
      i = 0;
      {
#line 921
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 921
        if (! (i < len)) {
#line 921
          goto while_break___10;
        }
#line 926
        mask___1 = (u_char )buf[i];
#line 927
        j___1 = 0;
        {
#line 927
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 927
          if (! (j___1 < 8)) {
#line 927
            goto while_break___11;
          }
#line 929
          if ((int )mask___1 & 1) {
#line 929
            tmp___1 = 255;
          } else {
#line 929
            tmp___1 = 0;
          }
          {
#line 929
          gl___1 = (u_char )tmp___1;
#line 930
          mask___1 >>= 1;
#line 931
          *(scan_win.tile + scan_win.tile_offset) = gl___1;
#line 932
          scan_win.tile_offset += (unsigned int )3;
#line 933
          advance();
          }
#line 934
          if (scan_win.x == 0) {
#line 935
            goto while_break___11;
          }
#line 927
          j___1 ++;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 921
        i ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 938
      goto switch_break___2;
      case_8___1: /* CIL Label */ 
#line 941
      i = 0;
      {
#line 941
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 941
        if (! (i < len)) {
#line 941
          goto while_break___12;
        }
        {
#line 943
        *(scan_win.tile + scan_win.tile_offset) = (guchar )buf[i];
#line 944
        scan_win.tile_offset += (unsigned int )3;
#line 945
        advance();
        }
#line 941
        i ++;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 947
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
    }
#line 951
    goto switch_break;
    switch_default___1: /* CIL Label */ 
    {
#line 954
    fprintf(stderr, "%s.input_available: bad frame format %d\n\230\001", prog_name,
            (unsigned int )scan_win.param.format);
    }
    {
#line 956
    scan_done___0();
    }
#line 957
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 960
  sanei_debug_xscanimage_call(4, "input_available: finished\n\200\372:V");
  }
#line 961
  return;
  bad_depth: 
  {
#line 965
  snprintf((char *)buf, sizeof(buf), "Cannot handle depth %d.", scan_win.param.depth);
  }
  {
#line 967
  gsg_error((char *)buf);
#line 968
  scan_done___0();
  }
#line 969
  return;
}
}
#line 974 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void scan_done___0(void) 
{ 
  int remaining ;
  guint __cil_tmp2 ;

  {
  {
#line 976
  sanei_debug_xscanimage_call(4, "scan_done\n\363\371:V");
#line 977
  gsg_set_sensitivity(dialog, ! 0);
  }
#line 978
  if (scan_win.preview) {
    {
#line 979
    gtk_widget_set_sensitive((scan_win.preview)->preview, ! 0);
    }
  }
  {
#line 980
  gtk_widget_set_sensitive(scan_win.scan_button, ! 0);
#line 981
  gtk_widget_set_sensitive(scan_win.menubar, ! 0);
  }
#line 983
  if (scan_win.input_tag >= 0) {
    {
#line 985
    gdk_input_remove(scan_win.input_tag);
#line 986
    scan_win.input_tag = - 1;
    }
  }
  {
#line 989
  sane_cancel(dialog->dev);
  }
#line 991
  if (! scan_win.progress) {
#line 992
    return;
  }
  {
#line 994
  progress_free(scan_win.progress);
#line 995
  scan_win.progress = (Progress_t *)0;
#line 996
  scan_win.header_size = (long )0;
  }
#line 998
  if (scan_win.mode == 0) {
    {
#line 1000
    fclose(scan_win.out);
#line 1001
    scan_win.out = (FILE *)0;
    }
  } else {
#line 1009
    if (scan_win.y > scan_win.param.lines) {
#line 1010
      scan_win.y = scan_win.param.lines;
    }
    {
#line 1012
    __cil_tmp2 = gimp_tile_height();
#line 1012
    remaining = (int )((unsigned int )scan_win.y % __cil_tmp2);
    }
#line 1013
    if (remaining) {
      {
#line 1014
      gimp_pixel_rgn_set_rect(& scan_win.region, scan_win.tile, 0, scan_win.y - remaining,
                              scan_win.param.pixels_per_line, remaining);
      }
    }
    {
#line 1017
    gimp_drawable_flush(scan_win.drawable);
#line 1018
    gimp_display_new(scan_win.image_ID);
#line 1019
    gimp_drawable_detach(scan_win.drawable);
#line 1020
    g_free(scan_win.tile);
#line 1021
    scan_win.tile = (guchar *)0;
    }
  }
  {
#line 1024
  sanei_debug_xscanimage_call(4, "scan_done: finished\n:V");
  }
  return;
}
}
#line 1028 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void progress_cancel___0(void) 
{ 


  {
  {
#line 1030
  sanei_debug_xscanimage_call(4, "progress_cancel\n\220");
#line 1031
  sane_cancel(dialog->dev);
#line 1032
  sanei_debug_xscanimage_call(4, "progress_cancel: done\n");
  }
  return;
}
}
#line 1036 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void scan_start___0(void) 
{ 
  SANE_Status status ;
  SANE_Handle dev ;
  SANE_Word resolution ;
  char const   *frame_type ;
  char buf[256] ;
  int fd ;
  int height ;
  int remaining ;
  guint __cil_tmp9 ;
  guint __cil_tmp10 ;
  SANE_Word __cil_tmp11 ;
  gboolean __cil_tmp12 ;
  SANE_Status __cil_tmp13 ;
  SANE_String_Const __cil_tmp14 ;
  SANE_Status __cil_tmp15 ;
  SANE_String_Const __cil_tmp16 ;
  int tmp ;
  int tmp___0 ;
  long __cil_tmp19 ;
  size_t tile_size ;
  guint __cil_tmp21 ;
  GimpImageType image_type ;
  GimpImageType drawable_type ;
  gint32 layer_ID ;
  gint32 __cil_tmp25 ;
  gint32 __cil_tmp26 ;
  GimpDrawable *__cil_tmp27 ;
  Progress_t *__cil_tmp28 ;
  SANE_Status __cil_tmp29 ;
  SANE_Status __cil_tmp30 ;
  gint __cil_tmp31 ;
  gboolean __cil_tmp32 ;

  {
  {
#line 1039
  dev = dialog->dev;
#line 1045
  frame_type = (char const   *)0;
#line 1049
  sanei_debug_xscanimage_call(4, "scan_start\n\372:V");
#line 1051
  gsg_set_sensitivity(dialog, 0);
  }
#line 1052
  if (scan_win.preview) {
    {
#line 1053
    gtk_widget_set_sensitive((scan_win.preview)->preview, 0);
    }
  }
  {
#line 1054
  gtk_widget_set_sensitive(scan_win.scan_button, 0);
#line 1055
  gtk_widget_set_sensitive(scan_win.menubar, 0);
  }
#line 1058
  if (scan_win.tile) {
#line 1058
    if (scan_win.mode == 1) {
#line 1064
      if (scan_win.y > scan_win.param.lines) {
#line 1065
        scan_win.y = scan_win.param.lines;
      }
      {
#line 1067
      __cil_tmp9 = gimp_tile_height();
#line 1067
      remaining = (int )((unsigned int )scan_win.y % __cil_tmp9);
      }
#line 1068
      if (remaining) {
        {
#line 1069
        gimp_pixel_rgn_set_rect(& scan_win.region, scan_win.tile, 0, scan_win.y - remaining,
                                scan_win.param.pixels_per_line, remaining);
        }
      }
      {
#line 1075
      __cil_tmp10 = gimp_tile_height();
#line 1075
      height = (int )__cil_tmp10;
      }
#line 1076
      if (height >= scan_win.param.lines) {
#line 1077
        height = scan_win.param.lines;
      }
      {
#line 1078
      gimp_pixel_rgn_get_rect(& scan_win.region, scan_win.tile, 0, 0, scan_win.param.pixels_per_line,
                              height);
      }
    }
  }
  {
#line 1084
  resolution = get_resolution(dev);
#line 1087
  scan_win.y = 0;
#line 1087
  scan_win.x = scan_win.y;
  }
  {
#line 1089
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1089
    __cil_tmp12 = gtk_events_pending();
    }
#line 1089
    if (! __cil_tmp12) {
#line 1089
      goto while_break;
    }
    {
#line 1090
    gtk_main_iteration();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1091
  status = sane_start(dev);
  }
#line 1092
  if ((unsigned int )status != 0U) {
    {
#line 1094
    gsg_set_sensitivity(dialog, ! 0);
#line 1095
    __cil_tmp14 = sane_strstatus(status);
#line 1095
    snprintf((char *)buf, sizeof(buf), "Failed to start scanner: %s\372:V", __cil_tmp14);
#line 1097
    gsg_error((char *)buf);
    }
#line 1098
    return;
  }
  {
#line 1101
  status = sane_get_parameters(dev, & scan_win.param);
  }
#line 1102
  if ((unsigned int )status != 0U) {
    {
#line 1104
    gsg_set_sensitivity(dialog, ! 0);
#line 1105
    __cil_tmp16 = sane_strstatus(status);
#line 1105
    snprintf((char *)buf, sizeof(buf), "Failed to get parameters: %s:V", __cil_tmp16);
#line 1107
    gsg_error((char *)buf);
#line 1108
    scan_done___0();
    }
#line 1109
    return;
  }
#line 1112
  if (scan_win.param.lines == -1) {
    {
#line 1114
    gsg_set_sensitivity(dialog, ! 0);
#line 1115
    snprintf((char *)buf, sizeof(buf), "Hand-Scanner mode not supported\377\220");
#line 1116
    gsg_error((char *)buf);
#line 1117
    scan_done___0();
    }
#line 1118
    return;
  }
#line 1121
  scan_win.num_bytes = (size_t )(scan_win.param.lines * scan_win.param.bytes_per_line);
#line 1122
  scan_win.bytes_read = (size_t )0;
#line 1123
  scan_win.have_odd_byte = 0;
  {
#line 1127
  if ((unsigned int )scan_win.param.format == (unsigned int )1) {
#line 1127
    goto case_1;
  }
#line 1130
  if ((unsigned int )scan_win.param.format == (unsigned int )2) {
#line 1130
    goto case_2;
  }
#line 1133
  if ((unsigned int )scan_win.param.format == (unsigned int )3) {
#line 1133
    goto case_3;
  }
#line 1136
  if ((unsigned int )scan_win.param.format == (unsigned int )4) {
#line 1136
    goto case_4;
  }
#line 1139
  if ((unsigned int )scan_win.param.format == (unsigned int )0) {
#line 1139
    goto case_0;
  }
#line 1125
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1128
  frame_type = "RGB\377\377\377\377\377\220";
#line 1129
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1131
  frame_type = "red\372:V";
#line 1132
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1134
  frame_type = "greenV";
#line 1135
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1137
  frame_type = "blue\377\377\377\377\220";
#line 1138
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1140
  frame_type = "gray:V";
#line 1141
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1144
  if (scan_win.mode == 0) {
#line 1146
    if (! scan_win.header_size) {
      {
#line 1152
      if ((unsigned int )scan_win.param.format == (unsigned int )4) {
#line 1152
        goto case_4___0;
      }
#line 1152
      if ((unsigned int )scan_win.param.format == (unsigned int )3) {
#line 1152
        goto case_4___0;
      }
#line 1152
      if ((unsigned int )scan_win.param.format == (unsigned int )2) {
#line 1152
        goto case_4___0;
      }
#line 1163
      if ((unsigned int )scan_win.param.format == (unsigned int )1) {
#line 1163
        goto case_1___0;
      }
#line 1169
      if ((unsigned int )scan_win.param.format == (unsigned int )0) {
#line 1169
        goto case_0___0;
      }
#line 1148
      goto switch_break___0;
      case_4___0: /* CIL Label */ 
      case_3___0: /* CIL Label */ 
      case_2___0: /* CIL Label */ 
#line 1153
      if (scan_win.param.depth > 8) {
        {
#line 1155
        gsg_set_sensitivity(dialog, ! 0);
#line 1156
        snprintf((char *)buf, sizeof(buf), "Separate channel transfers are not supported with %d bits/channel.",
                 scan_win.param.depth);
#line 1159
        gsg_error((char *)buf);
#line 1160
        scan_done___0();
        }
#line 1161
        return;
      }
      case_1___0: /* CIL Label */ 
#line 1164
      if (scan_win.param.depth <= 8) {
#line 1164
        tmp = 255;
      } else {
#line 1164
        tmp = 65535;
      }
      {
#line 1164
      fprintf(scan_win.out, "P6\n# SANE data follows\n%d %d\n%d\n\230\001", scan_win.param.pixels_per_line,
              scan_win.param.lines, tmp);
      }
#line 1167
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 1170
      if (scan_win.param.depth == 1) {
        {
#line 1171
        fprintf(scan_win.out, "P4\n# SANE data follows\n%d %d\nV", scan_win.param.pixels_per_line,
                scan_win.param.lines);
        }
      } else {
#line 1175
        if (scan_win.param.depth <= 8) {
#line 1175
          tmp___0 = 255;
        } else {
#line 1175
          tmp___0 = 65535;
        }
        {
#line 1175
        fprintf(scan_win.out, "P5\n# SANE data follows\n%d %d\n%d\n\230\001", scan_win.param.pixels_per_line,
                scan_win.param.lines, tmp___0);
        }
      }
#line 1178
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 1180
      scan_win.header_size = ftell(scan_win.out);
      }
    }
#line 1182
    if ((unsigned int )scan_win.param.format >= 2U) {
#line 1182
      if ((unsigned int )scan_win.param.format <= 4U) {
        {
#line 1184
        fseek(scan_win.out, (scan_win.header_size + (long )scan_win.param.format) - 2L,
              0);
        }
      }
    }
    {
#line 1187
    snprintf((char *)buf, sizeof(buf), "Receiving %s data for `%s\'...V", frame_type,
             preferences.filename);
    }
  } else {
#line 1197
    if (scan_win.param.depth > 8) {
      {
#line 1199
      gsg_set_sensitivity(dialog, ! 0);
#line 1200
      snprintf((char *)buf, sizeof(buf), "The Gimp doesn\'t support images with %d bits/channel.\377\377\377\377\377\377\377\230\001",
               scan_win.param.depth);
#line 1202
      gsg_error((char *)buf);
      }
#line 1203
      return;
    }
    {
#line 1206
    scan_win.tile_offset = (unsigned int )0;
#line 1207
    __cil_tmp21 = gimp_tile_height();
#line 1207
    tile_size = (size_t )((unsigned int )scan_win.param.pixels_per_line * __cil_tmp21);
    }
#line 1208
    if ((unsigned int )scan_win.param.format != 0U) {
#line 1209
      tile_size *= (unsigned long )3;
    }
#line 1210
    if (scan_win.tile) {
#line 1211
      scan_win.first_frame = 0;
    } else {
#line 1214
      image_type = (GimpImageType )0;
#line 1215
      drawable_type = (GimpImageType )0;
#line 1218
      if ((unsigned int )scan_win.param.format == 0U) {
#line 1220
        image_type = (GimpImageType )1;
#line 1221
        drawable_type = (GimpImageType )2;
      }
      {
#line 1224
      scan_win.image_ID = gimp_image_new(scan_win.param.pixels_per_line, scan_win.param.lines,
                                         (GimpImageBaseType )image_type);
      }
#line 1230
      if (resolution > 0) {
        {
#line 1231
        gimp_image_set_resolution(scan_win.image_ID, (gdouble )resolution, (gdouble )resolution);
        }
      }
      {
#line 1235
      layer_ID = gimp_layer_new(scan_win.image_ID, (gchar *)"Background\333\371:V",
                                scan_win.param.pixels_per_line, scan_win.param.lines,
                                drawable_type, (gdouble )100, (GimpLayerMode )0);
#line 1239
      gimp_image_add_layer(scan_win.image_ID, layer_ID, 0);
#line 1241
      scan_win.drawable = gimp_drawable_get(layer_ID);
#line 1242
      gimp_pixel_rgn_init(& scan_win.region, scan_win.drawable, 0, 0, (gint )(scan_win.drawable)->width,
                          (gint )(scan_win.drawable)->height, ! 0, 0);
#line 1245
      scan_win.tile = (guchar *)0;
#line 1246
      scan_win.first_frame = 1;
      }
    }
#line 1248
    if ((unsigned int )scan_win.param.format >= 2U) {
#line 1248
      if ((unsigned int )scan_win.param.format <= 4U) {
#line 1250
        scan_win.tile_offset = (unsigned int )scan_win.param.format - 2U;
      }
    }
    {
#line 1251
    snprintf((char *)buf, sizeof(buf), "Receiving %s data for GIMP...\377\377\377\230\001",
             frame_type);
    }
  }
#line 1255
  if (scan_win.progress) {
    {
#line 1256
    progress_free(scan_win.progress);
    }
  }
  {
#line 1257
  scan_win.progress = progress_new("Scanning\230\001", (char *)buf, (GtkSignalFunc )(& progress_cancel___0),
                                   (void *)0);
#line 1260
  scan_win.input_tag = - 1;
#line 1261
  __cil_tmp30 = sane_get_select_fd(dev, & fd);
  }
  {
#line 1261
  __cil_tmp29 = sane_set_io_mode(dev, 1);
  }
#line 1261
  if ((unsigned int )__cil_tmp29 == 0U) {
#line 1261
    if ((unsigned int )__cil_tmp30 == 0U) {
      {
#line 1263
      scan_win.input_tag = gdk_input_add(fd, (GdkInputCondition )5, & input_available___0,
                                         (gpointer )0);
      }
    } else {
#line 1261
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1268
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1268
      __cil_tmp32 = gtk_events_pending();
      }
#line 1268
      if (! __cil_tmp32) {
#line 1268
        goto while_break___0;
      }
      {
#line 1269
      gtk_main_iteration();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1270
    input_available___0((gpointer )0, - 1, (GdkInputCondition )1);
    }
  }
  {
#line 1272
  sanei_debug_xscanimage_call(4, "scan_start: finished\nV");
  }
  return;
}
}
#line 1277 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void scan_dialog(GtkWidget *widget , gpointer call_data ) 
{ 
  char buf[256] ;
  char testfilename[256] ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  FILE *__cil_tmp13 ;
  int *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 1282
  sanei_debug_xscanimage_call(4, "scan_dialog\n:V");
  }
#line 1283
  if (scan_win.mode == 0) {
    {
#line 1286
    strncpy((char *)testfilename, preferences.filename, sizeof(testfilename));
#line 1287
    testfilename[sizeof(testfilename) - 1UL] = (char )0;
#line 1288
    g_strreverse((char *)testfilename);
#line 1289
    __cil_tmp12 = strncmp((char const   *)((char *)testfilename), "MPP.\377\377\377\377\251",
                          (unsigned long )4);
    }
    {
#line 1289
    __cil_tmp11 = strncmp((char const   *)((char *)testfilename), "MBP.:V", (unsigned long )4);
    }
    {
#line 1289
    __cil_tmp10 = strncmp((char const   *)((char *)testfilename), "MGP.\377\377\377\377\251",
                          (unsigned long )4);
    }
    {
#line 1289
    __cil_tmp9 = strncmp((char const   *)((char *)testfilename), "MNP.:V", (unsigned long )4);
    }
    {
#line 1289
    __cil_tmp8 = strncmp((char const   *)((char *)testfilename), "mpp.:V", (unsigned long )4);
    }
    {
#line 1289
    __cil_tmp7 = strncmp((char const   *)((char *)testfilename), "mbp.:V", (unsigned long )4);
    }
    {
#line 1289
    __cil_tmp6 = strncmp((char const   *)((char *)testfilename), "mgp.:V", (unsigned long )4);
    }
    {
#line 1289
    __cil_tmp5 = strncmp((char const   *)((char *)testfilename), "mnp.:V", (unsigned long )4);
    }
#line 1289
    if (! (((((((! __cil_tmp5 || ! __cil_tmp6) || ! __cil_tmp7) || ! __cil_tmp8) || ! __cil_tmp9) || ! __cil_tmp10) || ! __cil_tmp11) || ! __cil_tmp12)) {
      {
#line 1298
      snprintf((char *)buf, sizeof(buf), "Failed to scan, wrong file extension, use pnm, pgm, pbm or ppm `%s\'\377\377\377\377\377\230\001",
               preferences.filename);
#line 1301
      gsg_error((char *)buf);
      }
#line 1302
      return;
    }
    {
#line 1304
    scan_win.out = fopen(preferences.filename, "w\020\212\372:V");
    }
#line 1305
    if (! scan_win.out) {
      {
#line 1307
      __cil_tmp14 = __errno_location();
#line 1307
      __cil_tmp15 = strerror(*__cil_tmp14);
#line 1307
      snprintf((char *)buf, sizeof(buf), "Failed to open `%s\': %s", preferences.filename,
               __cil_tmp15);
#line 1309
      gsg_error((char *)buf);
      }
#line 1310
      return;
    }
  }
  {
#line 1313
  gsg_sync(dialog);
#line 1314
  scan_start___0();
#line 1315
  sanei_debug_xscanimage_call(4, "scan_dialog: finished\n\377\377\220");
  }
  return;
}
}
#line 1348 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void files_exit_callback(GtkWidget *widget , gpointer data ) 
{ 


  {
  {
#line 1350
  quit_xscanimage();
  }
  return;
}
}
#line 1354 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static GtkWidget *files_build_menu(void) 
{ 
  GtkWidget *menu ;
  GtkWidget *item ;
  GtkWidget *__cil_tmp3 ;
  GtkWidget *__cil_tmp4 ;
  GType __cil_tmp5 ;
  GTypeInstance *__cil_tmp6 ;
  GtkWidget *__cil_tmp7 ;
  GType __cil_tmp8 ;
  GTypeInstance *__cil_tmp9 ;
  GType __cil_tmp10 ;
  GTypeInstance *__cil_tmp11 ;

  {
  {
#line 1358
  sanei_debug_xscanimage_call(4, "files_build_menu\n\241?\372:V");
#line 1359
  menu = gtk_menu_new();
#line 1361
  item = gtk_menu_item_new();
#line 1362
  __cil_tmp5 = gtk_container_get_type();
#line 1362
  __cil_tmp6 = g_type_check_instance_cast((GTypeInstance *)menu, __cil_tmp5);
#line 1362
  gtk_container_add((GtkContainer *)((void *)__cil_tmp6), item);
#line 1363
  gtk_widget_show(item);
#line 1365
  item = gtk_menu_item_new_with_label((gchar *)"Exit\377\377\377\377\220\036x\372:V");
#line 1366
  __cil_tmp8 = gtk_container_get_type();
#line 1366
  __cil_tmp9 = g_type_check_instance_cast((GTypeInstance *)menu, __cil_tmp8);
#line 1366
  gtk_container_add((GtkContainer *)((void *)__cil_tmp9), item);
#line 1367
  __cil_tmp10 = gtk_object_get_type();
#line 1367
  __cil_tmp11 = g_type_check_instance_cast((GTypeInstance *)item, __cil_tmp10);
#line 1367
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp11), (gchar *)"activate\310\001\374\377\377\377\377\377",
                          (GtkSignalFunc )(& files_exit_callback), (GtkCallbackMarshal )((void *)0),
                          (gpointer )0, (GDestroyNotify )((void *)0), 0, 0);
#line 1369
  gtk_widget_show(item);
#line 1371
  sanei_debug_xscanimage_call(4, "files_build_menu: finished\n");
  }
#line 1372
  return (menu);
}
}
#line 1376 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void pref_set_unit_callback(GtkWidget *widget , gpointer data ) 
{ 
  char const   *unit ;
  double unit_conversion_factor ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 1378
  unit = data;
#line 1379
  unit_conversion_factor = 1.;
#line 1381
  sanei_debug_xscanimage_call(4, "pref_set_unit_callback\n");
#line 1383
  __cil_tmp5 = strcmp(unit, "cm");
  }
#line 1383
  if (__cil_tmp5 == 0) {
#line 1384
    unit_conversion_factor = 10.;
  } else {
    {
#line 1385
    __cil_tmp6 = strcmp(unit, "in");
    }
#line 1385
    if (__cil_tmp6 == 0) {
#line 1386
      unit_conversion_factor = 25.4;
    }
  }
  {
#line 1388
  preferences.length_unit = unit_conversion_factor;
#line 1390
  gsg_refresh_dialog(dialog);
  }
#line 1391
  if (scan_win.preview) {
    {
#line 1392
    preview_update(scan_win.preview);
    }
  }
  {
#line 1394
  pref_xscanimage_save();
#line 1395
  sanei_debug_xscanimage_call(4, "pref_set_unit_callback: finished\n");
  }
  return;
}
}
#line 1399 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void update_int_callback(GtkWidget *widget , gpointer data ) 
{ 
  int *valuep ;
  GType __cil_tmp4 ;
  GTypeInstance *__cil_tmp5 ;

  {
#line 1401
  valuep = data;
#line 1403
  *valuep = (int )((GtkToggleButton *)((void *)__cil_tmp5))->active != 0;
  return;
}
}
#line 1407 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void update_double_callback(GtkWidget *widget , gpointer data ) 
{ 
  double *valuep ;
  char const   *start ;
  char *end ;
  double v ;
  GType __cil_tmp7 ;
  GTypeInstance *__cil_tmp8 ;
  gchar *__cil_tmp9 ;
  double __cil_tmp10 ;

  {
  {
#line 1409
  valuep = data;
#line 1414
  __cil_tmp7 = gtk_entry_get_type();
#line 1414
  __cil_tmp8 = g_type_check_instance_cast((GTypeInstance *)widget, __cil_tmp7);
#line 1414
  __cil_tmp9 = gtk_entry_get_text((GtkEntry *)((void *)__cil_tmp8));
#line 1414
  start = __cil_tmp9;
  }
#line 1415
  if (! start) {
#line 1416
    return;
  }
  {
#line 1418
  v = strtod(start, & end);
  }
#line 1419
  if (end > start) {
#line 1420
    *valuep = v;
  }
  return;
}
}
#line 1424 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void preview_options_ok_callback(GtkWidget *widget , gpointer data ) 
{ 
  GtkWidget *dialog___5 ;
  char buf[1024] ;

  {
  {
#line 1426
  dialog___5 = data;
#line 1429
  sanei_debug_xscanimage_call(4, "preview_options_ok_callback\n");
  }
#line 1432
  if (preferences.preview_gamma < 0.) {
    {
    {
#line 1434
    snprintf((char *)buf, sizeof(buf), "Gamma value %g is < 0 or > 255, please change!",
             preferences.preview_gamma);
    }
    {
#line 1437
    gsg_warning((char *)buf);
    }
    }
#line 1438
    return;
  } else
#line 1432
  if (preferences.preview_gamma > 255.) {
    {
    {
#line 1434
    snprintf((char *)buf, sizeof(buf), "Gamma value %g is < 0 or > 255, please change!",
             preferences.preview_gamma);
    }
    {
#line 1437
    gsg_warning((char *)buf);
    }
    }
#line 1438
    return;
  }
  {
#line 1442
  gtk_widget_destroy(dialog___5);
#line 1443
  pref_xscanimage_save();
#line 1446
  snprintf((char *)buf, sizeof(buf), "It is necessary to restart %s for the changes to take effect.",
           prog_name);
#line 1449
  gsg_warning((char *)buf);
#line 1450
  sanei_debug_xscanimage_call(4, "preview_options_ok_callback: finished\n");
  }
  return;
}
}
#line 1454 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void preview_options_cancel_callback(GtkWidget *widget , gpointer data ) 
{ 
  GtkWidget *dialog___6 ;

  {
  {
#line 1456
  dialog___6 = data;
#line 1458
  gtk_widget_destroy(dialog___6);
  }
  return;
}
}
#line 1462 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void preview_options_dialog(GtkWidget *widget , gpointer data ) 
{ 
  GtkWidget *dialog___7 ;
  GtkWidget *vbox ;
  GtkWidget *hbox ;
  GtkWidget *button ;
  GtkWidget *label ;
  GtkWidget *text ;
  char buf[64] ;
  GtkWidget *__cil_tmp10 ;
  GType __cil_tmp11 ;
  GTypeInstance *__cil_tmp12 ;
  GType __cil_tmp13 ;
  GTypeInstance *__cil_tmp14 ;
  GtkWidget *__cil_tmp15 ;
  GType __cil_tmp16 ;
  GTypeInstance *__cil_tmp17 ;
  GtkWidget *__cil_tmp18 ;
  GType __cil_tmp19 ;
  GTypeInstance *__cil_tmp20 ;
  GType __cil_tmp21 ;
  GTypeInstance *__cil_tmp22 ;
  GType __cil_tmp23 ;
  GTypeInstance *__cil_tmp24 ;
  GtkWidget *__cil_tmp25 ;
  GType __cil_tmp26 ;
  GTypeInstance *__cil_tmp27 ;
  GtkWidget *__cil_tmp28 ;
  GType __cil_tmp29 ;
  GTypeInstance *__cil_tmp30 ;
  GType __cil_tmp31 ;
  GTypeInstance *__cil_tmp32 ;
  GType __cil_tmp33 ;
  GTypeInstance *__cil_tmp34 ;
  GtkWidget *__cil_tmp35 ;
  GType __cil_tmp36 ;
  GTypeInstance *__cil_tmp37 ;
  GtkWidget *__cil_tmp38 ;
  GType __cil_tmp39 ;
  GTypeInstance *__cil_tmp40 ;
  GtkWidget *__cil_tmp41 ;
  GType __cil_tmp42 ;
  GTypeInstance *__cil_tmp43 ;
  GType __cil_tmp44 ;
  GTypeInstance *__cil_tmp45 ;
  GType __cil_tmp46 ;
  GTypeInstance *__cil_tmp47 ;
  GType __cil_tmp48 ;
  GTypeInstance *__cil_tmp49 ;
  GtkWidget *__cil_tmp50 ;
  GType __cil_tmp51 ;
  GTypeInstance *__cil_tmp52 ;
  GType __cil_tmp53 ;
  GTypeInstance *__cil_tmp54 ;
  GType __cil_tmp55 ;
  GTypeInstance *__cil_tmp56 ;
  GtkWidget *__cil_tmp57 ;
  GType __cil_tmp58 ;
  GTypeInstance *__cil_tmp59 ;
  GType __cil_tmp60 ;
  GTypeInstance *__cil_tmp61 ;

  {
  {
#line 1467
  sanei_debug_xscanimage_call(4, "preview_options_dialog\n");
#line 1468
  dialog___7 = gtk_dialog_new();
#line 1469
  sprintf((char *)buf, "%s preview options", prog_name);
#line 1470
  __cil_tmp11 = gtk_window_get_type();
#line 1470
  __cil_tmp12 = g_type_check_instance_cast((GTypeInstance *)dialog___7, __cil_tmp11);
#line 1470
  gtk_window_set_title((GtkWindow *)((void *)__cil_tmp12), (char *)buf);
#line 1472
  vbox = ((GtkDialog *)((void *)__cil_tmp14))->vbox;
#line 1476
  hbox = gtk_hbox_new(0, 0);
#line 1477
  __cil_tmp16 = gtk_box_get_type();
#line 1477
  __cil_tmp17 = g_type_check_instance_cast((GTypeInstance *)vbox, __cil_tmp16);
#line 1477
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp17), hbox, ! 0, ! 0, (guint )2);
#line 1478
  button = gtk_check_button_new_with_label((gchar *)"Preserve preview image");
#line 1479
  __cil_tmp19 = gtk_object_get_type();
#line 1479
  __cil_tmp20 = g_type_check_instance_cast((GTypeInstance *)button, __cil_tmp19);
#line 1479
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp20), (gchar *)"toggled",
                          (GtkSignalFunc )(& update_int_callback), (GtkCallbackMarshal )((void *)0),
                          & preferences.preserve_preview, (GDestroyNotify )((void *)0),
                          0, 0);
#line 1482
  __cil_tmp21 = gtk_toggle_button_get_type();
#line 1482
  __cil_tmp22 = g_type_check_instance_cast((GTypeInstance *)button, __cil_tmp21);
#line 1482
  gtk_toggle_button_set_active((GtkToggleButton *)((void *)__cil_tmp22), preferences.preserve_preview);
#line 1484
  __cil_tmp23 = gtk_box_get_type();
#line 1484
  __cil_tmp24 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp23);
#line 1484
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp24), button, ! 0, ! 0, (guint )2);
#line 1486
  gtk_widget_show(button);
#line 1487
  gtk_widget_show(hbox);
#line 1491
  hbox = gtk_hbox_new(0, 0);
#line 1492
  __cil_tmp26 = gtk_box_get_type();
#line 1492
  __cil_tmp27 = g_type_check_instance_cast((GTypeInstance *)vbox, __cil_tmp26);
#line 1492
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp27), hbox, ! 0, ! 0, (guint )2);
#line 1493
  button = gtk_check_button_new_with_label((gchar *)"Use private colormap");
#line 1494
  __cil_tmp29 = gtk_object_get_type();
#line 1494
  __cil_tmp30 = g_type_check_instance_cast((GTypeInstance *)button, __cil_tmp29);
#line 1494
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp30), (gchar *)"toggled",
                          (GtkSignalFunc )(& update_int_callback), (GtkCallbackMarshal )((void *)0),
                          & preferences.preview_own_cmap, (GDestroyNotify )((void *)0),
                          0, 0);
#line 1497
  __cil_tmp31 = gtk_toggle_button_get_type();
#line 1497
  __cil_tmp32 = g_type_check_instance_cast((GTypeInstance *)button, __cil_tmp31);
#line 1497
  gtk_toggle_button_set_active((GtkToggleButton *)((void *)__cil_tmp32), preferences.preview_own_cmap);
#line 1499
  __cil_tmp33 = gtk_box_get_type();
#line 1499
  __cil_tmp34 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp33);
#line 1499
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp34), button, ! 0, ! 0, (guint )2);
#line 1501
  gtk_widget_show(button);
#line 1502
  gtk_widget_show(hbox);
#line 1506
  hbox = gtk_hbox_new(0, 0);
#line 1507
  __cil_tmp36 = gtk_box_get_type();
#line 1507
  __cil_tmp37 = g_type_check_instance_cast((GTypeInstance *)vbox, __cil_tmp36);
#line 1507
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp37), hbox, ! 0, ! 0, (guint )2);
#line 1508
  gtk_widget_show(hbox);
#line 1510
  label = gtk_label_new((gchar *)"Gamma correction value");
#line 1511
  __cil_tmp39 = gtk_box_get_type();
#line 1511
  __cil_tmp40 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp39);
#line 1511
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp40), label, 0, 0, (guint )2);
#line 1512
  gtk_widget_show(label);
#line 1514
  sprintf((char *)buf, "%g", preferences.preview_gamma);
#line 1515
  text = gtk_entry_new();
#line 1516
  __cil_tmp42 = gtk_entry_get_type();
#line 1516
  __cil_tmp43 = g_type_check_instance_cast((GTypeInstance *)text, __cil_tmp42);
#line 1516
  gtk_entry_set_text((GtkEntry *)((void *)__cil_tmp43), (char *)buf);
#line 1517
  __cil_tmp44 = gtk_box_get_type();
#line 1517
  __cil_tmp45 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp44);
#line 1517
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp45), text, ! 0, ! 0, (guint )2);
#line 1518
  __cil_tmp46 = gtk_object_get_type();
#line 1518
  __cil_tmp47 = g_type_check_instance_cast((GTypeInstance *)text, __cil_tmp46);
#line 1518
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp47), (gchar *)"changed",
                          (GtkSignalFunc )(& update_double_callback), (GtkCallbackMarshal )((void *)0),
                          & preferences.preview_gamma, (GDestroyNotify )((void *)0),
                          0, 0);
#line 1521
  gtk_widget_show(text);
#line 1524
  hbox = ((GtkDialog *)((void *)__cil_tmp49))->action_area;
#line 1526
  button = gtk_button_new_with_label((gchar *)"OK");
  }
  {
#line 1527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1527
    ((GtkObject *)((void *)__cil_tmp52))->flags |= (unsigned int )8192;
#line 1527
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1528
  __cil_tmp53 = gtk_object_get_type();
#line 1528
  __cil_tmp54 = g_type_check_instance_cast((GTypeInstance *)button, __cil_tmp53);
#line 1528
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp54), (gchar *)"clicked",
                          (GtkSignalFunc )(& preview_options_ok_callback), (GtkCallbackMarshal )((void *)0),
                          dialog___7, (GDestroyNotify )((void *)0), 0, 0);
#line 1530
  __cil_tmp55 = gtk_box_get_type();
#line 1530
  __cil_tmp56 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp55);
#line 1530
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp56), button, ! 0, ! 0, (guint )0);
#line 1531
  gtk_widget_grab_default(button);
#line 1532
  gtk_widget_show(button);
#line 1534
  button = gtk_button_new_with_label((gchar *)"Cancel");
#line 1535
  __cil_tmp58 = gtk_object_get_type();
#line 1535
  __cil_tmp59 = g_type_check_instance_cast((GTypeInstance *)button, __cil_tmp58);
#line 1535
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp59), (gchar *)"clicked",
                          (GtkSignalFunc )(& preview_options_cancel_callback), (GtkCallbackMarshal )((void *)0),
                          dialog___7, (GDestroyNotify )((void *)0), 0, 0);
#line 1538
  __cil_tmp60 = gtk_box_get_type();
#line 1538
  __cil_tmp61 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp60);
#line 1538
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp61), button, ! 0, ! 0, (guint )0);
#line 1539
  gtk_widget_show(button);
#line 1541
  gtk_widget_show(dialog___7);
#line 1542
  sanei_debug_xscanimage_call(4, "preview_options_dialog: finished\n");
  }
  return;
}
}
#line 1546 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void pref_device_save(GtkWidget *widget , gpointer data ) 
{ 
  char filename[4096] ;
  int fd ;
  int __cil_tmp5 ;
  char buf[256] ;
  int *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1551
  sanei_debug_xscanimage_call(4, "pref_device_save\n");
#line 1552
  gsg_make_path(sizeof(filename), (char *)filename, "xscanimage", (char const   *)0,
                dialog->dev_name, ".rc");
#line 1554
  fd = open((char const   *)((char *)filename), 577, 438);
  }
#line 1555
  if (fd < 0) {
    {
#line 1559
    __cil_tmp7 = __errno_location();
#line 1559
    __cil_tmp8 = strerror(*__cil_tmp7);
#line 1559
    snprintf((char *)buf, sizeof(buf), "Failed to create file: %s.", __cil_tmp8);
#line 1561
    gsg_error((char *)buf);
    }
#line 1562
    return;
  }
  {
#line 1564
  gsg_sync(dialog);
#line 1565
  sanei_save_values(fd, dialog->dev);
#line 1566
  close(fd);
#line 1567
  sanei_debug_xscanimage_call(4, "pref_device_save: finished\n");
  }
  return;
}
}
#line 1571 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void pref_device_restore(void) 
{ 
  char filename[4096] ;
  int fd ;
  int __cil_tmp3 ;

  {
  {
#line 1576
  sanei_debug_xscanimage_call(4, "pref_device_restore\n");
#line 1577
  gsg_make_path(sizeof(filename), (char *)filename, "xscanimage", (char const   *)0,
                dialog->dev_name, ".rc");
#line 1579
  fd = open((char const   *)((char *)filename), 0);
  }
#line 1580
  if (fd < 0) {
#line 1581
    return;
  }
  {
#line 1582
  sanei_load_values(fd, dialog->dev);
#line 1583
  close(fd);
#line 1585
  gsg_refresh_dialog(dialog);
#line 1586
  sanei_debug_xscanimage_call(4, "pref_device_restore: finished\n");
  }
  return;
}
}
#line 1590 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void pref_toggle_advanced(GtkWidget *widget , gpointer data ) 
{ 
  GType __cil_tmp3 ;
  GTypeInstance *__cil_tmp4 ;

  {
  {
#line 1592
  preferences.advanced = (int )((GtkCheckMenuItem *)((void *)__cil_tmp4))->active != 0;
#line 1593
  gsg_set_advanced(dialog, preferences.advanced);
#line 1594
  pref_xscanimage_save();
  }
  return;
}
}
#line 1598 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void pref_toggle_tooltips(GtkWidget *widget , gpointer data ) 
{ 
  GType __cil_tmp3 ;
  GTypeInstance *__cil_tmp4 ;

  {
  {
#line 1600
  preferences.tooltips_enabled = (int )((GtkCheckMenuItem *)((void *)__cil_tmp4))->active != 0;
#line 1601
  gsg_set_tooltips(dialog, preferences.tooltips_enabled);
#line 1602
  pref_xscanimage_save();
  }
  return;
}
}
#line 1606 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void pref_toggle_twocolumn(GtkWidget *widget , gpointer data ) 
{ 
  GType __cil_tmp3 ;
  GTypeInstance *__cil_tmp4 ;

  {
  {
#line 1608
  preferences.twocolumn_enabled = (int )((GtkCheckMenuItem *)((void *)__cil_tmp4))->active != 0;
#line 1609
  gsg_set_twocolumn(dialog, preferences.twocolumn_enabled);
#line 1610
  pref_xscanimage_save();
  }
  return;
}
}
#line 1614 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static GtkWidget *pref_build_menu(void) 
{ 
  GtkWidget *menu ;
  GtkWidget *item ;
  GtkWidget *submenu ;
  GtkWidget *unit_mm ;
  GtkWidget *unit_cm ;
  GtkWidget *unit_in ;
  GSList *units_group ;
  double unit ;
  GtkWidget *__cil_tmp9 ;
  GtkWidget *__cil_tmp10 ;
  GType __cil_tmp11 ;
  GTypeInstance *__cil_tmp12 ;
  GType __cil_tmp13 ;
  GTypeInstance *__cil_tmp14 ;
  GType __cil_tmp15 ;
  GTypeInstance *__cil_tmp16 ;
  GtkWidget *__cil_tmp17 ;
  GType __cil_tmp18 ;
  GTypeInstance *__cil_tmp19 ;
  GType __cil_tmp20 ;
  GTypeInstance *__cil_tmp21 ;
  GType __cil_tmp22 ;
  GTypeInstance *__cil_tmp23 ;
  GtkWidget *__cil_tmp24 ;
  GType __cil_tmp25 ;
  GTypeInstance *__cil_tmp26 ;
  GType __cil_tmp27 ;
  GTypeInstance *__cil_tmp28 ;
  GType __cil_tmp29 ;
  GTypeInstance *__cil_tmp30 ;
  GtkWidget *__cil_tmp31 ;
  GType __cil_tmp32 ;
  GTypeInstance *__cil_tmp33 ;
  GtkWidget *__cil_tmp34 ;
  GtkWidget *__cil_tmp35 ;
  GType __cil_tmp36 ;
  GTypeInstance *__cil_tmp37 ;
  GSList *__cil_tmp38 ;
  GType __cil_tmp39 ;
  GTypeInstance *__cil_tmp40 ;
  GtkWidget *__cil_tmp41 ;
  GType __cil_tmp42 ;
  GTypeInstance *__cil_tmp43 ;
  GSList *__cil_tmp44 ;
  GType __cil_tmp45 ;
  GTypeInstance *__cil_tmp46 ;
  GtkWidget *__cil_tmp47 ;
  GType __cil_tmp48 ;
  GTypeInstance *__cil_tmp49 ;
  GType __cil_tmp50 ;
  GTypeInstance *__cil_tmp51 ;
  GType __cil_tmp52 ;
  GTypeInstance *__cil_tmp53 ;
  GType __cil_tmp54 ;
  GTypeInstance *__cil_tmp55 ;
  GType __cil_tmp56 ;
  GTypeInstance *__cil_tmp57 ;
  GType __cil_tmp58 ;
  GTypeInstance *__cil_tmp59 ;
  GType __cil_tmp60 ;
  GTypeInstance *__cil_tmp61 ;
  GType __cil_tmp62 ;
  GTypeInstance *__cil_tmp63 ;
  GtkWidget *__cil_tmp64 ;
  GType __cil_tmp65 ;
  GTypeInstance *__cil_tmp66 ;
  GType __cil_tmp67 ;
  GTypeInstance *__cil_tmp68 ;
  GtkWidget *__cil_tmp69 ;
  GType __cil_tmp70 ;
  GTypeInstance *__cil_tmp71 ;
  GtkWidget *__cil_tmp72 ;
  GType __cil_tmp73 ;
  GTypeInstance *__cil_tmp74 ;
  GType __cil_tmp75 ;
  GTypeInstance *__cil_tmp76 ;
  GtkWidget *__cil_tmp77 ;
  GType __cil_tmp78 ;
  GTypeInstance *__cil_tmp79 ;
  GType __cil_tmp80 ;
  GTypeInstance *__cil_tmp81 ;

  {
  {
#line 1618
  units_group = (GSList *)((void *)0);
#line 1621
  sanei_debug_xscanimage_call(4, "pref_build_menu\n\220");
#line 1622
  menu = gtk_menu_new();
#line 1625
  item = gtk_check_menu_item_new_with_label((gchar *)"Show advanced options");
#line 1626
  __cil_tmp11 = gtk_check_menu_item_get_type();
#line 1626
  __cil_tmp12 = g_type_check_instance_cast((GTypeInstance *)item, __cil_tmp11);
#line 1626
  gtk_check_menu_item_set_active((GtkCheckMenuItem *)((void *)__cil_tmp12), preferences.advanced);
#line 1628
  __cil_tmp13 = gtk_menu_get_type();
#line 1628
  __cil_tmp14 = g_type_check_instance_cast((GTypeInstance *)menu, __cil_tmp13);
#line 1628
  gtk_menu_shell_append((GtkMenuShell *)((GtkMenu *)((void *)__cil_tmp14)), item);
#line 1629
  gtk_widget_show(item);
#line 1630
  __cil_tmp15 = gtk_object_get_type();
#line 1630
  __cil_tmp16 = g_type_check_instance_cast((GTypeInstance *)item, __cil_tmp15);
#line 1630
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp16), (gchar *)"toggled",
                          (GtkSignalFunc )(& pref_toggle_advanced), (GtkCallbackMarshal )((void *)0),
                          (gpointer )0, (GDestroyNotify )((void *)0), 0, 0);
#line 1635
  item = gtk_check_menu_item_new_with_label((gchar *)"Show tooltips");
#line 1636
  __cil_tmp18 = gtk_check_menu_item_get_type();
#line 1636
  __cil_tmp19 = g_type_check_instance_cast((GTypeInstance *)item, __cil_tmp18);
#line 1636
  gtk_check_menu_item_set_active((GtkCheckMenuItem *)((void *)__cil_tmp19), preferences.tooltips_enabled);
#line 1638
  __cil_tmp20 = gtk_menu_get_type();
#line 1638
  __cil_tmp21 = g_type_check_instance_cast((GTypeInstance *)menu, __cil_tmp20);
#line 1638
  gtk_menu_shell_append((GtkMenuShell *)((GtkMenu *)((void *)__cil_tmp21)), item);
#line 1639
  gtk_widget_show(item);
#line 1640
  __cil_tmp22 = gtk_object_get_type();
#line 1640
  __cil_tmp23 = g_type_check_instance_cast((GTypeInstance *)item, __cil_tmp22);
#line 1640
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp23), (gchar *)"toggled",
                          (GtkSignalFunc )(& pref_toggle_tooltips), (GtkCallbackMarshal )((void *)0),
                          (gpointer )0, (GDestroyNotify )((void *)0), 0, 0);
#line 1645
  item = gtk_check_menu_item_new_with_label((gchar *)"Show two column display");
#line 1646
  __cil_tmp25 = gtk_check_menu_item_get_type();
#line 1646
  __cil_tmp26 = g_type_check_instance_cast((GTypeInstance *)item, __cil_tmp25);
#line 1646
  gtk_check_menu_item_set_active((GtkCheckMenuItem *)((void *)__cil_tmp26), preferences.twocolumn_enabled);
#line 1648
  __cil_tmp27 = gtk_menu_get_type();
#line 1648
  __cil_tmp28 = g_type_check_instance_cast((GTypeInstance *)menu, __cil_tmp27);
#line 1648
  gtk_menu_shell_append((GtkMenuShell *)((GtkMenu *)((void *)__cil_tmp28)), item);
#line 1649
  gtk_widget_show(item);
#line 1650
  __cil_tmp29 = gtk_object_get_type();
#line 1650
  __cil_tmp30 = g_type_check_instance_cast((GTypeInstance *)item, __cil_tmp29);
#line 1650
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp30), (gchar *)"toggled",
                          (GtkSignalFunc )(& pref_toggle_twocolumn), (GtkCallbackMarshal )((void *)0),
                          (gpointer )0, (GDestroyNotify )((void *)0), 0, 0);
#line 1655
  item = gtk_menu_item_new_with_label((gchar *)"Length unit");
#line 1656
  __cil_tmp32 = gtk_menu_get_type();
#line 1656
  __cil_tmp33 = g_type_check_instance_cast((GTypeInstance *)menu, __cil_tmp32);
#line 1656
  gtk_menu_shell_append((GtkMenuShell *)((GtkMenu *)((void *)__cil_tmp33)), item);
#line 1657
  gtk_widget_show(item);
#line 1659
  submenu = gtk_menu_new();
#line 1661
  unit_mm = gtk_radio_menu_item_new_with_label(units_group, (gchar *)"millimeters");
#line 1662
  __cil_tmp36 = gtk_radio_menu_item_get_type();
#line 1662
  __cil_tmp37 = g_type_check_instance_cast((GTypeInstance *)unit_mm, __cil_tmp36);
#line 1662
  __cil_tmp38 = gtk_radio_menu_item_get_group((GtkRadioMenuItem *)((void *)__cil_tmp37));
#line 1662
  units_group = __cil_tmp38;
#line 1663
  __cil_tmp39 = gtk_menu_get_type();
#line 1663
  __cil_tmp40 = g_type_check_instance_cast((GTypeInstance *)submenu, __cil_tmp39);
#line 1663
  gtk_menu_shell_append((GtkMenuShell *)((GtkMenu *)((void *)__cil_tmp40)), unit_mm);
#line 1664
  gtk_widget_show(unit_mm);
#line 1666
  unit_cm = gtk_radio_menu_item_new_with_label(units_group, (gchar *)"centimeters");
#line 1667
  __cil_tmp42 = gtk_radio_menu_item_get_type();
#line 1667
  __cil_tmp43 = g_type_check_instance_cast((GTypeInstance *)unit_cm, __cil_tmp42);
#line 1667
  __cil_tmp44 = gtk_radio_menu_item_get_group((GtkRadioMenuItem *)((void *)__cil_tmp43));
#line 1667
  units_group = __cil_tmp44;
#line 1668
  __cil_tmp45 = gtk_menu_get_type();
#line 1668
  __cil_tmp46 = g_type_check_instance_cast((GTypeInstance *)submenu, __cil_tmp45);
#line 1668
  gtk_menu_shell_append((GtkMenuShell *)((GtkMenu *)((void *)__cil_tmp46)), unit_cm);
#line 1669
  gtk_widget_show(unit_cm);
#line 1671
  unit_in = gtk_radio_menu_item_new_with_label(units_group, (gchar *)"inches");
#line 1672
  __cil_tmp48 = gtk_menu_get_type();
#line 1672
  __cil_tmp49 = g_type_check_instance_cast((GTypeInstance *)submenu, __cil_tmp48);
#line 1672
  gtk_menu_shell_append((GtkMenuShell *)((GtkMenu *)((void *)__cil_tmp49)), unit_in);
#line 1673
  gtk_widget_show(unit_in);
#line 1675
  unit = preferences.length_unit;
  }
#line 1676
  if (unit > 9.90000000001) {
#line 1676
    if (unit < 10.1) {
      {
#line 1677
      __cil_tmp50 = gtk_check_menu_item_get_type();
#line 1677
      __cil_tmp51 = g_type_check_instance_cast((GTypeInstance *)unit_cm, __cil_tmp50);
#line 1677
      gtk_check_menu_item_set_active((GtkCheckMenuItem *)((void *)__cil_tmp51), ! 0);
      }
    } else {
#line 1676
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1678
  if (unit > 25.3000000001) {
#line 1678
    if (unit < 25.5) {
      {
#line 1679
      __cil_tmp52 = gtk_check_menu_item_get_type();
#line 1679
      __cil_tmp53 = g_type_check_instance_cast((GTypeInstance *)unit_in, __cil_tmp52);
#line 1679
      gtk_check_menu_item_set_active((GtkCheckMenuItem *)((void *)__cil_tmp53), ! 0);
      }
    } else {
      {
      {
#line 1682
      __cil_tmp54 = gtk_check_menu_item_get_type();
      }
      {
#line 1682
      __cil_tmp55 = g_type_check_instance_cast((GTypeInstance *)unit_mm, __cil_tmp54);
      }
      {
#line 1682
      gtk_check_menu_item_set_active((GtkCheckMenuItem *)((void *)__cil_tmp55), ! 0);
      }
#line 1683
      preferences.length_unit = 1.;
      }
    }
  } else {
    {
    {
#line 1682
    __cil_tmp54 = gtk_check_menu_item_get_type();
    }
    {
#line 1682
    __cil_tmp55 = g_type_check_instance_cast((GTypeInstance *)unit_mm, __cil_tmp54);
    }
    {
#line 1682
    gtk_check_menu_item_set_active((GtkCheckMenuItem *)((void *)__cil_tmp55), ! 0);
    }
#line 1683
    preferences.length_unit = 1.;
    }
  }
  {
#line 1685
  __cil_tmp56 = gtk_object_get_type();
#line 1685
  __cil_tmp57 = g_type_check_instance_cast((GTypeInstance *)unit_mm, __cil_tmp56);
#line 1685
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp57), (gchar *)"toggled",
                          (GtkSignalFunc )(& pref_set_unit_callback), (GtkCallbackMarshal )((void *)0),
                          "mm", (GDestroyNotify )((void *)0), 0, 0);
#line 1687
  __cil_tmp58 = gtk_object_get_type();
#line 1687
  __cil_tmp59 = g_type_check_instance_cast((GTypeInstance *)unit_cm, __cil_tmp58);
#line 1687
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp59), (gchar *)"toggled",
                          (GtkSignalFunc )(& pref_set_unit_callback), (GtkCallbackMarshal )((void *)0),
                          "cm", (GDestroyNotify )((void *)0), 0, 0);
#line 1689
  __cil_tmp60 = gtk_object_get_type();
#line 1689
  __cil_tmp61 = g_type_check_instance_cast((GTypeInstance *)unit_in, __cil_tmp60);
#line 1689
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp61), (gchar *)"toggled",
                          (GtkSignalFunc )(& pref_set_unit_callback), (GtkCallbackMarshal )((void *)0),
                          "in", (GDestroyNotify )((void *)0), 0, 0);
#line 1692
  __cil_tmp62 = gtk_menu_item_get_type();
#line 1692
  __cil_tmp63 = g_type_check_instance_cast((GTypeInstance *)item, __cil_tmp62);
#line 1692
  gtk_menu_item_set_submenu((GtkMenuItem *)((void *)__cil_tmp63), submenu);
#line 1696
  item = gtk_menu_item_new_with_label((gchar *)"Preview options...");
#line 1697
  __cil_tmp65 = gtk_menu_get_type();
#line 1697
  __cil_tmp66 = g_type_check_instance_cast((GTypeInstance *)menu, __cil_tmp65);
#line 1697
  gtk_menu_shell_append((GtkMenuShell *)((GtkMenu *)((void *)__cil_tmp66)), item);
#line 1698
  __cil_tmp67 = gtk_object_get_type();
#line 1698
  __cil_tmp68 = g_type_check_instance_cast((GTypeInstance *)item, __cil_tmp67);
#line 1698
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp68), (gchar *)"activate\310\001",
                          (GtkSignalFunc )(& preview_options_dialog), (GtkCallbackMarshal )((void *)0),
                          (gpointer )0, (GDestroyNotify )((void *)0), 0, 0);
#line 1700
  gtk_widget_show(item);
#line 1703
  item = gtk_menu_item_new();
#line 1704
  __cil_tmp70 = gtk_menu_get_type();
#line 1704
  __cil_tmp71 = g_type_check_instance_cast((GTypeInstance *)menu, __cil_tmp70);
#line 1704
  gtk_menu_shell_append((GtkMenuShell *)((GtkMenu *)((void *)__cil_tmp71)), item);
#line 1705
  gtk_widget_show(item);
#line 1707
  item = gtk_menu_item_new_with_label((gchar *)"Save device settings");
#line 1708
  __cil_tmp73 = gtk_menu_get_type();
#line 1708
  __cil_tmp74 = g_type_check_instance_cast((GTypeInstance *)menu, __cil_tmp73);
#line 1708
  gtk_menu_shell_append((GtkMenuShell *)((GtkMenu *)((void *)__cil_tmp74)), item);
#line 1709
  __cil_tmp75 = gtk_object_get_type();
#line 1709
  __cil_tmp76 = g_type_check_instance_cast((GTypeInstance *)item, __cil_tmp75);
#line 1709
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp76), (gchar *)"activate\310\001",
                          (GtkSignalFunc )(& pref_device_save), (GtkCallbackMarshal )((void *)0),
                          (gpointer )0, (GDestroyNotify )((void *)0), 0, 0);
#line 1711
  gtk_widget_show(item);
#line 1713
  item = gtk_menu_item_new_with_label((gchar *)"Restore device settings");
#line 1714
  __cil_tmp78 = gtk_menu_get_type();
#line 1714
  __cil_tmp79 = g_type_check_instance_cast((GTypeInstance *)menu, __cil_tmp78);
#line 1714
  gtk_menu_shell_append((GtkMenuShell *)((GtkMenu *)((void *)__cil_tmp79)), item);
#line 1715
  __cil_tmp80 = gtk_object_get_type();
#line 1715
  __cil_tmp81 = g_type_check_instance_cast((GTypeInstance *)item, __cil_tmp80);
#line 1715
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp81), (gchar *)"activate\310\001",
                          (GtkSignalFunc )(& pref_device_restore), (GtkCallbackMarshal )((void *)0),
                          (gpointer )0, (GDestroyNotify )((void *)0), 0, 0);
#line 1717
  gtk_widget_show(item);
#line 1719
  sanei_debug_xscanimage_call(4, "pref_build_menu: finished\n");
  }
#line 1720
  return (menu);
}
}
#line 1724 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void browse_filename_callback(GtkWidget *widget , gpointer data ) 
{ 
  char filename[1024] ;
  GType __cil_tmp4 ;
  GTypeInstance *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 1728
  sanei_debug_xscanimage_call(4, "browse_filename_callback\n");
  }
#line 1729
  if (preferences.filename) {
    {
#line 1731
    strncpy((char *)filename, preferences.filename, sizeof(filename));
#line 1732
    filename[sizeof(filename) - 1UL] = (char )'\000';
    }
  } else {
    {
#line 1735
    strcpy((char *)filename, "out.pnm");
    }
  }
  {
#line 1736
  gsg_get_filename("Output Filename", (char const   *)((char *)filename), sizeof(filename),
                   (char *)filename);
#line 1737
  __cil_tmp4 = gtk_entry_get_type();
#line 1737
  __cil_tmp5 = g_type_check_instance_cast((GTypeInstance *)scan_win.filename_entry,
                                          __cil_tmp4);
#line 1737
  gtk_entry_set_text((GtkEntry *)((void *)__cil_tmp5), (char *)filename);
  }
#line 1739
  if (preferences.filename) {
    {
#line 1740
    free((void *)preferences.filename);
    }
  }
  {
#line 1741
  __cil_tmp6 = strdup((char const   *)((char *)filename));
#line 1741
  preferences.filename = (char const   *)__cil_tmp6;
#line 1742
  sanei_debug_xscanimage_call(4, "browse_filename_callback: finished\n");
  }
  return;
}
}
#line 1746 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void filename_changed_callback(GtkWidget *widget , gpointer data ) 
{ 
  GType __cil_tmp3 ;
  GTypeInstance *__cil_tmp4 ;
  gchar *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1748
  if (preferences.filename) {
    {
#line 1749
    free((void *)preferences.filename);
    }
  }
  {
#line 1750
  __cil_tmp3 = gtk_entry_get_type();
#line 1750
  __cil_tmp4 = g_type_check_instance_cast((GTypeInstance *)widget, __cil_tmp3);
#line 1750
  __cil_tmp5 = gtk_entry_get_text((GtkEntry *)((void *)__cil_tmp4));
#line 1750
  __cil_tmp6 = strdup(__cil_tmp5);
#line 1750
  preferences.filename = (char const   *)__cil_tmp6;
  }
  return;
}
}
#line 1755 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void device_dialog(void) 
{ 
  GtkWidget *vbox ;
  GtkWidget *hbox ;
  GtkWidget *button ;
  GtkWidget *frame ;
  GtkWidget *scrolled_window ;
  GtkWidget *dialog_window ;
  GtkWidget *label ;
  GtkWidget *text ;
  GtkWidget *menubar_item ;
  gchar *devname ;
  GtkWidget *__cil_tmp11 ;
  GType __cil_tmp12 ;
  GTypeInstance *__cil_tmp13 ;
  GType __cil_tmp14 ;
  GTypeInstance *__cil_tmp15 ;
  GType __cil_tmp16 ;
  GTypeInstance *__cil_tmp17 ;
  GType __cil_tmp18 ;
  GTypeInstance *__cil_tmp19 ;
  GType __cil_tmp20 ;
  GTypeInstance *__cil_tmp21 ;
  GtkWidget *__cil_tmp22 ;
  GType __cil_tmp23 ;
  GTypeInstance *__cil_tmp24 ;
  GtkWidget *__cil_tmp25 ;
  GType __cil_tmp26 ;
  GTypeInstance *__cil_tmp27 ;
  GType __cil_tmp28 ;
  GTypeInstance *__cil_tmp29 ;
  GtkWidget *__cil_tmp30 ;
  GtkWidget *__cil_tmp31 ;
  GType __cil_tmp32 ;
  GTypeInstance *__cil_tmp33 ;
  GType __cil_tmp34 ;
  GTypeInstance *__cil_tmp35 ;
  GtkWidget *__cil_tmp36 ;
  GtkWidget *__cil_tmp37 ;
  GType __cil_tmp38 ;
  GTypeInstance *__cil_tmp39 ;
  GType __cil_tmp40 ;
  GTypeInstance *__cil_tmp41 ;
  GType __cil_tmp42 ;
  GTypeInstance *__cil_tmp43 ;
  GtkWidget *__cil_tmp44 ;
  GType __cil_tmp45 ;
  GTypeInstance *__cil_tmp46 ;
  GType __cil_tmp47 ;
  GTypeInstance *__cil_tmp48 ;
  GtkWidget *__cil_tmp49 ;
  GType __cil_tmp50 ;
  GTypeInstance *__cil_tmp51 ;
  GtkWidget *__cil_tmp52 ;
  GType __cil_tmp53 ;
  GTypeInstance *__cil_tmp54 ;
  GType __cil_tmp55 ;
  GTypeInstance *__cil_tmp56 ;
  GType __cil_tmp57 ;
  GTypeInstance *__cil_tmp58 ;
  GtkWidget *__cil_tmp59 ;
  GType __cil_tmp60 ;
  GTypeInstance *__cil_tmp61 ;
  GType __cil_tmp62 ;
  GTypeInstance *__cil_tmp63 ;
  GtkWidget *__cil_tmp64 ;
  GType __cil_tmp65 ;
  GTypeInstance *__cil_tmp66 ;
  GType __cil_tmp67 ;
  GTypeInstance *__cil_tmp68 ;
  GtkWidget *__cil_tmp69 ;
  GType __cil_tmp70 ;
  GTypeInstance *__cil_tmp71 ;
  GType __cil_tmp72 ;
  GTypeInstance *__cil_tmp73 ;
  GSGDialog *__cil_tmp74 ;
  GtkWidget *__cil_tmp75 ;
  GType __cil_tmp76 ;
  GTypeInstance *__cil_tmp77 ;
  GType __cil_tmp78 ;
  GTypeInstance *__cil_tmp79 ;
  GtkWidget *__cil_tmp80 ;
  GType __cil_tmp81 ;
  GTypeInstance *__cil_tmp82 ;
  GType __cil_tmp83 ;
  GTypeInstance *__cil_tmp84 ;
  GtkWidget *__cil_tmp85 ;
  GType __cil_tmp86 ;
  GTypeInstance *__cil_tmp87 ;
  GType __cil_tmp88 ;
  GTypeInstance *__cil_tmp89 ;
  GtkWidget *__cil_tmp90 ;
  GType __cil_tmp91 ;
  GTypeInstance *__cil_tmp92 ;
  GType __cil_tmp93 ;
  GTypeInstance *__cil_tmp94 ;
  GtkWidget *__cil_tmp95 ;
  GType __cil_tmp96 ;
  GTypeInstance *__cil_tmp97 ;
  GType __cil_tmp98 ;
  GTypeInstance *__cil_tmp99 ;
  GtkWidget *__cil_tmp100 ;
  GType __cil_tmp101 ;
  GTypeInstance *__cil_tmp102 ;
  GType __cil_tmp103 ;
  GTypeInstance *__cil_tmp104 ;

  {
  {
#line 1762
  sanei_debug_xscanimage_call(4, "device_dialog\n");
#line 1764
  pref_xscanimage_restore();
#line 1766
  devname = (*(devlist + seldev))->name;
#line 1769
  scan_win.shell = gtk_dialog_new();
#line 1770
  __cil_tmp12 = gtk_window_get_type();
#line 1770
  __cil_tmp13 = g_type_check_instance_cast((GTypeInstance *)scan_win.shell, __cil_tmp12);
#line 1770
  gtk_window_set_title((GtkWindow *)((void *)__cil_tmp13), (char *)devname);
#line 1771
  __cil_tmp14 = gtk_window_get_type();
#line 1771
  __cil_tmp15 = g_type_check_instance_cast((GTypeInstance *)scan_win.shell, __cil_tmp14);
#line 1771
  gtk_window_set_policy((GtkWindow *)((void *)__cil_tmp15), 0, ! 0, ! 0);
#line 1772
  __cil_tmp16 = gtk_window_get_type();
#line 1772
  __cil_tmp17 = g_type_check_instance_cast((GTypeInstance *)scan_win.shell, __cil_tmp16);
#line 1772
  gtk_window_set_default_size((GtkWindow *)((void *)__cil_tmp17), 400, 400);
#line 1773
  __cil_tmp18 = gtk_object_get_type();
#line 1773
  __cil_tmp19 = g_type_check_instance_cast((GTypeInstance *)scan_win.shell, __cil_tmp18);
#line 1773
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp19), (gchar *)"delete_event",
                          (GCallback )(& scan_win_delete), (GtkCallbackMarshal )((void *)0),
                          (void *)0, (GDestroyNotify )((void *)0), 0, 0);
#line 1777
  vbox = ((GtkDialog *)((void *)__cil_tmp21))->vbox;
#line 1781
  scan_win.menubar = gtk_menu_bar_new();
#line 1782
  __cil_tmp23 = gtk_box_get_type();
#line 1782
  __cil_tmp24 = g_type_check_instance_cast((GTypeInstance *)vbox, __cil_tmp23);
#line 1782
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp24), scan_win.menubar, 0, 0, (guint )0);
#line 1785
  menubar_item = gtk_menu_item_new_with_label((gchar *)"File");
#line 1786
  __cil_tmp26 = gtk_container_get_type();
#line 1786
  __cil_tmp27 = g_type_check_instance_cast((GTypeInstance *)scan_win.menubar, __cil_tmp26);
#line 1786
  gtk_container_add((GtkContainer *)((void *)__cil_tmp27), menubar_item);
#line 1787
  __cil_tmp28 = gtk_menu_item_get_type();
#line 1787
  __cil_tmp29 = g_type_check_instance_cast((GTypeInstance *)menubar_item, __cil_tmp28);
  }
  {
#line 1787
  __cil_tmp30 = files_build_menu();
#line 1787
  gtk_menu_item_set_submenu((GtkMenuItem *)((void *)__cil_tmp29), __cil_tmp30);
#line 1789
  gtk_widget_show(menubar_item);
#line 1792
  menubar_item = gtk_menu_item_new_with_label((gchar *)"Preferences");
#line 1793
  __cil_tmp32 = gtk_container_get_type();
#line 1793
  __cil_tmp33 = g_type_check_instance_cast((GTypeInstance *)scan_win.menubar, __cil_tmp32);
#line 1793
  gtk_container_add((GtkContainer *)((void *)__cil_tmp33), menubar_item);
#line 1794
  __cil_tmp34 = gtk_menu_item_get_type();
#line 1794
  __cil_tmp35 = g_type_check_instance_cast((GTypeInstance *)menubar_item, __cil_tmp34);
  }
  {
#line 1794
  __cil_tmp36 = pref_build_menu();
#line 1794
  gtk_menu_item_set_submenu((GtkMenuItem *)((void *)__cil_tmp35), __cil_tmp36);
#line 1796
  gtk_widget_show(menubar_item);
#line 1798
  gtk_widget_show(scan_win.menubar);
  }
#line 1801
  if (scan_win.mode == 0) {
    {
#line 1803
    frame = gtk_frame_new((gchar *)"Output");
#line 1804
    __cil_tmp38 = gtk_container_get_type();
#line 1804
    __cil_tmp39 = g_type_check_instance_cast((GTypeInstance *)frame, __cil_tmp38);
#line 1804
    gtk_container_set_border_width((GtkContainer *)((void *)__cil_tmp39), (guint )4);
#line 1805
    __cil_tmp40 = gtk_frame_get_type();
#line 1805
    __cil_tmp41 = g_type_check_instance_cast((GTypeInstance *)frame, __cil_tmp40);
#line 1805
    gtk_frame_set_shadow_type((GtkFrame *)((void *)__cil_tmp41), (GtkShadowType )3);
#line 1806
    __cil_tmp42 = gtk_box_get_type();
#line 1806
    __cil_tmp43 = g_type_check_instance_cast((GTypeInstance *)vbox, __cil_tmp42);
#line 1806
    gtk_box_pack_start((GtkBox *)((void *)__cil_tmp43), frame, 0, 0, (guint )0);
#line 1808
    hbox = gtk_hbox_new(0, 2);
#line 1809
    __cil_tmp45 = gtk_container_get_type();
#line 1809
    __cil_tmp46 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp45);
#line 1809
    gtk_container_set_border_width((GtkContainer *)((void *)__cil_tmp46), (guint )2);
#line 1810
    __cil_tmp47 = gtk_container_get_type();
#line 1810
    __cil_tmp48 = g_type_check_instance_cast((GTypeInstance *)frame, __cil_tmp47);
#line 1810
    gtk_container_add((GtkContainer *)((void *)__cil_tmp48), hbox);
#line 1812
    label = gtk_label_new((gchar *)"Filename\220");
#line 1813
    __cil_tmp50 = gtk_box_get_type();
#line 1813
    __cil_tmp51 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp50);
#line 1813
    gtk_box_pack_start((GtkBox *)((void *)__cil_tmp51), label, 0, 0, (guint )2);
#line 1815
    text = gtk_entry_new();
#line 1816
    __cil_tmp53 = gtk_entry_get_type();
#line 1816
    __cil_tmp54 = g_type_check_instance_cast((GTypeInstance *)text, __cil_tmp53);
#line 1816
    gtk_entry_set_text((GtkEntry *)((void *)__cil_tmp54), (char *)preferences.filename);
#line 1817
    __cil_tmp55 = gtk_box_get_type();
#line 1817
    __cil_tmp56 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp55);
#line 1817
    gtk_box_pack_start((GtkBox *)((void *)__cil_tmp56), text, ! 0, ! 0, (guint )2);
#line 1818
    __cil_tmp57 = gtk_object_get_type();
#line 1818
    __cil_tmp58 = g_type_check_instance_cast((GTypeInstance *)text, __cil_tmp57);
#line 1818
    gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp58), (gchar *)"changed",
                            (GtkSignalFunc )(& filename_changed_callback), (GtkCallbackMarshal )((void *)0),
                            (gpointer )0, (GDestroyNotify )((void *)0), 0, 0);
#line 1821
    scan_win.filename_entry = text;
#line 1823
    button = gtk_button_new_with_label((gchar *)"Browse");
#line 1824
    __cil_tmp60 = gtk_box_get_type();
#line 1824
    __cil_tmp61 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp60);
#line 1824
    gtk_box_pack_start((GtkBox *)((void *)__cil_tmp61), button, 0, 0, (guint )2);
#line 1825
    __cil_tmp62 = gtk_object_get_type();
#line 1825
    __cil_tmp63 = g_type_check_instance_cast((GTypeInstance *)button, __cil_tmp62);
#line 1825
    gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp63), (gchar *)"clicked",
                            (GtkSignalFunc )(& browse_filename_callback), (GtkCallbackMarshal )((void *)0),
                            (gpointer )0, (GDestroyNotify )((void *)0), 0, 0);
#line 1828
    gtk_widget_show(button);
#line 1829
    gtk_widget_show(label);
#line 1830
    gtk_widget_show(text);
#line 1831
    gtk_widget_show(hbox);
#line 1832
    gtk_widget_show(frame);
    }
  }
  {
#line 1836
  scrolled_window = gtk_scrolled_window_new((GtkAdjustment *)((void *)0), (GtkAdjustment *)((void *)0));
#line 1837
  __cil_tmp65 = gtk_scrolled_window_get_type();
#line 1837
  __cil_tmp66 = g_type_check_instance_cast((GTypeInstance *)scrolled_window, __cil_tmp65);
#line 1837
  gtk_scrolled_window_set_policy((GtkScrolledWindow *)((void *)__cil_tmp66), (GtkPolicyType )2,
                                 (GtkPolicyType )1);
#line 1839
  __cil_tmp67 = gtk_scrolled_window_get_type();
#line 1839
  __cil_tmp68 = g_type_check_instance_cast((GTypeInstance *)scrolled_window, __cil_tmp67);
#line 1839
  gtk_scrolled_window_set_placement((GtkScrolledWindow *)((void *)__cil_tmp68), (GtkCornerType )2);
#line 1841
  dialog_window = gtk_hbox_new(0, 0);
#line 1842
  __cil_tmp70 = gtk_scrolled_window_get_type();
#line 1842
  __cil_tmp71 = g_type_check_instance_cast((GTypeInstance *)scrolled_window, __cil_tmp70);
#line 1842
  gtk_scrolled_window_add_with_viewport((GtkScrolledWindow *)((void *)__cil_tmp71),
                                        dialog_window);
#line 1845
  __cil_tmp72 = gtk_box_get_type();
#line 1845
  __cil_tmp73 = g_type_check_instance_cast((GTypeInstance *)vbox, __cil_tmp72);
#line 1845
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp73), scrolled_window, ! 0, ! 0, (guint )0);
#line 1846
  gtk_widget_show(scrolled_window);
#line 1847
  gtk_widget_show(dialog_window);
#line 1849
  dialog = gsg_create_dialog(dialog_window, devname, & update_preview, (void *)0,
                             & update_param, (void *)0);
  }
#line 1851
  if (! dialog) {
#line 1852
    return;
  }
  {
#line 1855
  hbox = gtk_hbox_new(0, 5);
#line 1856
  __cil_tmp76 = gtk_container_get_type();
#line 1856
  __cil_tmp77 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp76);
#line 1856
  gtk_container_set_border_width((GtkContainer *)((void *)__cil_tmp77), (guint )3);
#line 1857
  __cil_tmp78 = gtk_box_get_type();
#line 1857
  __cil_tmp79 = g_type_check_instance_cast((GTypeInstance *)vbox, __cil_tmp78);
#line 1857
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp79), hbox, 0, 0, (guint )0);
#line 1858
  gtk_widget_show(hbox);
#line 1860
  frame = gtk_frame_new((gchar *)((void *)0));
#line 1861
  __cil_tmp81 = gtk_frame_get_type();
#line 1861
  __cil_tmp82 = g_type_check_instance_cast((GTypeInstance *)frame, __cil_tmp81);
#line 1861
  gtk_frame_set_shadow_type((GtkFrame *)((void *)__cil_tmp82), (GtkShadowType )1);
#line 1862
  __cil_tmp83 = gtk_box_get_type();
#line 1862
  __cil_tmp84 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp83);
#line 1862
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp84), frame, 0, 0, (guint )0);
#line 1863
  gtk_widget_show(frame);
#line 1865
  hbox = gtk_hbox_new(0, 5);
#line 1866
  __cil_tmp86 = gtk_container_get_type();
#line 1866
  __cil_tmp87 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp86);
#line 1866
  gtk_container_set_border_width((GtkContainer *)((void *)__cil_tmp87), (guint )2);
#line 1867
  __cil_tmp88 = gtk_container_get_type();
#line 1867
  __cil_tmp89 = g_type_check_instance_cast((GTypeInstance *)frame, __cil_tmp88);
#line 1867
  gtk_container_add((GtkContainer *)((void *)__cil_tmp89), hbox);
#line 1868
  gtk_widget_show(hbox);
#line 1870
  scan_win.info_label = gtk_label_new((gchar *)"0x0: 0KB\220");
#line 1871
  __cil_tmp91 = gtk_box_get_type();
#line 1871
  __cil_tmp92 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp91);
#line 1871
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp92), scan_win.info_label, 0, 0, (guint )0);
#line 1872
  gtk_widget_show(scan_win.info_label);
#line 1874
  update_param(dialog, (void *)0);
#line 1877
  hbox = ((GtkDialog *)((void *)__cil_tmp94))->action_area;
#line 1880
  scan_win.scan_button = gtk_button_new_with_label((gchar *)"Scan");
#line 1881
  __cil_tmp96 = gtk_object_get_type();
#line 1881
  __cil_tmp97 = g_type_check_instance_cast((GTypeInstance *)scan_win.scan_button,
                                           __cil_tmp96);
#line 1881
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp97), (gchar *)"clicked",
                          (GtkSignalFunc )(& scan_dialog), (GtkCallbackMarshal )((void *)0),
                          (void *)0, (GDestroyNotify )((void *)0), 0, 0);
#line 1883
  __cil_tmp98 = gtk_box_get_type();
#line 1883
  __cil_tmp99 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp98);
#line 1883
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp99), scan_win.scan_button, ! 0, ! 0,
                     (guint )0);
#line 1884
  gtk_widget_show(scan_win.scan_button);
#line 1887
  scan_win.preview_button = gtk_toggle_button_new_with_label((gchar *)"Preview Window");
#line 1889
  __cil_tmp101 = gtk_object_get_type();
#line 1889
  __cil_tmp102 = g_type_check_instance_cast((GTypeInstance *)scan_win.preview_button,
                                            __cil_tmp101);
#line 1889
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp102), (gchar *)"clicked",
                          (GtkSignalFunc )(& scan_preview), (GtkCallbackMarshal )((void *)0),
                          (void *)0, (GDestroyNotify )((void *)0), 0, 0);
#line 1891
  __cil_tmp103 = gtk_box_get_type();
#line 1891
  __cil_tmp104 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp103);
#line 1891
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp104), scan_win.preview_button, ! 0,
                     ! 0, (guint )0);
#line 1892
  gtk_widget_show(scan_win.preview_button);
#line 1910
  pref_device_restore();
#line 1911
  gtk_widget_show(scan_win.shell);
#line 1912
  sanei_debug_xscanimage_call(4, "device_dialog: finished\n\220");
  }
  return;
}
}
#line 1916 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void ok_choose_dialog_callback(void) 
{ 


  {
  {
#line 1918
  gtk_widget_destroy(choose_device_dialog);
#line 1919
  device_dialog();
  }
  return;
}
}
#line 1923 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static int select_device_callback(GtkWidget *widget , GdkEventButton *event , gpointer data ) 
{ 


  {
#line 1926
  seldev = (gint )((long )data);
#line 1927
  if ((int )event->type == 5) {
#line 1927
    if (event->button == 1U) {
      {
#line 1928
      ok_choose_dialog_callback();
      }
    }
  }
#line 1930
  return (0);
}
}
#line 1934 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static gint32 choose_device(void) 
{ 
  GtkWidget *main_vbox ;
  GtkWidget *vbox ;
  GtkWidget *hbox ;
  GtkWidget *button ;
  GSList *owner ;
  SANE_Device *adev ;
  gint i ;
  GtkWidget *__cil_tmp8 ;
  GType __cil_tmp9 ;
  GTypeInstance *__cil_tmp10 ;
  GType __cil_tmp11 ;
  GTypeInstance *__cil_tmp12 ;
  GType __cil_tmp13 ;
  GTypeInstance *__cil_tmp14 ;
  GtkWidget *__cil_tmp15 ;
  GType __cil_tmp16 ;
  GTypeInstance *__cil_tmp17 ;
  GType __cil_tmp18 ;
  GTypeInstance *__cil_tmp19 ;
  GtkWidget *__cil_tmp20 ;
  GType __cil_tmp21 ;
  GTypeInstance *__cil_tmp22 ;
  GType __cil_tmp23 ;
  GTypeInstance *__cil_tmp24 ;
  GType __cil_tmp25 ;
  GTypeInstance *__cil_tmp26 ;
  GSList *__cil_tmp27 ;
  GType __cil_tmp28 ;
  GTypeInstance *__cil_tmp29 ;
  gint __cil_tmp30 ;
  GType __cil_tmp31 ;
  GTypeInstance *__cil_tmp32 ;
  GtkWidget *__cil_tmp33 ;
  GType __cil_tmp34 ;
  GTypeInstance *__cil_tmp35 ;
  GType __cil_tmp36 ;
  GTypeInstance *__cil_tmp37 ;
  GType __cil_tmp38 ;
  GTypeInstance *__cil_tmp39 ;
  GtkWidget *__cil_tmp40 ;
  GType __cil_tmp41 ;
  GTypeInstance *__cil_tmp42 ;
  GType __cil_tmp43 ;
  GTypeInstance *__cil_tmp44 ;

  {
  {
#line 1941
  sanei_debug_xscanimage_call(4, "choose_device\n");
#line 1942
  choose_device_dialog = gtk_dialog_new();
#line 1943
  __cil_tmp9 = gtk_window_get_type();
#line 1943
  __cil_tmp10 = g_type_check_instance_cast((GTypeInstance *)choose_device_dialog,
                                           __cil_tmp9);
#line 1943
  gtk_window_set_title((GtkWindow *)((void *)__cil_tmp10), (gchar *)"Select device");
#line 1944
  __cil_tmp11 = gtk_object_get_type();
#line 1944
  __cil_tmp12 = g_type_check_instance_cast((GTypeInstance *)choose_device_dialog,
                                           __cil_tmp11);
#line 1944
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp12), (gchar *)"delete_event",
                          (GCallback )(& files_exit_callback), (GtkCallbackMarshal )((void *)0),
                          (void *)0, (GDestroyNotify )((void *)0), 0, 0);
#line 1947
  main_vbox = ((GtkDialog *)((void *)__cil_tmp14))->vbox;
#line 1950
  vbox = gtk_vbox_new(0, 5);
#line 1951
  __cil_tmp16 = gtk_container_get_type();
#line 1951
  __cil_tmp17 = g_type_check_instance_cast((GTypeInstance *)vbox, __cil_tmp16);
#line 1951
  gtk_container_set_border_width((GtkContainer *)((void *)__cil_tmp17), (guint )3);
#line 1952
  __cil_tmp18 = gtk_box_get_type();
#line 1952
  __cil_tmp19 = g_type_check_instance_cast((GTypeInstance *)main_vbox, __cil_tmp18);
#line 1952
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp19), vbox, ! 0, ! 0, (guint )0);
#line 1953
  gtk_widget_show(vbox);
#line 1956
  owner = (GSList *)((void *)0);
#line 1957
  i = 0;
  }
  {
#line 1957
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1957
    if (! (i < ndevs)) {
#line 1957
      goto while_break;
    }
    {
#line 1959
    adev = *(devlist + i);
#line 1961
    button = gtk_radio_button_new_with_label(owner, (char *)adev->name);
#line 1962
    __cil_tmp21 = gtk_object_get_type();
#line 1962
    __cil_tmp22 = g_type_check_instance_cast((GTypeInstance *)button, __cil_tmp21);
#line 1962
    gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp22), (gchar *)"button_press_event",
                            (GtkSignalFunc )(& select_device_callback), (GtkCallbackMarshal )((void *)0),
                            (void *)((long )i), (GDestroyNotify )((void *)0), 0, 0);
#line 1965
    __cil_tmp23 = gtk_box_get_type();
#line 1965
    __cil_tmp24 = g_type_check_instance_cast((GTypeInstance *)vbox, __cil_tmp23);
#line 1965
    gtk_box_pack_start((GtkBox *)((void *)__cil_tmp24), button, ! 0, ! 0, (guint )0);
#line 1966
    gtk_widget_show(button);
#line 1967
    __cil_tmp25 = gtk_radio_button_get_type();
#line 1967
    __cil_tmp26 = g_type_check_instance_cast((GTypeInstance *)button, __cil_tmp25);
#line 1967
    __cil_tmp27 = gtk_radio_button_get_group((GtkRadioButton *)((void *)__cil_tmp26));
#line 1967
    owner = __cil_tmp27;
    }
#line 1968
    if (i == defdev) {
      {
#line 1969
      __cil_tmp28 = gtk_toggle_button_get_type();
#line 1969
      __cil_tmp29 = g_type_check_instance_cast((GTypeInstance *)button, __cil_tmp28);
#line 1969
      gtk_toggle_button_set_active((GtkToggleButton *)((void *)__cil_tmp29), ! 0);
      }
    }
#line 1957
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1973
  hbox = ((GtkDialog *)((void *)__cil_tmp32))->action_area;
#line 1976
  button = gtk_button_new_with_label((gchar *)"OK");
  }
  {
#line 1977
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1977
    ((GtkObject *)((void *)__cil_tmp35))->flags |= (unsigned int )8192;
#line 1977
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1978
  __cil_tmp36 = gtk_object_get_type();
#line 1978
  __cil_tmp37 = g_type_check_instance_cast((GTypeInstance *)button, __cil_tmp36);
#line 1978
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp37), (gchar *)"clicked",
                          (GtkSignalFunc )(& ok_choose_dialog_callback), (GtkCallbackMarshal )((void *)0),
                          (void *)0, (GDestroyNotify )((void *)0), 0, 0);
#line 1980
  __cil_tmp38 = gtk_box_get_type();
#line 1980
  __cil_tmp39 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp38);
#line 1980
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp39), button, ! 0, ! 0, (guint )0);
#line 1981
  gtk_widget_grab_default(button);
#line 1982
  gtk_widget_show(button);
#line 1985
  button = gtk_button_new_with_label((gchar *)"Cancel");
#line 1986
  __cil_tmp41 = gtk_object_get_type();
#line 1986
  __cil_tmp42 = g_type_check_instance_cast((GTypeInstance *)button, __cil_tmp41);
#line 1986
  gtk_signal_connect_full((GtkObject *)((void *)__cil_tmp42), (gchar *)"clicked",
                          (GtkSignalFunc )(& files_exit_callback), (GtkCallbackMarshal )((void *)0),
                          (void *)0, (GDestroyNotify )((void *)0), 0, 0);
#line 1988
  __cil_tmp43 = gtk_box_get_type();
#line 1988
  __cil_tmp44 = g_type_check_instance_cast((GTypeInstance *)hbox, __cil_tmp43);
#line 1988
  gtk_box_pack_start((GtkBox *)((void *)__cil_tmp44), button, ! 0, ! 0, (guint )0);
#line 1989
  gtk_widget_show(button);
#line 1991
  gtk_widget_show(choose_device_dialog);
#line 1992
  sanei_debug_xscanimage_call(4, "choose_device: finished\n\220");
  }
#line 1993
  return (0);
}
}
#line 1997 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void usage(void) 
{ 


  {
  {
#line 1999
  printf("Usage: %s [OPTION]... [DEVICE]\n\nStart up graphical user interface to access SANE (Scanner Access Now\nEasy) devices.\n\n-h, --help                 display this help message and exit\n-V, --version              print version information\n\230\001",
         prog_name);
  }
  return;
}
}
#line 2009 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void init(int argc , char **argv ) 
{ 
  char filename[4096] ;
  struct stat st ;
  SANE_Status status ;
  gchar *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  SANE_Status __cil_tmp9 ;
  SANE_String_Const __cil_tmp10 ;
  static SANE_Device dev ;
  static SANE_Device *device_list[2] ;
  int ch ;
  int __cil_tmp14 ;
  char *defdevname ;
  SANE_Status __cil_tmp16 ;
  SANE_String_Const __cil_tmp17 ;
  char *__cil_tmp18 ;
  int i ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;

  {
  {
#line 2015
  sanei_init_debug("xscanimage", & sanei_debug_xscanimage);
#line 2017
  sanei_debug_xscanimage_call(4, "init\n");
#line 2018
  gtk_init(& argc, & argv);
#line 2020
  __cil_tmp6 = gimp_gtkrc();
#line 2020
  gtk_rc_parse(__cil_tmp6);
#line 2025
  gdk_set_use_xshm(! 0);
#line 2031
  gsg_make_path(sizeof(filename), (char *)filename, (char const   *)0, "sane-style",
                (char const   *)0, ".rc");
#line 2032
  __cil_tmp7 = stat((char const   *)((char *)filename), & st);
  }
#line 2032
  if (__cil_tmp7 >= 0) {
    {
#line 2033
    gtk_rc_parse((char *)filename);
    }
  } else {
    {
#line 2036
    strncpy((char *)filename, "/usr/local/share/sane/sane-style.rc", sizeof(filename));
#line 2038
    filename[sizeof(filename) - 1UL] = (char )'\000';
#line 2039
    __cil_tmp8 = stat((char const   *)((char *)filename), & st);
    }
#line 2039
    if (__cil_tmp8 >= 0) {
      {
#line 2040
      gtk_rc_parse((char *)filename);
      }
    }
  }
  {
#line 2043
  status = sane_init((SANE_Int *)0, (SANE_Auth_Callback )0);
  }
#line 2044
  if ((unsigned int )status != 0U) {
    {
#line 2046
    __cil_tmp10 = sane_strstatus(status);
#line 2046
    sanei_debug_xscanimage_call(0, "init: sane_init failed: %s\n", __cil_tmp10);
#line 2048
    exit(1);
    }
  }
#line 2051
  if (argc > 1) {
#line 2054
    device_list[0] = & dev;
#line 2054
    device_list[1] = (SANE_Device *)0;
    {
#line 2057
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2057
      ch = getopt_long(argc, (char * const  *)argv, "ghV", (struct option *)long_options,
                       (int *)0);
      }
#line 2057
      if (! (ch != -1)) {
#line 2057
        goto while_break;
      }
      {
#line 2061
      if (ch == 'g') {
#line 2061
        goto case_103;
      }
#line 2065
      if (ch == 'V') {
#line 2065
        goto case_86;
      }
#line 2070
      goto switch_default;
      case_103: /* CIL Label */ 
      {
#line 2062
      printf("%s: GIMP support missing.\n", *(argv + 0));
      }
      {
#line 2063
      exit(0);
      }
      case_86: /* CIL Label */ 
      {
#line 2066
      printf("xscanimage (%s) %s\n", "sane-frontends", "1.0.14");
      }
      {
#line 2067
      exit(0);
      }
      switch_default: /* CIL Label */ 
      case_104: /* CIL Label */ 
      {
#line 2071
      usage();
      }
      {
#line 2072
      exit(0);
      }
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2076
    if (optind < argc) {
      {
#line 2078
      memset(& dev, 0, sizeof(dev));
#line 2079
      dev.name = *(argv + (argc - 1));
#line 2080
      dev.vendor = (SANE_String_Const )"Unknown";
#line 2081
      dev.type = (SANE_String_Const )"unknown";
#line 2082
      dev.model = (SANE_String_Const )"unknown";
#line 2084
      devlist = (SANE_Device **)device_list;
#line 2085
      seldev = 0;
      }
    }
  }
#line 2089
  if (seldev < 0) {
    {
#line 2093
    status = sane_get_devices(& devlist, 0);
    }
#line 2094
    if ((unsigned int )status != 0U) {
      {
#line 2096
      __cil_tmp17 = sane_strstatus(status);
#line 2096
      sanei_debug_xscanimage_call(0, "init: sane_get_devices failed: %s\n", __cil_tmp17);
#line 2098
      exit(1);
      }
    }
    {
#line 2101
    defdevname = getenv("SANE_DEFAULT_DEVICE");
    }
#line 2101
    if (defdevname != (void *)0) {
#line 2105
      i = 0;
      {
#line 2105
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2105
        if (! (*(devlist + i) != (SANE_Device *)0)) {
#line 2105
          goto while_break___0;
        }
        {
#line 2107
        __cil_tmp20 = strcmp((*(devlist + i))->name, (char const   *)defdevname);
        }
#line 2107
        if (__cil_tmp20 == 0) {
#line 2109
          defdev = i;
#line 2110
          goto while_break___0;
        }
#line 2105
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2113
      if (defdev < 0) {
        {
#line 2114
        sanei_debug_xscanimage_call(1, "default device is `%s\' wasn\'t found by sane_get_devices() \n",
                                    defdevname);
        }
      } else {
        {
#line 2117
        sanei_debug_xscanimage_call(3, "default device is `%s\'\n", defdevname);
        }
      }
    }
  }
  {
#line 2120
  sanei_debug_xscanimage_call(4, "init: finished\n");
  }
  return;
}
}
#line 2124 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
static void interface(int argc , char **argv ) 
{ 


  {
  {
#line 2126
  scan_win.info_label = (GtkWidget *)((void *)0);
#line 2128
  sanei_debug_xscanimage_call(4, "interface\n");
#line 2129
  init(argc, argv);
#line 2131
  ndevs = 0;
  }
  {
#line 2131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2131
    if (! *(devlist + ndevs)) {
#line 2131
      goto while_break;
    }

#line 2131
    ndevs ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2133
  if (seldev >= 0) {
#line 2135
    if (seldev >= ndevs) {
      {
#line 2137
      fprintf(stderr, "%s: device %d is unavailable.\n", prog_name, seldev);
#line 2139
      quit_xscanimage();
      }
    }
    {
#line 2141
    device_dialog();
    }
#line 2142
    if (! dialog) {
      {
#line 2143
      quit_xscanimage();
      }
    }
  } else
#line 2147
  if (ndevs > 0) {
#line 2149
    seldev = 0;
#line 2150
    if (ndevs == 1) {
      {
#line 2152
      device_dialog();
      }
#line 2153
      if (! dialog) {
        {
#line 2154
        quit_xscanimage();
        }
      }
    } else {
      {
#line 2157
      choose_device();
      }
    }
  } else {
    {
#line 2161
    sanei_debug_xscanimage_call(0, "No scanners were identified. If you were expecting something\n          different, check that the scanner is plugged in, turned on and\n          detected by sane-find-scanner (if appropriate). Please read\n          the documentation which came with this software (README, FAQ,\n          manpages).\n");
#line 2167
    quit_xscanimage();
    }
  }
  {
#line 2170
  gtk_quit_flag = 1;
#line 2171
  sanei_debug_xscanimage_call(4, "interface: now running gtk_main ()\n");
#line 2172
  gtk_main();
#line 2173
  sane_exit();
#line 2174
  sanei_debug_xscanimage_call(4, "interface: finished\n");
  }
  return;
}
}
#line 2178 "/root/oss-experiment/data/sane-frontends-1.0.14/src/xscanimage.c"
int main(int argc , char **argv ) 
{ 
  gboolean __cil_tmp3 ;
  char *__cil_tmp4 ;
  GPrintFunc old_print_func ;
  GPrintFunc old_printerr_func ;
  int result ;
  GPrintFunc __cil_tmp8 ;
  GPrintFunc __cil_tmp9 ;
  gint __cil_tmp10 ;

  {
  {
#line 2180
  sanei_init_debug("xscanimage", & sanei_debug_xscanimage);
#line 2181
  sanei_debug_xscanimage_call(4, "main\n");
#line 2182
  sanei_debug_xscanimage_call(1, "xscanimage (version: %s, package: %s) starting\n",
                              "1.0.14", "sane-frontends");
#line 2184
  little_endian = calc_little_endian();
#line 2185
  scan_win.mode = 0;
#line 2186
  gtk_quit_flag = 0;
#line 2187
  __cil_tmp4 = strrchr((char const   *)*(argv + 0), '/');
#line 2187
  prog_name = (char const   *)__cil_tmp4;
  }
#line 2188
  if (prog_name) {
#line 2189
    prog_name ++;
  } else {
#line 2191
    prog_name = (char const   *)*(argv + 0);
  }
  {
#line 2203
  old_print_func = g_set_print_handler(& null_print_func);
#line 2204
  old_printerr_func = g_set_printerr_handler(& null_print_func);
#line 2210
  result = gimp_main(& PLUG_IN_INFO, argc, argv);
#line 2214
  g_set_print_handler(old_print_func);
#line 2215
  g_set_printerr_handler(old_printerr_func);
  }
#line 2216
  if (result) {
    {
#line 2217
    interface(argc, argv);
    }
  }
  {
#line 2222
  sanei_debug_xscanimage_call(4, "main: finished\n");
  }
#line 2223
  return (0);
}
}
